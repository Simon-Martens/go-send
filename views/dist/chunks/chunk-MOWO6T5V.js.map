{
  "version": 3,
  "sources": ["../../src/vendor/noble-ed25519.mjs", "../../src/crypto/credentials.mjs"],
  "sourcesContent": ["// Minimal subset of @noble/ed25519 (MIT License, https://github.com/paulmillr/noble-ed25519)\n// Only the synchronous getPublicKey & sign helpers are included to keep the bundle lean.\n// The implementation is adapted to work in modern browsers without Node built-ins.\n\nconst _0n = BigInt(0);\nconst _1n = BigInt(1);\nconst _2n = BigInt(2);\nconst _3n = BigInt(3);\nconst _4n = BigInt(4);\nconst _5n = BigInt(5);\nconst _8n = BigInt(8);\n\nfunction bytesToHex(uint8a) {\n  if (!(uint8a instanceof Uint8Array))\n    throw new TypeError(\"Expected Uint8Array\");\n  let hex = \"\";\n  for (const i of uint8a) hex += i.toString(16).padStart(2, \"0\");\n  return hex;\n}\nfunction hexToBytes(hex) {\n  if (typeof hex !== \"string\")\n    throw new TypeError(\"hex must be a string\");\n  if (hex.length % 2)\n    throw new Error(\"hex must be even length\");\n  const array = new Uint8Array(hex.length / 2);\n  for (let i = 0; i < array.length; i++) {\n    const j = i * 2;\n    array[i] = parseInt(hex.slice(j, j + 2), 16);\n  }\n  return array;\n}\nfunction utf8ToBytes(str) {\n  if (typeof str !== \"string\")\n    throw new TypeError(\"utf8ToBytes expected string\");\n  return new TextEncoder().encode(str);\n}\nfunction concatBytes(...arrays) {\n  if (!arrays.every((a) => a instanceof Uint8Array))\n    throw new TypeError(\"Uint8Array expected\");\n  const length = arrays.reduce((a, arr) => a + arr.length, 0);\n  const result = new Uint8Array(length);\n  let offset = 0;\n  for (const arr of arrays) {\n    result.set(arr, offset);\n    offset += arr.length;\n  }\n  return result;\n}\n\nconst mod = (a, b) => {\n  const result = a % b;\n  return result >= _0n ? result : b + result;\n};\nconst pow2 = (bits) => mod(_1n << BigInt(bits), CURVE.p);\n\nfunction sqrtMod(a) {\n  const { p } = CURVE;\n  const _1p = mod(p + _1n, _4n);\n  if (_1p === _3n) {\n    return pow(a, mod(p + _1n, _4n));\n  }\n  if (p % _8n !== _5n) {\n    throw new Error(\"Cannot find square root for p % 8 != 5\");\n  }\n  let x = pow(a, mod(p + _3n, _8n));\n  const t = mod(x * x, p);\n  const x2 = mod(x * (_1n - t) * sqrtMinusOne, p);\n  if (!isSquare(t)) x = x2;\n  if (!isSquare(mod(x * x - a, p)))\n    throw new Error(\"Cannot find square root\");\n  return x;\n}\nconst invert = (number) => pow(number, CURVE.p - _2n);\n\nfunction invertBatch(nums) {\n  const tmp = new Array(nums.length);\n  let last = _1n;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] === _0n) continue;\n    tmp[i] = last;\n    last = mod(last * nums[i], CURVE.p);\n  }\n  last = invert(last);\n  for (let i = nums.length - 1; i >= 0; i--) {\n    if (nums[i] === _0n) continue;\n    tmp[i] = mod(last * tmp[i], CURVE.p);\n    last = mod(last * nums[i], CURVE.p);\n  }\n  return tmp;\n}\n\nconst pow = (number, power) => {\n  let n = mod(number, CURVE.p);\n  let e = power;\n  let result = _1n;\n  while (e > _0n) {\n    if (e & _1n) result = mod(result * n, CURVE.p);\n    n = mod(n * n, CURVE.p);\n    e >>= _1n;\n  }\n  return result;\n};\nconst isSquare = (y) => {\n  return pow(y, (CURVE.p - _1n) >> _1n) === _1n;\n};\n\nconst CURVE = {\n  a: BigInt(-1),\n  d: BigInt(\"37095705934669439343138083508754565189542113879843219016388785533085940283555\"),\n  P: [\n    BigInt(\"15112221349535400772501151409588531511454012693041857206046113283949847762202\"),\n    BigInt(\"46316835694926478169428394003475163141307993866256225615783033603165251855960\")\n  ],\n  p: BigInt(\"0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffed\"),\n  n: BigInt(\"0x1000000000000000000000000000000014def9dea2f79cd65812631a5cf5d3ed\"),\n  h: BigInt(8),\n};\nconst sqrtMinusOne = pow(BigInt(-1), (CURVE.p - _1n) / _4n);\n\nfunction bytesToNumberLE(bytes) {\n  return BigInt(\"0x\" + bytesToHex(Uint8Array.from(bytes).reverse()));\n}\n\nfunction numberToBytesLE(num, length) {\n  return hexToBytes(num.toString(16).padStart(length * 2, \"0\")).reverse();\n}\n\nfunction modL_LE(hash) {\n  return mod(bytesToNumberLE(hash), CURVE.n);\n}\n\nfunction ensureBytes(hex, ...lengths) {\n  let bytes;\n  if (hex instanceof Uint8Array) {\n    bytes = Uint8Array.from(hex);\n  } else if (typeof hex === \"string\") {\n    bytes = hex.length % 2 ? hexToBytes(`0${hex}`) : hexToBytes(hex);\n  } else if (ArrayBuffer.isView(hex)) {\n    bytes = new Uint8Array(hex.buffer.slice(hex.byteOffset, hex.byteOffset + hex.byteLength));\n  } else {\n    throw new TypeError(\"Expected hex or Uint8Array\");\n  }\n  if (lengths.length > 0 && !lengths.includes(bytes.length)) {\n    throw new TypeError(`Expected hex / Uint8Array of length ${lengths}, not ${bytes.length}`);\n  }\n  return bytes;\n}\n\nasync function getExtendedPublicKey(privateKey) {\n    const hash = await utils.sha512(privateKey);\n  const head = hash.slice(0, 32);\n  const prefix = hash.slice(32);\n  head[0] &= 248;\n  head[31] &= 63;\n  head[31] |= 64;\n  const scalar = mod(bytesToNumberLE(head), CURVE.n);\n  const point = Point.BASE.multiplyUnsafe(scalar).toRawBytes();\n  return { head, prefix, scalar, point };\n}\n\nfunction assertPrivateKey(key) {\n  key = ensureBytes(key, 32);\n  return key;\n}\nfunction assertPublicKey(key) {\n  key = ensureBytes(key, 32);\n  return key;\n}\n\nclass Point {\n  constructor(x, y, z, t) {\n    this.x = x;\n    this.y = y;\n    this.z = z;\n    this.t = t;\n  }\n  static fromAffine({ x, y }) {\n    if (!isValidFieldElement(x) || !isValidFieldElement(y)) throw new TypeError(\"invalid point\");\n    return new Point(x, y, _1n, mod(x * y, CURVE.p));\n  }\n  toAffine() {\n    const { x, y, z } = this;\n    const iz = invert(z);\n    return { x: mod(x * iz, CURVE.p), y: mod(y * iz, CURVE.p) };\n  }\n  toRawBytes() {\n    const { x, y } = this.toAffine();\n    const bytes = numberToBytesLE(y, 32);\n    bytes[31] |= Number(x & _1n) << 7;\n    return bytes;\n  }\n  is0() {\n    return this.x === _0n && this.y === this.z && this.z === _0n;\n  }\n  negate() {\n    return new Point(mod(-this.x, CURVE.p), this.y, this.z, mod(-this.t, CURVE.p));\n  }\n  add(other) {\n    if (!(other instanceof Point)) {\n      throw new TypeError(\"Expected Point\");\n    }\n    const A = mod((this.y - this.x) * (other.y - other.x), CURVE.p);\n    const B = mod((this.y + this.x) * (other.y + other.x), CURVE.p);\n    const F = mod(this.t * _2n * other.t * CURVE.d, CURVE.p);\n    const C = mod(this.z * _2n * other.z, CURVE.p);\n    const D = mod(F + C, CURVE.p);\n    const E = mod(B - A, CURVE.p);\n    const G = mod(B + A, CURVE.p);\n    const H = mod(C - F, CURVE.p);\n    const X3 = mod(E * H, CURVE.p);\n    const Y3 = mod(G * D, CURVE.p);\n    const T3 = mod(E * G, CURVE.p);\n    const Z3 = mod(D * H, CURVE.p);\n    return new Point(X3, Y3, Z3, T3);\n  }\n  double() {\n    const X1 = this.x;\n    const Y1 = this.y;\n    const Z1 = this.z;\n    const A = mod(X1 ** _2n, CURVE.p);\n    const B = mod(Y1 ** _2n, CURVE.p);\n    const C = mod(_2n * Z1 ** _2n, CURVE.p);\n    const D = mod(-A, CURVE.p);\n    const E = mod((X1 + Y1) ** _2n - A - B, CURVE.p);\n    const G = mod(D + B, CURVE.p);\n    const F = mod(G - C, CURVE.p);\n    const H = mod(D - B, CURVE.p);\n    const X3 = mod(E * F, CURVE.p);\n    const Y3 = mod(G * H, CURVE.p);\n    const T3 = mod(E * H, CURVE.p);\n    const Z3 = mod(F * G, CURVE.p);\n    return new Point(X3, Y3, Z3, T3);\n  }\n  multiplyUnsafe(scalar) {\n    let n = scalar;\n    if (scalar <= _0n) return Point.ZERO;\n    if (scalar === _1n) return this;\n    let p = Point.ZERO;\n    let d = this;\n    while (n > _0n) {\n      if (n & _1n) p = p.add(d);\n      d = d.double();\n      n >>= _1n;\n    }\n    return p;\n  }\n  static fromHex(hex) {\n    const bytes = ensureBytes(hex, 32);\n    const last = bytes[31] & 0x80;\n    bytes[31] &= 0x7f;\n    const y = bytesToNumberLE(bytes);\n    if (y >= CURVE.p) throw new Error(\"Expected 0 < number < P\");\n    const y2 = mod(y * y, CURVE.p);\n    const u = mod(y2 - _1n, CURVE.p);\n    const v = mod(CURVE.d * y2 + _1n, CURVE.p);\n    let x = mod(u * invert(v), CURVE.p);\n    if (!isSquare(x)) x = mod(x * sqrtMinusOne, CURVE.p);\n    const isLast = (x & _1n) === _1n;\n    if (last && !isLast) x = mod(-x, CURVE.p);\n    if (!last && isLast) x = mod(-x, CURVE.p);\n    return Point.fromAffine({ x, y });\n  }\n}\n\nPoint.BASE = Point.fromAffine({ x: CURVE.P[0], y: CURVE.P[1] });\nPoint.ZERO = new Point(_0n, _1n, _1n, _0n);\n\nfunction isValidFieldElement(n) {\n  return typeof n === \"bigint\" && _0n <= n && n < CURVE.p;\n}\n\nfunction sha512(message) {\n  if (typeof crypto?.subtle?.digest !== \"function\") {\n    throw new Error(\"crypto.subtle.digest not available\");\n  }\n  return crypto.subtle.digest(\"SHA-512\", message);\n}\n\nconst utils = {\n  sha512: async (msg) => {\n    const buf = await sha512(msg);\n    return new Uint8Array(buf);\n  },\n  randomBytes: (len) => {\n    const out = new Uint8Array(len);\n    crypto.getRandomValues(out);\n    return out;\n  },\n};\n\nasync function getPublicKeyAsync(privateKey) {\n  const key = assertPrivateKey(privateKey);\n  const { point } = await getExtendedPublicKey(key);\n  return point;\n}\n\nexport async function getPublicKey(privateKey) {\n  return getPublicKeyAsync(privateKey);\n}\n\nasync function signAsync(message, privateKey) {\n  const key = assertPrivateKey(privateKey);\n  const msg = ensureBytes(message);\n  const { head, prefix, scalar, point } = await getExtendedPublicKey(key);\n  prefix; point;\n  const r = modL_LE(await utils.sha512(concatBytes(prefix, msg)));\n  const R = Point.BASE.multiplyUnsafe(r).toRawBytes();\n  const k = modL_LE(await utils.sha512(concatBytes(R, point, msg)));\n  const s = mod(r + k * scalar, CURVE.n);\n  const signature = concatBytes(R, numberToBytesLE(s, 32));\n  return signature;\n}\n\nexport async function sign(message, privateKey) {\n  return signAsync(message, privateKey);\n}\n", "import { arrayToB64, b64ToArray } from \"../utils.mjs\";\nimport { getPublicKey, sign } from \"../vendor/noble-ed25519.mjs\";\n\nconst encoder = new TextEncoder();\n\nexport const DEFAULT_KDF_SETTINGS = {\n  algorithm: \"pbkdf2-sha256\",\n  hash: \"SHA-256\",\n  iterations: 310000,\n  saltLength: 16,\n  outputLength: 32,\n};\n\nconst DERIVATION_INFO = encoder.encode(\"go-send-ed25519-seed\");\n\nexport function generateSalt(length = DEFAULT_KDF_SETTINGS.saltLength) {\n  if (length <= 0) {\n    throw new Error(\"Salt length must be positive\");\n  }\n  const salt = new Uint8Array(length);\n  crypto.getRandomValues(salt);\n  return salt;\n}\n\nexport async function deriveSeed(password, salt, settings = DEFAULT_KDF_SETTINGS) {\n  if (!password) {\n    throw new Error(\"Password is required for seed derivation\");\n  }\n  if (!(salt instanceof Uint8Array)) {\n    throw new TypeError(\"Salt must be a Uint8Array\");\n  }\n\n  const iterations = settings.iterations || DEFAULT_KDF_SETTINGS.iterations;\n  const hash = settings.hash || DEFAULT_KDF_SETTINGS.hash;\n  const length = settings.outputLength || DEFAULT_KDF_SETTINGS.outputLength;\n\n  const keyMaterial = await crypto.subtle.importKey(\n    \"raw\",\n    encoder.encode(password),\n    \"PBKDF2\",\n    false,\n    [\"deriveBits\"]\n  );\n\n  const derivedBits = await crypto.subtle.deriveBits(\n    {\n      name: \"PBKDF2\",\n      salt,\n      iterations,\n      hash,\n    },\n    keyMaterial,\n    length * 8\n  );\n\n  const seed = new Uint8Array(derivedBits);\n\n  // Optional HKDF to decorrelate direct PBKDF2 output from Ed25519 private key\n  const hkdfKey = await crypto.subtle.importKey(\"raw\", seed, { name: \"HKDF\" }, false, [\n    \"deriveBits\",\n  ]);\n\n  const hkdfBits = await crypto.subtle.deriveBits(\n    {\n      name: \"HKDF\",\n      hash: \"SHA-256\",\n      salt: new Uint8Array(),\n      info: DERIVATION_INFO,\n    },\n    hkdfKey,\n    length * 8\n  );\n\n  seed.fill(0);\n  return new Uint8Array(hkdfBits);\n}\n\nexport async function deriveKeyPair(password, salt, settings = DEFAULT_KDF_SETTINGS) {\n  const seed = await deriveSeed(password, salt, settings);\n  const publicKey = await getPublicKey(seed);\n  return { seed, publicKey };\n}\n\nexport function serializeKDFSettings(settings = DEFAULT_KDF_SETTINGS) {\n  return {\n    algorithm: settings.algorithm,\n    hash: settings.hash,\n    iterations: settings.iterations,\n    saltLength: settings.saltLength,\n    outputLength: settings.outputLength,\n  };\n}\n\nexport function normalizeKDFSettings(settings) {\n  if (!settings) {\n    return { ...DEFAULT_KDF_SETTINGS };\n  }\n  return {\n    algorithm: settings.algorithm || DEFAULT_KDF_SETTINGS.algorithm,\n    hash: settings.hash || DEFAULT_KDF_SETTINGS.hash,\n    iterations: settings.iterations || DEFAULT_KDF_SETTINGS.iterations,\n    saltLength: settings.saltLength || DEFAULT_KDF_SETTINGS.saltLength,\n    outputLength: settings.outputLength || DEFAULT_KDF_SETTINGS.outputLength,\n  };\n}\n\nexport function encodeSalt(salt) {\n  return arrayToB64(salt);\n}\n\nexport function encodePublicKey(publicKey) {\n  return arrayToB64(publicKey);\n}\n\nexport function decodeSalt(saltB64) {\n  return b64ToArray(saltB64);\n}\n\nexport function decodePublicKey(publicKeyB64) {\n  return b64ToArray(publicKeyB64);\n}\n\nexport async function signChallenge(seed, challengeB64) {\n  const challenge = b64ToArray(challengeB64);\n  try {\n    const signature = await sign(challenge, seed);\n    return arrayToB64(signature);\n  } finally {\n    seed.fill(0);\n  }\n}\n"],
  "mappings": "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",
  "names": []
}
