import {
  __commonJS
} from "./chunk-5WRI5ZAA.js";

// node_modules/nanoassert/index.js
var require_nanoassert = __commonJS({
  "node_modules/nanoassert/index.js"(exports, module) {
    assert.notEqual = notEqual;
    assert.notOk = notOk;
    assert.equal = equal;
    assert.ok = assert;
    module.exports = assert;
    function equal(a, b, m) {
      assert(a == b, m);
    }
    function notEqual(a, b, m) {
      assert(a != b, m);
    }
    function notOk(t, m) {
      assert(!t, m);
    }
    function assert(t, m) {
      if (!t) throw new Error(m || "AssertionError");
    }
  }
});

// node_modules/nanoscheduler/index.js
var require_nanoscheduler = __commonJS({
  "node_modules/nanoscheduler/index.js"(exports, module) {
    var assert = require_nanoassert();
    var hasWindow = typeof window !== "undefined";
    function createScheduler() {
      var scheduler;
      if (hasWindow) {
        if (!window._nanoScheduler) window._nanoScheduler = new NanoScheduler(true);
        scheduler = window._nanoScheduler;
      } else {
        scheduler = new NanoScheduler();
      }
      return scheduler;
    }
    function NanoScheduler(hasWindow2) {
      this.hasWindow = hasWindow2;
      this.hasIdle = this.hasWindow && window.requestIdleCallback;
      this.method = this.hasIdle ? window.requestIdleCallback.bind(window) : this.setTimeout;
      this.scheduled = false;
      this.queue = [];
    }
    NanoScheduler.prototype.push = function(cb) {
      assert.equal(typeof cb, "function", "nanoscheduler.push: cb should be type function");
      this.queue.push(cb);
      this.schedule();
    };
    NanoScheduler.prototype.schedule = function() {
      if (this.scheduled) return;
      this.scheduled = true;
      var self = this;
      this.method(function(idleDeadline) {
        var cb;
        while (self.queue.length && idleDeadline.timeRemaining() > 0) {
          cb = self.queue.shift();
          cb(idleDeadline);
        }
        self.scheduled = false;
        if (self.queue.length) self.schedule();
      });
    };
    NanoScheduler.prototype.setTimeout = function(cb) {
      setTimeout(cb, 0, {
        timeRemaining: function() {
          return 1;
        }
      });
    };
    module.exports = createScheduler;
  }
});

// node_modules/nanotiming/browser.js
var require_browser = __commonJS({
  "node_modules/nanotiming/browser.js"(exports, module) {
    var scheduler = require_nanoscheduler()();
    var assert = require_nanoassert();
    var perf;
    nanotiming.disabled = true;
    try {
      perf = window.performance;
      nanotiming.disabled = window.localStorage.DISABLE_NANOTIMING === "true" || !perf.mark;
    } catch (e) {
    }
    module.exports = nanotiming;
    function nanotiming(name) {
      assert.equal(typeof name, "string", "nanotiming: name should be type string");
      if (nanotiming.disabled) return noop;
      var uuid = (perf.now() * 1e4).toFixed() % Number.MAX_SAFE_INTEGER;
      var startName = "start-" + uuid + "-" + name;
      perf.mark(startName);
      function end(cb) {
        var endName = "end-" + uuid + "-" + name;
        perf.mark(endName);
        scheduler.push(function() {
          var err = null;
          try {
            var measureName = name + " [" + uuid + "]";
            perf.measure(measureName, startName, endName);
            perf.clearMarks(startName);
            perf.clearMarks(endName);
          } catch (e) {
            err = e;
          }
          if (cb) cb(err, name);
        });
      }
      end.uuid = uuid;
      return end;
    }
    function noop(cb) {
      if (cb) {
        scheduler.push(function() {
          cb(new Error("nanotiming: performance API unavailable"));
        });
      }
    }
  }
});

export {
  require_nanoassert,
  require_browser
};
//# sourceMappingURL=chunk-ZGAGZEOQ.js.map
