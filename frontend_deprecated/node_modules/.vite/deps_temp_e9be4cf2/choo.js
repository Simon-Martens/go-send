import {
  require_nanobus
} from "./chunk-HAPA4TAD.js";
import {
  require_browser,
  require_nanoassert
} from "./chunk-ZGAGZEOQ.js";
import {
  __commonJS
} from "./chunk-5WRI5ZAA.js";

// node_modules/scroll-to-anchor/index.js
var require_scroll_to_anchor = __commonJS({
  "node_modules/scroll-to-anchor/index.js"(exports, module) {
    module.exports = scrollToAnchor;
    function scrollToAnchor(anchor, options) {
      if (anchor) {
        try {
          var el = document.querySelector(anchor);
          if (el) el.scrollIntoView(options);
        } catch (e) {
        }
      }
    }
  }
});

// node_modules/document-ready/index.js
var require_document_ready = __commonJS({
  "node_modules/document-ready/index.js"(exports, module) {
    "use strict";
    module.exports = ready;
    function ready(callback) {
      if (typeof document === "undefined") {
        throw new Error("document-ready only runs in the browser");
      }
      var state = document.readyState;
      if (state === "complete" || state === "interactive") {
        return setTimeout(callback, 0);
      }
      document.addEventListener("DOMContentLoaded", function onLoad() {
        callback();
      });
    }
  }
});

// node_modules/wayfarer/trie.js
var require_trie = __commonJS({
  "node_modules/wayfarer/trie.js"(exports, module) {
    var assert = require_nanoassert();
    module.exports = Trie;
    function Trie() {
      if (!(this instanceof Trie)) return new Trie();
      this.trie = { nodes: {} };
    }
    Trie.prototype.create = function(route) {
      assert.equal(typeof route, "string", "route should be a string");
      var routes = route.replace(/^\//, "").split("/");
      function createNode(index, trie) {
        var thisRoute = has(routes, index) && routes[index];
        if (thisRoute === false) return trie;
        var node = null;
        if (/^:|^\*/.test(thisRoute)) {
          if (!has(trie.nodes, "$$")) {
            node = { nodes: {} };
            trie.nodes.$$ = node;
          } else {
            node = trie.nodes.$$;
          }
          if (thisRoute[0] === "*") {
            trie.wildcard = true;
          }
          trie.name = thisRoute.replace(/^:|^\*/, "");
        } else if (!has(trie.nodes, thisRoute)) {
          node = { nodes: {} };
          trie.nodes[thisRoute] = node;
        } else {
          node = trie.nodes[thisRoute];
        }
        return createNode(index + 1, node);
      }
      return createNode(0, this.trie);
    };
    Trie.prototype.match = function(route) {
      assert.equal(typeof route, "string", "route should be a string");
      var routes = route.replace(/^\//, "").split("/");
      var params = {};
      function search(index, trie) {
        if (trie === void 0) return void 0;
        var thisRoute = routes[index];
        if (thisRoute === void 0) return trie;
        if (has(trie.nodes, thisRoute)) {
          return search(index + 1, trie.nodes[thisRoute]);
        } else if (trie.name) {
          try {
            params[trie.name] = decodeURIComponent(thisRoute);
          } catch (e) {
            return search(index, void 0);
          }
          return search(index + 1, trie.nodes.$$);
        } else if (trie.wildcard) {
          try {
            params.wildcard = decodeURIComponent(routes.slice(index).join("/"));
          } catch (e) {
            return search(index, void 0);
          }
          return trie.nodes.$$;
        } else {
          return search(index + 1);
        }
      }
      var node = search(0, this.trie);
      if (!node) return void 0;
      node = Object.assign({}, node);
      node.params = params;
      return node;
    };
    Trie.prototype.mount = function(route, trie) {
      assert.equal(typeof route, "string", "route should be a string");
      assert.equal(typeof trie, "object", "trie should be a object");
      var split = route.replace(/^\//, "").split("/");
      var node = null;
      var key = null;
      if (split.length === 1) {
        key = split[0];
        node = this.create(key);
      } else {
        var head = split.join("/");
        key = split[0];
        node = this.create(head);
      }
      Object.assign(node.nodes, trie.nodes);
      if (trie.name) node.name = trie.name;
      if (node.nodes[""]) {
        Object.keys(node.nodes[""]).forEach(function(key2) {
          if (key2 === "nodes") return;
          node[key2] = node.nodes[""][key2];
        });
        Object.assign(node.nodes, node.nodes[""].nodes);
        delete node.nodes[""].nodes;
      }
    };
    function has(object, property) {
      return Object.prototype.hasOwnProperty.call(object, property);
    }
  }
});

// node_modules/wayfarer/index.js
var require_wayfarer = __commonJS({
  "node_modules/wayfarer/index.js"(exports, module) {
    var assert = require_nanoassert();
    var trie = require_trie();
    module.exports = Wayfarer;
    function Wayfarer(dft) {
      if (!(this instanceof Wayfarer)) return new Wayfarer(dft);
      var _default = (dft || "").replace(/^\//, "");
      var _trie = trie();
      emit._trie = _trie;
      emit.on = on;
      emit.emit = emit;
      emit.match = match;
      emit._wayfarer = true;
      return emit;
      function on(route, cb) {
        assert.equal(typeof route, "string");
        assert.equal(typeof cb, "function");
        route = route || "/";
        if (cb._wayfarer && cb._trie) {
          _trie.mount(route, cb._trie.trie);
        } else {
          var node = _trie.create(route);
          node.cb = cb;
          node.route = route;
        }
        return emit;
      }
      function emit(route) {
        var matched = match(route);
        var args = new Array(arguments.length);
        args[0] = matched.params;
        for (var i = 1; i < args.length; i++) {
          args[i] = arguments[i];
        }
        return matched.cb.apply(matched.cb, args);
      }
      function match(route) {
        assert.notEqual(route, void 0, "'route' must be defined");
        var matched = _trie.match(route);
        if (matched && matched.cb) return new Route(matched);
        var dft2 = _trie.match(_default);
        if (dft2 && dft2.cb) return new Route(dft2);
        throw new Error("route '" + route + "' did not match");
      }
      function Route(matched) {
        this.cb = matched.cb;
        this.route = matched.route;
        this.params = matched.params;
      }
    }
  }
});

// node_modules/nanorouter/index.js
var require_nanorouter = __commonJS({
  "node_modules/nanorouter/index.js"(exports, module) {
    var assert = require_nanoassert();
    var wayfarer = require_wayfarer();
    var isLocalFile = /file:\/\//.test(
      typeof window === "object" && window.location && window.location.origin
    );
    var electron = "^(file://|/)(.*.html?/?)?";
    var protocol = "^(http(s)?(://))?(www.)?";
    var domain = "[a-zA-Z0-9-_.]+(:[0-9]{1,5})?(/{1})?";
    var qs = "[?].*$";
    var stripElectron = new RegExp(electron);
    var prefix = new RegExp(protocol + domain);
    var normalize = new RegExp("#");
    var suffix = new RegExp(qs);
    module.exports = Nanorouter;
    function Nanorouter(opts) {
      if (!(this instanceof Nanorouter)) return new Nanorouter(opts);
      opts = opts || {};
      this.router = wayfarer(opts.default || "/404");
    }
    Nanorouter.prototype.on = function(routename, listener) {
      assert.equal(typeof routename, "string");
      routename = routename.replace(/^[#/]/, "");
      this.router.on(routename, listener);
    };
    Nanorouter.prototype.emit = function(routename) {
      assert.equal(typeof routename, "string");
      routename = pathname(routename, isLocalFile);
      return this.router.emit(routename);
    };
    Nanorouter.prototype.match = function(routename) {
      assert.equal(typeof routename, "string");
      routename = pathname(routename, isLocalFile);
      return this.router.match(routename);
    };
    function pathname(routename, isElectron) {
      if (isElectron) routename = routename.replace(stripElectron, "");
      else routename = routename.replace(prefix, "");
      return decodeURI(routename.replace(suffix, "").replace(normalize, "/"));
    }
  }
});

// node_modules/nanomorph/lib/events.js
var require_events = __commonJS({
  "node_modules/nanomorph/lib/events.js"(exports, module) {
    module.exports = [
      // attribute events (can be set with attributes)
      "onclick",
      "ondblclick",
      "onmousedown",
      "onmouseup",
      "onmouseover",
      "onmousemove",
      "onmouseout",
      "onmouseenter",
      "onmouseleave",
      "ontouchcancel",
      "ontouchend",
      "ontouchmove",
      "ontouchstart",
      "ondragstart",
      "ondrag",
      "ondragenter",
      "ondragleave",
      "ondragover",
      "ondrop",
      "ondragend",
      "onkeydown",
      "onkeypress",
      "onkeyup",
      "onunload",
      "onabort",
      "onerror",
      "onresize",
      "onscroll",
      "onselect",
      "onchange",
      "onsubmit",
      "onreset",
      "onfocus",
      "onblur",
      "oninput",
      "onanimationend",
      "onanimationiteration",
      "onanimationstart",
      // other common events
      "oncontextmenu",
      "onfocusin",
      "onfocusout"
    ];
  }
});

// node_modules/nanomorph/lib/morph.js
var require_morph = __commonJS({
  "node_modules/nanomorph/lib/morph.js"(exports, module) {
    var events = require_events();
    var eventsLength = events.length;
    var ELEMENT_NODE = 1;
    var TEXT_NODE = 3;
    var COMMENT_NODE = 8;
    module.exports = morph;
    function morph(newNode, oldNode) {
      var nodeType = newNode.nodeType;
      var nodeName = newNode.nodeName;
      if (nodeType === ELEMENT_NODE) {
        copyAttrs(newNode, oldNode);
      }
      if (nodeType === TEXT_NODE || nodeType === COMMENT_NODE) {
        if (oldNode.nodeValue !== newNode.nodeValue) {
          oldNode.nodeValue = newNode.nodeValue;
        }
      }
      if (nodeName === "INPUT") updateInput(newNode, oldNode);
      else if (nodeName === "OPTION") updateOption(newNode, oldNode);
      else if (nodeName === "TEXTAREA") updateTextarea(newNode, oldNode);
      copyEvents(newNode, oldNode);
    }
    function copyAttrs(newNode, oldNode) {
      var oldAttrs = oldNode.attributes;
      var newAttrs = newNode.attributes;
      var attrNamespaceURI = null;
      var attrValue = null;
      var fromValue = null;
      var attrName = null;
      var attr = null;
      for (var i = newAttrs.length - 1; i >= 0; --i) {
        attr = newAttrs[i];
        attrName = attr.name;
        attrNamespaceURI = attr.namespaceURI;
        attrValue = attr.value;
        if (attrNamespaceURI) {
          attrName = attr.localName || attrName;
          fromValue = oldNode.getAttributeNS(attrNamespaceURI, attrName);
          if (fromValue !== attrValue) {
            oldNode.setAttributeNS(attrNamespaceURI, attrName, attrValue);
          }
        } else {
          if (!oldNode.hasAttribute(attrName)) {
            oldNode.setAttribute(attrName, attrValue);
          } else {
            fromValue = oldNode.getAttribute(attrName);
            if (fromValue !== attrValue) {
              if (attrValue === "null" || attrValue === "undefined") {
                oldNode.removeAttribute(attrName);
              } else {
                oldNode.setAttribute(attrName, attrValue);
              }
            }
          }
        }
      }
      for (var j = oldAttrs.length - 1; j >= 0; --j) {
        attr = oldAttrs[j];
        if (attr.specified !== false) {
          attrName = attr.name;
          attrNamespaceURI = attr.namespaceURI;
          if (attrNamespaceURI) {
            attrName = attr.localName || attrName;
            if (!newNode.hasAttributeNS(attrNamespaceURI, attrName)) {
              oldNode.removeAttributeNS(attrNamespaceURI, attrName);
            }
          } else {
            if (!newNode.hasAttributeNS(null, attrName)) {
              oldNode.removeAttribute(attrName);
            }
          }
        }
      }
    }
    function copyEvents(newNode, oldNode) {
      for (var i = 0; i < eventsLength; i++) {
        var ev = events[i];
        if (newNode[ev]) {
          oldNode[ev] = newNode[ev];
        } else if (oldNode[ev]) {
          oldNode[ev] = void 0;
        }
      }
    }
    function updateOption(newNode, oldNode) {
      updateAttribute(newNode, oldNode, "selected");
    }
    function updateInput(newNode, oldNode) {
      var newValue = newNode.value;
      var oldValue = oldNode.value;
      updateAttribute(newNode, oldNode, "checked");
      updateAttribute(newNode, oldNode, "disabled");
      if (newNode.indeterminate !== oldNode.indeterminate) {
        oldNode.indeterminate = newNode.indeterminate;
      }
      if (oldNode.type === "file") return;
      if (newValue !== oldValue) {
        oldNode.setAttribute("value", newValue);
        oldNode.value = newValue;
      }
      if (newValue === "null") {
        oldNode.value = "";
        oldNode.removeAttribute("value");
      }
      if (!newNode.hasAttributeNS(null, "value")) {
        oldNode.removeAttribute("value");
      } else if (oldNode.type === "range") {
        oldNode.value = newValue;
      }
    }
    function updateTextarea(newNode, oldNode) {
      var newValue = newNode.value;
      if (newValue !== oldNode.value) {
        oldNode.value = newValue;
      }
      if (oldNode.firstChild && oldNode.firstChild.nodeValue !== newValue) {
        if (newValue === "" && oldNode.firstChild.nodeValue === oldNode.placeholder) {
          return;
        }
        oldNode.firstChild.nodeValue = newValue;
      }
    }
    function updateAttribute(newNode, oldNode, name) {
      if (newNode[name] !== oldNode[name]) {
        oldNode[name] = newNode[name];
        if (newNode[name]) {
          oldNode.setAttribute(name, "");
        } else {
          oldNode.removeAttribute(name);
        }
      }
    }
  }
});

// node_modules/nanomorph/index.js
var require_nanomorph = __commonJS({
  "node_modules/nanomorph/index.js"(exports, module) {
    var assert = require_nanoassert();
    var morph = require_morph();
    var TEXT_NODE = 3;
    module.exports = nanomorph;
    function nanomorph(oldTree, newTree, options) {
      assert.equal(typeof oldTree, "object", "nanomorph: oldTree should be an object");
      assert.equal(typeof newTree, "object", "nanomorph: newTree should be an object");
      if (options && options.childrenOnly) {
        updateChildren(newTree, oldTree);
        return oldTree;
      }
      assert.notEqual(
        newTree.nodeType,
        11,
        "nanomorph: newTree should have one root node (which is not a DocumentFragment)"
      );
      return walk(newTree, oldTree);
    }
    function walk(newNode, oldNode) {
      if (!oldNode) {
        return newNode;
      } else if (!newNode) {
        return null;
      } else if (newNode.isSameNode && newNode.isSameNode(oldNode)) {
        return oldNode;
      } else if (newNode.tagName !== oldNode.tagName || getComponentId(newNode) !== getComponentId(oldNode)) {
        return newNode;
      } else {
        morph(newNode, oldNode);
        updateChildren(newNode, oldNode);
        return oldNode;
      }
    }
    function getComponentId(node) {
      return node.dataset ? node.dataset.nanomorphComponentId : void 0;
    }
    function updateChildren(newNode, oldNode) {
      var oldChild, newChild, morphed, oldMatch;
      var offset = 0;
      for (var i = 0; ; i++) {
        oldChild = oldNode.childNodes[i];
        newChild = newNode.childNodes[i - offset];
        if (!oldChild && !newChild) {
          break;
        } else if (!newChild) {
          oldNode.removeChild(oldChild);
          i--;
        } else if (!oldChild) {
          oldNode.appendChild(newChild);
          offset++;
        } else if (same(newChild, oldChild)) {
          morphed = walk(newChild, oldChild);
          if (morphed !== oldChild) {
            oldNode.replaceChild(morphed, oldChild);
            offset++;
          }
        } else {
          oldMatch = null;
          for (var j = i; j < oldNode.childNodes.length; j++) {
            if (same(oldNode.childNodes[j], newChild)) {
              oldMatch = oldNode.childNodes[j];
              break;
            }
          }
          if (oldMatch) {
            morphed = walk(newChild, oldMatch);
            if (morphed !== oldMatch) offset++;
            oldNode.insertBefore(morphed, oldChild);
          } else if (!newChild.id && !oldChild.id) {
            morphed = walk(newChild, oldChild);
            if (morphed !== oldChild) {
              oldNode.replaceChild(morphed, oldChild);
              offset++;
            }
          } else {
            oldNode.insertBefore(newChild, oldChild);
            offset++;
          }
        }
      }
    }
    function same(a, b) {
      if (a.id) return a.id === b.id;
      if (a.isSameNode) return a.isSameNode(b);
      if (a.tagName !== b.tagName) return false;
      if (a.type === TEXT_NODE) return a.nodeValue === b.nodeValue;
      return false;
    }
  }
});

// node_modules/nanoquery/browser.js
var require_browser2 = __commonJS({
  "node_modules/nanoquery/browser.js"(exports, module) {
    var reg = /([^?=&]+)(=([^&]*))?/g;
    var assert = require_nanoassert();
    module.exports = qs;
    function qs(url) {
      assert.equal(typeof url, "string", "nanoquery: url should be type string");
      var obj = {};
      url.replace(/^.*\?/, "").replace(reg, function(a0, a1, a2, a3) {
        var value = decodeURIComponent(a3);
        var key = decodeURIComponent(a1);
        if (obj.hasOwnProperty(key)) {
          if (Array.isArray(obj[key])) obj[key].push(value);
          else obj[key] = [obj[key], value];
        } else {
          obj[key] = value;
        }
      });
      return obj;
    }
  }
});

// node_modules/nanohref/index.js
var require_nanohref = __commonJS({
  "node_modules/nanohref/index.js"(exports, module) {
    var assert = require_nanoassert();
    var safeExternalLink = /(noopener|noreferrer) (noopener|noreferrer)/;
    var protocolLink = /^[\w-_]+:/;
    module.exports = href;
    function href(cb, root) {
      assert.notEqual(typeof window, "undefined", "nanohref: expected window to exist");
      root = root || window.document;
      assert.equal(typeof cb, "function", "nanohref: cb should be type function");
      assert.equal(typeof root, "object", "nanohref: root should be type object");
      window.addEventListener("click", function(e) {
        if (e.button && e.button !== 0 || e.ctrlKey || e.metaKey || e.altKey || e.shiftKey || e.defaultPrevented) return;
        var anchor = function traverse(node) {
          if (!node || node === root) return;
          if (node.localName !== "a" || node.href === void 0) {
            return traverse(node.parentNode);
          }
          return node;
        }(e.target);
        if (!anchor) return;
        if (window.location.protocol !== anchor.protocol || window.location.hostname !== anchor.hostname || window.location.port !== anchor.port || anchor.hasAttribute("data-nanohref-ignore") || anchor.hasAttribute("download") || anchor.getAttribute("target") === "_blank" && safeExternalLink.test(anchor.getAttribute("rel")) || protocolLink.test(anchor.getAttribute("href"))) return;
        e.preventDefault();
        cb(anchor);
      });
    }
  }
});

// node_modules/nanoraf/index.js
var require_nanoraf = __commonJS({
  "node_modules/nanoraf/index.js"(exports, module) {
    "use strict";
    var assert = require_nanoassert();
    module.exports = nanoraf;
    function nanoraf(render, raf) {
      assert.equal(typeof render, "function", "nanoraf: render should be a function");
      assert.ok(typeof raf === "function" || typeof raf === "undefined", "nanoraf: raf should be a function or undefined");
      if (!raf) raf = window.requestAnimationFrame;
      var redrawScheduled = false;
      var args = null;
      return function frame() {
        if (args === null && !redrawScheduled) {
          redrawScheduled = true;
          raf(function redraw() {
            redrawScheduled = false;
            var length = args.length;
            var _args = new Array(length);
            for (var i = 0; i < length; i++) _args[i] = args[i];
            render.apply(render, _args);
            args = null;
          });
        }
        args = arguments;
      };
    }
  }
});

// node_modules/nanolru/index.js
var require_nanolru = __commonJS({
  "node_modules/nanolru/index.js"(exports, module) {
    module.exports = LRU;
    function LRU(opts) {
      if (!(this instanceof LRU)) return new LRU(opts);
      if (typeof opts === "number") opts = { max: opts };
      if (!opts) opts = {};
      this.cache = {};
      this.head = this.tail = null;
      this.length = 0;
      this.max = opts.max || 1e3;
      this.maxAge = opts.maxAge || 0;
    }
    Object.defineProperty(LRU.prototype, "keys", {
      get: function() {
        return Object.keys(this.cache);
      }
    });
    LRU.prototype.clear = function() {
      this.cache = {};
      this.head = this.tail = null;
      this.length = 0;
    };
    LRU.prototype.remove = function(key) {
      if (typeof key !== "string") key = "" + key;
      if (!this.cache.hasOwnProperty(key)) return;
      var element = this.cache[key];
      delete this.cache[key];
      this._unlink(key, element.prev, element.next);
      return element.value;
    };
    LRU.prototype._unlink = function(key, prev, next) {
      this.length--;
      if (this.length === 0) {
        this.head = this.tail = null;
      } else {
        if (this.head === key) {
          this.head = prev;
          this.cache[this.head].next = null;
        } else if (this.tail === key) {
          this.tail = next;
          this.cache[this.tail].prev = null;
        } else {
          this.cache[prev].next = next;
          this.cache[next].prev = prev;
        }
      }
    };
    LRU.prototype.peek = function(key) {
      if (!this.cache.hasOwnProperty(key)) return;
      var element = this.cache[key];
      if (!this._checkAge(key, element)) return;
      return element.value;
    };
    LRU.prototype.set = function(key, value) {
      if (typeof key !== "string") key = "" + key;
      var element;
      if (this.cache.hasOwnProperty(key)) {
        element = this.cache[key];
        element.value = value;
        if (this.maxAge) element.modified = Date.now();
        if (key === this.head) return value;
        this._unlink(key, element.prev, element.next);
      } else {
        element = { value, modified: 0, next: null, prev: null };
        if (this.maxAge) element.modified = Date.now();
        this.cache[key] = element;
        if (this.length === this.max) this.evict();
      }
      this.length++;
      element.next = null;
      element.prev = this.head;
      if (this.head) this.cache[this.head].next = key;
      this.head = key;
      if (!this.tail) this.tail = key;
      return value;
    };
    LRU.prototype._checkAge = function(key, element) {
      if (this.maxAge && Date.now() - element.modified > this.maxAge) {
        this.remove(key);
        return false;
      }
      return true;
    };
    LRU.prototype.get = function(key) {
      if (typeof key !== "string") key = "" + key;
      if (!this.cache.hasOwnProperty(key)) return;
      var element = this.cache[key];
      if (!this._checkAge(key, element)) return;
      if (this.head !== key) {
        if (key === this.tail) {
          this.tail = element.next;
          this.cache[this.tail].prev = null;
        } else {
          this.cache[element.prev].next = element.next;
        }
        this.cache[element.next].prev = element.prev;
        this.cache[this.head].next = key;
        element.prev = this.head;
        element.next = null;
        this.head = key;
      }
      return element.value;
    };
    LRU.prototype.evict = function() {
      if (!this.tail) return;
      this.remove(this.tail);
    };
  }
});

// node_modules/choo/component/cache.js
var require_cache = __commonJS({
  "node_modules/choo/component/cache.js"(exports, module) {
    var assert = require_nanoassert();
    var LRU = require_nanolru();
    module.exports = ChooComponentCache;
    function ChooComponentCache(state, emit, lru) {
      assert.ok(this instanceof ChooComponentCache, "ChooComponentCache should be created with `new`");
      assert.equal(typeof state, "object", "ChooComponentCache: state should be type object");
      assert.equal(typeof emit, "function", "ChooComponentCache: emit should be type function");
      if (typeof lru === "number") this.cache = new LRU(lru);
      else this.cache = lru || new LRU(100);
      this.state = state;
      this.emit = emit;
    }
    ChooComponentCache.prototype.render = function(Component, id) {
      assert.equal(typeof Component, "function", "ChooComponentCache.render: Component should be type function");
      assert.ok(typeof id === "string" || typeof id === "number", "ChooComponentCache.render: id should be type string or type number");
      var el = this.cache.get(id);
      if (!el) {
        var args = [];
        for (var i = 2, len = arguments.length; i < len; i++) {
          args.push(arguments[i]);
        }
        args.unshift(Component, id, this.state, this.emit);
        el = newCall.apply(newCall, args);
        this.cache.set(id, el);
      }
      return el;
    };
    function newCall(Cls) {
      return new (Cls.bind.apply(Cls, arguments))();
    }
  }
});

// node_modules/choo/index.js
var require_choo = __commonJS({
  "node_modules/choo/index.js"(exports, module) {
    var scrollToAnchor = require_scroll_to_anchor();
    var documentReady = require_document_ready();
    var nanotiming = require_browser();
    var nanorouter = require_nanorouter();
    var nanomorph = require_nanomorph();
    var nanoquery = require_browser2();
    var nanohref = require_nanohref();
    var nanoraf = require_nanoraf();
    var nanobus = require_nanobus();
    var assert = require_nanoassert();
    var Cache = require_cache();
    module.exports = Choo;
    var HISTORY_OBJECT = {};
    function Choo(opts) {
      var timing = nanotiming("choo.constructor");
      if (!(this instanceof Choo)) return new Choo(opts);
      opts = opts || {};
      assert.equal(typeof opts, "object", "choo: opts should be type object");
      var self = this;
      this._events = {
        DOMCONTENTLOADED: "DOMContentLoaded",
        DOMTITLECHANGE: "DOMTitleChange",
        REPLACESTATE: "replaceState",
        PUSHSTATE: "pushState",
        NAVIGATE: "navigate",
        POPSTATE: "popState",
        RENDER: "render"
      };
      this._historyEnabled = opts.history === void 0 ? true : opts.history;
      this._hrefEnabled = opts.href === void 0 ? true : opts.href;
      this._hashEnabled = opts.hash === void 0 ? false : opts.hash;
      this._hasWindow = typeof window !== "undefined";
      this._cache = opts.cache;
      this._loaded = false;
      this._stores = [ondomtitlechange];
      this._tree = null;
      var _state = {
        events: this._events,
        components: {}
      };
      if (this._hasWindow) {
        this.state = window.initialState ? Object.assign({}, window.initialState, _state) : _state;
        delete window.initialState;
      } else {
        this.state = _state;
      }
      this.router = nanorouter({ curry: true });
      this.emitter = nanobus("choo.emit");
      this.emit = this.emitter.emit.bind(this.emitter);
      if (this._hasWindow) this.state.title = document.title;
      function ondomtitlechange(state) {
        self.emitter.prependListener(self._events.DOMTITLECHANGE, function(title) {
          assert.equal(typeof title, "string", "events.DOMTitleChange: title should be type string");
          state.title = title;
          if (self._hasWindow) document.title = title;
        });
      }
      timing();
    }
    Choo.prototype.route = function(route, handler) {
      var routeTiming = nanotiming("choo.route('" + route + "')");
      assert.equal(typeof route, "string", "choo.route: route should be type string");
      assert.equal(typeof handler, "function", "choo.handler: route should be type function");
      this.router.on(route, handler);
      routeTiming();
    };
    Choo.prototype.use = function(cb) {
      assert.equal(typeof cb, "function", "choo.use: cb should be type function");
      var self = this;
      this._stores.push(function(state) {
        var msg = "choo.use";
        msg = cb.storeName ? msg + "(" + cb.storeName + ")" : msg;
        var endTiming = nanotiming(msg);
        cb(state, self.emitter, self);
        endTiming();
      });
    };
    Choo.prototype.start = function() {
      assert.equal(typeof window, "object", "choo.start: window was not found. .start() must be called in a browser, use .toString() if running in Node");
      var startTiming = nanotiming("choo.start");
      var self = this;
      if (this._historyEnabled) {
        this.emitter.prependListener(this._events.NAVIGATE, function() {
          self._matchRoute(self.state);
          if (self._loaded) {
            self.emitter.emit(self._events.RENDER);
            setTimeout(scrollToAnchor.bind(null, window.location.hash), 0);
          }
        });
        this.emitter.prependListener(this._events.POPSTATE, function() {
          self.emitter.emit(self._events.NAVIGATE);
        });
        this.emitter.prependListener(this._events.PUSHSTATE, function(href) {
          assert.equal(typeof href, "string", "events.pushState: href should be type string");
          window.history.pushState(HISTORY_OBJECT, null, href);
          self.emitter.emit(self._events.NAVIGATE);
        });
        this.emitter.prependListener(this._events.REPLACESTATE, function(href) {
          assert.equal(typeof href, "string", "events.replaceState: href should be type string");
          window.history.replaceState(HISTORY_OBJECT, null, href);
          self.emitter.emit(self._events.NAVIGATE);
        });
        window.onpopstate = function() {
          self.emitter.emit(self._events.POPSTATE);
        };
        if (self._hrefEnabled) {
          nanohref(function(location) {
            var href = location.href;
            var hash = location.hash;
            if (href === window.location.href) {
              if (!self._hashEnabled && hash) scrollToAnchor(hash);
              return;
            }
            self.emitter.emit(self._events.PUSHSTATE, href);
          });
        }
      }
      this._setCache(this.state);
      this._matchRoute(this.state);
      this._stores.forEach(function(initStore) {
        initStore(self.state);
      });
      this._tree = this._prerender(this.state);
      assert.ok(this._tree, "choo.start: no valid DOM node returned for location " + this.state.href);
      this.emitter.prependListener(self._events.RENDER, nanoraf(function() {
        var renderTiming = nanotiming("choo.render");
        var newTree = self._prerender(self.state);
        assert.ok(newTree, "choo.render: no valid DOM node returned for location " + self.state.href);
        assert.equal(self._tree.nodeName, newTree.nodeName, "choo.render: The target node <" + self._tree.nodeName.toLowerCase() + "> is not the same type as the new node <" + newTree.nodeName.toLowerCase() + ">.");
        var morphTiming = nanotiming("choo.morph");
        nanomorph(self._tree, newTree);
        morphTiming();
        renderTiming();
      }));
      documentReady(function() {
        self.emitter.emit(self._events.DOMCONTENTLOADED);
        self._loaded = true;
      });
      startTiming();
      return this._tree;
    };
    Choo.prototype.mount = function mount(selector) {
      var mountTiming = nanotiming("choo.mount('" + selector + "')");
      if (typeof window !== "object") {
        assert.ok(typeof selector === "string", "choo.mount: selector should be type String");
        this.selector = selector;
        mountTiming();
        return this;
      }
      assert.ok(typeof selector === "string" || typeof selector === "object", "choo.mount: selector should be type String or HTMLElement");
      var self = this;
      documentReady(function() {
        var renderTiming = nanotiming("choo.render");
        var newTree = self.start();
        if (typeof selector === "string") {
          self._tree = document.querySelector(selector);
        } else {
          self._tree = selector;
        }
        assert.ok(self._tree, "choo.mount: could not query selector: " + selector);
        assert.equal(self._tree.nodeName, newTree.nodeName, "choo.mount: The target node <" + self._tree.nodeName.toLowerCase() + "> is not the same type as the new node <" + newTree.nodeName.toLowerCase() + ">.");
        var morphTiming = nanotiming("choo.morph");
        nanomorph(self._tree, newTree);
        morphTiming();
        renderTiming();
      });
      mountTiming();
    };
    Choo.prototype.toString = function(location, state) {
      state = state || {};
      state.components = state.components || {};
      state.events = Object.assign({}, state.events, this._events);
      assert.notEqual(typeof window, "object", "choo.mount: window was found. .toString() must be called in Node, use .start() or .mount() if running in the browser");
      assert.equal(typeof location, "string", "choo.toString: location should be type string");
      assert.equal(typeof state, "object", "choo.toString: state should be type object");
      this._setCache(state);
      this._matchRoute(state, location);
      this.emitter.removeAllListeners();
      this._stores.forEach(function(initStore) {
        initStore(state);
      });
      var html = this._prerender(state);
      assert.ok(html, "choo.toString: no valid value returned for the route " + location);
      assert(!Array.isArray(html), "choo.toString: return value was an array for the route " + location);
      return typeof html.outerHTML === "string" ? html.outerHTML : html.toString();
    };
    Choo.prototype._matchRoute = function(state, locationOverride) {
      var location, queryString;
      if (locationOverride) {
        location = locationOverride.replace(/\?.+$/, "").replace(/\/$/, "");
        if (!this._hashEnabled) location = location.replace(/#.+$/, "");
        queryString = locationOverride;
      } else {
        location = window.location.pathname.replace(/\/$/, "");
        if (this._hashEnabled) location += window.location.hash.replace(/^#/, "/");
        queryString = window.location.search;
      }
      var matched = this.router.match(location);
      this._handler = matched.cb;
      state.href = location;
      state.query = nanoquery(queryString);
      state.route = matched.route;
      state.params = matched.params;
    };
    Choo.prototype._prerender = function(state) {
      var routeTiming = nanotiming("choo.prerender('" + state.route + "')");
      var res = this._handler(state, this.emit);
      routeTiming();
      return res;
    };
    Choo.prototype._setCache = function(state) {
      var cache = new Cache(state, this.emitter.emit.bind(this.emitter), this._cache);
      state.cache = renderComponent;
      function renderComponent(Component, id) {
        assert.equal(typeof Component, "function", "choo.state.cache: Component should be type function");
        var args = [];
        for (var i = 0, len = arguments.length; i < len; i++) {
          args.push(arguments[i]);
        }
        return cache.render.apply(cache, args);
      }
      renderComponent.toJSON = function() {
        return null;
      };
    };
  }
});
export default require_choo();
//# sourceMappingURL=choo.js.map
