{
  "version": 3,
  "sources": ["../../src/utils-worker.mjs", "../../src/streams.mjs", "../../src/crypto/ece.mjs", "../../src/api.mjs"],
  "sourcesContent": ["// Worker-safe utilities (no DOM dependencies)\n\n// INFO: base64 encoding/decoding\n// INFO: support for .toBase64() and .fromBase64() was added to browsers in late 24. So we use this for now.\nexport function arrayToB64(array) {\n  let bin = \"\";\n  const chunkSize = 0x8000; // 32k chars per chunk\n  for (let i = 0; i < array.length; i += chunkSize) {\n    bin += String.fromCharCode(...array.subarray(i, i + chunkSize));\n  }\n  return btoa(bin).replace(/\\+/g, \"-\").replace(/\\//g, \"_\").replace(/=+$/, \"\");\n}\n\nexport function b64ToArray(str) {\n  const b64 =\n    str.replace(/-/g, \"+\").replace(/_/g, \"/\") +\n    \"===\".slice((str.length + 3) % 4);\n  const bin = atob(b64);\n  const out = new Uint8Array(bin.length);\n  for (let i = 0; i < bin.length; i++) out[i] = bin.charCodeAt(i);\n  return out;\n}\n\n// Concatenate multiple Uint8Arrays into a single Uint8Array\nexport function concatUint8Arrays(arrays) {\n  const totalLength = arrays.reduce((sum, arr) => sum + arr.length, 0);\n  const result = new Uint8Array(totalLength);\n  let offset = 0;\n  for (const arr of arrays) {\n    result.set(arr, offset);\n    offset += arr.length;\n  }\n  return result;\n}\n\n// Read a 32-bit unsigned integer in big-endian format\nexport function readUint32BE(array, offset) {\n  const view = new DataView(array.buffer, array.byteOffset, array.byteLength);\n  return view.getUint32(offset, false); // false = big-endian\n}\n\n// Write a 32-bit unsigned integer in big-endian format\nexport function writeUint32BE(array, offset, value) {\n  const view = new DataView(array.buffer, array.byteOffset, array.byteLength);\n  view.setUint32(offset, value, false); // false = big-endian\n}\n\n// Read an 8-bit unsigned integer\nexport function readUint8(array, offset) {\n  return array[offset];\n}\n\n// Write an 8-bit unsigned integer\nexport function writeUint8(array, offset, value) {\n  array[offset] = value;\n}\n\n//////////////////// OTHER HELPERS ////////////////////\nexport function delay(delay = 100) {\n  return new Promise((resolve) => setTimeout(resolve, delay));\n}\n\nexport async function streamToArrayBuffer(stream, size) {\n  const reader = stream.getReader();\n  let state = await reader.read();\n\n  if (size) {\n    const result = new Uint8Array(size);\n    let offset = 0;\n    while (!state.done) {\n      result.set(state.value, offset);\n      offset += state.value.length;\n      state = await reader.read();\n    }\n    return result.buffer;\n  }\n\n  const parts = [];\n  let len = 0;\n  while (!state.done) {\n    parts.push(state.value);\n    len += state.value.length;\n    state = await reader.read();\n  }\n  let offset = 0;\n  const result = new Uint8Array(len);\n  for (const part of parts) {\n    result.set(part, offset);\n    offset += part.length;\n  }\n  return result.buffer;\n}\n", "/* global TransformStream */\n\nexport function transformStream(readable, transformer = {}, oncancel) {\n  const reader = readable.getReader();\n  const wrappedTransformer = transformer || {};\n\n  return new ReadableStream({\n    async start(controller) {\n      if (wrappedTransformer.start) {\n        await wrappedTransformer.start(controller);\n      }\n    },\n\n    async pull(controller) {\n      while (true) {\n        const { value, done } = await reader.read();\n\n        if (done) {\n          if (wrappedTransformer.flush) {\n            await wrappedTransformer.flush(controller);\n          }\n          reader.releaseLock();\n          controller.close();\n          return;\n        }\n\n        if (!wrappedTransformer.transform) {\n          controller.enqueue(value);\n          return;\n        }\n\n        let enqueued = false;\n        const wrappedController = {\n          enqueue(chunk) {\n            enqueued = true;\n            controller.enqueue(chunk);\n          }\n        };\n\n        await wrappedTransformer.transform(value, wrappedController);\n\n        if (enqueued) {\n          return;\n        }\n        // If nothing was enqueued, loop to read the next chunk.\n      }\n    },\n\n    cancel(reason) {\n      reader.cancel(reason);\n      if (wrappedTransformer.cancel) {\n        wrappedTransformer.cancel(reason);\n      }\n      if (oncancel) {\n        oncancel(reason);\n      }\n    }\n  });\n}\n\nclass BlobStreamController {\n  constructor(blob, size) {\n    this.blob = blob;\n    this.index = 0;\n    this.chunkSize = size || 1024 * 64;\n  }\n\n  pull(controller) {\n    return new Promise((resolve, reject) => {\n      const bytesLeft = this.blob.size - this.index;\n      if (bytesLeft <= 0) {\n        controller.close();\n        return resolve();\n      }\n      const size = Math.min(this.chunkSize, bytesLeft);\n      const slice = this.blob.slice(this.index, this.index + size);\n      const reader = new FileReader();\n      reader.onload = () => {\n        controller.enqueue(new Uint8Array(reader.result));\n        resolve();\n      };\n      reader.onerror = reject;\n      reader.readAsArrayBuffer(slice);\n      this.index += size;\n    });\n  }\n}\n\nexport function blobStream(blob, size) {\n  return new ReadableStream(new BlobStreamController(blob, size));\n}\n\nclass ConcatStreamController {\n  constructor(streams) {\n    this.streams = streams;\n    this.index = 0;\n    this.reader = null;\n    this.nextReader();\n  }\n\n  nextReader() {\n    const next = this.streams[this.index++];\n    this.reader = next && next.getReader();\n  }\n\n  async pull(controller) {\n    if (!this.reader) {\n      return controller.close();\n    }\n    const data = await this.reader.read();\n    if (data.done) {\n      this.nextReader();\n      return this.pull(controller);\n    }\n    controller.enqueue(data.value);\n  }\n}\n\nexport function concatStream(streams) {\n  return new ReadableStream(new ConcatStreamController(streams));\n}\n", "import { transformStream } from \"../streams\";\nimport {\n  concatUint8Arrays,\n  readUint32BE,\n  writeUint32BE,\n  readUint8,\n  writeUint8,\n} from \"../utils-worker.mjs\";\n\nconst NONCE_LENGTH = 12;\nconst TAG_LENGTH = 16;\nconst KEY_LENGTH = 16;\nconst MODE_ENCRYPT = \"encrypt\";\nconst MODE_DECRYPT = \"decrypt\";\nexport const ECE_RECORD_SIZE = 1024 * 64;\n\nconst encoder = new TextEncoder();\n\nfunction generateSalt(len) {\n  const randSalt = new Uint8Array(len);\n  crypto.getRandomValues(randSalt);\n  return randSalt.buffer;\n}\n\nclass ECETransformer {\n  constructor(mode, ikm, rs, salt) {\n    this.mode = mode;\n    this.prevChunk;\n    this.seq = 0;\n    this.firstchunk = true;\n    this.rs = rs;\n    this.ikm = ikm.buffer;\n    this.salt = salt;\n  }\n\n  async generateKey() {\n    const inputKey = await crypto.subtle.importKey(\n      \"raw\",\n      this.ikm,\n      \"HKDF\",\n      false,\n      [\"deriveKey\"],\n    );\n\n    return crypto.subtle.deriveKey(\n      {\n        name: \"HKDF\",\n        salt: this.salt,\n        info: encoder.encode(\"Content-Encoding: aes128gcm\\0\"),\n        hash: \"SHA-256\",\n      },\n      inputKey,\n      {\n        name: \"AES-GCM\",\n        length: 128,\n      },\n      true, // Edge polyfill requires key to be extractable to encrypt :/\n      [\"encrypt\", \"decrypt\"],\n    );\n  }\n\n  async generateNonceBase() {\n    const inputKey = await crypto.subtle.importKey(\n      \"raw\",\n      this.ikm,\n      \"HKDF\",\n      false,\n      [\"deriveKey\"],\n    );\n\n    const base = await crypto.subtle.exportKey(\n      \"raw\",\n      await crypto.subtle.deriveKey(\n        {\n          name: \"HKDF\",\n          salt: this.salt,\n          info: encoder.encode(\"Content-Encoding: nonce\\0\"),\n          hash: \"SHA-256\",\n        },\n        inputKey,\n        {\n          name: \"AES-GCM\",\n          length: 128,\n        },\n        true,\n        [\"encrypt\", \"decrypt\"],\n      ),\n    );\n\n    return new Uint8Array(base.slice(0, NONCE_LENGTH));\n  }\n\n  generateNonce(seq) {\n    if (seq > 0xffffffff) {\n      throw new Error(\"record sequence number exceeds limit\");\n    }\n    const nonce = new Uint8Array(this.nonceBase);\n    const m = readUint32BE(nonce, nonce.length - 4);\n    const xor = (m ^ seq) >>> 0; //forces unsigned int xor\n    writeUint32BE(nonce, nonce.length - 4, xor);\n\n    return nonce;\n  }\n\n  pad(data, isLast) {\n    const len = data.length;\n    if (len + TAG_LENGTH >= this.rs) {\n      throw new Error(\"data too large for record size\");\n    }\n\n    if (isLast) {\n      const padding = new Uint8Array(1);\n      padding[0] = 2;\n      return concatUint8Arrays([data, padding]);\n    } else {\n      const padding = new Uint8Array(this.rs - len - TAG_LENGTH);\n      // Uint8Array is already zero-filled, no need for .fill(0)\n      padding[0] = 1;\n      return concatUint8Arrays([data, padding]);\n    }\n  }\n\n  unpad(data, isLast) {\n    for (let i = data.length - 1; i >= 0; i--) {\n      if (data[i]) {\n        if (isLast) {\n          if (data[i] !== 2) {\n            throw new Error(\"delimiter of final record is not 2\");\n          }\n        } else {\n          if (data[i] !== 1) {\n            throw new Error(\"delimiter of not final record is not 1\");\n          }\n        }\n        return data.slice(0, i);\n      }\n    }\n    throw new Error(\"no delimiter found\");\n  }\n\n  createHeader() {\n    const nums = new Uint8Array(5);\n    writeUint32BE(nums, 0, this.rs);\n    writeUint8(nums, 4, 0);\n    return concatUint8Arrays([new Uint8Array(this.salt), nums]);\n  }\n\n  readHeader(buffer) {\n    if (buffer.length < 21) {\n      throw new Error(\"chunk too small for reading header\");\n    }\n    const header = {};\n    header.salt = buffer.buffer.slice(0, KEY_LENGTH);\n    header.rs = readUint32BE(buffer, KEY_LENGTH);\n    const idlen = readUint8(buffer, KEY_LENGTH + 4);\n    header.length = idlen + KEY_LENGTH + 5;\n    return header;\n  }\n\n  async encryptRecord(buffer, seq, isLast) {\n    const nonce = this.generateNonce(seq);\n    const encrypted = await crypto.subtle.encrypt(\n      { name: \"AES-GCM\", iv: nonce },\n      this.key,\n      this.pad(buffer, isLast),\n    );\n    return new Uint8Array(encrypted);\n  }\n\n  async decryptRecord(buffer, seq, isLast) {\n    const nonce = this.generateNonce(seq);\n    const data = await crypto.subtle.decrypt(\n      {\n        name: \"AES-GCM\",\n        iv: nonce,\n        tagLength: 128,\n      },\n      this.key,\n      buffer,\n    );\n\n    return this.unpad(new Uint8Array(data), isLast);\n  }\n\n  async start(controller) {\n    if (this.mode === MODE_ENCRYPT) {\n      this.key = await this.generateKey();\n      this.nonceBase = await this.generateNonceBase();\n      controller.enqueue(this.createHeader());\n    } else if (this.mode !== MODE_DECRYPT) {\n      throw new Error(\"mode must be either encrypt or decrypt\");\n    }\n  }\n\n  async transformPrevChunk(isLast, controller) {\n    if (this.mode === MODE_ENCRYPT) {\n      controller.enqueue(\n        await this.encryptRecord(this.prevChunk, this.seq, isLast),\n      );\n      this.seq++;\n    } else {\n      if (this.seq === 0) {\n        //the first chunk during decryption contains only the header\n        const header = this.readHeader(this.prevChunk);\n        this.salt = header.salt;\n        this.rs = header.rs;\n        this.key = await this.generateKey();\n        this.nonceBase = await this.generateNonceBase();\n      } else {\n        controller.enqueue(\n          await this.decryptRecord(this.prevChunk, this.seq - 1, isLast),\n        );\n      }\n      this.seq++;\n    }\n  }\n\n  async transform(chunk, controller) {\n    if (!this.firstchunk) {\n      await this.transformPrevChunk(false, controller);\n    }\n    this.firstchunk = false;\n    this.prevChunk = new Uint8Array(chunk.buffer);\n  }\n\n  async flush(controller) {\n    //console.log('ece stream ends')\n    if (this.prevChunk) {\n      await this.transformPrevChunk(true, controller);\n    }\n  }\n}\n\nclass StreamSlicer {\n  constructor(rs, mode) {\n    this.mode = mode;\n    this.rs = rs;\n    this.chunkSize = mode === MODE_ENCRYPT ? rs - 17 : 21;\n    this.partialChunk = new Uint8Array(this.chunkSize); //where partial chunks are saved\n    this.offset = 0;\n  }\n\n  send(buf, controller) {\n    controller.enqueue(buf);\n    if (this.chunkSize === 21 && this.mode === MODE_DECRYPT) {\n      this.chunkSize = this.rs;\n    }\n    this.partialChunk = new Uint8Array(this.chunkSize);\n    this.offset = 0;\n  }\n\n  //reslice input into record sized chunks\n  transform(chunk, controller) {\n    //console.log('Received chunk with %d bytes.', chunk.byteLength)\n    let i = 0;\n\n    if (this.offset > 0) {\n      const len = Math.min(chunk.byteLength, this.chunkSize - this.offset);\n      this.partialChunk.set(chunk.slice(0, len), this.offset);\n      this.offset += len;\n      i += len;\n\n      if (this.offset === this.chunkSize) {\n        this.send(this.partialChunk, controller);\n      }\n    }\n\n    while (i < chunk.byteLength) {\n      const remainingBytes = chunk.byteLength - i;\n      if (remainingBytes >= this.chunkSize) {\n        const record = chunk.slice(i, i + this.chunkSize);\n        i += this.chunkSize;\n        this.send(record, controller);\n      } else {\n        const end = chunk.slice(i, i + remainingBytes);\n        i += end.byteLength;\n        this.partialChunk.set(end);\n        this.offset = end.byteLength;\n      }\n    }\n  }\n\n  flush(controller) {\n    if (this.offset > 0) {\n      controller.enqueue(this.partialChunk.slice(0, this.offset));\n    }\n  }\n}\n\n/*\ninput: a ReadableStream containing data to be transformed\nkey:  Uint8Array containing key of size KEY_LENGTH\nrs:   int containing record size, optional\nsalt: ArrayBuffer containing salt of KEY_LENGTH length, optional\n*/\nexport function encryptStream(\n  input,\n  key,\n  rs = ECE_RECORD_SIZE,\n  salt = generateSalt(KEY_LENGTH),\n) {\n  const mode = \"encrypt\";\n  const inputStream = transformStream(input, new StreamSlicer(rs, mode));\n  return transformStream(inputStream, new ECETransformer(mode, key, rs, salt));\n}\n\n/*\ninput: a ReadableStream containing data to be transformed\nkey:  Uint8Array containing key of size KEY_LENGTH\nrs:   int containing record size, optional\n*/\nexport function decryptStream(input, key, rs = ECE_RECORD_SIZE) {\n  const mode = \"decrypt\";\n  const inputStream = transformStream(input, new StreamSlicer(rs, mode));\n  return transformStream(inputStream, new ECETransformer(mode, key, rs));\n}\n", "import { arrayToB64, b64ToArray, delay } from \"./utils-worker\";\nimport { ECE_RECORD_SIZE } from \"./crypto/ece.mjs\";\n\nlet fileProtocolWssUrl = null;\n\ntry {\n  fileProtocolWssUrl = localStorage.getItem(\"wssURL\");\n} catch (e) {\n  // NOOP\n}\n\nif (!fileProtocolWssUrl) {\n  fileProtocolWssUrl = \"wss://send.firefox.com/api/ws\";\n}\n\nexport class ConnectionError extends Error {\n  constructor(cancelled, duration, size) {\n    super(cancelled ? \"0\" : \"connection closed\");\n    this.cancelled = cancelled;\n    this.duration = duration;\n    this.size = size;\n  }\n}\n\nexport function setFileProtocolWssUrl(url) {\n  localStorage && localStorage.setItem(\"wssURL\", url);\n  fileProtocolWssUrl = url;\n}\n\nexport function getFileProtocolWssUrl() {\n  return fileProtocolWssUrl;\n}\n\nlet apiUrlPrefix = \"\";\nexport function getApiUrl(path) {\n  return apiUrlPrefix + path;\n}\n\nexport function setApiUrlPrefix(prefix) {\n  apiUrlPrefix = prefix;\n}\n\nfunction post(obj) {\n  const h = {\n    \"Content-Type\": \"application/json\",\n  };\n  return {\n    method: \"POST\",\n    headers: new Headers(h),\n    body: JSON.stringify(obj),\n  };\n}\n\nexport async function fetchUsers() {\n  const response = await fetch(getApiUrl(\"/api/users\"));\n\n  if (response.ok) {\n    const data = await response.json();\n    return data.users || [];\n  }\n\n  throw new Error(response.status);\n}\n\nexport async function fetchLogs(page = 1, fileId = null) {\n  let url = `/api/logs?page=${page}`;\n  if (fileId) {\n    url += `&fileId=${encodeURIComponent(fileId)}`;\n  }\n  const response = await fetch(getApiUrl(url));\n\n  if (response.ok) {\n    const data = await response.json();\n    return {\n      logs: data.logs || [],\n      currentPage: data.currentPage || page,\n      totalCount: data.totalCount || 0,\n    };\n  }\n\n  throw new Error(response.status);\n}\n\nexport function parseNonce(header) {\n  header = header || \"\";\n  return header.split(\" \")[1];\n}\n\nasync function fetchWithAuth(url, params, keychain) {\n  const result = {};\n  params = params || {};\n  const h = await keychain.authHeader();\n  params.headers = new Headers({\n    Authorization: h,\n    \"Content-Type\": \"application/json\",\n  });\n  const response = await fetch(url, params);\n  result.response = response;\n  result.ok = response.ok;\n  const nonce = parseNonce(response.headers.get(\"WWW-Authenticate\"));\n  result.shouldRetry = response.status === 401 && nonce !== keychain.nonce;\n  keychain.nonce = nonce;\n  return result;\n}\n\nasync function fetchWithAuthAndRetry(url, params, keychain) {\n  const result = await fetchWithAuth(url, params, keychain);\n  if (result.shouldRetry) {\n    return fetchWithAuth(url, params, keychain);\n  }\n  return result;\n}\n\nexport async function del(id, owner_token) {\n  const response = await fetch(\n    getApiUrl(`/api/delete/${id}`),\n    post({ owner_token }),\n  );\n  return response.ok;\n}\n\nexport async function setParams(id, owner_token, params) {\n  const response = await fetch(\n    getApiUrl(`/api/params/${id}`),\n    post({\n      owner_token,\n      dlimit: params.dlimit,\n    }),\n  );\n  return response.ok;\n}\n\nexport async function fileInfo(id, owner_token) {\n  const response = await fetch(\n    getApiUrl(`/api/info/${id}`),\n    post({ owner_token }),\n  );\n\n  if (response.ok) {\n    const obj = await response.json();\n    return obj;\n  }\n\n  throw new Error(response.status);\n}\n\nexport async function metadata(id, keychain) {\n  const result = await fetchWithAuthAndRetry(\n    getApiUrl(`/api/metadata/${id}`),\n    { method: \"GET\" },\n    keychain,\n  );\n  if (result.ok) {\n    const data = await result.response.json();\n    const meta = await keychain.decryptMetadata(b64ToArray(data.metadata));\n    return {\n      size: meta.size,\n      ttl: data.ttl,\n      iv: meta.iv,\n      name: meta.name,\n      type: meta.type,\n      manifest: meta.manifest,\n    };\n  }\n  throw new Error(result.response.status);\n}\n\nexport async function setPassword(id, owner_token, keychain) {\n  const auth = await keychain.authKeyB64();\n  const response = await fetch(\n    getApiUrl(`/api/password/${id}`),\n    post({ owner_token, auth }),\n  );\n  return response.ok;\n}\n\nfunction asyncInitWebSocket(server, timeout = 10000) {\n  return new Promise((resolve, reject) => {\n    try {\n      const ws = new WebSocket(server);\n      const timeoutId = setTimeout(() => {\n        ws.close();\n        reject(new Error(\"WebSocket connection timeout\"));\n      }, timeout);\n\n      ws.addEventListener(\n        \"open\",\n        () => {\n          clearTimeout(timeoutId);\n          resolve(ws);\n        },\n        { once: true },\n      );\n\n      ws.addEventListener(\n        \"error\",\n        (e) => {\n          clearTimeout(timeoutId);\n          reject(new ConnectionError(false));\n        },\n        { once: true },\n      );\n    } catch (e) {\n      reject(new ConnectionError(false));\n    }\n  });\n}\n\nfunction listenForResponse(ws, canceller) {\n  return new Promise((resolve, reject) => {\n    function handleClose(event) {\n      // a 'close' event before a 'message' event means the request failed\n      ws.removeEventListener(\"message\", handleMessage);\n      reject(new ConnectionError(canceller.cancelled));\n    }\n    function handleMessage(msg) {\n      ws.removeEventListener(\"close\", handleClose);\n      try {\n        const response = JSON.parse(msg.data);\n        if (response.error) {\n          throw new Error(response.error);\n        } else {\n          resolve(response);\n        }\n      } catch (e) {\n        reject(e);\n      }\n    }\n    ws.addEventListener(\"message\", handleMessage, { once: true });\n    ws.addEventListener(\"close\", handleClose, { once: true });\n  });\n}\n\nasync function upload(\n  stream,\n  metadata,\n  verifierB64,\n  timeLimit,\n  dlimit,\n  onprogress,\n  canceller,\n  ownerWrap,\n  recipientWrap,\n) {\n  let size = 0;\n  const start = Date.now();\n  const host = window.location.hostname;\n  const port = window.location.port;\n  const protocol = window.location.protocol === \"https:\" ? \"wss:\" : \"ws:\";\n  const endpoint =\n    window.location.protocol === \"file:\"\n      ? fileProtocolWssUrl\n      : `${protocol}//${host}${port ? \":\" : \"\"}${port}/api/ws`;\n\n  // Retry WebSocket connection with exponential backoff\n  let ws;\n  let lastError;\n  const maxRetries = 3;\n\n  for (let attempt = 0; attempt < maxRetries; attempt++) {\n    if (canceller.cancelled) {\n      throw new ConnectionError(true);\n    }\n\n    try {\n      ws = await asyncInitWebSocket(endpoint);\n      break; // Success\n    } catch (e) {\n      lastError = e;\n      if (attempt < maxRetries - 1) {\n        // Exponential backoff: 500ms, 1000ms, 2000ms\n        const backoffMs = 500 * Math.pow(2, attempt);\n        await delay(backoffMs);\n      }\n    }\n  }\n\n  if (!ws) {\n    throw lastError || new ConnectionError(false);\n  }\n\n  try {\n    const metadataHeader = arrayToB64(new Uint8Array(metadata));\n    const fileMeta = {\n      fileMetadata: metadataHeader,\n      authorization: `send-v1 ${verifierB64}`,\n      timeLimit,\n      dlimit,\n    };\n    if (\n      ownerWrap &&\n      ownerWrap.ciphertext &&\n      ownerWrap.nonce &&\n      ownerWrap.ephemeralPublicKey\n    ) {\n      fileMeta.ownerSecretCiphertext = ownerWrap.ciphertext;\n      fileMeta.ownerSecretNonce = ownerWrap.nonce;\n      fileMeta.ownerSecretEphemeralPub = ownerWrap.ephemeralPublicKey;\n      if (ownerWrap.version != null) {\n        fileMeta.ownerSecretVersion = ownerWrap.version;\n      }\n    }\n    // INFO: Same thing as above, basically\n    // Add recipient encryption data (optional - file encrypted FOR a specific user)\n    if (\n      recipientWrap &&\n      recipientWrap.userId &&\n      recipientWrap.ciphertext &&\n      recipientWrap.nonce &&\n      recipientWrap.ephemeralPublicKey\n    ) {\n      fileMeta.recipientUserId = recipientWrap.userId;\n      fileMeta.recipientSecretCiphertext = recipientWrap.ciphertext;\n      fileMeta.recipientSecretNonce = recipientWrap.nonce;\n      fileMeta.recipientSecretEphemeralPub = recipientWrap.ephemeralPublicKey;\n      if (recipientWrap.version != null) {\n        fileMeta.recipientSecretVersion = recipientWrap.version;\n      }\n    }\n    const uploadInfoResponse = listenForResponse(ws, canceller);\n    ws.send(JSON.stringify(fileMeta));\n    const uploadInfo = await uploadInfoResponse;\n\n    const completedResponse = listenForResponse(ws, canceller);\n\n    const reader = stream.getReader();\n    let state = await reader.read();\n    while (!state.done) {\n      if (canceller.cancelled) {\n        ws.close();\n      }\n      if (ws.readyState !== WebSocket.OPEN) {\n        break;\n      }\n      const buf = state.value;\n      ws.send(buf);\n      onprogress(size);\n      size += buf.length;\n      state = await reader.read();\n      while (\n        ws.bufferedAmount > ECE_RECORD_SIZE * 2 &&\n        ws.readyState === WebSocket.OPEN &&\n        !canceller.cancelled\n      ) {\n        await delay();\n      }\n    }\n    if (ws.readyState === WebSocket.OPEN) {\n      ws.send(new Uint8Array([0])); //EOF\n    }\n\n    await completedResponse;\n    uploadInfo.duration = Date.now() - start;\n    return uploadInfo;\n  } catch (e) {\n    e.size = size;\n    e.duration = Date.now() - start;\n    throw e;\n  } finally {\n    if (![WebSocket.CLOSED, WebSocket.CLOSING].includes(ws.readyState)) {\n      ws.close();\n    }\n  }\n}\n\nexport function uploadWs(\n  encrypted,\n  metadata,\n  verifierB64,\n  timeLimit,\n  dlimit,\n  onprogress,\n  ownerWrap = null,\n  recipientWrap = null,\n) {\n  const canceller = { cancelled: false };\n\n  return {\n    cancel: function () {\n      canceller.cancelled = true;\n    },\n\n    result: upload(\n      encrypted,\n      metadata,\n      verifierB64,\n      timeLimit,\n      dlimit,\n      onprogress,\n      canceller,\n      ownerWrap,\n      recipientWrap,\n    ),\n  };\n}\n\n////////////////////////\n\nasync function downloadS(id, keychain, signal) {\n  const auth = await keychain.authHeader();\n\n  const response = await fetch(getApiUrl(`/api/download/${id}`), {\n    signal: signal,\n    method: \"GET\",\n    headers: { Authorization: auth },\n  });\n\n  const authHeader = response.headers.get(\"WWW-Authenticate\");\n  if (authHeader) {\n    keychain.nonce = parseNonce(authHeader);\n  }\n\n  if (response.status !== 200) {\n    throw new Error(response.status);\n  }\n\n  return response.body;\n}\n\nasync function tryDownloadStream(id, keychain, signal, tries = 2) {\n  try {\n    const result = await downloadS(id, keychain, signal);\n    return result;\n  } catch (e) {\n    if (e.message === \"401\" && --tries > 0) {\n      return tryDownloadStream(id, keychain, signal, tries);\n    }\n    if (e.name === \"AbortError\") {\n      throw new Error(\"0\");\n    }\n    throw e;\n  }\n}\n\nexport function downloadStream(id, keychain) {\n  const controller = new AbortController();\n  function cancel() {\n    controller.abort();\n  }\n  return {\n    cancel,\n    result: tryDownloadStream(id, keychain, controller.signal),\n  };\n}\n\n//////////////////\n\nasync function download(id, keychain, onprogress, canceller) {\n  const auth = await keychain.authHeader();\n  const xhr = new XMLHttpRequest();\n  canceller.oncancel = function () {\n    xhr.abort();\n  };\n  return new Promise(function (resolve, reject) {\n    xhr.addEventListener(\"loadend\", function () {\n      canceller.oncancel = function () {};\n      const authHeader = xhr.getResponseHeader(\"WWW-Authenticate\");\n      if (authHeader) {\n        keychain.nonce = parseNonce(authHeader);\n      }\n      if (xhr.status !== 200) {\n        return reject(new Error(xhr.status));\n      }\n\n      const blob = new Blob([xhr.response]);\n      resolve(blob);\n    });\n\n    xhr.addEventListener(\"progress\", function (event) {\n      if (event.target.status === 200) {\n        onprogress(event.loaded);\n      }\n    });\n    xhr.open(\"get\", getApiUrl(`/api/download/blob/${id}`));\n    xhr.setRequestHeader(\"Authorization\", auth);\n    xhr.responseType = \"blob\";\n    xhr.send();\n    onprogress(0);\n  });\n}\n\nasync function tryDownload(id, keychain, onprogress, canceller, tries = 2) {\n  try {\n    const result = await download(id, keychain, onprogress, canceller);\n    return result;\n  } catch (e) {\n    if (e.message === \"401\" && --tries > 0) {\n      return tryDownload(id, keychain, onprogress, canceller, tries);\n    }\n    throw e;\n  }\n}\n\nexport function downloadFile(id, keychain, onprogress) {\n  const canceller = {\n    oncancel: function () {}, // download() sets this\n  };\n  function cancel() {\n    canceller.oncancel();\n  }\n  return {\n    cancel,\n    result: tryDownload(id, keychain, onprogress, canceller),\n  };\n}\n\nexport async function getFileList(bearerToken, kid) {\n  const headers = new Headers({ Authorization: `Bearer ${bearerToken}` });\n  const response = await fetch(getApiUrl(`/api/filelist/${kid}`), { headers });\n  if (response.ok) {\n    const encrypted = await response.blob();\n    return encrypted;\n  }\n  throw new Error(response.status);\n}\n\nexport async function setFileList(bearerToken, kid, data) {\n  const headers = new Headers({ Authorization: `Bearer ${bearerToken}` });\n  const response = await fetch(getApiUrl(`/api/filelist/${kid}`), {\n    headers,\n    method: \"POST\",\n    body: data,\n  });\n  return response.ok;\n}\n\nexport async function getConstants() {\n  const response = await fetch(getApiUrl(\"/config\"));\n\n  if (response.ok) {\n    const obj = await response.json();\n    return obj;\n  }\n\n  throw new Error(response.status);\n}\n"],
  "mappings": "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",
  "names": ["delay", "result", "offset", "metadata"]
}
