{
  "version": 3,
  "sources": ["../../@fluent/bundle/esm/types.js", "../../@fluent/bundle/esm/resolver.js", "../../@fluent/bundle/esm/scope.js", "../../@fluent/bundle/esm/builtins.js", "../../@fluent/bundle/esm/memoizer.js", "../../@fluent/bundle/esm/bundle.js", "../../@fluent/bundle/esm/resource.js"],
  "sourcesContent": ["/**\n * The `FluentType` class is the base of Fluent's type system.\n *\n * Fluent types wrap JavaScript values and store additional configuration for\n * them, which can then be used in the `toString` method together with a proper\n * `Intl` formatter.\n */\nexport class FluentType {\n    /**\n     * Create a `FluentType` instance.\n     *\n     * @param value The JavaScript value to wrap.\n     */\n    constructor(value) {\n        this.value = value;\n    }\n    /**\n     * Unwrap the raw value stored by this `FluentType`.\n     */\n    valueOf() {\n        return this.value;\n    }\n}\n/**\n * A `FluentType` representing no correct value.\n */\nexport class FluentNone extends FluentType {\n    /**\n     * Create an instance of `FluentNone` with an optional fallback value.\n     * @param value The fallback value of this `FluentNone`.\n     */\n    constructor(value = \"???\") {\n        super(value);\n    }\n    /**\n     * Format this `FluentNone` to the fallback string.\n     */\n    toString(scope) {\n        return `{${this.value}}`;\n    }\n}\n/**\n * A `FluentType` representing a number.\n *\n * A `FluentNumber` instance stores the number value of the number it\n * represents. It may also store an option bag of options which will be passed\n * to `Intl.NumerFormat` when the `FluentNumber` is formatted to a string.\n */\nexport class FluentNumber extends FluentType {\n    /**\n     * Create an instance of `FluentNumber` with options to the\n     * `Intl.NumberFormat` constructor.\n     *\n     * @param value The number value of this `FluentNumber`.\n     * @param opts Options which will be passed to `Intl.NumberFormat`.\n     */\n    constructor(value, opts = {}) {\n        super(value);\n        this.opts = opts;\n    }\n    /**\n     * Format this `FluentNumber` to a string.\n     */\n    toString(scope) {\n        try {\n            const nf = scope.memoizeIntlObject(Intl.NumberFormat, this.opts);\n            return nf.format(this.value);\n        }\n        catch (err) {\n            scope.reportError(err);\n            return this.value.toString(10);\n        }\n    }\n}\n/**\n * A `FluentType` representing a date and time.\n *\n * A `FluentDateTime` instance stores the number value of the date it\n * represents, as a numerical timestamp in milliseconds. It may also store an\n * option bag of options which will be passed to `Intl.DateTimeFormat` when the\n * `FluentDateTime` is formatted to a string.\n */\nexport class FluentDateTime extends FluentType {\n    /**\n     * Create an instance of `FluentDateTime` with options to the\n     * `Intl.DateTimeFormat` constructor.\n     *\n     * @param value The number value of this `FluentDateTime`, in milliseconds.\n     * @param opts Options which will be passed to `Intl.DateTimeFormat`.\n     */\n    constructor(value, opts = {}) {\n        super(value);\n        this.opts = opts;\n    }\n    /**\n     * Format this `FluentDateTime` to a string.\n     */\n    toString(scope) {\n        try {\n            const dtf = scope.memoizeIntlObject(Intl.DateTimeFormat, this.opts);\n            return dtf.format(this.value);\n        }\n        catch (err) {\n            scope.reportError(err);\n            return new Date(this.value).toISOString();\n        }\n    }\n}\n", "/* global Intl */\n/**\n * @overview\n *\n * The role of the Fluent resolver is to format a `Pattern` to an instance of\n * `FluentValue`. For performance reasons, primitive strings are considered\n * such instances, too.\n *\n * Translations can contain references to other messages or variables,\n * conditional logic in form of select expressions, traits which describe their\n * grammatical features, and can use Fluent builtins which make use of the\n * `Intl` formatters to format numbers and dates into the bundle's languages.\n * See the documentation of the Fluent syntax for more information.\n *\n * In case of errors the resolver will try to salvage as much of the\n * translation as possible. In rare situations where the resolver didn't know\n * how to recover from an error it will return an instance of `FluentNone`.\n *\n * All expressions resolve to an instance of `FluentValue`. The caller should\n * use the `toString` method to convert the instance to a native value.\n *\n * Functions in this file pass around an instance of the `Scope` class, which\n * stores the data required for successful resolution and error recovery.\n */\nimport { FluentType, FluentNone, FluentNumber, FluentDateTime } from \"./types.js\";\n// The maximum number of placeables which can be expanded in a single call to\n// `formatPattern`. The limit protects against the Billion Laughs and Quadratic\n// Blowup attacks. See https://msdn.microsoft.com/en-us/magazine/ee335713.aspx.\nconst MAX_PLACEABLES = 100;\n// Unicode bidi isolation characters.\nconst FSI = \"\\u2068\";\nconst PDI = \"\\u2069\";\n// Helper: match a variant key to the given selector.\nfunction match(scope, selector, key) {\n    if (key === selector) {\n        // Both are strings.\n        return true;\n    }\n    // XXX Consider comparing options too, e.g. minimumFractionDigits.\n    if (key instanceof FluentNumber &&\n        selector instanceof FluentNumber &&\n        key.value === selector.value) {\n        return true;\n    }\n    if (selector instanceof FluentNumber && typeof key === \"string\") {\n        let category = scope\n            .memoizeIntlObject(Intl.PluralRules, selector.opts)\n            .select(selector.value);\n        if (key === category) {\n            return true;\n        }\n    }\n    return false;\n}\n// Helper: resolve the default variant from a list of variants.\nfunction getDefault(scope, variants, star) {\n    if (variants[star]) {\n        return resolvePattern(scope, variants[star].value);\n    }\n    scope.reportError(new RangeError(\"No default\"));\n    return new FluentNone();\n}\n// Helper: resolve arguments to a call expression.\nfunction getArguments(scope, args) {\n    const positional = [];\n    const named = Object.create(null);\n    for (const arg of args) {\n        if (arg.type === \"narg\") {\n            named[arg.name] = resolveExpression(scope, arg.value);\n        }\n        else {\n            positional.push(resolveExpression(scope, arg));\n        }\n    }\n    return { positional, named };\n}\n// Resolve an expression to a Fluent type.\nfunction resolveExpression(scope, expr) {\n    switch (expr.type) {\n        case \"str\":\n            return expr.value;\n        case \"num\":\n            return new FluentNumber(expr.value, {\n                minimumFractionDigits: expr.precision\n            });\n        case \"var\":\n            return resolveVariableReference(scope, expr);\n        case \"mesg\":\n            return resolveMessageReference(scope, expr);\n        case \"term\":\n            return resolveTermReference(scope, expr);\n        case \"func\":\n            return resolveFunctionReference(scope, expr);\n        case \"select\":\n            return resolveSelectExpression(scope, expr);\n        default:\n            return new FluentNone();\n    }\n}\n// Resolve a reference to a variable.\nfunction resolveVariableReference(scope, { name }) {\n    let arg;\n    if (scope.params) {\n        // We're inside a TermReference. It's OK to reference undefined parameters.\n        if (Object.prototype.hasOwnProperty.call(scope.params, name)) {\n            arg = scope.params[name];\n        }\n        else {\n            return new FluentNone(`$${name}`);\n        }\n    }\n    else if (scope.args\n        && Object.prototype.hasOwnProperty.call(scope.args, name)) {\n        // We're in the top-level Pattern or inside a MessageReference. Missing\n        // variables references produce ReferenceErrors.\n        arg = scope.args[name];\n    }\n    else {\n        scope.reportError(new ReferenceError(`Unknown variable: $${name}`));\n        return new FluentNone(`$${name}`);\n    }\n    // Return early if the argument already is an instance of FluentType.\n    if (arg instanceof FluentType) {\n        return arg;\n    }\n    // Convert the argument to a Fluent type.\n    switch (typeof arg) {\n        case \"string\":\n            return arg;\n        case \"number\":\n            return new FluentNumber(arg);\n        case \"object\":\n            if (arg instanceof Date) {\n                return new FluentDateTime(arg.getTime());\n            }\n        // eslint-disable-next-line no-fallthrough\n        default:\n            scope.reportError(new TypeError(`Variable type not supported: $${name}, ${typeof arg}`));\n            return new FluentNone(`$${name}`);\n    }\n}\n// Resolve a reference to another message.\nfunction resolveMessageReference(scope, { name, attr }) {\n    const message = scope.bundle._messages.get(name);\n    if (!message) {\n        scope.reportError(new ReferenceError(`Unknown message: ${name}`));\n        return new FluentNone(name);\n    }\n    if (attr) {\n        const attribute = message.attributes[attr];\n        if (attribute) {\n            return resolvePattern(scope, attribute);\n        }\n        scope.reportError(new ReferenceError(`Unknown attribute: ${attr}`));\n        return new FluentNone(`${name}.${attr}`);\n    }\n    if (message.value) {\n        return resolvePattern(scope, message.value);\n    }\n    scope.reportError(new ReferenceError(`No value: ${name}`));\n    return new FluentNone(name);\n}\n// Resolve a call to a Term with key-value arguments.\nfunction resolveTermReference(scope, { name, attr, args }) {\n    const id = `-${name}`;\n    const term = scope.bundle._terms.get(id);\n    if (!term) {\n        scope.reportError(new ReferenceError(`Unknown term: ${id}`));\n        return new FluentNone(id);\n    }\n    if (attr) {\n        const attribute = term.attributes[attr];\n        if (attribute) {\n            // Every TermReference has its own variables.\n            scope.params = getArguments(scope, args).named;\n            const resolved = resolvePattern(scope, attribute);\n            scope.params = null;\n            return resolved;\n        }\n        scope.reportError(new ReferenceError(`Unknown attribute: ${attr}`));\n        return new FluentNone(`${id}.${attr}`);\n    }\n    scope.params = getArguments(scope, args).named;\n    const resolved = resolvePattern(scope, term.value);\n    scope.params = null;\n    return resolved;\n}\n// Resolve a call to a Function with positional and key-value arguments.\nfunction resolveFunctionReference(scope, { name, args }) {\n    // Some functions are built-in. Others may be provided by the runtime via\n    // the `FluentBundle` constructor.\n    let func = scope.bundle._functions[name];\n    if (!func) {\n        scope.reportError(new ReferenceError(`Unknown function: ${name}()`));\n        return new FluentNone(`${name}()`);\n    }\n    if (typeof func !== \"function\") {\n        scope.reportError(new TypeError(`Function ${name}() is not callable`));\n        return new FluentNone(`${name}()`);\n    }\n    try {\n        let resolved = getArguments(scope, args);\n        return func(resolved.positional, resolved.named);\n    }\n    catch (err) {\n        scope.reportError(err);\n        return new FluentNone(`${name}()`);\n    }\n}\n// Resolve a select expression to the member object.\nfunction resolveSelectExpression(scope, { selector, variants, star }) {\n    let sel = resolveExpression(scope, selector);\n    if (sel instanceof FluentNone) {\n        return getDefault(scope, variants, star);\n    }\n    // Match the selector against keys of each variant, in order.\n    for (const variant of variants) {\n        const key = resolveExpression(scope, variant.key);\n        if (match(scope, sel, key)) {\n            return resolvePattern(scope, variant.value);\n        }\n    }\n    return getDefault(scope, variants, star);\n}\n// Resolve a pattern (a complex string with placeables).\nexport function resolveComplexPattern(scope, ptn) {\n    if (scope.dirty.has(ptn)) {\n        scope.reportError(new RangeError(\"Cyclic reference\"));\n        return new FluentNone();\n    }\n    // Tag the pattern as dirty for the purpose of the current resolution.\n    scope.dirty.add(ptn);\n    const result = [];\n    // Wrap interpolations with Directional Isolate Formatting characters\n    // only when the pattern has more than one element.\n    const useIsolating = scope.bundle._useIsolating && ptn.length > 1;\n    for (const elem of ptn) {\n        if (typeof elem === \"string\") {\n            result.push(scope.bundle._transform(elem));\n            continue;\n        }\n        scope.placeables++;\n        if (scope.placeables > MAX_PLACEABLES) {\n            scope.dirty.delete(ptn);\n            // This is a fatal error which causes the resolver to instantly bail out\n            // on this pattern. The length check protects against excessive memory\n            // usage, and throwing protects against eating up the CPU when long\n            // placeables are deeply nested.\n            throw new RangeError(`Too many placeables expanded: ${scope.placeables}, ` +\n                `max allowed is ${MAX_PLACEABLES}`);\n        }\n        if (useIsolating) {\n            result.push(FSI);\n        }\n        result.push(resolveExpression(scope, elem).toString(scope));\n        if (useIsolating) {\n            result.push(PDI);\n        }\n    }\n    scope.dirty.delete(ptn);\n    return result.join(\"\");\n}\n// Resolve a simple or a complex Pattern to a FluentString (which is really the\n// string primitive).\nfunction resolvePattern(scope, value) {\n    // Resolve a simple pattern.\n    if (typeof value === \"string\") {\n        return scope.bundle._transform(value);\n    }\n    return resolveComplexPattern(scope, value);\n}\n", "export class Scope {\n    constructor(bundle, errors, args) {\n        /** The Set of patterns already encountered during this resolution.\n         * Used to detect and prevent cyclic resolutions. */\n        this.dirty = new WeakSet();\n        /** A dict of parameters passed to a TermReference. */\n        this.params = null;\n        /** The running count of placeables resolved so far. Used to detect the\n          * Billion Laughs and Quadratic Blowup attacks. */\n        this.placeables = 0;\n        this.bundle = bundle;\n        this.errors = errors;\n        this.args = args;\n    }\n    reportError(error) {\n        if (!this.errors || !(error instanceof Error)) {\n            throw error;\n        }\n        this.errors.push(error);\n    }\n    memoizeIntlObject(ctor, opts) {\n        let cache = this.bundle._intls.get(ctor);\n        if (!cache) {\n            cache = {};\n            this.bundle._intls.set(ctor, cache);\n        }\n        let id = JSON.stringify(opts);\n        if (!cache[id]) {\n            cache[id] = new ctor(this.bundle.locales, opts);\n        }\n        return cache[id];\n    }\n}\n", "/**\n * @overview\n *\n * The FTL resolver ships with a number of functions built-in.\n *\n * Each function take two arguments:\n *   - args - an array of positional args\n *   - opts - an object of key-value args\n *\n * Arguments to functions are guaranteed to already be instances of\n * `FluentValue`.  Functions must return `FluentValues` as well.\n */\nimport { FluentNone, FluentNumber, FluentDateTime } from \"./types.js\";\nfunction values(opts, allowed) {\n    const unwrapped = Object.create(null);\n    for (const [name, opt] of Object.entries(opts)) {\n        if (allowed.includes(name)) {\n            unwrapped[name] = opt.valueOf();\n        }\n    }\n    return unwrapped;\n}\nconst NUMBER_ALLOWED = [\n    \"unitDisplay\",\n    \"currencyDisplay\",\n    \"useGrouping\",\n    \"minimumIntegerDigits\",\n    \"minimumFractionDigits\",\n    \"maximumFractionDigits\",\n    \"minimumSignificantDigits\",\n    \"maximumSignificantDigits\",\n];\n/**\n * The implementation of the `NUMBER()` builtin available to translations.\n *\n * Translations may call the `NUMBER()` builtin in order to specify formatting\n * options of a number. For example:\n *\n *     pi = The value of π is {NUMBER($pi, maximumFractionDigits: 2)}.\n *\n * The implementation expects an array of `FluentValues` representing the\n * positional arguments, and an object of named `FluentValues` representing the\n * named parameters.\n *\n * The following options are recognized:\n *\n *     unitDisplay\n *     currencyDisplay\n *     useGrouping\n *     minimumIntegerDigits\n *     minimumFractionDigits\n *     maximumFractionDigits\n *     minimumSignificantDigits\n *     maximumSignificantDigits\n *\n * Other options are ignored.\n *\n * @param args The positional arguments passed to this `NUMBER()`.\n * @param opts The named argments passed to this `NUMBER()`.\n */\nexport function NUMBER(args, opts) {\n    let arg = args[0];\n    if (arg instanceof FluentNone) {\n        return new FluentNone(`NUMBER(${arg.valueOf()})`);\n    }\n    if (arg instanceof FluentNumber) {\n        return new FluentNumber(arg.valueOf(), {\n            ...arg.opts,\n            ...values(opts, NUMBER_ALLOWED)\n        });\n    }\n    if (arg instanceof FluentDateTime) {\n        return new FluentNumber(arg.valueOf(), {\n            ...values(opts, NUMBER_ALLOWED)\n        });\n    }\n    throw new TypeError(\"Invalid argument to NUMBER\");\n}\nconst DATETIME_ALLOWED = [\n    \"dateStyle\",\n    \"timeStyle\",\n    \"fractionalSecondDigits\",\n    \"dayPeriod\",\n    \"hour12\",\n    \"weekday\",\n    \"era\",\n    \"year\",\n    \"month\",\n    \"day\",\n    \"hour\",\n    \"minute\",\n    \"second\",\n    \"timeZoneName\",\n];\n/**\n * The implementation of the `DATETIME()` builtin available to translations.\n *\n * Translations may call the `DATETIME()` builtin in order to specify\n * formatting options of a number. For example:\n *\n *     now = It's {DATETIME($today, month: \"long\")}.\n *\n * The implementation expects an array of `FluentValues` representing the\n * positional arguments, and an object of named `FluentValues` representing the\n * named parameters.\n *\n * The following options are recognized:\n *\n *     dateStyle\n *     timeStyle\n *     fractionalSecondDigits\n *     dayPeriod\n *     hour12\n *     weekday\n *     era\n *     year\n *     month\n *     day\n *     hour\n *     minute\n *     second\n *     timeZoneName\n *\n * Other options are ignored.\n *\n * @param args The positional arguments passed to this `DATETIME()`.\n * @param opts The named argments passed to this `DATETIME()`.\n */\nexport function DATETIME(args, opts) {\n    let arg = args[0];\n    if (arg instanceof FluentNone) {\n        return new FluentNone(`DATETIME(${arg.valueOf()})`);\n    }\n    if (arg instanceof FluentDateTime) {\n        return new FluentDateTime(arg.valueOf(), {\n            ...arg.opts,\n            ...values(opts, DATETIME_ALLOWED)\n        });\n    }\n    if (arg instanceof FluentNumber) {\n        return new FluentDateTime(arg.valueOf(), {\n            ...values(opts, DATETIME_ALLOWED)\n        });\n    }\n    throw new TypeError(\"Invalid argument to DATETIME\");\n}\n", "const cache = new Map();\nexport function getMemoizerForLocale(locales) {\n    const stringLocale = Array.isArray(locales) ? locales.join(\" \") : locales;\n    let memoizer = cache.get(stringLocale);\n    if (memoizer === undefined) {\n        memoizer = new Map();\n        cache.set(stringLocale, memoizer);\n    }\n    return memoizer;\n}\n", "import { resolveComplexPattern } from \"./resolver.js\";\nimport { Scope } from \"./scope.js\";\nimport { FluentNone } from \"./types.js\";\nimport { NUMBER, DATETIME } from \"./builtins.js\";\nimport { getMemoizerForLocale } from \"./memoizer.js\";\n/**\n * Message bundles are single-language stores of translation resources. They are\n * responsible for formatting message values and attributes to strings.\n */\nexport class FluentBundle {\n    /**\n     * Create an instance of `FluentBundle`.\n     *\n     * The `locales` argument is used to instantiate `Intl` formatters used by\n     * translations. The `options` object can be used to configure the bundle.\n     *\n     * Examples:\n     *\n     *     let bundle = new FluentBundle([\"en-US\", \"en\"]);\n     *\n     *     let bundle = new FluentBundle(locales, {useIsolating: false});\n     *\n     *     let bundle = new FluentBundle(locales, {\n     *       useIsolating: true,\n     *       functions: {\n     *         NODE_ENV: () => process.env.NODE_ENV\n     *       }\n     *     });\n     *\n     * Available options:\n     *\n     *   - `functions` - an object of additional functions available to\n     *     translations as builtins.\n     *\n     *   - `useIsolating` - boolean specifying whether to use Unicode isolation\n     *     marks (FSI, PDI) for bidi interpolations. Default: `true`.\n     *\n     *   - `transform` - a function used to transform string parts of patterns.\n     */\n    constructor(locales, { functions, useIsolating = true, transform = (v) => v } = {}) {\n        this._terms = new Map();\n        this._messages = new Map();\n        this.locales = Array.isArray(locales) ? locales : [locales];\n        this._functions = {\n            NUMBER,\n            DATETIME,\n            ...functions\n        };\n        this._useIsolating = useIsolating;\n        this._transform = transform;\n        this._intls = getMemoizerForLocale(locales);\n    }\n    /**\n     * Check if a message is present in the bundle.\n     *\n     * @param id - The identifier of the message to check.\n     */\n    hasMessage(id) {\n        return this._messages.has(id);\n    }\n    /**\n     * Return a raw unformatted message object from the bundle.\n     *\n     * Raw messages are `{value, attributes}` shapes containing translation units\n     * called `Patterns`. `Patterns` are implementation-specific; they should be\n     * treated as black boxes and formatted with `FluentBundle.formatPattern`.\n     *\n     * @param id - The identifier of the message to check.\n     */\n    getMessage(id) {\n        return this._messages.get(id);\n    }\n    /**\n     * Add a translation resource to the bundle.\n     *\n     * The translation resource must be an instance of `FluentResource`.\n     *\n     *     let res = new FluentResource(\"foo = Foo\");\n     *     bundle.addResource(res);\n     *     bundle.getMessage(\"foo\");\n     *     // → {value: .., attributes: {..}}\n     *\n     * Available options:\n     *\n     *   - `allowOverrides` - boolean specifying whether it's allowed to override\n     *     an existing message or term with a new value. Default: `false`.\n     *\n     * @param   res - FluentResource object.\n     * @param   options\n     */\n    addResource(res, { allowOverrides = false } = {}) {\n        const errors = [];\n        for (let i = 0; i < res.body.length; i++) {\n            let entry = res.body[i];\n            if (entry.id.startsWith(\"-\")) {\n                // Identifiers starting with a dash (-) define terms. Terms are private\n                // and cannot be retrieved from FluentBundle.\n                if (allowOverrides === false && this._terms.has(entry.id)) {\n                    errors.push(new Error(`Attempt to override an existing term: \"${entry.id}\"`));\n                    continue;\n                }\n                this._terms.set(entry.id, entry);\n            }\n            else {\n                if (allowOverrides === false && this._messages.has(entry.id)) {\n                    errors.push(new Error(`Attempt to override an existing message: \"${entry.id}\"`));\n                    continue;\n                }\n                this._messages.set(entry.id, entry);\n            }\n        }\n        return errors;\n    }\n    /**\n     * Format a `Pattern` to a string.\n     *\n     * Format a raw `Pattern` into a string. `args` will be used to resolve\n     * references to variables passed as arguments to the translation.\n     *\n     * In case of errors `formatPattern` will try to salvage as much of the\n     * translation as possible and will still return a string. For performance\n     * reasons, the encountered errors are not returned but instead are appended\n     * to the `errors` array passed as the third argument.\n     *\n     *     let errors = [];\n     *     bundle.addResource(\n     *         new FluentResource(\"hello = Hello, {$name}!\"));\n     *\n     *     let hello = bundle.getMessage(\"hello\");\n     *     if (hello.value) {\n     *         bundle.formatPattern(hello.value, {name: \"Jane\"}, errors);\n     *         // Returns \"Hello, Jane!\" and `errors` is empty.\n     *\n     *         bundle.formatPattern(hello.value, undefined, errors);\n     *         // Returns \"Hello, {$name}!\" and `errors` is now:\n     *         // [<ReferenceError: Unknown variable: name>]\n     *     }\n     *\n     * If `errors` is omitted, the first encountered error will be thrown.\n     */\n    formatPattern(pattern, args = null, errors = null) {\n        // Resolve a simple pattern without creating a scope. No error handling is\n        // required; by definition simple patterns don't have placeables.\n        if (typeof pattern === \"string\") {\n            return this._transform(pattern);\n        }\n        // Resolve a complex pattern.\n        let scope = new Scope(this, errors, args);\n        try {\n            let value = resolveComplexPattern(scope, pattern);\n            return value.toString(scope);\n        }\n        catch (err) {\n            if (scope.errors && err instanceof Error) {\n                scope.errors.push(err);\n                return new FluentNone().toString(scope);\n            }\n            throw err;\n        }\n    }\n}\n", "// This regex is used to iterate through the beginnings of messages and terms.\n// With the /m flag, the ^ matches at the beginning of every line.\nconst RE_MESSAGE_START = /^(-?[a-zA-Z][\\w-]*) *= */gm;\n// Both Attributes and Variants are parsed in while loops. These regexes are\n// used to break out of them.\nconst RE_ATTRIBUTE_START = /\\.([a-zA-Z][\\w-]*) *= */y;\nconst RE_VARIANT_START = /\\*?\\[/y;\nconst RE_NUMBER_LITERAL = /(-?[0-9]+(?:\\.([0-9]+))?)/y;\nconst RE_IDENTIFIER = /([a-zA-Z][\\w-]*)/y;\nconst RE_REFERENCE = /([$-])?([a-zA-Z][\\w-]*)(?:\\.([a-zA-Z][\\w-]*))?/y;\nconst RE_FUNCTION_NAME = /^[A-Z][A-Z0-9_-]*$/;\n// A \"run\" is a sequence of text or string literal characters which don't\n// require any special handling. For TextElements such special characters are: {\n// (starts a placeable), and line breaks which require additional logic to check\n// if the next line is indented. For StringLiterals they are: \\ (starts an\n// escape sequence), \" (ends the literal), and line breaks which are not allowed\n// in StringLiterals. Note that string runs may be empty; text runs may not.\nconst RE_TEXT_RUN = /([^{}\\n\\r]+)/y;\nconst RE_STRING_RUN = /([^\\\\\"\\n\\r]*)/y;\n// Escape sequences.\nconst RE_STRING_ESCAPE = /\\\\([\\\\\"])/y;\nconst RE_UNICODE_ESCAPE = /\\\\u([a-fA-F0-9]{4})|\\\\U([a-fA-F0-9]{6})/y;\n// Used for trimming TextElements and indents.\nconst RE_LEADING_NEWLINES = /^\\n+/;\nconst RE_TRAILING_SPACES = / +$/;\n// Used in makeIndent to strip spaces from blank lines and normalize CRLF to LF.\nconst RE_BLANK_LINES = / *\\r?\\n/g;\n// Used in makeIndent to measure the indentation.\nconst RE_INDENT = /( *)$/;\n// Common tokens.\nconst TOKEN_BRACE_OPEN = /{\\s*/y;\nconst TOKEN_BRACE_CLOSE = /\\s*}/y;\nconst TOKEN_BRACKET_OPEN = /\\[\\s*/y;\nconst TOKEN_BRACKET_CLOSE = /\\s*] */y;\nconst TOKEN_PAREN_OPEN = /\\s*\\(\\s*/y;\nconst TOKEN_ARROW = /\\s*->\\s*/y;\nconst TOKEN_COLON = /\\s*:\\s*/y;\n// Note the optional comma. As a deviation from the Fluent EBNF, the parser\n// doesn't enforce commas between call arguments.\nconst TOKEN_COMMA = /\\s*,?\\s*/y;\nconst TOKEN_BLANK = /\\s+/y;\n/**\n * Fluent Resource is a structure storing parsed localization entries.\n */\nexport class FluentResource {\n    constructor(source) {\n        this.body = [];\n        RE_MESSAGE_START.lastIndex = 0;\n        let cursor = 0;\n        // Iterate over the beginnings of messages and terms to efficiently skip\n        // comments and recover from errors.\n        while (true) {\n            let next = RE_MESSAGE_START.exec(source);\n            if (next === null) {\n                break;\n            }\n            cursor = RE_MESSAGE_START.lastIndex;\n            try {\n                this.body.push(parseMessage(next[1]));\n            }\n            catch (err) {\n                if (err instanceof SyntaxError) {\n                    // Don't report any Fluent syntax errors. Skip directly to the\n                    // beginning of the next message or term.\n                    continue;\n                }\n                throw err;\n            }\n        }\n        // The parser implementation is inlined below for performance reasons,\n        // as well as for convenience of accessing `source` and `cursor`.\n        // The parser focuses on minimizing the number of false negatives at the\n        // expense of increasing the risk of false positives. In other words, it\n        // aims at parsing valid Fluent messages with a success rate of 100%, but it\n        // may also parse a few invalid messages which the reference parser would\n        // reject. The parser doesn't perform any validation and may produce entries\n        // which wouldn't make sense in the real world. For best results users are\n        // advised to validate translations with the fluent-syntax parser\n        // pre-runtime.\n        // The parser makes an extensive use of sticky regexes which can be anchored\n        // to any offset of the source string without slicing it. Errors are thrown\n        // to bail out of parsing of ill-formed messages.\n        function test(re) {\n            re.lastIndex = cursor;\n            return re.test(source);\n        }\n        // Advance the cursor by the char if it matches. May be used as a predicate\n        // (was the match found?) or, if errorClass is passed, as an assertion.\n        function consumeChar(char, errorClass) {\n            if (source[cursor] === char) {\n                cursor++;\n                return true;\n            }\n            if (errorClass) {\n                throw new errorClass(`Expected ${char}`);\n            }\n            return false;\n        }\n        // Advance the cursor by the token if it matches. May be used as a predicate\n        // (was the match found?) or, if errorClass is passed, as an assertion.\n        function consumeToken(re, errorClass) {\n            if (test(re)) {\n                cursor = re.lastIndex;\n                return true;\n            }\n            if (errorClass) {\n                throw new errorClass(`Expected ${re.toString()}`);\n            }\n            return false;\n        }\n        // Execute a regex, advance the cursor, and return all capture groups.\n        function match(re) {\n            re.lastIndex = cursor;\n            let result = re.exec(source);\n            if (result === null) {\n                throw new SyntaxError(`Expected ${re.toString()}`);\n            }\n            cursor = re.lastIndex;\n            return result;\n        }\n        // Execute a regex, advance the cursor, and return the capture group.\n        function match1(re) {\n            return match(re)[1];\n        }\n        function parseMessage(id) {\n            let value = parsePattern();\n            let attributes = parseAttributes();\n            if (value === null && Object.keys(attributes).length === 0) {\n                throw new SyntaxError(\"Expected message value or attributes\");\n            }\n            return { id, value, attributes };\n        }\n        function parseAttributes() {\n            let attrs = Object.create(null);\n            while (test(RE_ATTRIBUTE_START)) {\n                let name = match1(RE_ATTRIBUTE_START);\n                let value = parsePattern();\n                if (value === null) {\n                    throw new SyntaxError(\"Expected attribute value\");\n                }\n                attrs[name] = value;\n            }\n            return attrs;\n        }\n        function parsePattern() {\n            let first;\n            // First try to parse any simple text on the same line as the id.\n            if (test(RE_TEXT_RUN)) {\n                first = match1(RE_TEXT_RUN);\n            }\n            // If there's a placeable on the first line, parse a complex pattern.\n            if (source[cursor] === \"{\" || source[cursor] === \"}\") {\n                // Re-use the text parsed above, if possible.\n                return parsePatternElements(first ? [first] : [], Infinity);\n            }\n            // RE_TEXT_VALUE stops at newlines. Only continue parsing the pattern if\n            // what comes after the newline is indented.\n            let indent = parseIndent();\n            if (indent) {\n                if (first) {\n                    // If there's text on the first line, the blank block is part of the\n                    // translation content in its entirety.\n                    return parsePatternElements([first, indent], indent.length);\n                }\n                // Otherwise, we're dealing with a block pattern, i.e. a pattern which\n                // starts on a new line. Discrad the leading newlines but keep the\n                // inline indent; it will be used by the dedentation logic.\n                indent.value = trim(indent.value, RE_LEADING_NEWLINES);\n                return parsePatternElements([indent], indent.length);\n            }\n            if (first) {\n                // It was just a simple inline text after all.\n                return trim(first, RE_TRAILING_SPACES);\n            }\n            return null;\n        }\n        // Parse a complex pattern as an array of elements.\n        function parsePatternElements(elements = [], commonIndent) {\n            while (true) {\n                if (test(RE_TEXT_RUN)) {\n                    elements.push(match1(RE_TEXT_RUN));\n                    continue;\n                }\n                if (source[cursor] === \"{\") {\n                    elements.push(parsePlaceable());\n                    continue;\n                }\n                if (source[cursor] === \"}\") {\n                    throw new SyntaxError(\"Unbalanced closing brace\");\n                }\n                let indent = parseIndent();\n                if (indent) {\n                    elements.push(indent);\n                    commonIndent = Math.min(commonIndent, indent.length);\n                    continue;\n                }\n                break;\n            }\n            let lastIndex = elements.length - 1;\n            let lastElement = elements[lastIndex];\n            // Trim the trailing spaces in the last element if it's a TextElement.\n            if (typeof lastElement === \"string\") {\n                elements[lastIndex] = trim(lastElement, RE_TRAILING_SPACES);\n            }\n            let baked = [];\n            for (let element of elements) {\n                if (element instanceof Indent) {\n                    // Dedent indented lines by the maximum common indent.\n                    element = element.value.slice(0, element.value.length - commonIndent);\n                }\n                if (element) {\n                    baked.push(element);\n                }\n            }\n            return baked;\n        }\n        function parsePlaceable() {\n            consumeToken(TOKEN_BRACE_OPEN, SyntaxError);\n            let selector = parseInlineExpression();\n            if (consumeToken(TOKEN_BRACE_CLOSE)) {\n                return selector;\n            }\n            if (consumeToken(TOKEN_ARROW)) {\n                let variants = parseVariants();\n                consumeToken(TOKEN_BRACE_CLOSE, SyntaxError);\n                return {\n                    type: \"select\",\n                    selector,\n                    ...variants\n                };\n            }\n            throw new SyntaxError(\"Unclosed placeable\");\n        }\n        function parseInlineExpression() {\n            if (source[cursor] === \"{\") {\n                // It's a nested placeable.\n                return parsePlaceable();\n            }\n            if (test(RE_REFERENCE)) {\n                let [, sigil, name, attr = null] = match(RE_REFERENCE);\n                if (sigil === \"$\") {\n                    return { type: \"var\", name };\n                }\n                if (consumeToken(TOKEN_PAREN_OPEN)) {\n                    let args = parseArguments();\n                    if (sigil === \"-\") {\n                        // A parameterized term: -term(...).\n                        return { type: \"term\", name, attr, args };\n                    }\n                    if (RE_FUNCTION_NAME.test(name)) {\n                        return { type: \"func\", name, args };\n                    }\n                    throw new SyntaxError(\"Function names must be all upper-case\");\n                }\n                if (sigil === \"-\") {\n                    // A non-parameterized term: -term.\n                    return {\n                        type: \"term\",\n                        name,\n                        attr,\n                        args: []\n                    };\n                }\n                return { type: \"mesg\", name, attr };\n            }\n            return parseLiteral();\n        }\n        function parseArguments() {\n            let args = [];\n            while (true) {\n                switch (source[cursor]) {\n                    case \")\": // End of the argument list.\n                        cursor++;\n                        return args;\n                    case undefined: // EOF\n                        throw new SyntaxError(\"Unclosed argument list\");\n                }\n                args.push(parseArgument());\n                // Commas between arguments are treated as whitespace.\n                consumeToken(TOKEN_COMMA);\n            }\n        }\n        function parseArgument() {\n            let expr = parseInlineExpression();\n            if (expr.type !== \"mesg\") {\n                return expr;\n            }\n            if (consumeToken(TOKEN_COLON)) {\n                // The reference is the beginning of a named argument.\n                return {\n                    type: \"narg\",\n                    name: expr.name,\n                    value: parseLiteral()\n                };\n            }\n            // It's a regular message reference.\n            return expr;\n        }\n        function parseVariants() {\n            let variants = [];\n            let count = 0;\n            let star;\n            while (test(RE_VARIANT_START)) {\n                if (consumeChar(\"*\")) {\n                    star = count;\n                }\n                let key = parseVariantKey();\n                let value = parsePattern();\n                if (value === null) {\n                    throw new SyntaxError(\"Expected variant value\");\n                }\n                variants[count++] = { key, value };\n            }\n            if (count === 0) {\n                return null;\n            }\n            if (star === undefined) {\n                throw new SyntaxError(\"Expected default variant\");\n            }\n            return { variants, star };\n        }\n        function parseVariantKey() {\n            consumeToken(TOKEN_BRACKET_OPEN, SyntaxError);\n            let key;\n            if (test(RE_NUMBER_LITERAL)) {\n                key = parseNumberLiteral();\n            }\n            else {\n                key = {\n                    type: \"str\",\n                    value: match1(RE_IDENTIFIER)\n                };\n            }\n            consumeToken(TOKEN_BRACKET_CLOSE, SyntaxError);\n            return key;\n        }\n        function parseLiteral() {\n            if (test(RE_NUMBER_LITERAL)) {\n                return parseNumberLiteral();\n            }\n            if (source[cursor] === '\"') {\n                return parseStringLiteral();\n            }\n            throw new SyntaxError(\"Invalid expression\");\n        }\n        function parseNumberLiteral() {\n            let [, value, fraction = \"\"] = match(RE_NUMBER_LITERAL);\n            let precision = fraction.length;\n            return {\n                type: \"num\",\n                value: parseFloat(value),\n                precision\n            };\n        }\n        function parseStringLiteral() {\n            consumeChar('\"', SyntaxError);\n            let value = \"\";\n            while (true) {\n                value += match1(RE_STRING_RUN);\n                if (source[cursor] === \"\\\\\") {\n                    value += parseEscapeSequence();\n                    continue;\n                }\n                if (consumeChar('\"')) {\n                    return { type: \"str\", value };\n                }\n                // We've reached an EOL of EOF.\n                throw new SyntaxError(\"Unclosed string literal\");\n            }\n        }\n        // Unescape known escape sequences.\n        function parseEscapeSequence() {\n            if (test(RE_STRING_ESCAPE)) {\n                return match1(RE_STRING_ESCAPE);\n            }\n            if (test(RE_UNICODE_ESCAPE)) {\n                let [, codepoint4, codepoint6] = match(RE_UNICODE_ESCAPE);\n                let codepoint = parseInt(codepoint4 || codepoint6, 16);\n                return codepoint <= 0xd7ff || 0xe000 <= codepoint\n                    // It's a Unicode scalar value.\n                    ? String.fromCodePoint(codepoint)\n                    // Lonely surrogates can cause trouble when the parsing result is\n                    // saved using UTF-8. Use U+FFFD REPLACEMENT CHARACTER instead.\n                    : \"�\";\n            }\n            throw new SyntaxError(\"Unknown escape sequence\");\n        }\n        // Parse blank space. Return it if it looks like indent before a pattern\n        // line. Skip it othwerwise.\n        function parseIndent() {\n            let start = cursor;\n            consumeToken(TOKEN_BLANK);\n            // Check the first non-blank character after the indent.\n            switch (source[cursor]) {\n                case \".\":\n                case \"[\":\n                case \"*\":\n                case \"}\":\n                case undefined: // EOF\n                    // A special character. End the Pattern.\n                    return false;\n                case \"{\":\n                    // Placeables don't require indentation (in EBNF: block-placeable).\n                    // Continue the Pattern.\n                    return makeIndent(source.slice(start, cursor));\n            }\n            // If the first character on the line is not one of the special characters\n            // listed above, it's a regular text character. Check if there's at least\n            // one space of indent before it.\n            if (source[cursor - 1] === \" \") {\n                // It's an indented text character (in EBNF: indented-char). Continue\n                // the Pattern.\n                return makeIndent(source.slice(start, cursor));\n            }\n            // A not-indented text character is likely the identifier of the next\n            // message. End the Pattern.\n            return false;\n        }\n        // Trim blanks in text according to the given regex.\n        function trim(text, re) {\n            return text.replace(re, \"\");\n        }\n        // Normalize a blank block and extract the indent details.\n        function makeIndent(blank) {\n            let value = blank.replace(RE_BLANK_LINES, \"\\n\");\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            let length = RE_INDENT.exec(blank)[1].length;\n            return new Indent(value, length);\n        }\n    }\n}\nclass Indent {\n    constructor(value, length) {\n        this.value = value;\n        this.length = length;\n    }\n}\n"],
  "mappings": ";;;AAOO,IAAM,aAAN,MAAiB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAMpB,YAAY,OAAO;AACf,SAAK,QAAQ;AAAA,EACjB;AAAA;AAAA;AAAA;AAAA,EAIA,UAAU;AACN,WAAO,KAAK;AAAA,EAChB;AACJ;AAIO,IAAM,aAAN,cAAyB,WAAW;AAAA;AAAA;AAAA;AAAA;AAAA,EAKvC,YAAY,QAAQ,OAAO;AACvB,UAAM,KAAK;AAAA,EACf;AAAA;AAAA;AAAA;AAAA,EAIA,SAAS,OAAO;AACZ,WAAO,IAAI,KAAK,KAAK;AAAA,EACzB;AACJ;AAQO,IAAM,eAAN,cAA2B,WAAW;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQzC,YAAY,OAAO,OAAO,CAAC,GAAG;AAC1B,UAAM,KAAK;AACX,SAAK,OAAO;AAAA,EAChB;AAAA;AAAA;AAAA;AAAA,EAIA,SAAS,OAAO;AACZ,QAAI;AACA,YAAM,KAAK,MAAM,kBAAkB,KAAK,cAAc,KAAK,IAAI;AAC/D,aAAO,GAAG,OAAO,KAAK,KAAK;AAAA,IAC/B,SACO,KAAK;AACR,YAAM,YAAY,GAAG;AACrB,aAAO,KAAK,MAAM,SAAS,EAAE;AAAA,IACjC;AAAA,EACJ;AACJ;AASO,IAAM,iBAAN,cAA6B,WAAW;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQ3C,YAAY,OAAO,OAAO,CAAC,GAAG;AAC1B,UAAM,KAAK;AACX,SAAK,OAAO;AAAA,EAChB;AAAA;AAAA;AAAA;AAAA,EAIA,SAAS,OAAO;AACZ,QAAI;AACA,YAAM,MAAM,MAAM,kBAAkB,KAAK,gBAAgB,KAAK,IAAI;AAClE,aAAO,IAAI,OAAO,KAAK,KAAK;AAAA,IAChC,SACO,KAAK;AACR,YAAM,YAAY,GAAG;AACrB,aAAO,IAAI,KAAK,KAAK,KAAK,EAAE,YAAY;AAAA,IAC5C;AAAA,EACJ;AACJ;;;AC/EA,IAAM,iBAAiB;AAEvB,IAAM,MAAM;AACZ,IAAM,MAAM;AAEZ,SAAS,MAAM,OAAO,UAAU,KAAK;AACjC,MAAI,QAAQ,UAAU;AAElB,WAAO;AAAA,EACX;AAEA,MAAI,eAAe,gBACf,oBAAoB,gBACpB,IAAI,UAAU,SAAS,OAAO;AAC9B,WAAO;AAAA,EACX;AACA,MAAI,oBAAoB,gBAAgB,OAAO,QAAQ,UAAU;AAC7D,QAAI,WAAW,MACV,kBAAkB,KAAK,aAAa,SAAS,IAAI,EACjD,OAAO,SAAS,KAAK;AAC1B,QAAI,QAAQ,UAAU;AAClB,aAAO;AAAA,IACX;AAAA,EACJ;AACA,SAAO;AACX;AAEA,SAAS,WAAW,OAAO,UAAU,MAAM;AACvC,MAAI,SAAS,IAAI,GAAG;AAChB,WAAO,eAAe,OAAO,SAAS,IAAI,EAAE,KAAK;AAAA,EACrD;AACA,QAAM,YAAY,IAAI,WAAW,YAAY,CAAC;AAC9C,SAAO,IAAI,WAAW;AAC1B;AAEA,SAAS,aAAa,OAAO,MAAM;AAC/B,QAAM,aAAa,CAAC;AACpB,QAAM,QAAQ,uBAAO,OAAO,IAAI;AAChC,aAAW,OAAO,MAAM;AACpB,QAAI,IAAI,SAAS,QAAQ;AACrB,YAAM,IAAI,IAAI,IAAI,kBAAkB,OAAO,IAAI,KAAK;AAAA,IACxD,OACK;AACD,iBAAW,KAAK,kBAAkB,OAAO,GAAG,CAAC;AAAA,IACjD;AAAA,EACJ;AACA,SAAO,EAAE,YAAY,MAAM;AAC/B;AAEA,SAAS,kBAAkB,OAAO,MAAM;AACpC,UAAQ,KAAK,MAAM;AAAA,IACf,KAAK;AACD,aAAO,KAAK;AAAA,IAChB,KAAK;AACD,aAAO,IAAI,aAAa,KAAK,OAAO;AAAA,QAChC,uBAAuB,KAAK;AAAA,MAChC,CAAC;AAAA,IACL,KAAK;AACD,aAAO,yBAAyB,OAAO,IAAI;AAAA,IAC/C,KAAK;AACD,aAAO,wBAAwB,OAAO,IAAI;AAAA,IAC9C,KAAK;AACD,aAAO,qBAAqB,OAAO,IAAI;AAAA,IAC3C,KAAK;AACD,aAAO,yBAAyB,OAAO,IAAI;AAAA,IAC/C,KAAK;AACD,aAAO,wBAAwB,OAAO,IAAI;AAAA,IAC9C;AACI,aAAO,IAAI,WAAW;AAAA,EAC9B;AACJ;AAEA,SAAS,yBAAyB,OAAO,EAAE,KAAK,GAAG;AAC/C,MAAI;AACJ,MAAI,MAAM,QAAQ;AAEd,QAAI,OAAO,UAAU,eAAe,KAAK,MAAM,QAAQ,IAAI,GAAG;AAC1D,YAAM,MAAM,OAAO,IAAI;AAAA,IAC3B,OACK;AACD,aAAO,IAAI,WAAW,IAAI,IAAI,EAAE;AAAA,IACpC;AAAA,EACJ,WACS,MAAM,QACR,OAAO,UAAU,eAAe,KAAK,MAAM,MAAM,IAAI,GAAG;AAG3D,UAAM,MAAM,KAAK,IAAI;AAAA,EACzB,OACK;AACD,UAAM,YAAY,IAAI,eAAe,sBAAsB,IAAI,EAAE,CAAC;AAClE,WAAO,IAAI,WAAW,IAAI,IAAI,EAAE;AAAA,EACpC;AAEA,MAAI,eAAe,YAAY;AAC3B,WAAO;AAAA,EACX;AAEA,UAAQ,OAAO,KAAK;AAAA,IAChB,KAAK;AACD,aAAO;AAAA,IACX,KAAK;AACD,aAAO,IAAI,aAAa,GAAG;AAAA,IAC/B,KAAK;AACD,UAAI,eAAe,MAAM;AACrB,eAAO,IAAI,eAAe,IAAI,QAAQ,CAAC;AAAA,MAC3C;AAAA,IAEJ;AACI,YAAM,YAAY,IAAI,UAAU,iCAAiC,IAAI,KAAK,OAAO,GAAG,EAAE,CAAC;AACvF,aAAO,IAAI,WAAW,IAAI,IAAI,EAAE;AAAA,EACxC;AACJ;AAEA,SAAS,wBAAwB,OAAO,EAAE,MAAM,KAAK,GAAG;AACpD,QAAM,UAAU,MAAM,OAAO,UAAU,IAAI,IAAI;AAC/C,MAAI,CAAC,SAAS;AACV,UAAM,YAAY,IAAI,eAAe,oBAAoB,IAAI,EAAE,CAAC;AAChE,WAAO,IAAI,WAAW,IAAI;AAAA,EAC9B;AACA,MAAI,MAAM;AACN,UAAM,YAAY,QAAQ,WAAW,IAAI;AACzC,QAAI,WAAW;AACX,aAAO,eAAe,OAAO,SAAS;AAAA,IAC1C;AACA,UAAM,YAAY,IAAI,eAAe,sBAAsB,IAAI,EAAE,CAAC;AAClE,WAAO,IAAI,WAAW,GAAG,IAAI,IAAI,IAAI,EAAE;AAAA,EAC3C;AACA,MAAI,QAAQ,OAAO;AACf,WAAO,eAAe,OAAO,QAAQ,KAAK;AAAA,EAC9C;AACA,QAAM,YAAY,IAAI,eAAe,aAAa,IAAI,EAAE,CAAC;AACzD,SAAO,IAAI,WAAW,IAAI;AAC9B;AAEA,SAAS,qBAAqB,OAAO,EAAE,MAAM,MAAM,KAAK,GAAG;AACvD,QAAM,KAAK,IAAI,IAAI;AACnB,QAAM,OAAO,MAAM,OAAO,OAAO,IAAI,EAAE;AACvC,MAAI,CAAC,MAAM;AACP,UAAM,YAAY,IAAI,eAAe,iBAAiB,EAAE,EAAE,CAAC;AAC3D,WAAO,IAAI,WAAW,EAAE;AAAA,EAC5B;AACA,MAAI,MAAM;AACN,UAAM,YAAY,KAAK,WAAW,IAAI;AACtC,QAAI,WAAW;AAEX,YAAM,SAAS,aAAa,OAAO,IAAI,EAAE;AACzC,YAAMA,YAAW,eAAe,OAAO,SAAS;AAChD,YAAM,SAAS;AACf,aAAOA;AAAA,IACX;AACA,UAAM,YAAY,IAAI,eAAe,sBAAsB,IAAI,EAAE,CAAC;AAClE,WAAO,IAAI,WAAW,GAAG,EAAE,IAAI,IAAI,EAAE;AAAA,EACzC;AACA,QAAM,SAAS,aAAa,OAAO,IAAI,EAAE;AACzC,QAAM,WAAW,eAAe,OAAO,KAAK,KAAK;AACjD,QAAM,SAAS;AACf,SAAO;AACX;AAEA,SAAS,yBAAyB,OAAO,EAAE,MAAM,KAAK,GAAG;AAGrD,MAAI,OAAO,MAAM,OAAO,WAAW,IAAI;AACvC,MAAI,CAAC,MAAM;AACP,UAAM,YAAY,IAAI,eAAe,qBAAqB,IAAI,IAAI,CAAC;AACnE,WAAO,IAAI,WAAW,GAAG,IAAI,IAAI;AAAA,EACrC;AACA,MAAI,OAAO,SAAS,YAAY;AAC5B,UAAM,YAAY,IAAI,UAAU,YAAY,IAAI,oBAAoB,CAAC;AACrE,WAAO,IAAI,WAAW,GAAG,IAAI,IAAI;AAAA,EACrC;AACA,MAAI;AACA,QAAI,WAAW,aAAa,OAAO,IAAI;AACvC,WAAO,KAAK,SAAS,YAAY,SAAS,KAAK;AAAA,EACnD,SACO,KAAK;AACR,UAAM,YAAY,GAAG;AACrB,WAAO,IAAI,WAAW,GAAG,IAAI,IAAI;AAAA,EACrC;AACJ;AAEA,SAAS,wBAAwB,OAAO,EAAE,UAAU,UAAU,KAAK,GAAG;AAClE,MAAI,MAAM,kBAAkB,OAAO,QAAQ;AAC3C,MAAI,eAAe,YAAY;AAC3B,WAAO,WAAW,OAAO,UAAU,IAAI;AAAA,EAC3C;AAEA,aAAW,WAAW,UAAU;AAC5B,UAAM,MAAM,kBAAkB,OAAO,QAAQ,GAAG;AAChD,QAAI,MAAM,OAAO,KAAK,GAAG,GAAG;AACxB,aAAO,eAAe,OAAO,QAAQ,KAAK;AAAA,IAC9C;AAAA,EACJ;AACA,SAAO,WAAW,OAAO,UAAU,IAAI;AAC3C;AAEO,SAAS,sBAAsB,OAAO,KAAK;AAC9C,MAAI,MAAM,MAAM,IAAI,GAAG,GAAG;AACtB,UAAM,YAAY,IAAI,WAAW,kBAAkB,CAAC;AACpD,WAAO,IAAI,WAAW;AAAA,EAC1B;AAEA,QAAM,MAAM,IAAI,GAAG;AACnB,QAAM,SAAS,CAAC;AAGhB,QAAM,eAAe,MAAM,OAAO,iBAAiB,IAAI,SAAS;AAChE,aAAW,QAAQ,KAAK;AACpB,QAAI,OAAO,SAAS,UAAU;AAC1B,aAAO,KAAK,MAAM,OAAO,WAAW,IAAI,CAAC;AACzC;AAAA,IACJ;AACA,UAAM;AACN,QAAI,MAAM,aAAa,gBAAgB;AACnC,YAAM,MAAM,OAAO,GAAG;AAKtB,YAAM,IAAI,WAAW,iCAAiC,MAAM,UAAU,oBAChD,cAAc,EAAE;AAAA,IAC1C;AACA,QAAI,cAAc;AACd,aAAO,KAAK,GAAG;AAAA,IACnB;AACA,WAAO,KAAK,kBAAkB,OAAO,IAAI,EAAE,SAAS,KAAK,CAAC;AAC1D,QAAI,cAAc;AACd,aAAO,KAAK,GAAG;AAAA,IACnB;AAAA,EACJ;AACA,QAAM,MAAM,OAAO,GAAG;AACtB,SAAO,OAAO,KAAK,EAAE;AACzB;AAGA,SAAS,eAAe,OAAO,OAAO;AAElC,MAAI,OAAO,UAAU,UAAU;AAC3B,WAAO,MAAM,OAAO,WAAW,KAAK;AAAA,EACxC;AACA,SAAO,sBAAsB,OAAO,KAAK;AAC7C;;;AC9QO,IAAM,QAAN,MAAY;AAAA,EACf,YAAY,QAAQ,QAAQ,MAAM;AAG9B,SAAK,QAAQ,oBAAI,QAAQ;AAEzB,SAAK,SAAS;AAGd,SAAK,aAAa;AAClB,SAAK,SAAS;AACd,SAAK,SAAS;AACd,SAAK,OAAO;AAAA,EAChB;AAAA,EACA,YAAY,OAAO;AACf,QAAI,CAAC,KAAK,UAAU,EAAE,iBAAiB,QAAQ;AAC3C,YAAM;AAAA,IACV;AACA,SAAK,OAAO,KAAK,KAAK;AAAA,EAC1B;AAAA,EACA,kBAAkB,MAAM,MAAM;AAC1B,QAAIC,SAAQ,KAAK,OAAO,OAAO,IAAI,IAAI;AACvC,QAAI,CAACA,QAAO;AACR,MAAAA,SAAQ,CAAC;AACT,WAAK,OAAO,OAAO,IAAI,MAAMA,MAAK;AAAA,IACtC;AACA,QAAI,KAAK,KAAK,UAAU,IAAI;AAC5B,QAAI,CAACA,OAAM,EAAE,GAAG;AACZ,MAAAA,OAAM,EAAE,IAAI,IAAI,KAAK,KAAK,OAAO,SAAS,IAAI;AAAA,IAClD;AACA,WAAOA,OAAM,EAAE;AAAA,EACnB;AACJ;;;ACnBA,SAAS,OAAO,MAAM,SAAS;AAC3B,QAAM,YAAY,uBAAO,OAAO,IAAI;AACpC,aAAW,CAAC,MAAM,GAAG,KAAK,OAAO,QAAQ,IAAI,GAAG;AAC5C,QAAI,QAAQ,SAAS,IAAI,GAAG;AACxB,gBAAU,IAAI,IAAI,IAAI,QAAQ;AAAA,IAClC;AAAA,EACJ;AACA,SAAO;AACX;AACA,IAAM,iBAAiB;AAAA,EACnB;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AACJ;AA6BO,SAAS,OAAO,MAAM,MAAM;AAC/B,MAAI,MAAM,KAAK,CAAC;AAChB,MAAI,eAAe,YAAY;AAC3B,WAAO,IAAI,WAAW,UAAU,IAAI,QAAQ,CAAC,GAAG;AAAA,EACpD;AACA,MAAI,eAAe,cAAc;AAC7B,WAAO,IAAI,aAAa,IAAI,QAAQ,GAAG;AAAA,MACnC,GAAG,IAAI;AAAA,MACP,GAAG,OAAO,MAAM,cAAc;AAAA,IAClC,CAAC;AAAA,EACL;AACA,MAAI,eAAe,gBAAgB;AAC/B,WAAO,IAAI,aAAa,IAAI,QAAQ,GAAG;AAAA,MACnC,GAAG,OAAO,MAAM,cAAc;AAAA,IAClC,CAAC;AAAA,EACL;AACA,QAAM,IAAI,UAAU,4BAA4B;AACpD;AACA,IAAM,mBAAmB;AAAA,EACrB;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AACJ;AAmCO,SAAS,SAAS,MAAM,MAAM;AACjC,MAAI,MAAM,KAAK,CAAC;AAChB,MAAI,eAAe,YAAY;AAC3B,WAAO,IAAI,WAAW,YAAY,IAAI,QAAQ,CAAC,GAAG;AAAA,EACtD;AACA,MAAI,eAAe,gBAAgB;AAC/B,WAAO,IAAI,eAAe,IAAI,QAAQ,GAAG;AAAA,MACrC,GAAG,IAAI;AAAA,MACP,GAAG,OAAO,MAAM,gBAAgB;AAAA,IACpC,CAAC;AAAA,EACL;AACA,MAAI,eAAe,cAAc;AAC7B,WAAO,IAAI,eAAe,IAAI,QAAQ,GAAG;AAAA,MACrC,GAAG,OAAO,MAAM,gBAAgB;AAAA,IACpC,CAAC;AAAA,EACL;AACA,QAAM,IAAI,UAAU,8BAA8B;AACtD;;;ACjJA,IAAM,QAAQ,oBAAI,IAAI;AACf,SAAS,qBAAqB,SAAS;AAC1C,QAAM,eAAe,MAAM,QAAQ,OAAO,IAAI,QAAQ,KAAK,GAAG,IAAI;AAClE,MAAI,WAAW,MAAM,IAAI,YAAY;AACrC,MAAI,aAAa,QAAW;AACxB,eAAW,oBAAI,IAAI;AACnB,UAAM,IAAI,cAAc,QAAQ;AAAA,EACpC;AACA,SAAO;AACX;;;ACAO,IAAM,eAAN,MAAmB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EA8BtB,YAAY,SAAS,EAAE,WAAW,eAAe,MAAM,YAAY,CAAC,MAAM,EAAE,IAAI,CAAC,GAAG;AAChF,SAAK,SAAS,oBAAI,IAAI;AACtB,SAAK,YAAY,oBAAI,IAAI;AACzB,SAAK,UAAU,MAAM,QAAQ,OAAO,IAAI,UAAU,CAAC,OAAO;AAC1D,SAAK,aAAa;AAAA,MACd;AAAA,MACA;AAAA,MACA,GAAG;AAAA,IACP;AACA,SAAK,gBAAgB;AACrB,SAAK,aAAa;AAClB,SAAK,SAAS,qBAAqB,OAAO;AAAA,EAC9C;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,WAAW,IAAI;AACX,WAAO,KAAK,UAAU,IAAI,EAAE;AAAA,EAChC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAUA,WAAW,IAAI;AACX,WAAO,KAAK,UAAU,IAAI,EAAE;AAAA,EAChC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAmBA,YAAY,KAAK,EAAE,iBAAiB,MAAM,IAAI,CAAC,GAAG;AAC9C,UAAM,SAAS,CAAC;AAChB,aAAS,IAAI,GAAG,IAAI,IAAI,KAAK,QAAQ,KAAK;AACtC,UAAI,QAAQ,IAAI,KAAK,CAAC;AACtB,UAAI,MAAM,GAAG,WAAW,GAAG,GAAG;AAG1B,YAAI,mBAAmB,SAAS,KAAK,OAAO,IAAI,MAAM,EAAE,GAAG;AACvD,iBAAO,KAAK,IAAI,MAAM,0CAA0C,MAAM,EAAE,GAAG,CAAC;AAC5E;AAAA,QACJ;AACA,aAAK,OAAO,IAAI,MAAM,IAAI,KAAK;AAAA,MACnC,OACK;AACD,YAAI,mBAAmB,SAAS,KAAK,UAAU,IAAI,MAAM,EAAE,GAAG;AAC1D,iBAAO,KAAK,IAAI,MAAM,6CAA6C,MAAM,EAAE,GAAG,CAAC;AAC/E;AAAA,QACJ;AACA,aAAK,UAAU,IAAI,MAAM,IAAI,KAAK;AAAA,MACtC;AAAA,IACJ;AACA,WAAO;AAAA,EACX;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EA4BA,cAAc,SAAS,OAAO,MAAM,SAAS,MAAM;AAG/C,QAAI,OAAO,YAAY,UAAU;AAC7B,aAAO,KAAK,WAAW,OAAO;AAAA,IAClC;AAEA,QAAI,QAAQ,IAAI,MAAM,MAAM,QAAQ,IAAI;AACxC,QAAI;AACA,UAAI,QAAQ,sBAAsB,OAAO,OAAO;AAChD,aAAO,MAAM,SAAS,KAAK;AAAA,IAC/B,SACO,KAAK;AACR,UAAI,MAAM,UAAU,eAAe,OAAO;AACtC,cAAM,OAAO,KAAK,GAAG;AACrB,eAAO,IAAI,WAAW,EAAE,SAAS,KAAK;AAAA,MAC1C;AACA,YAAM;AAAA,IACV;AAAA,EACJ;AACJ;;;AC9JA,IAAM,mBAAmB;AAGzB,IAAM,qBAAqB;AAC3B,IAAM,mBAAmB;AACzB,IAAM,oBAAoB;AAC1B,IAAM,gBAAgB;AACtB,IAAM,eAAe;AACrB,IAAM,mBAAmB;AAOzB,IAAM,cAAc;AACpB,IAAM,gBAAgB;AAEtB,IAAM,mBAAmB;AACzB,IAAM,oBAAoB;AAE1B,IAAM,sBAAsB;AAC5B,IAAM,qBAAqB;AAE3B,IAAM,iBAAiB;AAEvB,IAAM,YAAY;AAElB,IAAM,mBAAmB;AACzB,IAAM,oBAAoB;AAC1B,IAAM,qBAAqB;AAC3B,IAAM,sBAAsB;AAC5B,IAAM,mBAAmB;AACzB,IAAM,cAAc;AACpB,IAAM,cAAc;AAGpB,IAAM,cAAc;AACpB,IAAM,cAAc;AAIb,IAAM,iBAAN,MAAqB;AAAA,EACxB,YAAY,QAAQ;AAChB,SAAK,OAAO,CAAC;AACb,qBAAiB,YAAY;AAC7B,QAAI,SAAS;AAGb,WAAO,MAAM;AACT,UAAI,OAAO,iBAAiB,KAAK,MAAM;AACvC,UAAI,SAAS,MAAM;AACf;AAAA,MACJ;AACA,eAAS,iBAAiB;AAC1B,UAAI;AACA,aAAK,KAAK,KAAK,aAAa,KAAK,CAAC,CAAC,CAAC;AAAA,MACxC,SACO,KAAK;AACR,YAAI,eAAe,aAAa;AAG5B;AAAA,QACJ;AACA,cAAM;AAAA,MACV;AAAA,IACJ;AAcA,aAAS,KAAK,IAAI;AACd,SAAG,YAAY;AACf,aAAO,GAAG,KAAK,MAAM;AAAA,IACzB;AAGA,aAAS,YAAY,MAAM,YAAY;AACnC,UAAI,OAAO,MAAM,MAAM,MAAM;AACzB;AACA,eAAO;AAAA,MACX;AACA,UAAI,YAAY;AACZ,cAAM,IAAI,WAAW,YAAY,IAAI,EAAE;AAAA,MAC3C;AACA,aAAO;AAAA,IACX;AAGA,aAAS,aAAa,IAAI,YAAY;AAClC,UAAI,KAAK,EAAE,GAAG;AACV,iBAAS,GAAG;AACZ,eAAO;AAAA,MACX;AACA,UAAI,YAAY;AACZ,cAAM,IAAI,WAAW,YAAY,GAAG,SAAS,CAAC,EAAE;AAAA,MACpD;AACA,aAAO;AAAA,IACX;AAEA,aAASC,OAAM,IAAI;AACf,SAAG,YAAY;AACf,UAAI,SAAS,GAAG,KAAK,MAAM;AAC3B,UAAI,WAAW,MAAM;AACjB,cAAM,IAAI,YAAY,YAAY,GAAG,SAAS,CAAC,EAAE;AAAA,MACrD;AACA,eAAS,GAAG;AACZ,aAAO;AAAA,IACX;AAEA,aAAS,OAAO,IAAI;AAChB,aAAOA,OAAM,EAAE,EAAE,CAAC;AAAA,IACtB;AACA,aAAS,aAAa,IAAI;AACtB,UAAI,QAAQ,aAAa;AACzB,UAAI,aAAa,gBAAgB;AACjC,UAAI,UAAU,QAAQ,OAAO,KAAK,UAAU,EAAE,WAAW,GAAG;AACxD,cAAM,IAAI,YAAY,sCAAsC;AAAA,MAChE;AACA,aAAO,EAAE,IAAI,OAAO,WAAW;AAAA,IACnC;AACA,aAAS,kBAAkB;AACvB,UAAI,QAAQ,uBAAO,OAAO,IAAI;AAC9B,aAAO,KAAK,kBAAkB,GAAG;AAC7B,YAAI,OAAO,OAAO,kBAAkB;AACpC,YAAI,QAAQ,aAAa;AACzB,YAAI,UAAU,MAAM;AAChB,gBAAM,IAAI,YAAY,0BAA0B;AAAA,QACpD;AACA,cAAM,IAAI,IAAI;AAAA,MAClB;AACA,aAAO;AAAA,IACX;AACA,aAAS,eAAe;AACpB,UAAI;AAEJ,UAAI,KAAK,WAAW,GAAG;AACnB,gBAAQ,OAAO,WAAW;AAAA,MAC9B;AAEA,UAAI,OAAO,MAAM,MAAM,OAAO,OAAO,MAAM,MAAM,KAAK;AAElD,eAAO,qBAAqB,QAAQ,CAAC,KAAK,IAAI,CAAC,GAAG,QAAQ;AAAA,MAC9D;AAGA,UAAI,SAAS,YAAY;AACzB,UAAI,QAAQ;AACR,YAAI,OAAO;AAGP,iBAAO,qBAAqB,CAAC,OAAO,MAAM,GAAG,OAAO,MAAM;AAAA,QAC9D;AAIA,eAAO,QAAQ,KAAK,OAAO,OAAO,mBAAmB;AACrD,eAAO,qBAAqB,CAAC,MAAM,GAAG,OAAO,MAAM;AAAA,MACvD;AACA,UAAI,OAAO;AAEP,eAAO,KAAK,OAAO,kBAAkB;AAAA,MACzC;AACA,aAAO;AAAA,IACX;AAEA,aAAS,qBAAqB,WAAW,CAAC,GAAG,cAAc;AACvD,aAAO,MAAM;AACT,YAAI,KAAK,WAAW,GAAG;AACnB,mBAAS,KAAK,OAAO,WAAW,CAAC;AACjC;AAAA,QACJ;AACA,YAAI,OAAO,MAAM,MAAM,KAAK;AACxB,mBAAS,KAAK,eAAe,CAAC;AAC9B;AAAA,QACJ;AACA,YAAI,OAAO,MAAM,MAAM,KAAK;AACxB,gBAAM,IAAI,YAAY,0BAA0B;AAAA,QACpD;AACA,YAAI,SAAS,YAAY;AACzB,YAAI,QAAQ;AACR,mBAAS,KAAK,MAAM;AACpB,yBAAe,KAAK,IAAI,cAAc,OAAO,MAAM;AACnD;AAAA,QACJ;AACA;AAAA,MACJ;AACA,UAAI,YAAY,SAAS,SAAS;AAClC,UAAI,cAAc,SAAS,SAAS;AAEpC,UAAI,OAAO,gBAAgB,UAAU;AACjC,iBAAS,SAAS,IAAI,KAAK,aAAa,kBAAkB;AAAA,MAC9D;AACA,UAAI,QAAQ,CAAC;AACb,eAAS,WAAW,UAAU;AAC1B,YAAI,mBAAmB,QAAQ;AAE3B,oBAAU,QAAQ,MAAM,MAAM,GAAG,QAAQ,MAAM,SAAS,YAAY;AAAA,QACxE;AACA,YAAI,SAAS;AACT,gBAAM,KAAK,OAAO;AAAA,QACtB;AAAA,MACJ;AACA,aAAO;AAAA,IACX;AACA,aAAS,iBAAiB;AACtB,mBAAa,kBAAkB,WAAW;AAC1C,UAAI,WAAW,sBAAsB;AACrC,UAAI,aAAa,iBAAiB,GAAG;AACjC,eAAO;AAAA,MACX;AACA,UAAI,aAAa,WAAW,GAAG;AAC3B,YAAI,WAAW,cAAc;AAC7B,qBAAa,mBAAmB,WAAW;AAC3C,eAAO;AAAA,UACH,MAAM;AAAA,UACN;AAAA,UACA,GAAG;AAAA,QACP;AAAA,MACJ;AACA,YAAM,IAAI,YAAY,oBAAoB;AAAA,IAC9C;AACA,aAAS,wBAAwB;AAC7B,UAAI,OAAO,MAAM,MAAM,KAAK;AAExB,eAAO,eAAe;AAAA,MAC1B;AACA,UAAI,KAAK,YAAY,GAAG;AACpB,YAAI,CAAC,EAAE,OAAO,MAAM,OAAO,IAAI,IAAIA,OAAM,YAAY;AACrD,YAAI,UAAU,KAAK;AACf,iBAAO,EAAE,MAAM,OAAO,KAAK;AAAA,QAC/B;AACA,YAAI,aAAa,gBAAgB,GAAG;AAChC,cAAI,OAAO,eAAe;AAC1B,cAAI,UAAU,KAAK;AAEf,mBAAO,EAAE,MAAM,QAAQ,MAAM,MAAM,KAAK;AAAA,UAC5C;AACA,cAAI,iBAAiB,KAAK,IAAI,GAAG;AAC7B,mBAAO,EAAE,MAAM,QAAQ,MAAM,KAAK;AAAA,UACtC;AACA,gBAAM,IAAI,YAAY,uCAAuC;AAAA,QACjE;AACA,YAAI,UAAU,KAAK;AAEf,iBAAO;AAAA,YACH,MAAM;AAAA,YACN;AAAA,YACA;AAAA,YACA,MAAM,CAAC;AAAA,UACX;AAAA,QACJ;AACA,eAAO,EAAE,MAAM,QAAQ,MAAM,KAAK;AAAA,MACtC;AACA,aAAO,aAAa;AAAA,IACxB;AACA,aAAS,iBAAiB;AACtB,UAAI,OAAO,CAAC;AACZ,aAAO,MAAM;AACT,gBAAQ,OAAO,MAAM,GAAG;AAAA,UACpB,KAAK;AACD;AACA,mBAAO;AAAA,UACX,KAAK;AACD,kBAAM,IAAI,YAAY,wBAAwB;AAAA,QACtD;AACA,aAAK,KAAK,cAAc,CAAC;AAEzB,qBAAa,WAAW;AAAA,MAC5B;AAAA,IACJ;AACA,aAAS,gBAAgB;AACrB,UAAI,OAAO,sBAAsB;AACjC,UAAI,KAAK,SAAS,QAAQ;AACtB,eAAO;AAAA,MACX;AACA,UAAI,aAAa,WAAW,GAAG;AAE3B,eAAO;AAAA,UACH,MAAM;AAAA,UACN,MAAM,KAAK;AAAA,UACX,OAAO,aAAa;AAAA,QACxB;AAAA,MACJ;AAEA,aAAO;AAAA,IACX;AACA,aAAS,gBAAgB;AACrB,UAAI,WAAW,CAAC;AAChB,UAAI,QAAQ;AACZ,UAAI;AACJ,aAAO,KAAK,gBAAgB,GAAG;AAC3B,YAAI,YAAY,GAAG,GAAG;AAClB,iBAAO;AAAA,QACX;AACA,YAAI,MAAM,gBAAgB;AAC1B,YAAI,QAAQ,aAAa;AACzB,YAAI,UAAU,MAAM;AAChB,gBAAM,IAAI,YAAY,wBAAwB;AAAA,QAClD;AACA,iBAAS,OAAO,IAAI,EAAE,KAAK,MAAM;AAAA,MACrC;AACA,UAAI,UAAU,GAAG;AACb,eAAO;AAAA,MACX;AACA,UAAI,SAAS,QAAW;AACpB,cAAM,IAAI,YAAY,0BAA0B;AAAA,MACpD;AACA,aAAO,EAAE,UAAU,KAAK;AAAA,IAC5B;AACA,aAAS,kBAAkB;AACvB,mBAAa,oBAAoB,WAAW;AAC5C,UAAI;AACJ,UAAI,KAAK,iBAAiB,GAAG;AACzB,cAAM,mBAAmB;AAAA,MAC7B,OACK;AACD,cAAM;AAAA,UACF,MAAM;AAAA,UACN,OAAO,OAAO,aAAa;AAAA,QAC/B;AAAA,MACJ;AACA,mBAAa,qBAAqB,WAAW;AAC7C,aAAO;AAAA,IACX;AACA,aAAS,eAAe;AACpB,UAAI,KAAK,iBAAiB,GAAG;AACzB,eAAO,mBAAmB;AAAA,MAC9B;AACA,UAAI,OAAO,MAAM,MAAM,KAAK;AACxB,eAAO,mBAAmB;AAAA,MAC9B;AACA,YAAM,IAAI,YAAY,oBAAoB;AAAA,IAC9C;AACA,aAAS,qBAAqB;AAC1B,UAAI,CAAC,EAAE,OAAO,WAAW,EAAE,IAAIA,OAAM,iBAAiB;AACtD,UAAI,YAAY,SAAS;AACzB,aAAO;AAAA,QACH,MAAM;AAAA,QACN,OAAO,WAAW,KAAK;AAAA,QACvB;AAAA,MACJ;AAAA,IACJ;AACA,aAAS,qBAAqB;AAC1B,kBAAY,KAAK,WAAW;AAC5B,UAAI,QAAQ;AACZ,aAAO,MAAM;AACT,iBAAS,OAAO,aAAa;AAC7B,YAAI,OAAO,MAAM,MAAM,MAAM;AACzB,mBAAS,oBAAoB;AAC7B;AAAA,QACJ;AACA,YAAI,YAAY,GAAG,GAAG;AAClB,iBAAO,EAAE,MAAM,OAAO,MAAM;AAAA,QAChC;AAEA,cAAM,IAAI,YAAY,yBAAyB;AAAA,MACnD;AAAA,IACJ;AAEA,aAAS,sBAAsB;AAC3B,UAAI,KAAK,gBAAgB,GAAG;AACxB,eAAO,OAAO,gBAAgB;AAAA,MAClC;AACA,UAAI,KAAK,iBAAiB,GAAG;AACzB,YAAI,CAAC,EAAE,YAAY,UAAU,IAAIA,OAAM,iBAAiB;AACxD,YAAI,YAAY,SAAS,cAAc,YAAY,EAAE;AACrD,eAAO,aAAa,SAAU,SAAU,YAElC,OAAO,cAAc,SAAS,IAG9B;AAAA,MACV;AACA,YAAM,IAAI,YAAY,yBAAyB;AAAA,IACnD;AAGA,aAAS,cAAc;AACnB,UAAI,QAAQ;AACZ,mBAAa,WAAW;AAExB,cAAQ,OAAO,MAAM,GAAG;AAAA,QACpB,KAAK;AAAA,QACL,KAAK;AAAA,QACL,KAAK;AAAA,QACL,KAAK;AAAA,QACL,KAAK;AAED,iBAAO;AAAA,QACX,KAAK;AAGD,iBAAO,WAAW,OAAO,MAAM,OAAO,MAAM,CAAC;AAAA,MACrD;AAIA,UAAI,OAAO,SAAS,CAAC,MAAM,KAAK;AAG5B,eAAO,WAAW,OAAO,MAAM,OAAO,MAAM,CAAC;AAAA,MACjD;AAGA,aAAO;AAAA,IACX;AAEA,aAAS,KAAK,MAAM,IAAI;AACpB,aAAO,KAAK,QAAQ,IAAI,EAAE;AAAA,IAC9B;AAEA,aAAS,WAAW,OAAO;AACvB,UAAI,QAAQ,MAAM,QAAQ,gBAAgB,IAAI;AAE9C,UAAI,SAAS,UAAU,KAAK,KAAK,EAAE,CAAC,EAAE;AACtC,aAAO,IAAI,OAAO,OAAO,MAAM;AAAA,IACnC;AAAA,EACJ;AACJ;AACA,IAAM,SAAN,MAAa;AAAA,EACT,YAAY,OAAO,QAAQ;AACvB,SAAK,QAAQ;AACb,SAAK,SAAS;AAAA,EAClB;AACJ;",
  "names": ["resolved", "cache", "match"]
}
