var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : {};
function getDefaultExportFromCjs(x) {
  return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x["default"] : x;
}
var buffer$2 = {};
var base64Js = {};
base64Js.byteLength = byteLength;
base64Js.toByteArray = toByteArray;
base64Js.fromByteArray = fromByteArray;
var lookup = [];
var revLookup = [];
var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
for (var i$1 = 0, len = code.length; i$1 < len; ++i$1) {
  lookup[i$1] = code[i$1];
  revLookup[code.charCodeAt(i$1)] = i$1;
}
revLookup["-".charCodeAt(0)] = 62;
revLookup["_".charCodeAt(0)] = 63;
function getLens(b64) {
  var len = b64.length;
  if (len % 4 > 0) {
    throw new Error("Invalid string. Length must be a multiple of 4");
  }
  var validLen = b64.indexOf("=");
  if (validLen === -1) validLen = len;
  var placeHoldersLen = validLen === len ? 0 : 4 - validLen % 4;
  return [validLen, placeHoldersLen];
}
function byteLength(b64) {
  var lens = getLens(b64);
  var validLen = lens[0];
  var placeHoldersLen = lens[1];
  return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
}
function _byteLength(b64, validLen, placeHoldersLen) {
  return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
}
function toByteArray(b64) {
  var tmp;
  var lens = getLens(b64);
  var validLen = lens[0];
  var placeHoldersLen = lens[1];
  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
  var curByte = 0;
  var len = placeHoldersLen > 0 ? validLen - 4 : validLen;
  var i;
  for (i = 0; i < len; i += 4) {
    tmp = revLookup[b64.charCodeAt(i)] << 18 | revLookup[b64.charCodeAt(i + 1)] << 12 | revLookup[b64.charCodeAt(i + 2)] << 6 | revLookup[b64.charCodeAt(i + 3)];
    arr[curByte++] = tmp >> 16 & 255;
    arr[curByte++] = tmp >> 8 & 255;
    arr[curByte++] = tmp & 255;
  }
  if (placeHoldersLen === 2) {
    tmp = revLookup[b64.charCodeAt(i)] << 2 | revLookup[b64.charCodeAt(i + 1)] >> 4;
    arr[curByte++] = tmp & 255;
  }
  if (placeHoldersLen === 1) {
    tmp = revLookup[b64.charCodeAt(i)] << 10 | revLookup[b64.charCodeAt(i + 1)] << 4 | revLookup[b64.charCodeAt(i + 2)] >> 2;
    arr[curByte++] = tmp >> 8 & 255;
    arr[curByte++] = tmp & 255;
  }
  return arr;
}
function tripletToBase64(num) {
  return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];
}
function encodeChunk(uint8, start2, end) {
  var tmp;
  var output = [];
  for (var i = start2; i < end; i += 3) {
    tmp = (uint8[i] << 16 & 16711680) + (uint8[i + 1] << 8 & 65280) + (uint8[i + 2] & 255);
    output.push(tripletToBase64(tmp));
  }
  return output.join("");
}
function fromByteArray(uint8) {
  var tmp;
  var len = uint8.length;
  var extraBytes = len % 3;
  var parts = [];
  var maxChunkLength = 16383;
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(uint8, i, i + maxChunkLength > len2 ? len2 : i + maxChunkLength));
  }
  if (extraBytes === 1) {
    tmp = uint8[len - 1];
    parts.push(lookup[tmp >> 2] + lookup[tmp << 4 & 63] + "==");
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1];
    parts.push(lookup[tmp >> 10] + lookup[tmp >> 4 & 63] + lookup[tmp << 2 & 63] + "=");
  }
  return parts.join("");
}
var ieee754$1 = {};
/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
ieee754$1.read = function(buffer2, offset, isLE, mLen, nBytes) {
  var e, m;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var nBits = -7;
  var i = isLE ? nBytes - 1 : 0;
  var d = isLE ? -1 : 1;
  var s = buffer2[offset + i];
  i += d;
  e = s & (1 << -nBits) - 1;
  s >>= -nBits;
  nBits += eLen;
  for (; nBits > 0; e = e * 256 + buffer2[offset + i], i += d, nBits -= 8) {
  }
  m = e & (1 << -nBits) - 1;
  e >>= -nBits;
  nBits += mLen;
  for (; nBits > 0; m = m * 256 + buffer2[offset + i], i += d, nBits -= 8) {
  }
  if (e === 0) {
    e = 1 - eBias;
  } else if (e === eMax) {
    return m ? NaN : (s ? -1 : 1) * Infinity;
  } else {
    m = m + Math.pow(2, mLen);
    e = e - eBias;
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
};
ieee754$1.write = function(buffer2, value, offset, isLE, mLen, nBytes) {
  var e, m, c;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
  var i = isLE ? 0 : nBytes - 1;
  var d = isLE ? 1 : -1;
  var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
  value = Math.abs(value);
  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0;
    e = eMax;
  } else {
    e = Math.floor(Math.log(value) / Math.LN2);
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--;
      c *= 2;
    }
    if (e + eBias >= 1) {
      value += rt / c;
    } else {
      value += rt * Math.pow(2, 1 - eBias);
    }
    if (value * c >= 2) {
      e++;
      c /= 2;
    }
    if (e + eBias >= eMax) {
      m = 0;
      e = eMax;
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * Math.pow(2, mLen);
      e = e + eBias;
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
      e = 0;
    }
  }
  for (; mLen >= 8; buffer2[offset + i] = m & 255, i += d, m /= 256, mLen -= 8) {
  }
  e = e << mLen | m;
  eLen += mLen;
  for (; eLen > 0; buffer2[offset + i] = e & 255, i += d, e /= 256, eLen -= 8) {
  }
  buffer2[offset + i - d] |= s * 128;
};
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
(function(exports) {
  const base64 = base64Js;
  const ieee7542 = ieee754$1;
  const customInspectSymbol = typeof Symbol === "function" && typeof Symbol["for"] === "function" ? Symbol["for"]("nodejs.util.inspect.custom") : null;
  exports.Buffer = Buffer;
  exports.SlowBuffer = SlowBuffer;
  exports.INSPECT_MAX_BYTES = 50;
  const K_MAX_LENGTH = 2147483647;
  exports.kMaxLength = K_MAX_LENGTH;
  Buffer.TYPED_ARRAY_SUPPORT = typedArraySupport();
  if (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== "undefined" && typeof console.error === "function") {
    console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support.");
  }
  function typedArraySupport() {
    try {
      const arr = new Uint8Array(1);
      const proto = {
        foo: function() {
          return 42;
        }
      };
      Object.setPrototypeOf(proto, Uint8Array.prototype);
      Object.setPrototypeOf(arr, proto);
      return arr.foo() === 42;
    } catch (e) {
      return false;
    }
  }
  Object.defineProperty(Buffer.prototype, "parent", {
    enumerable: true,
    get: function() {
      if (!Buffer.isBuffer(this)) return void 0;
      return this.buffer;
    }
  });
  Object.defineProperty(Buffer.prototype, "offset", {
    enumerable: true,
    get: function() {
      if (!Buffer.isBuffer(this)) return void 0;
      return this.byteOffset;
    }
  });
  function createBuffer2(length) {
    if (length > K_MAX_LENGTH) {
      throw new RangeError('The value "' + length + '" is invalid for option "size"');
    }
    const buf = new Uint8Array(length);
    Object.setPrototypeOf(buf, Buffer.prototype);
    return buf;
  }
  function Buffer(arg, encodingOrOffset, length) {
    if (typeof arg === "number") {
      if (typeof encodingOrOffset === "string") {
        throw new TypeError('The "string" argument must be of type string. Received type number');
      }
      return allocUnsafe(arg);
    }
    return from7(arg, encodingOrOffset, length);
  }
  Buffer.poolSize = 8192;
  function from7(value, encodingOrOffset, length) {
    if (typeof value === "string") {
      return fromString2(value, encodingOrOffset);
    }
    if (ArrayBuffer.isView(value)) {
      return fromArrayView(value);
    }
    if (value == null) {
      throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value);
    }
    if (isInstance(value, ArrayBuffer) || value && isInstance(value.buffer, ArrayBuffer)) {
      return fromArrayBuffer(value, encodingOrOffset, length);
    }
    if (typeof SharedArrayBuffer !== "undefined" && (isInstance(value, SharedArrayBuffer) || value && isInstance(value.buffer, SharedArrayBuffer))) {
      return fromArrayBuffer(value, encodingOrOffset, length);
    }
    if (typeof value === "number") {
      throw new TypeError('The "value" argument must not be of type number. Received type number');
    }
    const valueOf = value.valueOf && value.valueOf();
    if (valueOf != null && valueOf !== value) {
      return Buffer.from(valueOf, encodingOrOffset, length);
    }
    const b = fromObject(value);
    if (b) return b;
    if (typeof Symbol !== "undefined" && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === "function") {
      return Buffer.from(value[Symbol.toPrimitive]("string"), encodingOrOffset, length);
    }
    throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value);
  }
  Buffer.from = function(value, encodingOrOffset, length) {
    return from7(value, encodingOrOffset, length);
  };
  Object.setPrototypeOf(Buffer.prototype, Uint8Array.prototype);
  Object.setPrototypeOf(Buffer, Uint8Array);
  function assertSize(size3) {
    if (typeof size3 !== "number") {
      throw new TypeError('"size" argument must be of type number');
    } else if (size3 < 0) {
      throw new RangeError('The value "' + size3 + '" is invalid for option "size"');
    }
  }
  function alloc(size3, fill4, encoding) {
    assertSize(size3);
    if (size3 <= 0) {
      return createBuffer2(size3);
    }
    if (fill4 !== void 0) {
      return typeof encoding === "string" ? createBuffer2(size3).fill(fill4, encoding) : createBuffer2(size3).fill(fill4);
    }
    return createBuffer2(size3);
  }
  Buffer.alloc = function(size3, fill4, encoding) {
    return alloc(size3, fill4, encoding);
  };
  function allocUnsafe(size3) {
    assertSize(size3);
    return createBuffer2(size3 < 0 ? 0 : checked(size3) | 0);
  }
  Buffer.allocUnsafe = function(size3) {
    return allocUnsafe(size3);
  };
  Buffer.allocUnsafeSlow = function(size3) {
    return allocUnsafe(size3);
  };
  function fromString2(string, encoding) {
    if (typeof encoding !== "string" || encoding === "") {
      encoding = "utf8";
    }
    if (!Buffer.isEncoding(encoding)) {
      throw new TypeError("Unknown encoding: " + encoding);
    }
    const length = byteLength2(string, encoding) | 0;
    let buf = createBuffer2(length);
    const actual = buf.write(string, encoding);
    if (actual !== length) {
      buf = buf.slice(0, actual);
    }
    return buf;
  }
  function fromArrayLike(array) {
    const length = array.length < 0 ? 0 : checked(array.length) | 0;
    const buf = createBuffer2(length);
    for (let i = 0; i < length; i += 1) {
      buf[i] = array[i] & 255;
    }
    return buf;
  }
  function fromArrayView(arrayView) {
    if (isInstance(arrayView, Uint8Array)) {
      const copy = new Uint8Array(arrayView);
      return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength);
    }
    return fromArrayLike(arrayView);
  }
  function fromArrayBuffer(array, byteOffset, length) {
    if (byteOffset < 0 || array.byteLength < byteOffset) {
      throw new RangeError('"offset" is outside of buffer bounds');
    }
    if (array.byteLength < byteOffset + (length || 0)) {
      throw new RangeError('"length" is outside of buffer bounds');
    }
    let buf;
    if (byteOffset === void 0 && length === void 0) {
      buf = new Uint8Array(array);
    } else if (length === void 0) {
      buf = new Uint8Array(array, byteOffset);
    } else {
      buf = new Uint8Array(array, byteOffset, length);
    }
    Object.setPrototypeOf(buf, Buffer.prototype);
    return buf;
  }
  function fromObject(obj) {
    if (Buffer.isBuffer(obj)) {
      const len = checked(obj.length) | 0;
      const buf = createBuffer2(len);
      if (buf.length === 0) {
        return buf;
      }
      obj.copy(buf, 0, 0, len);
      return buf;
    }
    if (obj.length !== void 0) {
      if (typeof obj.length !== "number" || numberIsNaN(obj.length)) {
        return createBuffer2(0);
      }
      return fromArrayLike(obj);
    }
    if (obj.type === "Buffer" && Array.isArray(obj.data)) {
      return fromArrayLike(obj.data);
    }
  }
  function checked(length) {
    if (length >= K_MAX_LENGTH) {
      throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + K_MAX_LENGTH.toString(16) + " bytes");
    }
    return length | 0;
  }
  function SlowBuffer(length) {
    if (+length != length) {
      length = 0;
    }
    return Buffer.alloc(+length);
  }
  Buffer.isBuffer = function isBuffer(b) {
    return b != null && b._isBuffer === true && b !== Buffer.prototype;
  };
  Buffer.compare = function compare(a, b) {
    if (isInstance(a, Uint8Array)) a = Buffer.from(a, a.offset, a.byteLength);
    if (isInstance(b, Uint8Array)) b = Buffer.from(b, b.offset, b.byteLength);
    if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
      throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
    }
    if (a === b) return 0;
    let x = a.length;
    let y = b.length;
    for (let i = 0, len = Math.min(x, y); i < len; ++i) {
      if (a[i] !== b[i]) {
        x = a[i];
        y = b[i];
        break;
      }
    }
    if (x < y) return -1;
    if (y < x) return 1;
    return 0;
  };
  Buffer.isEncoding = function isEncoding(encoding) {
    switch (String(encoding).toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "latin1":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return true;
      default:
        return false;
    }
  };
  Buffer.concat = function concat4(list, length) {
    if (!Array.isArray(list)) {
      throw new TypeError('"list" argument must be an Array of Buffers');
    }
    if (list.length === 0) {
      return Buffer.alloc(0);
    }
    let i;
    if (length === void 0) {
      length = 0;
      for (i = 0; i < list.length; ++i) {
        length += list[i].length;
      }
    }
    const buffer2 = Buffer.allocUnsafe(length);
    let pos = 0;
    for (i = 0; i < list.length; ++i) {
      let buf = list[i];
      if (isInstance(buf, Uint8Array)) {
        if (pos + buf.length > buffer2.length) {
          if (!Buffer.isBuffer(buf)) buf = Buffer.from(buf);
          buf.copy(buffer2, pos);
        } else {
          Uint8Array.prototype.set.call(buffer2, buf, pos);
        }
      } else if (!Buffer.isBuffer(buf)) {
        throw new TypeError('"list" argument must be an Array of Buffers');
      } else {
        buf.copy(buffer2, pos);
      }
      pos += buf.length;
    }
    return buffer2;
  };
  function byteLength2(string, encoding) {
    if (Buffer.isBuffer(string)) {
      return string.length;
    }
    if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
      return string.byteLength;
    }
    if (typeof string !== "string") {
      throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof string);
    }
    const len = string.length;
    const mustMatch = arguments.length > 2 && arguments[2] === true;
    if (!mustMatch && len === 0) return 0;
    let loweredCase = false;
    for (; ; ) {
      switch (encoding) {
        case "ascii":
        case "latin1":
        case "binary":
          return len;
        case "utf8":
        case "utf-8":
          return utf8ToBytes(string).length;
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return len * 2;
        case "hex":
          return len >>> 1;
        case "base64":
          return base64ToBytes(string).length;
        default:
          if (loweredCase) {
            return mustMatch ? -1 : utf8ToBytes(string).length;
          }
          encoding = ("" + encoding).toLowerCase();
          loweredCase = true;
      }
    }
  }
  Buffer.byteLength = byteLength2;
  function slowToString(encoding, start2, end) {
    let loweredCase = false;
    if (start2 === void 0 || start2 < 0) {
      start2 = 0;
    }
    if (start2 > this.length) {
      return "";
    }
    if (end === void 0 || end > this.length) {
      end = this.length;
    }
    if (end <= 0) {
      return "";
    }
    end >>>= 0;
    start2 >>>= 0;
    if (end <= start2) {
      return "";
    }
    if (!encoding) encoding = "utf8";
    while (true) {
      switch (encoding) {
        case "hex":
          return hexSlice(this, start2, end);
        case "utf8":
        case "utf-8":
          return utf8Slice(this, start2, end);
        case "ascii":
          return asciiSlice(this, start2, end);
        case "latin1":
        case "binary":
          return latin1Slice(this, start2, end);
        case "base64":
          return base64Slice(this, start2, end);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return utf16leSlice(this, start2, end);
        default:
          if (loweredCase) throw new TypeError("Unknown encoding: " + encoding);
          encoding = (encoding + "").toLowerCase();
          loweredCase = true;
      }
    }
  }
  Buffer.prototype._isBuffer = true;
  function swap(b, n, m) {
    const i = b[n];
    b[n] = b[m];
    b[m] = i;
  }
  Buffer.prototype.swap16 = function swap16() {
    const len = this.length;
    if (len % 2 !== 0) {
      throw new RangeError("Buffer size must be a multiple of 16-bits");
    }
    for (let i = 0; i < len; i += 2) {
      swap(this, i, i + 1);
    }
    return this;
  };
  Buffer.prototype.swap32 = function swap32() {
    const len = this.length;
    if (len % 4 !== 0) {
      throw new RangeError("Buffer size must be a multiple of 32-bits");
    }
    for (let i = 0; i < len; i += 4) {
      swap(this, i, i + 3);
      swap(this, i + 1, i + 2);
    }
    return this;
  };
  Buffer.prototype.swap64 = function swap64() {
    const len = this.length;
    if (len % 8 !== 0) {
      throw new RangeError("Buffer size must be a multiple of 64-bits");
    }
    for (let i = 0; i < len; i += 8) {
      swap(this, i, i + 7);
      swap(this, i + 1, i + 6);
      swap(this, i + 2, i + 5);
      swap(this, i + 3, i + 4);
    }
    return this;
  };
  Buffer.prototype.toString = function toString7() {
    const length = this.length;
    if (length === 0) return "";
    if (arguments.length === 0) return utf8Slice(this, 0, length);
    return slowToString.apply(this, arguments);
  };
  Buffer.prototype.toLocaleString = Buffer.prototype.toString;
  Buffer.prototype.equals = function equals(b) {
    if (!Buffer.isBuffer(b)) throw new TypeError("Argument must be a Buffer");
    if (this === b) return true;
    return Buffer.compare(this, b) === 0;
  };
  Buffer.prototype.inspect = function inspect() {
    let str = "";
    const max2 = exports.INSPECT_MAX_BYTES;
    str = this.toString("hex", 0, max2).replace(/(.{2})/g, "$1 ").trim();
    if (this.length > max2) str += " ... ";
    return "<Buffer " + str + ">";
  };
  if (customInspectSymbol) {
    Buffer.prototype[customInspectSymbol] = Buffer.prototype.inspect;
  }
  Buffer.prototype.compare = function compare(target, start2, end, thisStart, thisEnd) {
    if (isInstance(target, Uint8Array)) {
      target = Buffer.from(target, target.offset, target.byteLength);
    }
    if (!Buffer.isBuffer(target)) {
      throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof target);
    }
    if (start2 === void 0) {
      start2 = 0;
    }
    if (end === void 0) {
      end = target ? target.length : 0;
    }
    if (thisStart === void 0) {
      thisStart = 0;
    }
    if (thisEnd === void 0) {
      thisEnd = this.length;
    }
    if (start2 < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
      throw new RangeError("out of range index");
    }
    if (thisStart >= thisEnd && start2 >= end) {
      return 0;
    }
    if (thisStart >= thisEnd) {
      return -1;
    }
    if (start2 >= end) {
      return 1;
    }
    start2 >>>= 0;
    end >>>= 0;
    thisStart >>>= 0;
    thisEnd >>>= 0;
    if (this === target) return 0;
    let x = thisEnd - thisStart;
    let y = end - start2;
    const len = Math.min(x, y);
    const thisCopy = this.slice(thisStart, thisEnd);
    const targetCopy = target.slice(start2, end);
    for (let i = 0; i < len; ++i) {
      if (thisCopy[i] !== targetCopy[i]) {
        x = thisCopy[i];
        y = targetCopy[i];
        break;
      }
    }
    if (x < y) return -1;
    if (y < x) return 1;
    return 0;
  };
  function bidirectionalIndexOf(buffer2, val, byteOffset, encoding, dir) {
    if (buffer2.length === 0) return -1;
    if (typeof byteOffset === "string") {
      encoding = byteOffset;
      byteOffset = 0;
    } else if (byteOffset > 2147483647) {
      byteOffset = 2147483647;
    } else if (byteOffset < -2147483648) {
      byteOffset = -2147483648;
    }
    byteOffset = +byteOffset;
    if (numberIsNaN(byteOffset)) {
      byteOffset = dir ? 0 : buffer2.length - 1;
    }
    if (byteOffset < 0) byteOffset = buffer2.length + byteOffset;
    if (byteOffset >= buffer2.length) {
      if (dir) return -1;
      else byteOffset = buffer2.length - 1;
    } else if (byteOffset < 0) {
      if (dir) byteOffset = 0;
      else return -1;
    }
    if (typeof val === "string") {
      val = Buffer.from(val, encoding);
    }
    if (Buffer.isBuffer(val)) {
      if (val.length === 0) {
        return -1;
      }
      return arrayIndexOf(buffer2, val, byteOffset, encoding, dir);
    } else if (typeof val === "number") {
      val = val & 255;
      if (typeof Uint8Array.prototype.indexOf === "function") {
        if (dir) {
          return Uint8Array.prototype.indexOf.call(buffer2, val, byteOffset);
        } else {
          return Uint8Array.prototype.lastIndexOf.call(buffer2, val, byteOffset);
        }
      }
      return arrayIndexOf(buffer2, [val], byteOffset, encoding, dir);
    }
    throw new TypeError("val must be string, number or Buffer");
  }
  function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
    let indexSize = 1;
    let arrLength = arr.length;
    let valLength = val.length;
    if (encoding !== void 0) {
      encoding = String(encoding).toLowerCase();
      if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
        if (arr.length < 2 || val.length < 2) {
          return -1;
        }
        indexSize = 2;
        arrLength /= 2;
        valLength /= 2;
        byteOffset /= 2;
      }
    }
    function read(buf, i2) {
      if (indexSize === 1) {
        return buf[i2];
      } else {
        return buf.readUInt16BE(i2 * indexSize);
      }
    }
    let i;
    if (dir) {
      let foundIndex = -1;
      for (i = byteOffset; i < arrLength; i++) {
        if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
          if (foundIndex === -1) foundIndex = i;
          if (i - foundIndex + 1 === valLength) return foundIndex * indexSize;
        } else {
          if (foundIndex !== -1) i -= i - foundIndex;
          foundIndex = -1;
        }
      }
    } else {
      if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;
      for (i = byteOffset; i >= 0; i--) {
        let found = true;
        for (let j = 0; j < valLength; j++) {
          if (read(arr, i + j) !== read(val, j)) {
            found = false;
            break;
          }
        }
        if (found) return i;
      }
    }
    return -1;
  }
  Buffer.prototype.includes = function includes5(val, byteOffset, encoding) {
    return this.indexOf(val, byteOffset, encoding) !== -1;
  };
  Buffer.prototype.indexOf = function indexOf4(val, byteOffset, encoding) {
    return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
  };
  Buffer.prototype.lastIndexOf = function lastIndexOf4(val, byteOffset, encoding) {
    return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
  };
  function hexWrite(buf, string, offset, length) {
    offset = Number(offset) || 0;
    const remaining = buf.length - offset;
    if (!length) {
      length = remaining;
    } else {
      length = Number(length);
      if (length > remaining) {
        length = remaining;
      }
    }
    const strLen = string.length;
    if (length > strLen / 2) {
      length = strLen / 2;
    }
    let i;
    for (i = 0; i < length; ++i) {
      const parsed = parseInt(string.substr(i * 2, 2), 16);
      if (numberIsNaN(parsed)) return i;
      buf[offset + i] = parsed;
    }
    return i;
  }
  function utf8Write(buf, string, offset, length) {
    return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
  }
  function asciiWrite(buf, string, offset, length) {
    return blitBuffer(asciiToBytes(string), buf, offset, length);
  }
  function base64Write(buf, string, offset, length) {
    return blitBuffer(base64ToBytes(string), buf, offset, length);
  }
  function ucs2Write(buf, string, offset, length) {
    return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
  }
  Buffer.prototype.write = function write(string, offset, length, encoding) {
    if (offset === void 0) {
      encoding = "utf8";
      length = this.length;
      offset = 0;
    } else if (length === void 0 && typeof offset === "string") {
      encoding = offset;
      length = this.length;
      offset = 0;
    } else if (isFinite(offset)) {
      offset = offset >>> 0;
      if (isFinite(length)) {
        length = length >>> 0;
        if (encoding === void 0) encoding = "utf8";
      } else {
        encoding = length;
        length = void 0;
      }
    } else {
      throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
    }
    const remaining = this.length - offset;
    if (length === void 0 || length > remaining) length = remaining;
    if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
      throw new RangeError("Attempt to write outside buffer bounds");
    }
    if (!encoding) encoding = "utf8";
    let loweredCase = false;
    for (; ; ) {
      switch (encoding) {
        case "hex":
          return hexWrite(this, string, offset, length);
        case "utf8":
        case "utf-8":
          return utf8Write(this, string, offset, length);
        case "ascii":
        case "latin1":
        case "binary":
          return asciiWrite(this, string, offset, length);
        case "base64":
          return base64Write(this, string, offset, length);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return ucs2Write(this, string, offset, length);
        default:
          if (loweredCase) throw new TypeError("Unknown encoding: " + encoding);
          encoding = ("" + encoding).toLowerCase();
          loweredCase = true;
      }
    }
  };
  Buffer.prototype.toJSON = function toJSON4() {
    return {
      type: "Buffer",
      data: Array.prototype.slice.call(this._arr || this, 0)
    };
  };
  function base64Slice(buf, start2, end) {
    if (start2 === 0 && end === buf.length) {
      return base64.fromByteArray(buf);
    } else {
      return base64.fromByteArray(buf.slice(start2, end));
    }
  }
  function utf8Slice(buf, start2, end) {
    end = Math.min(buf.length, end);
    const res = [];
    let i = start2;
    while (i < end) {
      const firstByte = buf[i];
      let codePoint = null;
      let bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
      if (i + bytesPerSequence <= end) {
        let secondByte, thirdByte, fourthByte, tempCodePoint;
        switch (bytesPerSequence) {
          case 1:
            if (firstByte < 128) {
              codePoint = firstByte;
            }
            break;
          case 2:
            secondByte = buf[i + 1];
            if ((secondByte & 192) === 128) {
              tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
              if (tempCodePoint > 127) {
                codePoint = tempCodePoint;
              }
            }
            break;
          case 3:
            secondByte = buf[i + 1];
            thirdByte = buf[i + 2];
            if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
              tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
              if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
                codePoint = tempCodePoint;
              }
            }
            break;
          case 4:
            secondByte = buf[i + 1];
            thirdByte = buf[i + 2];
            fourthByte = buf[i + 3];
            if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
              tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
              if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
                codePoint = tempCodePoint;
              }
            }
        }
      }
      if (codePoint === null) {
        codePoint = 65533;
        bytesPerSequence = 1;
      } else if (codePoint > 65535) {
        codePoint -= 65536;
        res.push(codePoint >>> 10 & 1023 | 55296);
        codePoint = 56320 | codePoint & 1023;
      }
      res.push(codePoint);
      i += bytesPerSequence;
    }
    return decodeCodePointsArray(res);
  }
  const MAX_ARGUMENTS_LENGTH = 4096;
  function decodeCodePointsArray(codePoints3) {
    const len = codePoints3.length;
    if (len <= MAX_ARGUMENTS_LENGTH) {
      return String.fromCharCode.apply(String, codePoints3);
    }
    let res = "";
    let i = 0;
    while (i < len) {
      res += String.fromCharCode.apply(String, codePoints3.slice(i, i += MAX_ARGUMENTS_LENGTH));
    }
    return res;
  }
  function asciiSlice(buf, start2, end) {
    let ret = "";
    end = Math.min(buf.length, end);
    for (let i = start2; i < end; ++i) {
      ret += String.fromCharCode(buf[i] & 127);
    }
    return ret;
  }
  function latin1Slice(buf, start2, end) {
    let ret = "";
    end = Math.min(buf.length, end);
    for (let i = start2; i < end; ++i) {
      ret += String.fromCharCode(buf[i]);
    }
    return ret;
  }
  function hexSlice(buf, start2, end) {
    const len = buf.length;
    if (!start2 || start2 < 0) start2 = 0;
    if (!end || end < 0 || end > len) end = len;
    let out = "";
    for (let i = start2; i < end; ++i) {
      out += hexSliceLookupTable[buf[i]];
    }
    return out;
  }
  function utf16leSlice(buf, start2, end) {
    const bytes = buf.slice(start2, end);
    let res = "";
    for (let i = 0; i < bytes.length - 1; i += 2) {
      res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
    }
    return res;
  }
  Buffer.prototype.slice = function slice5(start2, end) {
    const len = this.length;
    start2 = ~~start2;
    end = end === void 0 ? len : ~~end;
    if (start2 < 0) {
      start2 += len;
      if (start2 < 0) start2 = 0;
    } else if (start2 > len) {
      start2 = len;
    }
    if (end < 0) {
      end += len;
      if (end < 0) end = 0;
    } else if (end > len) {
      end = len;
    }
    if (end < start2) end = start2;
    const newBuf = this.subarray(start2, end);
    Object.setPrototypeOf(newBuf, Buffer.prototype);
    return newBuf;
  };
  function checkOffset(offset, ext, length) {
    if (offset % 1 !== 0 || offset < 0) throw new RangeError("offset is not uint");
    if (offset + ext > length) throw new RangeError("Trying to access beyond buffer length");
  }
  Buffer.prototype.readUintLE = Buffer.prototype.readUIntLE = function readUIntLE(offset, byteLength3, noAssert) {
    offset = offset >>> 0;
    byteLength3 = byteLength3 >>> 0;
    if (!noAssert) checkOffset(offset, byteLength3, this.length);
    let val = this[offset];
    let mul = 1;
    let i = 0;
    while (++i < byteLength3 && (mul *= 256)) {
      val += this[offset + i] * mul;
    }
    return val;
  };
  Buffer.prototype.readUintBE = Buffer.prototype.readUIntBE = function readUIntBE(offset, byteLength3, noAssert) {
    offset = offset >>> 0;
    byteLength3 = byteLength3 >>> 0;
    if (!noAssert) {
      checkOffset(offset, byteLength3, this.length);
    }
    let val = this[offset + --byteLength3];
    let mul = 1;
    while (byteLength3 > 0 && (mul *= 256)) {
      val += this[offset + --byteLength3] * mul;
    }
    return val;
  };
  Buffer.prototype.readUint8 = Buffer.prototype.readUInt8 = function readUInt8(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 1, this.length);
    return this[offset];
  };
  Buffer.prototype.readUint16LE = Buffer.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 2, this.length);
    return this[offset] | this[offset + 1] << 8;
  };
  Buffer.prototype.readUint16BE = Buffer.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 2, this.length);
    return this[offset] << 8 | this[offset + 1];
  };
  Buffer.prototype.readUint32LE = Buffer.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216;
  };
  Buffer.prototype.readUint32BE = Buffer.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
  };
  Buffer.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE(offset) {
    offset = offset >>> 0;
    validateNumber(offset, "offset");
    const first = this[offset];
    const last = this[offset + 7];
    if (first === void 0 || last === void 0) {
      boundsError(offset, this.length - 8);
    }
    const lo = first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24;
    const hi2 = this[++offset] + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + last * 2 ** 24;
    return BigInt(lo) + (BigInt(hi2) << BigInt(32));
  });
  Buffer.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE(offset) {
    offset = offset >>> 0;
    validateNumber(offset, "offset");
    const first = this[offset];
    const last = this[offset + 7];
    if (first === void 0 || last === void 0) {
      boundsError(offset, this.length - 8);
    }
    const hi2 = first * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
    const lo = this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last;
    return (BigInt(hi2) << BigInt(32)) + BigInt(lo);
  });
  Buffer.prototype.readIntLE = function readIntLE(offset, byteLength3, noAssert) {
    offset = offset >>> 0;
    byteLength3 = byteLength3 >>> 0;
    if (!noAssert) checkOffset(offset, byteLength3, this.length);
    let val = this[offset];
    let mul = 1;
    let i = 0;
    while (++i < byteLength3 && (mul *= 256)) {
      val += this[offset + i] * mul;
    }
    mul *= 128;
    if (val >= mul) val -= Math.pow(2, 8 * byteLength3);
    return val;
  };
  Buffer.prototype.readIntBE = function readIntBE(offset, byteLength3, noAssert) {
    offset = offset >>> 0;
    byteLength3 = byteLength3 >>> 0;
    if (!noAssert) checkOffset(offset, byteLength3, this.length);
    let i = byteLength3;
    let mul = 1;
    let val = this[offset + --i];
    while (i > 0 && (mul *= 256)) {
      val += this[offset + --i] * mul;
    }
    mul *= 128;
    if (val >= mul) val -= Math.pow(2, 8 * byteLength3);
    return val;
  };
  Buffer.prototype.readInt8 = function readInt8(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 1, this.length);
    if (!(this[offset] & 128)) return this[offset];
    return (255 - this[offset] + 1) * -1;
  };
  Buffer.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 2, this.length);
    const val = this[offset] | this[offset + 1] << 8;
    return val & 32768 ? val | 4294901760 : val;
  };
  Buffer.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 2, this.length);
    const val = this[offset + 1] | this[offset] << 8;
    return val & 32768 ? val | 4294901760 : val;
  };
  Buffer.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
  };
  Buffer.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
  };
  Buffer.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE(offset) {
    offset = offset >>> 0;
    validateNumber(offset, "offset");
    const first = this[offset];
    const last = this[offset + 7];
    if (first === void 0 || last === void 0) {
      boundsError(offset, this.length - 8);
    }
    const val = this[offset + 4] + this[offset + 5] * 2 ** 8 + this[offset + 6] * 2 ** 16 + (last << 24);
    return (BigInt(val) << BigInt(32)) + BigInt(first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24);
  });
  Buffer.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE(offset) {
    offset = offset >>> 0;
    validateNumber(offset, "offset");
    const first = this[offset];
    const last = this[offset + 7];
    if (first === void 0 || last === void 0) {
      boundsError(offset, this.length - 8);
    }
    const val = (first << 24) + // Overflow
    this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
    return (BigInt(val) << BigInt(32)) + BigInt(this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last);
  });
  Buffer.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return ieee7542.read(this, offset, true, 23, 4);
  };
  Buffer.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return ieee7542.read(this, offset, false, 23, 4);
  };
  Buffer.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 8, this.length);
    return ieee7542.read(this, offset, true, 52, 8);
  };
  Buffer.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 8, this.length);
    return ieee7542.read(this, offset, false, 52, 8);
  };
  function checkInt(buf, value, offset, ext, max2, min2) {
    if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance');
    if (value > max2 || value < min2) throw new RangeError('"value" argument is out of bounds');
    if (offset + ext > buf.length) throw new RangeError("Index out of range");
  }
  Buffer.prototype.writeUintLE = Buffer.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength3, noAssert) {
    value = +value;
    offset = offset >>> 0;
    byteLength3 = byteLength3 >>> 0;
    if (!noAssert) {
      const maxBytes = Math.pow(2, 8 * byteLength3) - 1;
      checkInt(this, value, offset, byteLength3, maxBytes, 0);
    }
    let mul = 1;
    let i = 0;
    this[offset] = value & 255;
    while (++i < byteLength3 && (mul *= 256)) {
      this[offset + i] = value / mul & 255;
    }
    return offset + byteLength3;
  };
  Buffer.prototype.writeUintBE = Buffer.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength3, noAssert) {
    value = +value;
    offset = offset >>> 0;
    byteLength3 = byteLength3 >>> 0;
    if (!noAssert) {
      const maxBytes = Math.pow(2, 8 * byteLength3) - 1;
      checkInt(this, value, offset, byteLength3, maxBytes, 0);
    }
    let i = byteLength3 - 1;
    let mul = 1;
    this[offset + i] = value & 255;
    while (--i >= 0 && (mul *= 256)) {
      this[offset + i] = value / mul & 255;
    }
    return offset + byteLength3;
  };
  Buffer.prototype.writeUint8 = Buffer.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 1, 255, 0);
    this[offset] = value & 255;
    return offset + 1;
  };
  Buffer.prototype.writeUint16LE = Buffer.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 2, 65535, 0);
    this[offset] = value & 255;
    this[offset + 1] = value >>> 8;
    return offset + 2;
  };
  Buffer.prototype.writeUint16BE = Buffer.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 2, 65535, 0);
    this[offset] = value >>> 8;
    this[offset + 1] = value & 255;
    return offset + 2;
  };
  Buffer.prototype.writeUint32LE = Buffer.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 4, 4294967295, 0);
    this[offset + 3] = value >>> 24;
    this[offset + 2] = value >>> 16;
    this[offset + 1] = value >>> 8;
    this[offset] = value & 255;
    return offset + 4;
  };
  Buffer.prototype.writeUint32BE = Buffer.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 4, 4294967295, 0);
    this[offset] = value >>> 24;
    this[offset + 1] = value >>> 16;
    this[offset + 2] = value >>> 8;
    this[offset + 3] = value & 255;
    return offset + 4;
  };
  function wrtBigUInt64LE(buf, value, offset, min2, max2) {
    checkIntBI(value, min2, max2, buf, offset, 7);
    let lo = Number(value & BigInt(4294967295));
    buf[offset++] = lo;
    lo = lo >> 8;
    buf[offset++] = lo;
    lo = lo >> 8;
    buf[offset++] = lo;
    lo = lo >> 8;
    buf[offset++] = lo;
    let hi2 = Number(value >> BigInt(32) & BigInt(4294967295));
    buf[offset++] = hi2;
    hi2 = hi2 >> 8;
    buf[offset++] = hi2;
    hi2 = hi2 >> 8;
    buf[offset++] = hi2;
    hi2 = hi2 >> 8;
    buf[offset++] = hi2;
    return offset;
  }
  function wrtBigUInt64BE(buf, value, offset, min2, max2) {
    checkIntBI(value, min2, max2, buf, offset, 7);
    let lo = Number(value & BigInt(4294967295));
    buf[offset + 7] = lo;
    lo = lo >> 8;
    buf[offset + 6] = lo;
    lo = lo >> 8;
    buf[offset + 5] = lo;
    lo = lo >> 8;
    buf[offset + 4] = lo;
    let hi2 = Number(value >> BigInt(32) & BigInt(4294967295));
    buf[offset + 3] = hi2;
    hi2 = hi2 >> 8;
    buf[offset + 2] = hi2;
    hi2 = hi2 >> 8;
    buf[offset + 1] = hi2;
    hi2 = hi2 >> 8;
    buf[offset] = hi2;
    return offset + 8;
  }
  Buffer.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE(value, offset = 0) {
    return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
  });
  Buffer.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE(value, offset = 0) {
    return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
  });
  Buffer.prototype.writeIntLE = function writeIntLE(value, offset, byteLength3, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) {
      const limit = Math.pow(2, 8 * byteLength3 - 1);
      checkInt(this, value, offset, byteLength3, limit - 1, -limit);
    }
    let i = 0;
    let mul = 1;
    let sub2 = 0;
    this[offset] = value & 255;
    while (++i < byteLength3 && (mul *= 256)) {
      if (value < 0 && sub2 === 0 && this[offset + i - 1] !== 0) {
        sub2 = 1;
      }
      this[offset + i] = (value / mul >> 0) - sub2 & 255;
    }
    return offset + byteLength3;
  };
  Buffer.prototype.writeIntBE = function writeIntBE(value, offset, byteLength3, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) {
      const limit = Math.pow(2, 8 * byteLength3 - 1);
      checkInt(this, value, offset, byteLength3, limit - 1, -limit);
    }
    let i = byteLength3 - 1;
    let mul = 1;
    let sub2 = 0;
    this[offset + i] = value & 255;
    while (--i >= 0 && (mul *= 256)) {
      if (value < 0 && sub2 === 0 && this[offset + i + 1] !== 0) {
        sub2 = 1;
      }
      this[offset + i] = (value / mul >> 0) - sub2 & 255;
    }
    return offset + byteLength3;
  };
  Buffer.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 1, 127, -128);
    if (value < 0) value = 255 + value + 1;
    this[offset] = value & 255;
    return offset + 1;
  };
  Buffer.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 2, 32767, -32768);
    this[offset] = value & 255;
    this[offset + 1] = value >>> 8;
    return offset + 2;
  };
  Buffer.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 2, 32767, -32768);
    this[offset] = value >>> 8;
    this[offset + 1] = value & 255;
    return offset + 2;
  };
  Buffer.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 4, 2147483647, -2147483648);
    this[offset] = value & 255;
    this[offset + 1] = value >>> 8;
    this[offset + 2] = value >>> 16;
    this[offset + 3] = value >>> 24;
    return offset + 4;
  };
  Buffer.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 4, 2147483647, -2147483648);
    if (value < 0) value = 4294967295 + value + 1;
    this[offset] = value >>> 24;
    this[offset + 1] = value >>> 16;
    this[offset + 2] = value >>> 8;
    this[offset + 3] = value & 255;
    return offset + 4;
  };
  Buffer.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE(value, offset = 0) {
    return wrtBigUInt64LE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  });
  Buffer.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE(value, offset = 0) {
    return wrtBigUInt64BE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  });
  function checkIEEE754(buf, value, offset, ext, max2, min2) {
    if (offset + ext > buf.length) throw new RangeError("Index out of range");
    if (offset < 0) throw new RangeError("Index out of range");
  }
  function writeFloat(buf, value, offset, littleEndian, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) {
      checkIEEE754(buf, value, offset, 4);
    }
    ieee7542.write(buf, value, offset, littleEndian, 23, 4);
    return offset + 4;
  }
  Buffer.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
    return writeFloat(this, value, offset, true, noAssert);
  };
  Buffer.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
    return writeFloat(this, value, offset, false, noAssert);
  };
  function writeDouble(buf, value, offset, littleEndian, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) {
      checkIEEE754(buf, value, offset, 8);
    }
    ieee7542.write(buf, value, offset, littleEndian, 52, 8);
    return offset + 8;
  }
  Buffer.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
    return writeDouble(this, value, offset, true, noAssert);
  };
  Buffer.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
    return writeDouble(this, value, offset, false, noAssert);
  };
  Buffer.prototype.copy = function copy(target, targetStart, start2, end) {
    if (!Buffer.isBuffer(target)) throw new TypeError("argument should be a Buffer");
    if (!start2) start2 = 0;
    if (!end && end !== 0) end = this.length;
    if (targetStart >= target.length) targetStart = target.length;
    if (!targetStart) targetStart = 0;
    if (end > 0 && end < start2) end = start2;
    if (end === start2) return 0;
    if (target.length === 0 || this.length === 0) return 0;
    if (targetStart < 0) {
      throw new RangeError("targetStart out of bounds");
    }
    if (start2 < 0 || start2 >= this.length) throw new RangeError("Index out of range");
    if (end < 0) throw new RangeError("sourceEnd out of bounds");
    if (end > this.length) end = this.length;
    if (target.length - targetStart < end - start2) {
      end = target.length - targetStart + start2;
    }
    const len = end - start2;
    if (this === target && typeof Uint8Array.prototype.copyWithin === "function") {
      this.copyWithin(targetStart, start2, end);
    } else {
      Uint8Array.prototype.set.call(target, this.subarray(start2, end), targetStart);
    }
    return len;
  };
  Buffer.prototype.fill = function fill4(val, start2, end, encoding) {
    if (typeof val === "string") {
      if (typeof start2 === "string") {
        encoding = start2;
        start2 = 0;
        end = this.length;
      } else if (typeof end === "string") {
        encoding = end;
        end = this.length;
      }
      if (encoding !== void 0 && typeof encoding !== "string") {
        throw new TypeError("encoding must be a string");
      }
      if (typeof encoding === "string" && !Buffer.isEncoding(encoding)) {
        throw new TypeError("Unknown encoding: " + encoding);
      }
      if (val.length === 1) {
        const code2 = val.charCodeAt(0);
        if (encoding === "utf8" && code2 < 128 || encoding === "latin1") {
          val = code2;
        }
      }
    } else if (typeof val === "number") {
      val = val & 255;
    } else if (typeof val === "boolean") {
      val = Number(val);
    }
    if (start2 < 0 || this.length < start2 || this.length < end) {
      throw new RangeError("Out of range index");
    }
    if (end <= start2) {
      return this;
    }
    start2 = start2 >>> 0;
    end = end === void 0 ? this.length : end >>> 0;
    if (!val) val = 0;
    let i;
    if (typeof val === "number") {
      for (i = start2; i < end; ++i) {
        this[i] = val;
      }
    } else {
      const bytes = Buffer.isBuffer(val) ? val : Buffer.from(val, encoding);
      const len = bytes.length;
      if (len === 0) {
        throw new TypeError('The value "' + val + '" is invalid for argument "value"');
      }
      for (i = 0; i < end - start2; ++i) {
        this[i + start2] = bytes[i % len];
      }
    }
    return this;
  };
  const errors = {};
  function E2(sym, getMessage, Base) {
    errors[sym] = class NodeError extends Base {
      constructor() {
        super();
        Object.defineProperty(this, "message", {
          value: getMessage.apply(this, arguments),
          writable: true,
          configurable: true
        });
        this.name = `${this.name} [${sym}]`;
        this.stack;
        delete this.name;
      }
      get code() {
        return sym;
      }
      set code(value) {
        Object.defineProperty(this, "code", {
          configurable: true,
          enumerable: true,
          value,
          writable: true
        });
      }
      toString() {
        return `${this.name} [${sym}]: ${this.message}`;
      }
    };
  }
  E2("ERR_BUFFER_OUT_OF_BOUNDS", function(name) {
    if (name) {
      return `${name} is outside of buffer bounds`;
    }
    return "Attempt to access memory outside buffer bounds";
  }, RangeError);
  E2("ERR_INVALID_ARG_TYPE", function(name, actual) {
    return `The "${name}" argument must be of type number. Received type ${typeof actual}`;
  }, TypeError);
  E2("ERR_OUT_OF_RANGE", function(str, range3, input) {
    let msg = `The value of "${str}" is out of range.`;
    let received = input;
    if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {
      received = addNumericalSeparator(String(input));
    } else if (typeof input === "bigint") {
      received = String(input);
      if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) {
        received = addNumericalSeparator(received);
      }
      received += "n";
    }
    msg += ` It must be ${range3}. Received ${received}`;
    return msg;
  }, RangeError);
  function addNumericalSeparator(val) {
    let res = "";
    let i = val.length;
    const start2 = val[0] === "-" ? 1 : 0;
    for (; i >= start2 + 4; i -= 3) {
      res = `_${val.slice(i - 3, i)}${res}`;
    }
    return `${val.slice(0, i)}${res}`;
  }
  function checkBounds(buf, offset, byteLength3) {
    validateNumber(offset, "offset");
    if (buf[offset] === void 0 || buf[offset + byteLength3] === void 0) {
      boundsError(offset, buf.length - (byteLength3 + 1));
    }
  }
  function checkIntBI(value, min2, max2, buf, offset, byteLength3) {
    if (value > max2 || value < min2) {
      const n = typeof min2 === "bigint" ? "n" : "";
      let range3;
      {
        if (min2 === 0 || min2 === BigInt(0)) {
          range3 = `>= 0${n} and < 2${n} ** ${(byteLength3 + 1) * 8}${n}`;
        } else {
          range3 = `>= -(2${n} ** ${(byteLength3 + 1) * 8 - 1}${n}) and < 2 ** ${(byteLength3 + 1) * 8 - 1}${n}`;
        }
      }
      throw new errors.ERR_OUT_OF_RANGE("value", range3, value);
    }
    checkBounds(buf, offset, byteLength3);
  }
  function validateNumber(value, name) {
    if (typeof value !== "number") {
      throw new errors.ERR_INVALID_ARG_TYPE(name, "number", value);
    }
  }
  function boundsError(value, length, type) {
    if (Math.floor(value) !== value) {
      validateNumber(value, type);
      throw new errors.ERR_OUT_OF_RANGE("offset", "an integer", value);
    }
    if (length < 0) {
      throw new errors.ERR_BUFFER_OUT_OF_BOUNDS();
    }
    throw new errors.ERR_OUT_OF_RANGE("offset", `>= ${0} and <= ${length}`, value);
  }
  const INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
  function base64clean(str) {
    str = str.split("=")[0];
    str = str.trim().replace(INVALID_BASE64_RE, "");
    if (str.length < 2) return "";
    while (str.length % 4 !== 0) {
      str = str + "=";
    }
    return str;
  }
  function utf8ToBytes(string, units) {
    units = units || Infinity;
    let codePoint;
    const length = string.length;
    let leadSurrogate = null;
    const bytes = [];
    for (let i = 0; i < length; ++i) {
      codePoint = string.charCodeAt(i);
      if (codePoint > 55295 && codePoint < 57344) {
        if (!leadSurrogate) {
          if (codePoint > 56319) {
            if ((units -= 3) > -1) bytes.push(239, 191, 189);
            continue;
          } else if (i + 1 === length) {
            if ((units -= 3) > -1) bytes.push(239, 191, 189);
            continue;
          }
          leadSurrogate = codePoint;
          continue;
        }
        if (codePoint < 56320) {
          if ((units -= 3) > -1) bytes.push(239, 191, 189);
          leadSurrogate = codePoint;
          continue;
        }
        codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
      } else if (leadSurrogate) {
        if ((units -= 3) > -1) bytes.push(239, 191, 189);
      }
      leadSurrogate = null;
      if (codePoint < 128) {
        if ((units -= 1) < 0) break;
        bytes.push(codePoint);
      } else if (codePoint < 2048) {
        if ((units -= 2) < 0) break;
        bytes.push(codePoint >> 6 | 192, codePoint & 63 | 128);
      } else if (codePoint < 65536) {
        if ((units -= 3) < 0) break;
        bytes.push(codePoint >> 12 | 224, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
      } else if (codePoint < 1114112) {
        if ((units -= 4) < 0) break;
        bytes.push(codePoint >> 18 | 240, codePoint >> 12 & 63 | 128, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
      } else {
        throw new Error("Invalid code point");
      }
    }
    return bytes;
  }
  function asciiToBytes(str) {
    const byteArray = [];
    for (let i = 0; i < str.length; ++i) {
      byteArray.push(str.charCodeAt(i) & 255);
    }
    return byteArray;
  }
  function utf16leToBytes(str, units) {
    let c, hi2, lo;
    const byteArray = [];
    for (let i = 0; i < str.length; ++i) {
      if ((units -= 2) < 0) break;
      c = str.charCodeAt(i);
      hi2 = c >> 8;
      lo = c % 256;
      byteArray.push(lo);
      byteArray.push(hi2);
    }
    return byteArray;
  }
  function base64ToBytes(str) {
    return base64.toByteArray(base64clean(str));
  }
  function blitBuffer(src, dst, offset, length) {
    let i;
    for (i = 0; i < length; ++i) {
      if (i + offset >= dst.length || i >= src.length) break;
      dst[i + offset] = src[i];
    }
    return i;
  }
  function isInstance(obj, type) {
    return obj instanceof type || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type.name;
  }
  function numberIsNaN(obj) {
    return obj !== obj;
  }
  const hexSliceLookupTable = function() {
    const alphabet = "0123456789abcdef";
    const table = new Array(256);
    for (let i = 0; i < 16; ++i) {
      const i16 = i * 16;
      for (let j = 0; j < 16; ++j) {
        table[i16 + j] = alphabet[i] + alphabet[j];
      }
    }
    return table;
  }();
  function defineBigIntMethod(fn) {
    return typeof BigInt === "undefined" ? BufferBigIntNotDefined : fn;
  }
  function BufferBigIntNotDefined() {
    throw new Error("BigInt not supported");
  }
})(buffer$2);
var check = function(it) {
  return it && it.Math === Math && it;
};
var globalThis_1 = (
  // eslint-disable-next-line es/no-global-this -- safe
  check(typeof globalThis == "object" && globalThis) || check(typeof window == "object" && window) || // eslint-disable-next-line no-restricted-globals -- safe
  check(typeof self == "object" && self) || check(typeof globalThis == "object" && globalThis) || check(typeof commonjsGlobal == "object" && commonjsGlobal) || // eslint-disable-next-line no-new-func -- fallback
  /* @__PURE__ */ function() {
    return this;
  }() || Function("return this")()
);
var objectGetOwnPropertyDescriptor = {};
var fails$1z = function(exec2) {
  try {
    return !!exec2();
  } catch (error3) {
    return true;
  }
};
var fails$1y = fails$1z;
var descriptors = !fails$1y(function() {
  return Object.defineProperty({}, 1, {
    get: function() {
      return 7;
    }
  })[1] !== 7;
});
var fails$1x = fails$1z;
var functionBindNative = !fails$1x(function() {
  var test2 = (function() {
  }).bind();
  return typeof test2 != "function" || test2.hasOwnProperty("prototype");
});
var NATIVE_BIND$4 = functionBindNative;
var call$1j = Function.prototype.call;
var functionCall = NATIVE_BIND$4 ? call$1j.bind(call$1j) : function() {
  return call$1j.apply(call$1j, arguments);
};
var objectPropertyIsEnumerable = {};
var $propertyIsEnumerable$2 = {}.propertyIsEnumerable;
var getOwnPropertyDescriptor$d = Object.getOwnPropertyDescriptor;
var NASHORN_BUG = getOwnPropertyDescriptor$d && !$propertyIsEnumerable$2.call({
  1: 2
}, 1);
objectPropertyIsEnumerable.f = NASHORN_BUG ? function propertyIsEnumerable(V) {
  var descriptor = getOwnPropertyDescriptor$d(this, V);
  return !!descriptor && descriptor.enumerable;
} : $propertyIsEnumerable$2;
var createPropertyDescriptor$d = function(bitmap, value) {
  return {
    enumerable: !(bitmap & 1),
    configurable: !(bitmap & 2),
    writable: !(bitmap & 4),
    value
  };
};
var NATIVE_BIND$3 = functionBindNative;
var FunctionPrototype$5 = Function.prototype;
var call$1i = FunctionPrototype$5.call;
var uncurryThisWithBind = NATIVE_BIND$3 && FunctionPrototype$5.bind.bind(call$1i, call$1i);
var functionUncurryThis = NATIVE_BIND$3 ? uncurryThisWithBind : function(fn) {
  return function() {
    return call$1i.apply(fn, arguments);
  };
};
var uncurryThis$1X = functionUncurryThis;
var toString$L = uncurryThis$1X({}.toString);
var stringSlice$m = uncurryThis$1X("".slice);
var classofRaw$2 = function(it) {
  return stringSlice$m(toString$L(it), 8, -1);
};
var uncurryThis$1W = functionUncurryThis;
var fails$1w = fails$1z;
var classof$r = classofRaw$2;
var $Object$8 = Object;
var split$5 = uncurryThis$1W("".split);
var indexedObject = fails$1w(function() {
  return !$Object$8("z").propertyIsEnumerable(0);
}) ? function(it) {
  return classof$r(it) === "String" ? split$5(it, "") : $Object$8(it);
} : $Object$8;
var isNullOrUndefined$j = function(it) {
  return it === null || it === void 0;
};
var isNullOrUndefined$i = isNullOrUndefined$j;
var $TypeError$N = TypeError;
var requireObjectCoercible$q = function(it) {
  if (isNullOrUndefined$i(it)) throw new $TypeError$N("Can't call method on " + it);
  return it;
};
var IndexedObject$7 = indexedObject;
var requireObjectCoercible$p = requireObjectCoercible$q;
var toIndexedObject$k = function(it) {
  return IndexedObject$7(requireObjectCoercible$p(it));
};
var documentAll = typeof document == "object" && document.all;
var isCallable$I = typeof documentAll == "undefined" && documentAll !== void 0 ? function(argument) {
  return typeof argument == "function" || argument === documentAll;
} : function(argument) {
  return typeof argument == "function";
};
var isCallable$H = isCallable$I;
var isObject$O = function(it) {
  return typeof it == "object" ? it !== null : isCallable$H(it);
};
var globalThis$1k = globalThis_1;
var isCallable$G = isCallable$I;
var aFunction = function(argument) {
  return isCallable$G(argument) ? argument : void 0;
};
var getBuiltIn$Q = function(namespace, method) {
  return arguments.length < 2 ? aFunction(globalThis$1k[namespace]) : globalThis$1k[namespace] && globalThis$1k[namespace][method];
};
var uncurryThis$1V = functionUncurryThis;
var objectIsPrototypeOf = uncurryThis$1V({}.isPrototypeOf);
var globalThis$1j = globalThis_1;
var navigator$1 = globalThis$1j.navigator;
var userAgent$8 = navigator$1 && navigator$1.userAgent;
var environmentUserAgent = userAgent$8 ? String(userAgent$8) : "";
var globalThis$1i = globalThis_1;
var userAgent$7 = environmentUserAgent;
var process$3 = globalThis$1i.process;
var Deno$1 = globalThis$1i.Deno;
var versions = process$3 && process$3.versions || Deno$1 && Deno$1.version;
var v8 = versions && versions.v8;
var match$1, version;
if (v8) {
  match$1 = v8.split(".");
  version = match$1[0] > 0 && match$1[0] < 4 ? 1 : +(match$1[0] + match$1[1]);
}
if (!version && userAgent$7) {
  match$1 = userAgent$7.match(/Edge\/(\d+)/);
  if (!match$1 || match$1[1] >= 74) {
    match$1 = userAgent$7.match(/Chrome\/(\d+)/);
    if (match$1) version = +match$1[1];
  }
}
var environmentV8Version = version;
var V8_VERSION$4 = environmentV8Version;
var fails$1v = fails$1z;
var globalThis$1h = globalThis_1;
var $String$a = globalThis$1h.String;
var symbolConstructorDetection = !!Object.getOwnPropertySymbols && !fails$1v(function() {
  var symbol = Symbol("symbol detection");
  return !$String$a(symbol) || !(Object(symbol) instanceof Symbol) || // Chrome 38-40 symbols are not inherited from DOM collections prototypes to instances
  !Symbol.sham && V8_VERSION$4 && V8_VERSION$4 < 41;
});
var NATIVE_SYMBOL$7 = symbolConstructorDetection;
var useSymbolAsUid = NATIVE_SYMBOL$7 && !Symbol.sham && typeof Symbol.iterator == "symbol";
var getBuiltIn$P = getBuiltIn$Q;
var isCallable$F = isCallable$I;
var isPrototypeOf$f = objectIsPrototypeOf;
var USE_SYMBOL_AS_UID$1 = useSymbolAsUid;
var $Object$7 = Object;
var isSymbol$8 = USE_SYMBOL_AS_UID$1 ? function(it) {
  return typeof it == "symbol";
} : function(it) {
  var $Symbol2 = getBuiltIn$P("Symbol");
  return isCallable$F($Symbol2) && isPrototypeOf$f($Symbol2.prototype, $Object$7(it));
};
var $String$9 = String;
var tryToString$7 = function(argument) {
  try {
    return $String$9(argument);
  } catch (error3) {
    return "Object";
  }
};
var isCallable$E = isCallable$I;
var tryToString$6 = tryToString$7;
var $TypeError$M = TypeError;
var aCallable$Q = function(argument) {
  if (isCallable$E(argument)) return argument;
  throw new $TypeError$M(tryToString$6(argument) + " is not a function");
};
var aCallable$P = aCallable$Q;
var isNullOrUndefined$h = isNullOrUndefined$j;
var getMethod$l = function(V, P) {
  var func = V[P];
  return isNullOrUndefined$h(func) ? void 0 : aCallable$P(func);
};
var call$1h = functionCall;
var isCallable$D = isCallable$I;
var isObject$N = isObject$O;
var $TypeError$L = TypeError;
var ordinaryToPrimitive$2 = function(input, pref) {
  var fn, val;
  if (pref === "string" && isCallable$D(fn = input.toString) && !isObject$N(val = call$1h(fn, input))) return val;
  if (isCallable$D(fn = input.valueOf) && !isObject$N(val = call$1h(fn, input))) return val;
  if (pref !== "string" && isCallable$D(fn = input.toString) && !isObject$N(val = call$1h(fn, input))) return val;
  throw new $TypeError$L("Can't convert object to primitive value");
};
var sharedStore = { exports: {} };
var isPure = false;
var globalThis$1g = globalThis_1;
var defineProperty$i = Object.defineProperty;
var defineGlobalProperty$3 = function(key, value) {
  try {
    defineProperty$i(globalThis$1g, key, {
      value,
      configurable: true,
      writable: true
    });
  } catch (error3) {
    globalThis$1g[key] = value;
  }
  return value;
};
var globalThis$1f = globalThis_1;
var defineGlobalProperty$2 = defineGlobalProperty$3;
var SHARED = "__core-js_shared__";
var store$5 = sharedStore.exports = globalThis$1f[SHARED] || defineGlobalProperty$2(SHARED, {});
(store$5.versions || (store$5.versions = [])).push({
  version: "3.41.0",
  mode: "global",
  copyright: " 2014-2025 Denis Pushkarev (zloirock.ru)",
  license: "https://github.com/zloirock/core-js/blob/v3.41.0/LICENSE",
  source: "https://github.com/zloirock/core-js"
});
var sharedStoreExports = sharedStore.exports;
var store$4 = sharedStoreExports;
var shared$a = function(key, value) {
  return store$4[key] || (store$4[key] = value || {});
};
var requireObjectCoercible$o = requireObjectCoercible$q;
var $Object$6 = Object;
var toObject$E = function(argument) {
  return $Object$6(requireObjectCoercible$o(argument));
};
var uncurryThis$1U = functionUncurryThis;
var toObject$D = toObject$E;
var hasOwnProperty = uncurryThis$1U({}.hasOwnProperty);
var hasOwnProperty_1 = Object.hasOwn || function hasOwn(it, key) {
  return hasOwnProperty(toObject$D(it), key);
};
var uncurryThis$1T = functionUncurryThis;
var id$2 = 0;
var postfix = Math.random();
var toString$K = uncurryThis$1T(1 .toString);
var uid$7 = function(key) {
  return "Symbol(" + (key === void 0 ? "" : key) + ")_" + toString$K(++id$2 + postfix, 36);
};
var globalThis$1e = globalThis_1;
var shared$9 = shared$a;
var hasOwn$G = hasOwnProperty_1;
var uid$6 = uid$7;
var NATIVE_SYMBOL$6 = symbolConstructorDetection;
var USE_SYMBOL_AS_UID = useSymbolAsUid;
var Symbol$7 = globalThis$1e.Symbol;
var WellKnownSymbolsStore$2 = shared$9("wks");
var createWellKnownSymbol = USE_SYMBOL_AS_UID ? Symbol$7["for"] || Symbol$7 : Symbol$7 && Symbol$7.withoutSetter || uid$6;
var wellKnownSymbol$S = function(name) {
  if (!hasOwn$G(WellKnownSymbolsStore$2, name)) {
    WellKnownSymbolsStore$2[name] = NATIVE_SYMBOL$6 && hasOwn$G(Symbol$7, name) ? Symbol$7[name] : createWellKnownSymbol("Symbol." + name);
  }
  return WellKnownSymbolsStore$2[name];
};
var call$1g = functionCall;
var isObject$M = isObject$O;
var isSymbol$7 = isSymbol$8;
var getMethod$k = getMethod$l;
var ordinaryToPrimitive$1 = ordinaryToPrimitive$2;
var wellKnownSymbol$R = wellKnownSymbol$S;
var $TypeError$K = TypeError;
var TO_PRIMITIVE$1 = wellKnownSymbol$R("toPrimitive");
var toPrimitive$4 = function(input, pref) {
  if (!isObject$M(input) || isSymbol$7(input)) return input;
  var exoticToPrim = getMethod$k(input, TO_PRIMITIVE$1);
  var result;
  if (exoticToPrim) {
    if (pref === void 0) pref = "default";
    result = call$1g(exoticToPrim, input, pref);
    if (!isObject$M(result) || isSymbol$7(result)) return result;
    throw new $TypeError$K("Can't convert object to primitive value");
  }
  if (pref === void 0) pref = "number";
  return ordinaryToPrimitive$1(input, pref);
};
var toPrimitive$3 = toPrimitive$4;
var isSymbol$6 = isSymbol$8;
var toPropertyKey$9 = function(argument) {
  var key = toPrimitive$3(argument, "string");
  return isSymbol$6(key) ? key : key + "";
};
var globalThis$1d = globalThis_1;
var isObject$L = isObject$O;
var document$3 = globalThis$1d.document;
var EXISTS$1 = isObject$L(document$3) && isObject$L(document$3.createElement);
var documentCreateElement$2 = function(it) {
  return EXISTS$1 ? document$3.createElement(it) : {};
};
var DESCRIPTORS$W = descriptors;
var fails$1u = fails$1z;
var createElement$1 = documentCreateElement$2;
var ie8DomDefine = !DESCRIPTORS$W && !fails$1u(function() {
  return Object.defineProperty(createElement$1("div"), "a", {
    get: function() {
      return 7;
    }
  }).a !== 7;
});
var DESCRIPTORS$V = descriptors;
var call$1f = functionCall;
var propertyIsEnumerableModule$2 = objectPropertyIsEnumerable;
var createPropertyDescriptor$c = createPropertyDescriptor$d;
var toIndexedObject$j = toIndexedObject$k;
var toPropertyKey$8 = toPropertyKey$9;
var hasOwn$F = hasOwnProperty_1;
var IE8_DOM_DEFINE$1 = ie8DomDefine;
var $getOwnPropertyDescriptor$2 = Object.getOwnPropertyDescriptor;
objectGetOwnPropertyDescriptor.f = DESCRIPTORS$V ? $getOwnPropertyDescriptor$2 : function getOwnPropertyDescriptor(O, P) {
  O = toIndexedObject$j(O);
  P = toPropertyKey$8(P);
  if (IE8_DOM_DEFINE$1) try {
    return $getOwnPropertyDescriptor$2(O, P);
  } catch (error3) {
  }
  if (hasOwn$F(O, P)) return createPropertyDescriptor$c(!call$1f(propertyIsEnumerableModule$2.f, O, P), O[P]);
};
var objectDefineProperty = {};
var DESCRIPTORS$U = descriptors;
var fails$1t = fails$1z;
var v8PrototypeDefineBug = DESCRIPTORS$U && fails$1t(function() {
  return Object.defineProperty(function() {
  }, "prototype", {
    value: 42,
    writable: false
  }).prototype !== 42;
});
var isObject$K = isObject$O;
var $String$8 = String;
var $TypeError$J = TypeError;
var anObject$1i = function(argument) {
  if (isObject$K(argument)) return argument;
  throw new $TypeError$J($String$8(argument) + " is not an object");
};
var DESCRIPTORS$T = descriptors;
var IE8_DOM_DEFINE = ie8DomDefine;
var V8_PROTOTYPE_DEFINE_BUG$1 = v8PrototypeDefineBug;
var anObject$1h = anObject$1i;
var toPropertyKey$7 = toPropertyKey$9;
var $TypeError$I = TypeError;
var $defineProperty$1 = Object.defineProperty;
var $getOwnPropertyDescriptor$1 = Object.getOwnPropertyDescriptor;
var ENUMERABLE = "enumerable";
var CONFIGURABLE$1 = "configurable";
var WRITABLE = "writable";
objectDefineProperty.f = DESCRIPTORS$T ? V8_PROTOTYPE_DEFINE_BUG$1 ? function defineProperty(O, P, Attributes) {
  anObject$1h(O);
  P = toPropertyKey$7(P);
  anObject$1h(Attributes);
  if (typeof O === "function" && P === "prototype" && "value" in Attributes && WRITABLE in Attributes && !Attributes[WRITABLE]) {
    var current = $getOwnPropertyDescriptor$1(O, P);
    if (current && current[WRITABLE]) {
      O[P] = Attributes.value;
      Attributes = {
        configurable: CONFIGURABLE$1 in Attributes ? Attributes[CONFIGURABLE$1] : current[CONFIGURABLE$1],
        enumerable: ENUMERABLE in Attributes ? Attributes[ENUMERABLE] : current[ENUMERABLE],
        writable: false
      };
    }
  }
  return $defineProperty$1(O, P, Attributes);
} : $defineProperty$1 : function defineProperty2(O, P, Attributes) {
  anObject$1h(O);
  P = toPropertyKey$7(P);
  anObject$1h(Attributes);
  if (IE8_DOM_DEFINE) try {
    return $defineProperty$1(O, P, Attributes);
  } catch (error3) {
  }
  if ("get" in Attributes || "set" in Attributes) throw new $TypeError$I("Accessors not supported");
  if ("value" in Attributes) O[P] = Attributes.value;
  return O;
};
var DESCRIPTORS$S = descriptors;
var definePropertyModule$b = objectDefineProperty;
var createPropertyDescriptor$b = createPropertyDescriptor$d;
var createNonEnumerableProperty$j = DESCRIPTORS$S ? function(object, key, value) {
  return definePropertyModule$b.f(object, key, createPropertyDescriptor$b(1, value));
} : function(object, key, value) {
  object[key] = value;
  return object;
};
var makeBuiltIn$5 = { exports: {} };
var DESCRIPTORS$R = descriptors;
var hasOwn$E = hasOwnProperty_1;
var FunctionPrototype$4 = Function.prototype;
var getDescriptor = DESCRIPTORS$R && Object.getOwnPropertyDescriptor;
var EXISTS = hasOwn$E(FunctionPrototype$4, "name");
var PROPER = EXISTS && (function something() {
}).name === "something";
var CONFIGURABLE = EXISTS && (!DESCRIPTORS$R || DESCRIPTORS$R && getDescriptor(FunctionPrototype$4, "name").configurable);
var functionName = {
  EXISTS,
  PROPER,
  CONFIGURABLE
};
var uncurryThis$1S = functionUncurryThis;
var isCallable$C = isCallable$I;
var store$3 = sharedStoreExports;
var functionToString$1 = uncurryThis$1S(Function.toString);
if (!isCallable$C(store$3.inspectSource)) {
  store$3.inspectSource = function(it) {
    return functionToString$1(it);
  };
}
var inspectSource$4 = store$3.inspectSource;
var globalThis$1c = globalThis_1;
var isCallable$B = isCallable$I;
var WeakMap$4 = globalThis$1c.WeakMap;
var weakMapBasicDetection = isCallable$B(WeakMap$4) && /native code/.test(String(WeakMap$4));
var shared$8 = shared$a;
var uid$5 = uid$7;
var keys$2 = shared$8("keys");
var sharedKey$4 = function(key) {
  return keys$2[key] || (keys$2[key] = uid$5(key));
};
var hiddenKeys$6 = {};
var NATIVE_WEAK_MAP$1 = weakMapBasicDetection;
var globalThis$1b = globalThis_1;
var isObject$J = isObject$O;
var createNonEnumerableProperty$i = createNonEnumerableProperty$j;
var hasOwn$D = hasOwnProperty_1;
var shared$7 = sharedStoreExports;
var sharedKey$3 = sharedKey$4;
var hiddenKeys$5 = hiddenKeys$6;
var OBJECT_ALREADY_INITIALIZED = "Object already initialized";
var TypeError$a = globalThis$1b.TypeError;
var WeakMap$3 = globalThis$1b.WeakMap;
var set$f, get$a, has$i;
var enforce = function(it) {
  return has$i(it) ? get$a(it) : set$f(it, {});
};
var getterFor$2 = function(TYPE) {
  return function(it) {
    var state;
    if (!isObject$J(it) || (state = get$a(it)).type !== TYPE) {
      throw new TypeError$a("Incompatible receiver, " + TYPE + " required");
    }
    return state;
  };
};
if (NATIVE_WEAK_MAP$1 || shared$7.state) {
  var store$2 = shared$7.state || (shared$7.state = new WeakMap$3());
  store$2.get = store$2.get;
  store$2.has = store$2.has;
  store$2.set = store$2.set;
  set$f = function(it, metadata3) {
    if (store$2.has(it)) throw new TypeError$a(OBJECT_ALREADY_INITIALIZED);
    metadata3.facade = it;
    store$2.set(it, metadata3);
    return metadata3;
  };
  get$a = function(it) {
    return store$2.get(it) || {};
  };
  has$i = function(it) {
    return store$2.has(it);
  };
} else {
  var STATE = sharedKey$3("state");
  hiddenKeys$5[STATE] = true;
  set$f = function(it, metadata3) {
    if (hasOwn$D(it, STATE)) throw new TypeError$a(OBJECT_ALREADY_INITIALIZED);
    metadata3.facade = it;
    createNonEnumerableProperty$i(it, STATE, metadata3);
    return metadata3;
  };
  get$a = function(it) {
    return hasOwn$D(it, STATE) ? it[STATE] : {};
  };
  has$i = function(it) {
    return hasOwn$D(it, STATE);
  };
}
var internalState = {
  set: set$f,
  get: get$a,
  has: has$i,
  enforce,
  getterFor: getterFor$2
};
var uncurryThis$1R = functionUncurryThis;
var fails$1s = fails$1z;
var isCallable$A = isCallable$I;
var hasOwn$C = hasOwnProperty_1;
var DESCRIPTORS$Q = descriptors;
var CONFIGURABLE_FUNCTION_NAME$2 = functionName.CONFIGURABLE;
var inspectSource$3 = inspectSource$4;
var InternalStateModule$n = internalState;
var enforceInternalState$4 = InternalStateModule$n.enforce;
var getInternalState$g = InternalStateModule$n.get;
var $String$7 = String;
var defineProperty$h = Object.defineProperty;
var stringSlice$l = uncurryThis$1R("".slice);
var replace$c = uncurryThis$1R("".replace);
var join$a = uncurryThis$1R([].join);
var CONFIGURABLE_LENGTH = DESCRIPTORS$Q && !fails$1s(function() {
  return defineProperty$h(function() {
  }, "length", {
    value: 8
  }).length !== 8;
});
var TEMPLATE = String(String).split("String");
var makeBuiltIn$4 = makeBuiltIn$5.exports = function(value, name, options) {
  if (stringSlice$l($String$7(name), 0, 7) === "Symbol(") {
    name = "[" + replace$c($String$7(name), /^Symbol\(([^)]*)\).*$/, "$1") + "]";
  }
  if (options && options.getter) name = "get " + name;
  if (options && options.setter) name = "set " + name;
  if (!hasOwn$C(value, "name") || CONFIGURABLE_FUNCTION_NAME$2 && value.name !== name) {
    if (DESCRIPTORS$Q) defineProperty$h(value, "name", {
      value: name,
      configurable: true
    });
    else value.name = name;
  }
  if (CONFIGURABLE_LENGTH && options && hasOwn$C(options, "arity") && value.length !== options.arity) {
    defineProperty$h(value, "length", {
      value: options.arity
    });
  }
  try {
    if (options && hasOwn$C(options, "constructor") && options.constructor) {
      if (DESCRIPTORS$Q) defineProperty$h(value, "prototype", {
        writable: false
      });
    } else if (value.prototype) value.prototype = void 0;
  } catch (error3) {
  }
  var state = enforceInternalState$4(value);
  if (!hasOwn$C(state, "source")) {
    state.source = join$a(TEMPLATE, typeof name == "string" ? name : "");
  }
  return value;
};
Function.prototype.toString = makeBuiltIn$4(function toString() {
  return isCallable$A(this) && getInternalState$g(this).source || inspectSource$3(this);
}, "toString");
var makeBuiltInExports = makeBuiltIn$5.exports;
var isCallable$z = isCallable$I;
var definePropertyModule$a = objectDefineProperty;
var makeBuiltIn$3 = makeBuiltInExports;
var defineGlobalProperty$1 = defineGlobalProperty$3;
var defineBuiltIn$u = function(O, key, value, options) {
  if (!options) options = {};
  var simple = options.enumerable;
  var name = options.name !== void 0 ? options.name : key;
  if (isCallable$z(value)) makeBuiltIn$3(value, name, options);
  if (options.global) {
    if (simple) O[key] = value;
    else defineGlobalProperty$1(key, value);
  } else {
    try {
      if (!options.unsafe) delete O[key];
      else if (O[key]) simple = true;
    } catch (error3) {
    }
    if (simple) O[key] = value;
    else definePropertyModule$a.f(O, key, {
      value,
      enumerable: false,
      configurable: !options.nonConfigurable,
      writable: !options.nonWritable
    });
  }
  return O;
};
var objectGetOwnPropertyNames = {};
var ceil$1 = Math.ceil;
var floor$a = Math.floor;
var mathTrunc = Math.trunc || function trunc(x) {
  var n = +x;
  return (n > 0 ? floor$a : ceil$1)(n);
};
var trunc$1 = mathTrunc;
var toIntegerOrInfinity$p = function(argument) {
  var number = +argument;
  return number !== number || number === 0 ? 0 : trunc$1(number);
};
var toIntegerOrInfinity$o = toIntegerOrInfinity$p;
var max$8 = Math.max;
var min$e = Math.min;
var toAbsoluteIndex$a = function(index, length) {
  var integer = toIntegerOrInfinity$o(index);
  return integer < 0 ? max$8(integer + length, 0) : min$e(integer, length);
};
var toIntegerOrInfinity$n = toIntegerOrInfinity$p;
var min$d = Math.min;
var toLength$d = function(argument) {
  var len = toIntegerOrInfinity$n(argument);
  return len > 0 ? min$d(len, 9007199254740991) : 0;
};
var toLength$c = toLength$d;
var lengthOfArrayLike$B = function(obj) {
  return toLength$c(obj.length);
};
var toIndexedObject$i = toIndexedObject$k;
var toAbsoluteIndex$9 = toAbsoluteIndex$a;
var lengthOfArrayLike$A = lengthOfArrayLike$B;
var createMethod$8 = function(IS_INCLUDES) {
  return function($this, el, fromIndex) {
    var O = toIndexedObject$i($this);
    var length = lengthOfArrayLike$A(O);
    if (length === 0) return !IS_INCLUDES && -1;
    var index = toAbsoluteIndex$9(fromIndex, length);
    var value;
    if (IS_INCLUDES && el !== el) while (length > index) {
      value = O[index++];
      if (value !== value) return true;
    }
    else for (; length > index; index++) {
      if ((IS_INCLUDES || index in O) && O[index] === el) return IS_INCLUDES || index || 0;
    }
    return !IS_INCLUDES && -1;
  };
};
var arrayIncludes = {
  // `Array.prototype.includes` method
  // https://tc39.es/ecma262/#sec-array.prototype.includes
  includes: createMethod$8(true),
  // `Array.prototype.indexOf` method
  // https://tc39.es/ecma262/#sec-array.prototype.indexof
  indexOf: createMethod$8(false)
};
var uncurryThis$1Q = functionUncurryThis;
var hasOwn$B = hasOwnProperty_1;
var toIndexedObject$h = toIndexedObject$k;
var indexOf$2 = arrayIncludes.indexOf;
var hiddenKeys$4 = hiddenKeys$6;
var push$s = uncurryThis$1Q([].push);
var objectKeysInternal = function(object, names) {
  var O = toIndexedObject$h(object);
  var i = 0;
  var result = [];
  var key;
  for (key in O) !hasOwn$B(hiddenKeys$4, key) && hasOwn$B(O, key) && push$s(result, key);
  while (names.length > i) if (hasOwn$B(O, key = names[i++])) {
    ~indexOf$2(result, key) || push$s(result, key);
  }
  return result;
};
var enumBugKeys$3 = ["constructor", "hasOwnProperty", "isPrototypeOf", "propertyIsEnumerable", "toLocaleString", "toString", "valueOf"];
var internalObjectKeys$1 = objectKeysInternal;
var enumBugKeys$2 = enumBugKeys$3;
var hiddenKeys$3 = enumBugKeys$2.concat("length", "prototype");
objectGetOwnPropertyNames.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
  return internalObjectKeys$1(O, hiddenKeys$3);
};
var objectGetOwnPropertySymbols = {};
objectGetOwnPropertySymbols.f = Object.getOwnPropertySymbols;
var getBuiltIn$O = getBuiltIn$Q;
var uncurryThis$1P = functionUncurryThis;
var getOwnPropertyNamesModule$2 = objectGetOwnPropertyNames;
var getOwnPropertySymbolsModule$3 = objectGetOwnPropertySymbols;
var anObject$1g = anObject$1i;
var concat$4 = uncurryThis$1P([].concat);
var ownKeys$3 = getBuiltIn$O("Reflect", "ownKeys") || function ownKeys(it) {
  var keys6 = getOwnPropertyNamesModule$2.f(anObject$1g(it));
  var getOwnPropertySymbols2 = getOwnPropertySymbolsModule$3.f;
  return getOwnPropertySymbols2 ? concat$4(keys6, getOwnPropertySymbols2(it)) : keys6;
};
var hasOwn$A = hasOwnProperty_1;
var ownKeys$2 = ownKeys$3;
var getOwnPropertyDescriptorModule$6 = objectGetOwnPropertyDescriptor;
var definePropertyModule$9 = objectDefineProperty;
var copyConstructorProperties$7 = function(target, source, exceptions) {
  var keys6 = ownKeys$2(source);
  var defineProperty7 = definePropertyModule$9.f;
  var getOwnPropertyDescriptor7 = getOwnPropertyDescriptorModule$6.f;
  for (var i = 0; i < keys6.length; i++) {
    var key = keys6[i];
    if (!hasOwn$A(target, key) && !(exceptions && hasOwn$A(exceptions, key))) {
      defineProperty7(target, key, getOwnPropertyDescriptor7(source, key));
    }
  }
};
var fails$1r = fails$1z;
var isCallable$y = isCallable$I;
var replacement = /#|\.prototype\./;
var isForced$5 = function(feature, detection) {
  var value = data[normalize$1(feature)];
  return value === POLYFILL ? true : value === NATIVE ? false : isCallable$y(detection) ? fails$1r(detection) : !!detection;
};
var normalize$1 = isForced$5.normalize = function(string) {
  return String(string).replace(replacement, ".").toLowerCase();
};
var data = isForced$5.data = {};
var NATIVE = isForced$5.NATIVE = "N";
var POLYFILL = isForced$5.POLYFILL = "P";
var isForced_1 = isForced$5;
var globalThis$1a = globalThis_1;
var getOwnPropertyDescriptor$c = objectGetOwnPropertyDescriptor.f;
var createNonEnumerableProperty$h = createNonEnumerableProperty$j;
var defineBuiltIn$t = defineBuiltIn$u;
var defineGlobalProperty = defineGlobalProperty$3;
var copyConstructorProperties$6 = copyConstructorProperties$7;
var isForced$4 = isForced_1;
var _export = function(options, source) {
  var TARGET = options.target;
  var GLOBAL = options.global;
  var STATIC = options.stat;
  var FORCED2, target, key, targetProperty, sourceProperty, descriptor;
  if (GLOBAL) {
    target = globalThis$1a;
  } else if (STATIC) {
    target = globalThis$1a[TARGET] || defineGlobalProperty(TARGET, {});
  } else {
    target = globalThis$1a[TARGET] && globalThis$1a[TARGET].prototype;
  }
  if (target) for (key in source) {
    sourceProperty = source[key];
    if (options.dontCallGetSet) {
      descriptor = getOwnPropertyDescriptor$c(target, key);
      targetProperty = descriptor && descriptor.value;
    } else targetProperty = target[key];
    FORCED2 = isForced$4(GLOBAL ? key : TARGET + (STATIC ? "." : "#") + key, options.forced);
    if (!FORCED2 && targetProperty !== void 0) {
      if (typeof sourceProperty == typeof targetProperty) continue;
      copyConstructorProperties$6(sourceProperty, targetProperty);
    }
    if (options.sham || targetProperty && targetProperty.sham) {
      createNonEnumerableProperty$h(sourceProperty, "sham", true);
    }
    defineBuiltIn$t(target, key, sourceProperty, options);
  }
};
var wellKnownSymbol$Q = wellKnownSymbol$S;
var TO_STRING_TAG$b = wellKnownSymbol$Q("toStringTag");
var test$2 = {};
test$2[TO_STRING_TAG$b] = "z";
var toStringTagSupport = String(test$2) === "[object z]";
var TO_STRING_TAG_SUPPORT$2 = toStringTagSupport;
var isCallable$x = isCallable$I;
var classofRaw$1 = classofRaw$2;
var wellKnownSymbol$P = wellKnownSymbol$S;
var TO_STRING_TAG$a = wellKnownSymbol$P("toStringTag");
var $Object$5 = Object;
var CORRECT_ARGUMENTS = classofRaw$1(/* @__PURE__ */ function() {
  return arguments;
}()) === "Arguments";
var tryGet = function(it, key) {
  try {
    return it[key];
  } catch (error3) {
  }
};
var classof$q = TO_STRING_TAG_SUPPORT$2 ? classofRaw$1 : function(it) {
  var O, tag, result;
  return it === void 0 ? "Undefined" : it === null ? "Null" : typeof (tag = tryGet(O = $Object$5(it), TO_STRING_TAG$a)) == "string" ? tag : CORRECT_ARGUMENTS ? classofRaw$1(O) : (result = classofRaw$1(O)) === "Object" && isCallable$x(O.callee) ? "Arguments" : result;
};
var classof$p = classof$q;
var $String$6 = String;
var toString$J = function(argument) {
  if (classof$p(argument) === "Symbol") throw new TypeError("Cannot convert a Symbol value to a string");
  return $String$6(argument);
};
var objectDefineProperties = {};
var internalObjectKeys = objectKeysInternal;
var enumBugKeys$1 = enumBugKeys$3;
var objectKeys$6 = Object.keys || function keys(O) {
  return internalObjectKeys(O, enumBugKeys$1);
};
var DESCRIPTORS$P = descriptors;
var V8_PROTOTYPE_DEFINE_BUG = v8PrototypeDefineBug;
var definePropertyModule$8 = objectDefineProperty;
var anObject$1f = anObject$1i;
var toIndexedObject$g = toIndexedObject$k;
var objectKeys$5 = objectKeys$6;
objectDefineProperties.f = DESCRIPTORS$P && !V8_PROTOTYPE_DEFINE_BUG ? Object.defineProperties : function defineProperties(O, Properties) {
  anObject$1f(O);
  var props = toIndexedObject$g(Properties);
  var keys6 = objectKeys$5(Properties);
  var length = keys6.length;
  var index = 0;
  var key;
  while (length > index) definePropertyModule$8.f(O, key = keys6[index++], props[key]);
  return O;
};
var getBuiltIn$N = getBuiltIn$Q;
var html$3 = getBuiltIn$N("document", "documentElement");
var anObject$1e = anObject$1i;
var definePropertiesModule$1 = objectDefineProperties;
var enumBugKeys = enumBugKeys$3;
var hiddenKeys$2 = hiddenKeys$6;
var html$2 = html$3;
var documentCreateElement$1 = documentCreateElement$2;
var sharedKey$2 = sharedKey$4;
var GT = ">";
var LT = "<";
var PROTOTYPE$2 = "prototype";
var SCRIPT = "script";
var IE_PROTO$1 = sharedKey$2("IE_PROTO");
var EmptyConstructor = function() {
};
var scriptTag = function(content) {
  return LT + SCRIPT + GT + content + LT + "/" + SCRIPT + GT;
};
var NullProtoObjectViaActiveX = function(activeXDocument2) {
  activeXDocument2.write(scriptTag(""));
  activeXDocument2.close();
  var temp = activeXDocument2.parentWindow.Object;
  activeXDocument2 = null;
  return temp;
};
var NullProtoObjectViaIFrame = function() {
  var iframe = documentCreateElement$1("iframe");
  var JS = "java" + SCRIPT + ":";
  var iframeDocument;
  iframe.style.display = "none";
  html$2.appendChild(iframe);
  iframe.src = String(JS);
  iframeDocument = iframe.contentWindow.document;
  iframeDocument.open();
  iframeDocument.write(scriptTag("document.F=Object"));
  iframeDocument.close();
  return iframeDocument.F;
};
var activeXDocument;
var NullProtoObject = function() {
  try {
    activeXDocument = new ActiveXObject("htmlfile");
  } catch (error3) {
  }
  NullProtoObject = typeof document != "undefined" ? document.domain && activeXDocument ? NullProtoObjectViaActiveX(activeXDocument) : NullProtoObjectViaIFrame() : NullProtoObjectViaActiveX(activeXDocument);
  var length = enumBugKeys.length;
  while (length--) delete NullProtoObject[PROTOTYPE$2][enumBugKeys[length]];
  return NullProtoObject();
};
hiddenKeys$2[IE_PROTO$1] = true;
var objectCreate$1 = Object.create || function create(O, Properties) {
  var result;
  if (O !== null) {
    EmptyConstructor[PROTOTYPE$2] = anObject$1e(O);
    result = new EmptyConstructor();
    EmptyConstructor[PROTOTYPE$2] = null;
    result[IE_PROTO$1] = O;
  } else result = NullProtoObject();
  return Properties === void 0 ? result : definePropertiesModule$1.f(result, Properties);
};
var objectGetOwnPropertyNamesExternal = {};
var uncurryThis$1O = functionUncurryThis;
var arraySlice$a = uncurryThis$1O([].slice);
var classof$o = classofRaw$2;
var toIndexedObject$f = toIndexedObject$k;
var $getOwnPropertyNames$1 = objectGetOwnPropertyNames.f;
var arraySlice$9 = arraySlice$a;
var windowNames = typeof window == "object" && window && Object.getOwnPropertyNames ? Object.getOwnPropertyNames(window) : [];
var getWindowNames = function(it) {
  try {
    return $getOwnPropertyNames$1(it);
  } catch (error3) {
    return arraySlice$9(windowNames);
  }
};
objectGetOwnPropertyNamesExternal.f = function getOwnPropertyNames2(it) {
  return windowNames && classof$o(it) === "Window" ? getWindowNames(it) : $getOwnPropertyNames$1(toIndexedObject$f(it));
};
var makeBuiltIn$2 = makeBuiltInExports;
var defineProperty$g = objectDefineProperty;
var defineBuiltInAccessor$p = function(target, name, descriptor) {
  if (descriptor.get) makeBuiltIn$2(descriptor.get, name, {
    getter: true
  });
  if (descriptor.set) makeBuiltIn$2(descriptor.set, name, {
    setter: true
  });
  return defineProperty$g.f(target, name, descriptor);
};
var wellKnownSymbolWrapped = {};
var wellKnownSymbol$O = wellKnownSymbol$S;
wellKnownSymbolWrapped.f = wellKnownSymbol$O;
var globalThis$19 = globalThis_1;
var path$2 = globalThis$19;
var path$1 = path$2;
var hasOwn$z = hasOwnProperty_1;
var wrappedWellKnownSymbolModule$1 = wellKnownSymbolWrapped;
var defineProperty$f = objectDefineProperty.f;
var wellKnownSymbolDefine = function(NAME2) {
  var Symbol2 = path$1.Symbol || (path$1.Symbol = {});
  if (!hasOwn$z(Symbol2, NAME2)) defineProperty$f(Symbol2, NAME2, {
    value: wrappedWellKnownSymbolModule$1.f(NAME2)
  });
};
var call$1e = functionCall;
var getBuiltIn$M = getBuiltIn$Q;
var wellKnownSymbol$N = wellKnownSymbol$S;
var defineBuiltIn$s = defineBuiltIn$u;
var symbolDefineToPrimitive = function() {
  var Symbol2 = getBuiltIn$M("Symbol");
  var SymbolPrototype2 = Symbol2 && Symbol2.prototype;
  var valueOf = SymbolPrototype2 && SymbolPrototype2.valueOf;
  var TO_PRIMITIVE2 = wellKnownSymbol$N("toPrimitive");
  if (SymbolPrototype2 && !SymbolPrototype2[TO_PRIMITIVE2]) {
    defineBuiltIn$s(SymbolPrototype2, TO_PRIMITIVE2, function(hint) {
      return call$1e(valueOf, this);
    }, {
      arity: 1
    });
  }
};
var defineProperty$e = objectDefineProperty.f;
var hasOwn$y = hasOwnProperty_1;
var wellKnownSymbol$M = wellKnownSymbol$S;
var TO_STRING_TAG$9 = wellKnownSymbol$M("toStringTag");
var setToStringTag$e = function(target, TAG, STATIC) {
  if (target && !STATIC) target = target.prototype;
  if (target && !hasOwn$y(target, TO_STRING_TAG$9)) {
    defineProperty$e(target, TO_STRING_TAG$9, {
      configurable: true,
      value: TAG
    });
  }
};
var classofRaw = classofRaw$2;
var uncurryThis$1N = functionUncurryThis;
var functionUncurryThisClause = function(fn) {
  if (classofRaw(fn) === "Function") return uncurryThis$1N(fn);
};
var uncurryThis$1M = functionUncurryThisClause;
var aCallable$O = aCallable$Q;
var NATIVE_BIND$2 = functionBindNative;
var bind$v = uncurryThis$1M(uncurryThis$1M.bind);
var functionBindContext = function(fn, that) {
  aCallable$O(fn);
  return that === void 0 ? fn : NATIVE_BIND$2 ? bind$v(fn, that) : function() {
    return fn.apply(that, arguments);
  };
};
var classof$n = classofRaw$2;
var isArray$b = Array.isArray || function isArray(argument) {
  return classof$n(argument) === "Array";
};
var uncurryThis$1L = functionUncurryThis;
var fails$1q = fails$1z;
var isCallable$w = isCallable$I;
var classof$m = classof$q;
var getBuiltIn$L = getBuiltIn$Q;
var inspectSource$2 = inspectSource$4;
var noop$1 = function() {
};
var construct$1 = getBuiltIn$L("Reflect", "construct");
var constructorRegExp = /^\s*(?:class|function)\b/;
var exec$h = uncurryThis$1L(constructorRegExp.exec);
var INCORRECT_TO_STRING$2 = !constructorRegExp.test(noop$1);
var isConstructorModern = function isConstructor(argument) {
  if (!isCallable$w(argument)) return false;
  try {
    construct$1(noop$1, [], argument);
    return true;
  } catch (error3) {
    return false;
  }
};
var isConstructorLegacy = function isConstructor2(argument) {
  if (!isCallable$w(argument)) return false;
  switch (classof$m(argument)) {
    case "AsyncFunction":
    case "GeneratorFunction":
    case "AsyncGeneratorFunction":
      return false;
  }
  try {
    return INCORRECT_TO_STRING$2 || !!exec$h(constructorRegExp, inspectSource$2(argument));
  } catch (error3) {
    return true;
  }
};
isConstructorLegacy.sham = true;
var isConstructor$a = !construct$1 || fails$1q(function() {
  var called;
  return isConstructorModern(isConstructorModern.call) || !isConstructorModern(Object) || !isConstructorModern(function() {
    called = true;
  }) || called;
}) ? isConstructorLegacy : isConstructorModern;
var isArray$a = isArray$b;
var isConstructor$9 = isConstructor$a;
var isObject$I = isObject$O;
var wellKnownSymbol$L = wellKnownSymbol$S;
var SPECIES$6 = wellKnownSymbol$L("species");
var $Array$d = Array;
var arraySpeciesConstructor$1 = function(originalArray) {
  var C;
  if (isArray$a(originalArray)) {
    C = originalArray.constructor;
    if (isConstructor$9(C) && (C === $Array$d || isArray$a(C.prototype))) C = void 0;
    else if (isObject$I(C)) {
      C = C[SPECIES$6];
      if (C === null) C = void 0;
    }
  }
  return C === void 0 ? $Array$d : C;
};
var arraySpeciesConstructor = arraySpeciesConstructor$1;
var arraySpeciesCreate$5 = function(originalArray, length) {
  return new (arraySpeciesConstructor(originalArray))(length === 0 ? 0 : length);
};
var bind$u = functionBindContext;
var uncurryThis$1K = functionUncurryThis;
var IndexedObject$6 = indexedObject;
var toObject$C = toObject$E;
var lengthOfArrayLike$z = lengthOfArrayLike$B;
var arraySpeciesCreate$4 = arraySpeciesCreate$5;
var push$r = uncurryThis$1K([].push);
var createMethod$7 = function(TYPE) {
  var IS_MAP = TYPE === 1;
  var IS_FILTER = TYPE === 2;
  var IS_SOME = TYPE === 3;
  var IS_EVERY = TYPE === 4;
  var IS_FIND_INDEX = TYPE === 6;
  var IS_FILTER_REJECT = TYPE === 7;
  var NO_HOLES = TYPE === 5 || IS_FIND_INDEX;
  return function($this, callbackfn, that, specificCreate) {
    var O = toObject$C($this);
    var self2 = IndexedObject$6(O);
    var length = lengthOfArrayLike$z(self2);
    var boundFunction = bind$u(callbackfn, that);
    var index = 0;
    var create4 = specificCreate || arraySpeciesCreate$4;
    var target = IS_MAP ? create4($this, length) : IS_FILTER || IS_FILTER_REJECT ? create4($this, 0) : void 0;
    var value, result;
    for (; length > index; index++) if (NO_HOLES || index in self2) {
      value = self2[index];
      result = boundFunction(value, index, O);
      if (TYPE) {
        if (IS_MAP) target[index] = result;
        else if (result) switch (TYPE) {
          case 3:
            return true;
          case 5:
            return value;
          case 6:
            return index;
          case 2:
            push$r(target, value);
        }
        else switch (TYPE) {
          case 4:
            return false;
          case 7:
            push$r(target, value);
        }
      }
    }
    return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : target;
  };
};
var arrayIteration = {
  // `Array.prototype.forEach` method
  // https://tc39.es/ecma262/#sec-array.prototype.foreach
  forEach: createMethod$7(0),
  // `Array.prototype.map` method
  // https://tc39.es/ecma262/#sec-array.prototype.map
  map: createMethod$7(1),
  // `Array.prototype.filter` method
  // https://tc39.es/ecma262/#sec-array.prototype.filter
  filter: createMethod$7(2),
  // `Array.prototype.some` method
  // https://tc39.es/ecma262/#sec-array.prototype.some
  some: createMethod$7(3),
  // `Array.prototype.every` method
  // https://tc39.es/ecma262/#sec-array.prototype.every
  every: createMethod$7(4),
  // `Array.prototype.find` method
  // https://tc39.es/ecma262/#sec-array.prototype.find
  find: createMethod$7(5),
  // `Array.prototype.findIndex` method
  // https://tc39.es/ecma262/#sec-array.prototype.findIndex
  findIndex: createMethod$7(6),
  // `Array.prototype.filterReject` method
  // https://github.com/tc39/proposal-array-filtering
  filterReject: createMethod$7(7)
};
var $$5F = _export;
var globalThis$18 = globalThis_1;
var call$1d = functionCall;
var uncurryThis$1J = functionUncurryThis;
var DESCRIPTORS$O = descriptors;
var NATIVE_SYMBOL$5 = symbolConstructorDetection;
var fails$1p = fails$1z;
var hasOwn$x = hasOwnProperty_1;
var isPrototypeOf$e = objectIsPrototypeOf;
var anObject$1d = anObject$1i;
var toIndexedObject$e = toIndexedObject$k;
var toPropertyKey$6 = toPropertyKey$9;
var $toString$3 = toString$J;
var createPropertyDescriptor$a = createPropertyDescriptor$d;
var nativeObjectCreate = objectCreate$1;
var objectKeys$4 = objectKeys$6;
var getOwnPropertyNamesModule$1 = objectGetOwnPropertyNames;
var getOwnPropertyNamesExternal = objectGetOwnPropertyNamesExternal;
var getOwnPropertySymbolsModule$2 = objectGetOwnPropertySymbols;
var getOwnPropertyDescriptorModule$5 = objectGetOwnPropertyDescriptor;
var definePropertyModule$7 = objectDefineProperty;
var definePropertiesModule = objectDefineProperties;
var propertyIsEnumerableModule$1 = objectPropertyIsEnumerable;
var defineBuiltIn$r = defineBuiltIn$u;
var defineBuiltInAccessor$o = defineBuiltInAccessor$p;
var shared$6 = shared$a;
var sharedKey$1 = sharedKey$4;
var hiddenKeys$1 = hiddenKeys$6;
var uid$4 = uid$7;
var wellKnownSymbol$K = wellKnownSymbol$S;
var wrappedWellKnownSymbolModule = wellKnownSymbolWrapped;
var defineWellKnownSymbol$m = wellKnownSymbolDefine;
var defineSymbolToPrimitive$1 = symbolDefineToPrimitive;
var setToStringTag$d = setToStringTag$e;
var InternalStateModule$m = internalState;
var $forEach$3 = arrayIteration.forEach;
var HIDDEN = sharedKey$1("hidden");
var SYMBOL = "Symbol";
var PROTOTYPE$1 = "prototype";
var setInternalState$m = InternalStateModule$m.set;
var getInternalState$f = InternalStateModule$m.getterFor(SYMBOL);
var ObjectPrototype$5 = Object[PROTOTYPE$1];
var $Symbol = globalThis$18.Symbol;
var SymbolPrototype$1 = $Symbol && $Symbol[PROTOTYPE$1];
var RangeError$4 = globalThis$18.RangeError;
var TypeError$9 = globalThis$18.TypeError;
var QObject = globalThis$18.QObject;
var nativeGetOwnPropertyDescriptor$2 = getOwnPropertyDescriptorModule$5.f;
var nativeDefineProperty$1 = definePropertyModule$7.f;
var nativeGetOwnPropertyNames = getOwnPropertyNamesExternal.f;
var nativePropertyIsEnumerable = propertyIsEnumerableModule$1.f;
var push$q = uncurryThis$1J([].push);
var AllSymbols = shared$6("symbols");
var ObjectPrototypeSymbols = shared$6("op-symbols");
var WellKnownSymbolsStore$1 = shared$6("wks");
var USE_SETTER = !QObject || !QObject[PROTOTYPE$1] || !QObject[PROTOTYPE$1].findChild;
var fallbackDefineProperty = function(O, P, Attributes) {
  var ObjectPrototypeDescriptor = nativeGetOwnPropertyDescriptor$2(ObjectPrototype$5, P);
  if (ObjectPrototypeDescriptor) delete ObjectPrototype$5[P];
  nativeDefineProperty$1(O, P, Attributes);
  if (ObjectPrototypeDescriptor && O !== ObjectPrototype$5) {
    nativeDefineProperty$1(ObjectPrototype$5, P, ObjectPrototypeDescriptor);
  }
};
var setSymbolDescriptor = DESCRIPTORS$O && fails$1p(function() {
  return nativeObjectCreate(nativeDefineProperty$1({}, "a", {
    get: function() {
      return nativeDefineProperty$1(this, "a", {
        value: 7
      }).a;
    }
  })).a !== 7;
}) ? fallbackDefineProperty : nativeDefineProperty$1;
var wrap = function(tag, description) {
  var symbol = AllSymbols[tag] = nativeObjectCreate(SymbolPrototype$1);
  setInternalState$m(symbol, {
    type: SYMBOL,
    tag,
    description
  });
  if (!DESCRIPTORS$O) symbol.description = description;
  return symbol;
};
var $defineProperty = function defineProperty3(O, P, Attributes) {
  if (O === ObjectPrototype$5) $defineProperty(ObjectPrototypeSymbols, P, Attributes);
  anObject$1d(O);
  var key = toPropertyKey$6(P);
  anObject$1d(Attributes);
  if (hasOwn$x(AllSymbols, key)) {
    if (!Attributes.enumerable) {
      if (!hasOwn$x(O, HIDDEN)) nativeDefineProperty$1(O, HIDDEN, createPropertyDescriptor$a(1, nativeObjectCreate(null)));
      O[HIDDEN][key] = true;
    } else {
      if (hasOwn$x(O, HIDDEN) && O[HIDDEN][key]) O[HIDDEN][key] = false;
      Attributes = nativeObjectCreate(Attributes, {
        enumerable: createPropertyDescriptor$a(0, false)
      });
    }
    return setSymbolDescriptor(O, key, Attributes);
  }
  return nativeDefineProperty$1(O, key, Attributes);
};
var $defineProperties = function defineProperties2(O, Properties) {
  anObject$1d(O);
  var properties = toIndexedObject$e(Properties);
  var keys6 = objectKeys$4(properties).concat($getOwnPropertySymbols(properties));
  $forEach$3(keys6, function(key) {
    if (!DESCRIPTORS$O || call$1d($propertyIsEnumerable$1, properties, key)) $defineProperty(O, key, properties[key]);
  });
  return O;
};
var $create = function create2(O, Properties) {
  return Properties === void 0 ? nativeObjectCreate(O) : $defineProperties(nativeObjectCreate(O), Properties);
};
var $propertyIsEnumerable$1 = function propertyIsEnumerable2(V) {
  var P = toPropertyKey$6(V);
  var enumerable = call$1d(nativePropertyIsEnumerable, this, P);
  if (this === ObjectPrototype$5 && hasOwn$x(AllSymbols, P) && !hasOwn$x(ObjectPrototypeSymbols, P)) return false;
  return enumerable || !hasOwn$x(this, P) || !hasOwn$x(AllSymbols, P) || hasOwn$x(this, HIDDEN) && this[HIDDEN][P] ? enumerable : true;
};
var $getOwnPropertyDescriptor = function getOwnPropertyDescriptor2(O, P) {
  var it = toIndexedObject$e(O);
  var key = toPropertyKey$6(P);
  if (it === ObjectPrototype$5 && hasOwn$x(AllSymbols, key) && !hasOwn$x(ObjectPrototypeSymbols, key)) return;
  var descriptor = nativeGetOwnPropertyDescriptor$2(it, key);
  if (descriptor && hasOwn$x(AllSymbols, key) && !(hasOwn$x(it, HIDDEN) && it[HIDDEN][key])) {
    descriptor.enumerable = true;
  }
  return descriptor;
};
var $getOwnPropertyNames = function getOwnPropertyNames3(O) {
  var names = nativeGetOwnPropertyNames(toIndexedObject$e(O));
  var result = [];
  $forEach$3(names, function(key) {
    if (!hasOwn$x(AllSymbols, key) && !hasOwn$x(hiddenKeys$1, key)) push$q(result, key);
  });
  return result;
};
var $getOwnPropertySymbols = function(O) {
  var IS_OBJECT_PROTOTYPE = O === ObjectPrototype$5;
  var names = nativeGetOwnPropertyNames(IS_OBJECT_PROTOTYPE ? ObjectPrototypeSymbols : toIndexedObject$e(O));
  var result = [];
  $forEach$3(names, function(key) {
    if (hasOwn$x(AllSymbols, key) && (!IS_OBJECT_PROTOTYPE || hasOwn$x(ObjectPrototype$5, key))) {
      push$q(result, AllSymbols[key]);
    }
  });
  return result;
};
if (!NATIVE_SYMBOL$5) {
  $Symbol = function Symbol2() {
    if (isPrototypeOf$e(SymbolPrototype$1, this)) throw new TypeError$9("Symbol is not a constructor");
    var description = !arguments.length || arguments[0] === void 0 ? void 0 : $toString$3(arguments[0]);
    var tag = uid$4(description);
    var setter = function(value) {
      var $this = this === void 0 ? globalThis$18 : this;
      if ($this === ObjectPrototype$5) call$1d(setter, ObjectPrototypeSymbols, value);
      if (hasOwn$x($this, HIDDEN) && hasOwn$x($this[HIDDEN], tag)) $this[HIDDEN][tag] = false;
      var descriptor = createPropertyDescriptor$a(1, value);
      try {
        setSymbolDescriptor($this, tag, descriptor);
      } catch (error3) {
        if (!(error3 instanceof RangeError$4)) throw error3;
        fallbackDefineProperty($this, tag, descriptor);
      }
    };
    if (DESCRIPTORS$O && USE_SETTER) setSymbolDescriptor(ObjectPrototype$5, tag, {
      configurable: true,
      set: setter
    });
    return wrap(tag, description);
  };
  SymbolPrototype$1 = $Symbol[PROTOTYPE$1];
  defineBuiltIn$r(SymbolPrototype$1, "toString", function toString7() {
    return getInternalState$f(this).tag;
  });
  defineBuiltIn$r($Symbol, "withoutSetter", function(description) {
    return wrap(uid$4(description), description);
  });
  propertyIsEnumerableModule$1.f = $propertyIsEnumerable$1;
  definePropertyModule$7.f = $defineProperty;
  definePropertiesModule.f = $defineProperties;
  getOwnPropertyDescriptorModule$5.f = $getOwnPropertyDescriptor;
  getOwnPropertyNamesModule$1.f = getOwnPropertyNamesExternal.f = $getOwnPropertyNames;
  getOwnPropertySymbolsModule$2.f = $getOwnPropertySymbols;
  wrappedWellKnownSymbolModule.f = function(name) {
    return wrap(wellKnownSymbol$K(name), name);
  };
  if (DESCRIPTORS$O) {
    defineBuiltInAccessor$o(SymbolPrototype$1, "description", {
      configurable: true,
      get: function description() {
        return getInternalState$f(this).description;
      }
    });
    {
      defineBuiltIn$r(ObjectPrototype$5, "propertyIsEnumerable", $propertyIsEnumerable$1, {
        unsafe: true
      });
    }
  }
}
$$5F({
  global: true,
  constructor: true,
  wrap: true,
  forced: !NATIVE_SYMBOL$5,
  sham: !NATIVE_SYMBOL$5
}, {
  Symbol: $Symbol
});
$forEach$3(objectKeys$4(WellKnownSymbolsStore$1), function(name) {
  defineWellKnownSymbol$m(name);
});
$$5F({
  target: SYMBOL,
  stat: true,
  forced: !NATIVE_SYMBOL$5
}, {
  useSetter: function() {
    USE_SETTER = true;
  },
  useSimple: function() {
    USE_SETTER = false;
  }
});
$$5F({
  target: "Object",
  stat: true,
  forced: !NATIVE_SYMBOL$5,
  sham: !DESCRIPTORS$O
}, {
  // `Object.create` method
  // https://tc39.es/ecma262/#sec-object.create
  create: $create,
  // `Object.defineProperty` method
  // https://tc39.es/ecma262/#sec-object.defineproperty
  defineProperty: $defineProperty,
  // `Object.defineProperties` method
  // https://tc39.es/ecma262/#sec-object.defineproperties
  defineProperties: $defineProperties,
  // `Object.getOwnPropertyDescriptor` method
  // https://tc39.es/ecma262/#sec-object.getownpropertydescriptors
  getOwnPropertyDescriptor: $getOwnPropertyDescriptor
});
$$5F({
  target: "Object",
  stat: true,
  forced: !NATIVE_SYMBOL$5
}, {
  // `Object.getOwnPropertyNames` method
  // https://tc39.es/ecma262/#sec-object.getownpropertynames
  getOwnPropertyNames: $getOwnPropertyNames
});
defineSymbolToPrimitive$1();
setToStringTag$d($Symbol, SYMBOL);
hiddenKeys$1[HIDDEN] = true;
var NATIVE_SYMBOL$4 = symbolConstructorDetection;
var symbolRegistryDetection = NATIVE_SYMBOL$4 && !!Symbol["for"] && !!Symbol.keyFor;
var $$5E = _export;
var getBuiltIn$K = getBuiltIn$Q;
var hasOwn$w = hasOwnProperty_1;
var toString$I = toString$J;
var shared$5 = shared$a;
var NATIVE_SYMBOL_REGISTRY$1 = symbolRegistryDetection;
var StringToSymbolRegistry = shared$5("string-to-symbol-registry");
var SymbolToStringRegistry$1 = shared$5("symbol-to-string-registry");
$$5E({
  target: "Symbol",
  stat: true,
  forced: !NATIVE_SYMBOL_REGISTRY$1
}, {
  "for": function(key) {
    var string = toString$I(key);
    if (hasOwn$w(StringToSymbolRegistry, string)) return StringToSymbolRegistry[string];
    var symbol = getBuiltIn$K("Symbol")(string);
    StringToSymbolRegistry[string] = symbol;
    SymbolToStringRegistry$1[symbol] = string;
    return symbol;
  }
});
var $$5D = _export;
var hasOwn$v = hasOwnProperty_1;
var isSymbol$5 = isSymbol$8;
var tryToString$5 = tryToString$7;
var shared$4 = shared$a;
var NATIVE_SYMBOL_REGISTRY = symbolRegistryDetection;
var SymbolToStringRegistry = shared$4("symbol-to-string-registry");
$$5D({
  target: "Symbol",
  stat: true,
  forced: !NATIVE_SYMBOL_REGISTRY
}, {
  keyFor: function keyFor(sym) {
    if (!isSymbol$5(sym)) throw new TypeError(tryToString$5(sym) + " is not a symbol");
    if (hasOwn$v(SymbolToStringRegistry, sym)) return SymbolToStringRegistry[sym];
  }
});
var NATIVE_BIND$1 = functionBindNative;
var FunctionPrototype$3 = Function.prototype;
var apply$e = FunctionPrototype$3.apply;
var call$1c = FunctionPrototype$3.call;
var functionApply$1 = typeof Reflect == "object" && Reflect.apply || (NATIVE_BIND$1 ? call$1c.bind(apply$e) : function() {
  return call$1c.apply(apply$e, arguments);
});
var uncurryThis$1I = functionUncurryThis;
var isArray$9 = isArray$b;
var isCallable$v = isCallable$I;
var classof$l = classofRaw$2;
var toString$H = toString$J;
var push$p = uncurryThis$1I([].push);
var getJsonReplacerFunction = function(replacer2) {
  if (isCallable$v(replacer2)) return replacer2;
  if (!isArray$9(replacer2)) return;
  var rawLength = replacer2.length;
  var keys6 = [];
  for (var i = 0; i < rawLength; i++) {
    var element = replacer2[i];
    if (typeof element == "string") push$p(keys6, element);
    else if (typeof element == "number" || classof$l(element) === "Number" || classof$l(element) === "String") push$p(keys6, toString$H(element));
  }
  var keysLength = keys6.length;
  var root2 = true;
  return function(key, value) {
    if (root2) {
      root2 = false;
      return value;
    }
    if (isArray$9(this)) return value;
    for (var j = 0; j < keysLength; j++) if (keys6[j] === key) return value;
  };
};
var $$5C = _export;
var getBuiltIn$J = getBuiltIn$Q;
var apply$d = functionApply$1;
var call$1b = functionCall;
var uncurryThis$1H = functionUncurryThis;
var fails$1o = fails$1z;
var isCallable$u = isCallable$I;
var isSymbol$4 = isSymbol$8;
var arraySlice$8 = arraySlice$a;
var getReplacerFunction$1 = getJsonReplacerFunction;
var NATIVE_SYMBOL$3 = symbolConstructorDetection;
var $String$5 = String;
var $stringify$1 = getBuiltIn$J("JSON", "stringify");
var exec$g = uncurryThis$1H(/./.exec);
var charAt$m = uncurryThis$1H("".charAt);
var charCodeAt$9 = uncurryThis$1H("".charCodeAt);
var replace$b = uncurryThis$1H("".replace);
var numberToString$5 = uncurryThis$1H(1 .toString);
var tester = /[\uD800-\uDFFF]/g;
var low = /^[\uD800-\uDBFF]$/;
var hi = /^[\uDC00-\uDFFF]$/;
var WRONG_SYMBOLS_CONVERSION = !NATIVE_SYMBOL$3 || fails$1o(function() {
  var symbol = getBuiltIn$J("Symbol")("stringify detection");
  return $stringify$1([symbol]) !== "[null]" || $stringify$1({
    a: symbol
  }) !== "{}" || $stringify$1(Object(symbol)) !== "{}";
});
var ILL_FORMED_UNICODE = fails$1o(function() {
  return $stringify$1("\uDF06\uD834") !== '"\\udf06\\ud834"' || $stringify$1("\uDEAD") !== '"\\udead"';
});
var stringifyWithSymbolsFix = function(it, replacer2) {
  var args = arraySlice$8(arguments);
  var $replacer = getReplacerFunction$1(replacer2);
  if (!isCallable$u($replacer) && (it === void 0 || isSymbol$4(it))) return;
  args[1] = function(key, value) {
    if (isCallable$u($replacer)) value = call$1b($replacer, this, $String$5(key), value);
    if (!isSymbol$4(value)) return value;
  };
  return apply$d($stringify$1, null, args);
};
var fixIllFormed = function(match2, offset, string) {
  var prev = charAt$m(string, offset - 1);
  var next11 = charAt$m(string, offset + 1);
  if (exec$g(low, match2) && !exec$g(hi, next11) || exec$g(hi, match2) && !exec$g(low, prev)) {
    return "\\u" + numberToString$5(charCodeAt$9(match2, 0), 16);
  }
  return match2;
};
if ($stringify$1) {
  $$5C({
    target: "JSON",
    stat: true,
    arity: 3,
    forced: WRONG_SYMBOLS_CONVERSION || ILL_FORMED_UNICODE
  }, {
    // eslint-disable-next-line no-unused-vars -- required for `.length`
    stringify: function stringify2(it, replacer2, space) {
      var args = arraySlice$8(arguments);
      var result = apply$d(WRONG_SYMBOLS_CONVERSION ? stringifyWithSymbolsFix : $stringify$1, null, args);
      return ILL_FORMED_UNICODE && typeof result == "string" ? replace$b(result, tester, fixIllFormed) : result;
    }
  });
}
var $$5B = _export;
var NATIVE_SYMBOL$2 = symbolConstructorDetection;
var fails$1n = fails$1z;
var getOwnPropertySymbolsModule$1 = objectGetOwnPropertySymbols;
var toObject$B = toObject$E;
var FORCED$I = !NATIVE_SYMBOL$2 || fails$1n(function() {
  getOwnPropertySymbolsModule$1.f(1);
});
$$5B({
  target: "Object",
  stat: true,
  forced: FORCED$I
}, {
  getOwnPropertySymbols: function getOwnPropertySymbols(it) {
    var $getOwnPropertySymbols2 = getOwnPropertySymbolsModule$1.f;
    return $getOwnPropertySymbols2 ? $getOwnPropertySymbols2(toObject$B(it)) : [];
  }
});
var $$5A = _export;
var DESCRIPTORS$N = descriptors;
var globalThis$17 = globalThis_1;
var uncurryThis$1G = functionUncurryThis;
var hasOwn$u = hasOwnProperty_1;
var isCallable$t = isCallable$I;
var isPrototypeOf$d = objectIsPrototypeOf;
var toString$G = toString$J;
var defineBuiltInAccessor$n = defineBuiltInAccessor$p;
var copyConstructorProperties$5 = copyConstructorProperties$7;
var NativeSymbol = globalThis$17.Symbol;
var SymbolPrototype = NativeSymbol && NativeSymbol.prototype;
if (DESCRIPTORS$N && isCallable$t(NativeSymbol) && (!("description" in SymbolPrototype) || // Safari 12 bug
NativeSymbol().description !== void 0)) {
  var EmptyStringDescriptionStore = {};
  var SymbolWrapper = function Symbol2() {
    var description = arguments.length < 1 || arguments[0] === void 0 ? void 0 : toString$G(arguments[0]);
    var result = isPrototypeOf$d(SymbolPrototype, this) ? new NativeSymbol(description) : description === void 0 ? NativeSymbol() : NativeSymbol(description);
    if (description === "") EmptyStringDescriptionStore[result] = true;
    return result;
  };
  copyConstructorProperties$5(SymbolWrapper, NativeSymbol);
  SymbolWrapper.prototype = SymbolPrototype;
  SymbolPrototype.constructor = SymbolWrapper;
  var NATIVE_SYMBOL$1 = String(NativeSymbol("description detection")) === "Symbol(description detection)";
  var thisSymbolValue$2 = uncurryThis$1G(SymbolPrototype.valueOf);
  var symbolDescriptiveString = uncurryThis$1G(SymbolPrototype.toString);
  var regexp = /^Symbol\((.*)\)[^)]+$/;
  var replace$a = uncurryThis$1G("".replace);
  var stringSlice$k = uncurryThis$1G("".slice);
  defineBuiltInAccessor$n(SymbolPrototype, "description", {
    configurable: true,
    get: function description() {
      var symbol = thisSymbolValue$2(this);
      if (hasOwn$u(EmptyStringDescriptionStore, symbol)) return "";
      var string = symbolDescriptiveString(symbol);
      var desc = NATIVE_SYMBOL$1 ? stringSlice$k(string, 7, -1) : replace$a(string, regexp, "$1");
      return desc === "" ? void 0 : desc;
    }
  });
  $$5A({
    global: true,
    constructor: true,
    forced: true
  }, {
    Symbol: SymbolWrapper
  });
}
var defineWellKnownSymbol$l = wellKnownSymbolDefine;
defineWellKnownSymbol$l("asyncIterator");
var defineWellKnownSymbol$k = wellKnownSymbolDefine;
defineWellKnownSymbol$k("hasInstance");
var defineWellKnownSymbol$j = wellKnownSymbolDefine;
defineWellKnownSymbol$j("isConcatSpreadable");
var defineWellKnownSymbol$i = wellKnownSymbolDefine;
defineWellKnownSymbol$i("iterator");
var defineWellKnownSymbol$h = wellKnownSymbolDefine;
defineWellKnownSymbol$h("match");
var defineWellKnownSymbol$g = wellKnownSymbolDefine;
defineWellKnownSymbol$g("matchAll");
var defineWellKnownSymbol$f = wellKnownSymbolDefine;
defineWellKnownSymbol$f("replace");
var defineWellKnownSymbol$e = wellKnownSymbolDefine;
defineWellKnownSymbol$e("search");
var defineWellKnownSymbol$d = wellKnownSymbolDefine;
defineWellKnownSymbol$d("species");
var defineWellKnownSymbol$c = wellKnownSymbolDefine;
defineWellKnownSymbol$c("split");
var defineWellKnownSymbol$b = wellKnownSymbolDefine;
var defineSymbolToPrimitive = symbolDefineToPrimitive;
defineWellKnownSymbol$b("toPrimitive");
defineSymbolToPrimitive();
var getBuiltIn$I = getBuiltIn$Q;
var defineWellKnownSymbol$a = wellKnownSymbolDefine;
var setToStringTag$c = setToStringTag$e;
defineWellKnownSymbol$a("toStringTag");
setToStringTag$c(getBuiltIn$I("Symbol"), "Symbol");
var defineWellKnownSymbol$9 = wellKnownSymbolDefine;
defineWellKnownSymbol$9("unscopables");
var uncurryThis$1F = functionUncurryThis;
var aCallable$N = aCallable$Q;
var functionUncurryThisAccessor = function(object, key, method) {
  try {
    return uncurryThis$1F(aCallable$N(Object.getOwnPropertyDescriptor(object, key)[method]));
  } catch (error3) {
  }
};
var isObject$H = isObject$O;
var isPossiblePrototype$2 = function(argument) {
  return isObject$H(argument) || argument === null;
};
var isPossiblePrototype$1 = isPossiblePrototype$2;
var $String$4 = String;
var $TypeError$H = TypeError;
var aPossiblePrototype$2 = function(argument) {
  if (isPossiblePrototype$1(argument)) return argument;
  throw new $TypeError$H("Can't set " + $String$4(argument) + " as a prototype");
};
var uncurryThisAccessor$3 = functionUncurryThisAccessor;
var isObject$G = isObject$O;
var requireObjectCoercible$n = requireObjectCoercible$q;
var aPossiblePrototype$1 = aPossiblePrototype$2;
var objectSetPrototypeOf$1 = Object.setPrototypeOf || ("__proto__" in {} ? function() {
  var CORRECT_SETTER = false;
  var test2 = {};
  var setter;
  try {
    setter = uncurryThisAccessor$3(Object.prototype, "__proto__", "set");
    setter(test2, []);
    CORRECT_SETTER = test2 instanceof Array;
  } catch (error3) {
  }
  return function setPrototypeOf3(O, proto) {
    requireObjectCoercible$n(O);
    aPossiblePrototype$1(proto);
    if (!isObject$G(O)) return O;
    if (CORRECT_SETTER) setter(O, proto);
    else O.__proto__ = proto;
    return O;
  };
}() : void 0);
var defineProperty$d = objectDefineProperty.f;
var proxyAccessor$2 = function(Target, Source, key) {
  key in Target || defineProperty$d(Target, key, {
    configurable: true,
    get: function() {
      return Source[key];
    },
    set: function(it) {
      Source[key] = it;
    }
  });
};
var isCallable$s = isCallable$I;
var isObject$F = isObject$O;
var setPrototypeOf$a = objectSetPrototypeOf$1;
var inheritIfRequired$7 = function($this, dummy, Wrapper) {
  var NewTarget, NewTargetPrototype;
  if (
    // it can work only with native `setPrototypeOf`
    setPrototypeOf$a && // we haven't completely correct pre-ES6 way for getting `new.target`, so use this
    isCallable$s(NewTarget = dummy.constructor) && NewTarget !== Wrapper && isObject$F(NewTargetPrototype = NewTarget.prototype) && NewTargetPrototype !== Wrapper.prototype
  ) setPrototypeOf$a($this, NewTargetPrototype);
  return $this;
};
var toString$F = toString$J;
var normalizeStringArgument$6 = function(argument, $default) {
  return argument === void 0 ? arguments.length < 2 ? "" : $default : toString$F(argument);
};
var isObject$E = isObject$O;
var createNonEnumerableProperty$g = createNonEnumerableProperty$j;
var installErrorCause$2 = function(O, options) {
  if (isObject$E(options) && "cause" in options) {
    createNonEnumerableProperty$g(O, "cause", options.cause);
  }
};
var uncurryThis$1E = functionUncurryThis;
var $Error$3 = Error;
var replace$9 = uncurryThis$1E("".replace);
var TEST = function(arg) {
  return String(new $Error$3(arg).stack);
}("zxcasd");
var V8_OR_CHAKRA_STACK_ENTRY = /\n\s*at [^:]*:[^\n]*/;
var IS_V8_OR_CHAKRA_STACK = V8_OR_CHAKRA_STACK_ENTRY.test(TEST);
var errorStackClear = function(stack, dropEntries) {
  if (IS_V8_OR_CHAKRA_STACK && typeof stack == "string" && !$Error$3.prepareStackTrace) {
    while (dropEntries--) stack = replace$9(stack, V8_OR_CHAKRA_STACK_ENTRY, "");
  }
  return stack;
};
var fails$1m = fails$1z;
var createPropertyDescriptor$9 = createPropertyDescriptor$d;
var errorStackInstallable = !fails$1m(function() {
  var error3 = new Error("a");
  if (!("stack" in error3)) return true;
  Object.defineProperty(error3, "stack", createPropertyDescriptor$9(1, 7));
  return error3.stack !== 7;
});
var createNonEnumerableProperty$f = createNonEnumerableProperty$j;
var clearErrorStack$2 = errorStackClear;
var ERROR_STACK_INSTALLABLE$1 = errorStackInstallable;
var captureStackTrace = Error.captureStackTrace;
var errorStackInstall = function(error3, C, stack, dropEntries) {
  if (ERROR_STACK_INSTALLABLE$1) {
    if (captureStackTrace) captureStackTrace(error3, C);
    else createNonEnumerableProperty$f(error3, "stack", clearErrorStack$2(stack, dropEntries));
  }
};
var getBuiltIn$H = getBuiltIn$Q;
var hasOwn$t = hasOwnProperty_1;
var createNonEnumerableProperty$e = createNonEnumerableProperty$j;
var isPrototypeOf$c = objectIsPrototypeOf;
var setPrototypeOf$9 = objectSetPrototypeOf$1;
var copyConstructorProperties$4 = copyConstructorProperties$7;
var proxyAccessor$1 = proxyAccessor$2;
var inheritIfRequired$6 = inheritIfRequired$7;
var normalizeStringArgument$5 = normalizeStringArgument$6;
var installErrorCause$1 = installErrorCause$2;
var installErrorStack$2 = errorStackInstall;
var DESCRIPTORS$M = descriptors;
var wrapErrorConstructorWithCause$2 = function(FULL_NAME, wrapper2, FORCED2, IS_AGGREGATE_ERROR) {
  var STACK_TRACE_LIMIT = "stackTraceLimit";
  var OPTIONS_POSITION = IS_AGGREGATE_ERROR ? 2 : 1;
  var path2 = FULL_NAME.split(".");
  var ERROR_NAME = path2[path2.length - 1];
  var OriginalError = getBuiltIn$H.apply(null, path2);
  if (!OriginalError) return;
  var OriginalErrorPrototype = OriginalError.prototype;
  if (hasOwn$t(OriginalErrorPrototype, "cause")) delete OriginalErrorPrototype.cause;
  if (!FORCED2) return OriginalError;
  var BaseError = getBuiltIn$H("Error");
  var WrappedError = wrapper2(function(a, b) {
    var message = normalizeStringArgument$5(IS_AGGREGATE_ERROR ? b : a, void 0);
    var result = IS_AGGREGATE_ERROR ? new OriginalError(a) : new OriginalError();
    if (message !== void 0) createNonEnumerableProperty$e(result, "message", message);
    installErrorStack$2(result, WrappedError, result.stack, 2);
    if (this && isPrototypeOf$c(OriginalErrorPrototype, this)) inheritIfRequired$6(result, this, WrappedError);
    if (arguments.length > OPTIONS_POSITION) installErrorCause$1(result, arguments[OPTIONS_POSITION]);
    return result;
  });
  WrappedError.prototype = OriginalErrorPrototype;
  if (ERROR_NAME !== "Error") {
    if (setPrototypeOf$9) setPrototypeOf$9(WrappedError, BaseError);
    else copyConstructorProperties$4(WrappedError, BaseError, {
      name: true
    });
  } else if (DESCRIPTORS$M && STACK_TRACE_LIMIT in OriginalError) {
    proxyAccessor$1(WrappedError, OriginalError, STACK_TRACE_LIMIT);
    proxyAccessor$1(WrappedError, OriginalError, "prepareStackTrace");
  }
  copyConstructorProperties$4(WrappedError, OriginalError);
  try {
    if (OriginalErrorPrototype.name !== ERROR_NAME) {
      createNonEnumerableProperty$e(OriginalErrorPrototype, "name", ERROR_NAME);
    }
    OriginalErrorPrototype.constructor = WrappedError;
  } catch (error3) {
  }
  return WrappedError;
};
var $$5z = _export;
var globalThis$16 = globalThis_1;
var apply$c = functionApply$1;
var wrapErrorConstructorWithCause$1 = wrapErrorConstructorWithCause$2;
var WEB_ASSEMBLY = "WebAssembly";
var WebAssembly = globalThis$16[WEB_ASSEMBLY];
var FORCED$H = new Error("e", {
  cause: 7
}).cause !== 7;
var exportGlobalErrorCauseWrapper = function(ERROR_NAME, wrapper2) {
  var O = {};
  O[ERROR_NAME] = wrapErrorConstructorWithCause$1(ERROR_NAME, wrapper2, FORCED$H);
  $$5z({
    global: true,
    constructor: true,
    arity: 1,
    forced: FORCED$H
  }, O);
};
var exportWebAssemblyErrorCauseWrapper = function(ERROR_NAME, wrapper2) {
  if (WebAssembly && WebAssembly[ERROR_NAME]) {
    var O = {};
    O[ERROR_NAME] = wrapErrorConstructorWithCause$1(WEB_ASSEMBLY + "." + ERROR_NAME, wrapper2, FORCED$H);
    $$5z({
      target: WEB_ASSEMBLY,
      stat: true,
      constructor: true,
      arity: 1,
      forced: FORCED$H
    }, O);
  }
};
exportGlobalErrorCauseWrapper("Error", function(init) {
  return function Error2(message) {
    return apply$c(init, this, arguments);
  };
});
exportGlobalErrorCauseWrapper("EvalError", function(init) {
  return function EvalError(message) {
    return apply$c(init, this, arguments);
  };
});
exportGlobalErrorCauseWrapper("RangeError", function(init) {
  return function RangeError2(message) {
    return apply$c(init, this, arguments);
  };
});
exportGlobalErrorCauseWrapper("ReferenceError", function(init) {
  return function ReferenceError2(message) {
    return apply$c(init, this, arguments);
  };
});
exportGlobalErrorCauseWrapper("SyntaxError", function(init) {
  return function SyntaxError2(message) {
    return apply$c(init, this, arguments);
  };
});
exportGlobalErrorCauseWrapper("TypeError", function(init) {
  return function TypeError2(message) {
    return apply$c(init, this, arguments);
  };
});
exportGlobalErrorCauseWrapper("URIError", function(init) {
  return function URIError(message) {
    return apply$c(init, this, arguments);
  };
});
exportWebAssemblyErrorCauseWrapper("CompileError", function(init) {
  return function CompileError(message) {
    return apply$c(init, this, arguments);
  };
});
exportWebAssemblyErrorCauseWrapper("LinkError", function(init) {
  return function LinkError(message) {
    return apply$c(init, this, arguments);
  };
});
exportWebAssemblyErrorCauseWrapper("RuntimeError", function(init) {
  return function RuntimeError(message) {
    return apply$c(init, this, arguments);
  };
});
var DESCRIPTORS$L = descriptors;
var fails$1l = fails$1z;
var anObject$1c = anObject$1i;
var normalizeStringArgument$4 = normalizeStringArgument$6;
var nativeErrorToString = Error.prototype.toString;
var INCORRECT_TO_STRING$1 = fails$1l(function() {
  if (DESCRIPTORS$L) {
    var object = Object.create(Object.defineProperty({}, "name", {
      get: function() {
        return this === object;
      }
    }));
    if (nativeErrorToString.call(object) !== "true") return true;
  }
  return nativeErrorToString.call({
    message: 1,
    name: 2
  }) !== "2: 1" || nativeErrorToString.call({}) !== "Error";
});
var errorToString$2 = INCORRECT_TO_STRING$1 ? function toString2() {
  var O = anObject$1c(this);
  var name = normalizeStringArgument$4(O.name, "Error");
  var message = normalizeStringArgument$4(O.message);
  return !name ? message : !message ? name : name + ": " + message;
} : nativeErrorToString;
var defineBuiltIn$q = defineBuiltIn$u;
var errorToString$1 = errorToString$2;
var ErrorPrototype$1 = Error.prototype;
if (ErrorPrototype$1.toString !== errorToString$1) {
  defineBuiltIn$q(ErrorPrototype$1, "toString", errorToString$1);
}
var fails$1k = fails$1z;
var correctPrototypeGetter = !fails$1k(function() {
  function F() {
  }
  F.prototype.constructor = null;
  return Object.getPrototypeOf(new F()) !== F.prototype;
});
var hasOwn$s = hasOwnProperty_1;
var isCallable$r = isCallable$I;
var toObject$A = toObject$E;
var sharedKey = sharedKey$4;
var CORRECT_PROTOTYPE_GETTER$2 = correctPrototypeGetter;
var IE_PROTO = sharedKey("IE_PROTO");
var $Object$4 = Object;
var ObjectPrototype$4 = $Object$4.prototype;
var objectGetPrototypeOf$2 = CORRECT_PROTOTYPE_GETTER$2 ? $Object$4.getPrototypeOf : function(O) {
  var object = toObject$A(O);
  if (hasOwn$s(object, IE_PROTO)) return object[IE_PROTO];
  var constructor = object.constructor;
  if (isCallable$r(constructor) && object instanceof constructor) {
    return constructor.prototype;
  }
  return object instanceof $Object$4 ? ObjectPrototype$4 : null;
};
var iterators = {};
var wellKnownSymbol$J = wellKnownSymbol$S;
var Iterators$5 = iterators;
var ITERATOR$c = wellKnownSymbol$J("iterator");
var ArrayPrototype$1 = Array.prototype;
var isArrayIteratorMethod$3 = function(it) {
  return it !== void 0 && (Iterators$5.Array === it || ArrayPrototype$1[ITERATOR$c] === it);
};
var classof$k = classof$q;
var getMethod$j = getMethod$l;
var isNullOrUndefined$g = isNullOrUndefined$j;
var Iterators$4 = iterators;
var wellKnownSymbol$I = wellKnownSymbol$S;
var ITERATOR$b = wellKnownSymbol$I("iterator");
var getIteratorMethod$9 = function(it) {
  if (!isNullOrUndefined$g(it)) return getMethod$j(it, ITERATOR$b) || getMethod$j(it, "@@iterator") || Iterators$4[classof$k(it)];
};
var call$1a = functionCall;
var aCallable$M = aCallable$Q;
var anObject$1b = anObject$1i;
var tryToString$4 = tryToString$7;
var getIteratorMethod$8 = getIteratorMethod$9;
var $TypeError$G = TypeError;
var getIterator$7 = function(argument, usingIterator) {
  var iteratorMethod = arguments.length < 2 ? getIteratorMethod$8(argument) : usingIterator;
  if (aCallable$M(iteratorMethod)) return anObject$1b(call$1a(iteratorMethod, argument));
  throw new $TypeError$G(tryToString$4(argument) + " is not iterable");
};
var call$19 = functionCall;
var anObject$1a = anObject$1i;
var getMethod$i = getMethod$l;
var iteratorClose$8 = function(iterator, kind, value) {
  var innerResult, innerError;
  anObject$1a(iterator);
  try {
    innerResult = getMethod$i(iterator, "return");
    if (!innerResult) {
      if (kind === "throw") throw value;
      return value;
    }
    innerResult = call$19(innerResult, iterator);
  } catch (error3) {
    innerError = true;
    innerResult = error3;
  }
  if (kind === "throw") throw value;
  if (innerError) throw innerResult;
  anObject$1a(innerResult);
  return value;
};
var bind$t = functionBindContext;
var call$18 = functionCall;
var anObject$19 = anObject$1i;
var tryToString$3 = tryToString$7;
var isArrayIteratorMethod$2 = isArrayIteratorMethod$3;
var lengthOfArrayLike$y = lengthOfArrayLike$B;
var isPrototypeOf$b = objectIsPrototypeOf;
var getIterator$6 = getIterator$7;
var getIteratorMethod$7 = getIteratorMethod$9;
var iteratorClose$7 = iteratorClose$8;
var $TypeError$F = TypeError;
var Result = function(stopped, result) {
  this.stopped = stopped;
  this.result = result;
};
var ResultPrototype = Result.prototype;
var iterate$H = function(iterable, unboundFunction, options) {
  var that = options && options.that;
  var AS_ENTRIES = !!(options && options.AS_ENTRIES);
  var IS_RECORD = !!(options && options.IS_RECORD);
  var IS_ITERATOR = !!(options && options.IS_ITERATOR);
  var INTERRUPTED = !!(options && options.INTERRUPTED);
  var fn = bind$t(unboundFunction, that);
  var iterator, iterFn, index, length, result, next11, step;
  var stop = function(condition) {
    if (iterator) iteratorClose$7(iterator, "normal", condition);
    return new Result(true, condition);
  };
  var callFn = function(value) {
    if (AS_ENTRIES) {
      anObject$19(value);
      return INTERRUPTED ? fn(value[0], value[1], stop) : fn(value[0], value[1]);
    }
    return INTERRUPTED ? fn(value, stop) : fn(value);
  };
  if (IS_RECORD) {
    iterator = iterable.iterator;
  } else if (IS_ITERATOR) {
    iterator = iterable;
  } else {
    iterFn = getIteratorMethod$7(iterable);
    if (!iterFn) throw new $TypeError$F(tryToString$3(iterable) + " is not iterable");
    if (isArrayIteratorMethod$2(iterFn)) {
      for (index = 0, length = lengthOfArrayLike$y(iterable); length > index; index++) {
        result = callFn(iterable[index]);
        if (result && isPrototypeOf$b(ResultPrototype, result)) return result;
      }
      return new Result(false);
    }
    iterator = getIterator$6(iterable, iterFn);
  }
  next11 = IS_RECORD ? iterable.next : iterator.next;
  while (!(step = call$18(next11, iterator)).done) {
    try {
      result = callFn(step.value);
    } catch (error3) {
      iteratorClose$7(iterator, "throw", error3);
    }
    if (typeof result == "object" && result && isPrototypeOf$b(ResultPrototype, result)) return result;
  }
  return new Result(false);
};
var $$5y = _export;
var isPrototypeOf$a = objectIsPrototypeOf;
var getPrototypeOf$g = objectGetPrototypeOf$2;
var setPrototypeOf$8 = objectSetPrototypeOf$1;
var copyConstructorProperties$3 = copyConstructorProperties$7;
var create$i = objectCreate$1;
var createNonEnumerableProperty$d = createNonEnumerableProperty$j;
var createPropertyDescriptor$8 = createPropertyDescriptor$d;
var installErrorCause = installErrorCause$2;
var installErrorStack$1 = errorStackInstall;
var iterate$G = iterate$H;
var normalizeStringArgument$3 = normalizeStringArgument$6;
var wellKnownSymbol$H = wellKnownSymbol$S;
var TO_STRING_TAG$8 = wellKnownSymbol$H("toStringTag");
var $Error$2 = Error;
var push$o = [].push;
var $AggregateError$1 = function AggregateError(errors, message) {
  var isInstance = isPrototypeOf$a(AggregateErrorPrototype, this);
  var that;
  if (setPrototypeOf$8) {
    that = setPrototypeOf$8(new $Error$2(), isInstance ? getPrototypeOf$g(this) : AggregateErrorPrototype);
  } else {
    that = isInstance ? this : create$i(AggregateErrorPrototype);
    createNonEnumerableProperty$d(that, TO_STRING_TAG$8, "Error");
  }
  if (message !== void 0) createNonEnumerableProperty$d(that, "message", normalizeStringArgument$3(message));
  installErrorStack$1(that, $AggregateError$1, that.stack, 1);
  if (arguments.length > 2) installErrorCause(that, arguments[2]);
  var errorsArray = [];
  iterate$G(errors, push$o, {
    that: errorsArray
  });
  createNonEnumerableProperty$d(that, "errors", errorsArray);
  return that;
};
if (setPrototypeOf$8) setPrototypeOf$8($AggregateError$1, $Error$2);
else copyConstructorProperties$3($AggregateError$1, $Error$2, {
  name: true
});
var AggregateErrorPrototype = $AggregateError$1.prototype = create$i($Error$2.prototype, {
  constructor: createPropertyDescriptor$8(1, $AggregateError$1),
  message: createPropertyDescriptor$8(1, ""),
  name: createPropertyDescriptor$8(1, "AggregateError")
});
$$5y({
  global: true,
  constructor: true,
  arity: 2
}, {
  AggregateError: $AggregateError$1
});
var $$5x = _export;
var getBuiltIn$G = getBuiltIn$Q;
var apply$b = functionApply$1;
var fails$1j = fails$1z;
var wrapErrorConstructorWithCause = wrapErrorConstructorWithCause$2;
var AGGREGATE_ERROR = "AggregateError";
var $AggregateError = getBuiltIn$G(AGGREGATE_ERROR);
var FORCED$G = !fails$1j(function() {
  return $AggregateError([1]).errors[0] !== 1;
}) && fails$1j(function() {
  return $AggregateError([1], AGGREGATE_ERROR, {
    cause: 7
  }).cause !== 7;
});
$$5x({
  global: true,
  constructor: true,
  arity: 2,
  forced: FORCED$G
}, {
  AggregateError: wrapErrorConstructorWithCause(AGGREGATE_ERROR, function(init) {
    return function AggregateError2(errors, message) {
      return apply$b(init, this, arguments);
    };
  }, FORCED$G, true)
});
var wellKnownSymbol$G = wellKnownSymbol$S;
var create$h = objectCreate$1;
var defineProperty$c = objectDefineProperty.f;
var UNSCOPABLES = wellKnownSymbol$G("unscopables");
var ArrayPrototype = Array.prototype;
if (ArrayPrototype[UNSCOPABLES] === void 0) {
  defineProperty$c(ArrayPrototype, UNSCOPABLES, {
    configurable: true,
    value: create$h(null)
  });
}
var addToUnscopables$n = function(key) {
  ArrayPrototype[UNSCOPABLES][key] = true;
};
var $$5w = _export;
var toObject$z = toObject$E;
var lengthOfArrayLike$x = lengthOfArrayLike$B;
var toIntegerOrInfinity$m = toIntegerOrInfinity$p;
var addToUnscopables$m = addToUnscopables$n;
$$5w({
  target: "Array",
  proto: true
}, {
  at: function at(index) {
    var O = toObject$z(this);
    var len = lengthOfArrayLike$x(O);
    var relativeIndex = toIntegerOrInfinity$m(index);
    var k = relativeIndex >= 0 ? relativeIndex : len + relativeIndex;
    return k < 0 || k >= len ? void 0 : O[k];
  }
});
addToUnscopables$m("at");
var $TypeError$E = TypeError;
var MAX_SAFE_INTEGER$1 = 9007199254740991;
var doesNotExceedSafeInteger$7 = function(it) {
  if (it > MAX_SAFE_INTEGER$1) throw $TypeError$E("Maximum allowed index exceeded");
  return it;
};
var DESCRIPTORS$K = descriptors;
var definePropertyModule$6 = objectDefineProperty;
var createPropertyDescriptor$7 = createPropertyDescriptor$d;
var createProperty$b = function(object, key, value) {
  if (DESCRIPTORS$K) definePropertyModule$6.f(object, key, createPropertyDescriptor$7(0, value));
  else object[key] = value;
};
var fails$1i = fails$1z;
var wellKnownSymbol$F = wellKnownSymbol$S;
var V8_VERSION$3 = environmentV8Version;
var SPECIES$5 = wellKnownSymbol$F("species");
var arrayMethodHasSpeciesSupport$5 = function(METHOD_NAME) {
  return V8_VERSION$3 >= 51 || !fails$1i(function() {
    var array = [];
    var constructor = array.constructor = {};
    constructor[SPECIES$5] = function() {
      return {
        foo: 1
      };
    };
    return array[METHOD_NAME](Boolean).foo !== 1;
  });
};
var $$5v = _export;
var fails$1h = fails$1z;
var isArray$8 = isArray$b;
var isObject$D = isObject$O;
var toObject$y = toObject$E;
var lengthOfArrayLike$w = lengthOfArrayLike$B;
var doesNotExceedSafeInteger$6 = doesNotExceedSafeInteger$7;
var createProperty$a = createProperty$b;
var arraySpeciesCreate$3 = arraySpeciesCreate$5;
var arrayMethodHasSpeciesSupport$4 = arrayMethodHasSpeciesSupport$5;
var wellKnownSymbol$E = wellKnownSymbol$S;
var V8_VERSION$2 = environmentV8Version;
var IS_CONCAT_SPREADABLE = wellKnownSymbol$E("isConcatSpreadable");
var IS_CONCAT_SPREADABLE_SUPPORT = V8_VERSION$2 >= 51 || !fails$1h(function() {
  var array = [];
  array[IS_CONCAT_SPREADABLE] = false;
  return array.concat()[0] !== array;
});
var isConcatSpreadable = function(O) {
  if (!isObject$D(O)) return false;
  var spreadable = O[IS_CONCAT_SPREADABLE];
  return spreadable !== void 0 ? !!spreadable : isArray$8(O);
};
var FORCED$F = !IS_CONCAT_SPREADABLE_SUPPORT || !arrayMethodHasSpeciesSupport$4("concat");
$$5v({
  target: "Array",
  proto: true,
  arity: 1,
  forced: FORCED$F
}, {
  // eslint-disable-next-line no-unused-vars -- required for `.length`
  concat: function concat(arg) {
    var O = toObject$y(this);
    var A = arraySpeciesCreate$3(O, 0);
    var n = 0;
    var i, k, length, len, E2;
    for (i = -1, length = arguments.length; i < length; i++) {
      E2 = i === -1 ? O : arguments[i];
      if (isConcatSpreadable(E2)) {
        len = lengthOfArrayLike$w(E2);
        doesNotExceedSafeInteger$6(n + len);
        for (k = 0; k < len; k++, n++) if (k in E2) createProperty$a(A, n, E2[k]);
      } else {
        doesNotExceedSafeInteger$6(n + 1);
        createProperty$a(A, n++, E2);
      }
    }
    A.length = n;
    return A;
  }
});
var tryToString$2 = tryToString$7;
var $TypeError$D = TypeError;
var deletePropertyOrThrow$4 = function(O, P) {
  if (!delete O[P]) throw new $TypeError$D("Cannot delete property " + tryToString$2(P) + " of " + tryToString$2(O));
};
var toObject$x = toObject$E;
var toAbsoluteIndex$8 = toAbsoluteIndex$a;
var lengthOfArrayLike$v = lengthOfArrayLike$B;
var deletePropertyOrThrow$3 = deletePropertyOrThrow$4;
var min$c = Math.min;
var arrayCopyWithin = [].copyWithin || function copyWithin(target, start2) {
  var O = toObject$x(this);
  var len = lengthOfArrayLike$v(O);
  var to = toAbsoluteIndex$8(target, len);
  var from7 = toAbsoluteIndex$8(start2, len);
  var end = arguments.length > 2 ? arguments[2] : void 0;
  var count = min$c((end === void 0 ? len : toAbsoluteIndex$8(end, len)) - from7, len - to);
  var inc = 1;
  if (from7 < to && to < from7 + count) {
    inc = -1;
    from7 += count - 1;
    to += count - 1;
  }
  while (count-- > 0) {
    if (from7 in O) O[to] = O[from7];
    else deletePropertyOrThrow$3(O, to);
    to += inc;
    from7 += inc;
  }
  return O;
};
var $$5u = _export;
var copyWithin2 = arrayCopyWithin;
var addToUnscopables$l = addToUnscopables$n;
$$5u({
  target: "Array",
  proto: true
}, {
  copyWithin: copyWithin2
});
addToUnscopables$l("copyWithin");
var fails$1g = fails$1z;
var arrayMethodIsStrict$b = function(METHOD_NAME, argument) {
  var method = [][METHOD_NAME];
  return !!method && fails$1g(function() {
    method.call(null, argument || function() {
      return 1;
    }, 1);
  });
};
var $$5t = _export;
var $every$2 = arrayIteration.every;
var arrayMethodIsStrict$a = arrayMethodIsStrict$b;
var STRICT_METHOD$4 = arrayMethodIsStrict$a("every");
$$5t({
  target: "Array",
  proto: true,
  forced: !STRICT_METHOD$4
}, {
  every: function every(callbackfn) {
    return $every$2(this, callbackfn, arguments.length > 1 ? arguments[1] : void 0);
  }
});
var toObject$w = toObject$E;
var toAbsoluteIndex$7 = toAbsoluteIndex$a;
var lengthOfArrayLike$u = lengthOfArrayLike$B;
var arrayFill$1 = function fill(value) {
  var O = toObject$w(this);
  var length = lengthOfArrayLike$u(O);
  var argumentsLength = arguments.length;
  var index = toAbsoluteIndex$7(argumentsLength > 1 ? arguments[1] : void 0, length);
  var end = argumentsLength > 2 ? arguments[2] : void 0;
  var endPos = end === void 0 ? length : toAbsoluteIndex$7(end, length);
  while (endPos > index) O[index++] = value;
  return O;
};
var $$5s = _export;
var fill$1 = arrayFill$1;
var addToUnscopables$k = addToUnscopables$n;
$$5s({
  target: "Array",
  proto: true
}, {
  fill: fill$1
});
addToUnscopables$k("fill");
var $$5r = _export;
var $filter$1 = arrayIteration.filter;
var arrayMethodHasSpeciesSupport$3 = arrayMethodHasSpeciesSupport$5;
var HAS_SPECIES_SUPPORT$3 = arrayMethodHasSpeciesSupport$3("filter");
$$5r({
  target: "Array",
  proto: true,
  forced: !HAS_SPECIES_SUPPORT$3
}, {
  filter: function filter(callbackfn) {
    return $filter$1(this, callbackfn, arguments.length > 1 ? arguments[1] : void 0);
  }
});
var $$5q = _export;
var $find$2 = arrayIteration.find;
var addToUnscopables$j = addToUnscopables$n;
var FIND = "find";
var SKIPS_HOLES$1 = true;
if (FIND in []) Array(1)[FIND](function() {
  SKIPS_HOLES$1 = false;
});
$$5q({
  target: "Array",
  proto: true,
  forced: SKIPS_HOLES$1
}, {
  find: function find(callbackfn) {
    return $find$2(this, callbackfn, arguments.length > 1 ? arguments[1] : void 0);
  }
});
addToUnscopables$j(FIND);
var $$5p = _export;
var $findIndex$1 = arrayIteration.findIndex;
var addToUnscopables$i = addToUnscopables$n;
var FIND_INDEX = "findIndex";
var SKIPS_HOLES = true;
if (FIND_INDEX in []) Array(1)[FIND_INDEX](function() {
  SKIPS_HOLES = false;
});
$$5p({
  target: "Array",
  proto: true,
  forced: SKIPS_HOLES
}, {
  findIndex: function findIndex(callbackfn) {
    return $findIndex$1(this, callbackfn, arguments.length > 1 ? arguments[1] : void 0);
  }
});
addToUnscopables$i(FIND_INDEX);
var bind$s = functionBindContext;
var IndexedObject$5 = indexedObject;
var toObject$v = toObject$E;
var lengthOfArrayLike$t = lengthOfArrayLike$B;
var createMethod$6 = function(TYPE) {
  var IS_FIND_LAST_INDEX = TYPE === 1;
  return function($this, callbackfn, that) {
    var O = toObject$v($this);
    var self2 = IndexedObject$5(O);
    var index = lengthOfArrayLike$t(self2);
    var boundFunction = bind$s(callbackfn, that);
    var value, result;
    while (index-- > 0) {
      value = self2[index];
      result = boundFunction(value, index, O);
      if (result) switch (TYPE) {
        case 0:
          return value;
        case 1:
          return index;
      }
    }
    return IS_FIND_LAST_INDEX ? -1 : void 0;
  };
};
var arrayIterationFromLast = {
  // `Array.prototype.findLast` method
  // https://github.com/tc39/proposal-array-find-from-last
  findLast: createMethod$6(0),
  // `Array.prototype.findLastIndex` method
  // https://github.com/tc39/proposal-array-find-from-last
  findLastIndex: createMethod$6(1)
};
var $$5o = _export;
var $findLast$1 = arrayIterationFromLast.findLast;
var addToUnscopables$h = addToUnscopables$n;
$$5o({
  target: "Array",
  proto: true
}, {
  findLast: function findLast(callbackfn) {
    return $findLast$1(this, callbackfn, arguments.length > 1 ? arguments[1] : void 0);
  }
});
addToUnscopables$h("findLast");
var $$5n = _export;
var $findLastIndex$1 = arrayIterationFromLast.findLastIndex;
var addToUnscopables$g = addToUnscopables$n;
$$5n({
  target: "Array",
  proto: true
}, {
  findLastIndex: function findLastIndex(callbackfn) {
    return $findLastIndex$1(this, callbackfn, arguments.length > 1 ? arguments[1] : void 0);
  }
});
addToUnscopables$g("findLastIndex");
var isArray$7 = isArray$b;
var lengthOfArrayLike$s = lengthOfArrayLike$B;
var doesNotExceedSafeInteger$5 = doesNotExceedSafeInteger$7;
var bind$r = functionBindContext;
var flattenIntoArray$2 = function(target, original, source, sourceLen, start2, depth, mapper, thisArg) {
  var targetIndex = start2;
  var sourceIndex = 0;
  var mapFn = mapper ? bind$r(mapper, thisArg) : false;
  var element, elementLen;
  while (sourceIndex < sourceLen) {
    if (sourceIndex in source) {
      element = mapFn ? mapFn(source[sourceIndex], sourceIndex, original) : source[sourceIndex];
      if (depth > 0 && isArray$7(element)) {
        elementLen = lengthOfArrayLike$s(element);
        targetIndex = flattenIntoArray$2(target, original, element, elementLen, targetIndex, depth - 1) - 1;
      } else {
        doesNotExceedSafeInteger$5(targetIndex + 1);
        target[targetIndex] = element;
      }
      targetIndex++;
    }
    sourceIndex++;
  }
  return targetIndex;
};
var flattenIntoArray_1 = flattenIntoArray$2;
var $$5m = _export;
var flattenIntoArray$1 = flattenIntoArray_1;
var toObject$u = toObject$E;
var lengthOfArrayLike$r = lengthOfArrayLike$B;
var toIntegerOrInfinity$l = toIntegerOrInfinity$p;
var arraySpeciesCreate$2 = arraySpeciesCreate$5;
$$5m({
  target: "Array",
  proto: true
}, {
  flat: function flat() {
    var depthArg = arguments.length ? arguments[0] : void 0;
    var O = toObject$u(this);
    var sourceLen = lengthOfArrayLike$r(O);
    var A = arraySpeciesCreate$2(O, 0);
    A.length = flattenIntoArray$1(A, O, O, sourceLen, 0, depthArg === void 0 ? 1 : toIntegerOrInfinity$l(depthArg));
    return A;
  }
});
var $$5l = _export;
var flattenIntoArray = flattenIntoArray_1;
var aCallable$L = aCallable$Q;
var toObject$t = toObject$E;
var lengthOfArrayLike$q = lengthOfArrayLike$B;
var arraySpeciesCreate$1 = arraySpeciesCreate$5;
$$5l({
  target: "Array",
  proto: true
}, {
  flatMap: function flatMap(callbackfn) {
    var O = toObject$t(this);
    var sourceLen = lengthOfArrayLike$q(O);
    var A;
    aCallable$L(callbackfn);
    A = arraySpeciesCreate$1(O, 0);
    A.length = flattenIntoArray(A, O, O, sourceLen, 0, 1, callbackfn, arguments.length > 1 ? arguments[1] : void 0);
    return A;
  }
});
var $forEach$2 = arrayIteration.forEach;
var arrayMethodIsStrict$9 = arrayMethodIsStrict$b;
var STRICT_METHOD$3 = arrayMethodIsStrict$9("forEach");
var arrayForEach = !STRICT_METHOD$3 ? function forEach(callbackfn) {
  return $forEach$2(this, callbackfn, arguments.length > 1 ? arguments[1] : void 0);
} : [].forEach;
var $$5k = _export;
var forEach$6 = arrayForEach;
$$5k({
  target: "Array",
  proto: true,
  forced: [].forEach !== forEach$6
}, {
  forEach: forEach$6
});
var anObject$18 = anObject$1i;
var iteratorClose$6 = iteratorClose$8;
var callWithSafeIterationClosing$3 = function(iterator, fn, value, ENTRIES2) {
  try {
    return ENTRIES2 ? fn(anObject$18(value)[0], value[1]) : fn(value);
  } catch (error3) {
    iteratorClose$6(iterator, "throw", error3);
  }
};
var bind$q = functionBindContext;
var call$17 = functionCall;
var toObject$s = toObject$E;
var callWithSafeIterationClosing$2 = callWithSafeIterationClosing$3;
var isArrayIteratorMethod$1 = isArrayIteratorMethod$3;
var isConstructor$8 = isConstructor$a;
var lengthOfArrayLike$p = lengthOfArrayLike$B;
var createProperty$9 = createProperty$b;
var getIterator$5 = getIterator$7;
var getIteratorMethod$6 = getIteratorMethod$9;
var $Array$c = Array;
var arrayFrom$1 = function from(arrayLike) {
  var O = toObject$s(arrayLike);
  var IS_CONSTRUCTOR = isConstructor$8(this);
  var argumentsLength = arguments.length;
  var mapfn = argumentsLength > 1 ? arguments[1] : void 0;
  var mapping = mapfn !== void 0;
  if (mapping) mapfn = bind$q(mapfn, argumentsLength > 2 ? arguments[2] : void 0);
  var iteratorMethod = getIteratorMethod$6(O);
  var index = 0;
  var length, result, step, iterator, next11, value;
  if (iteratorMethod && !(this === $Array$c && isArrayIteratorMethod$1(iteratorMethod))) {
    result = IS_CONSTRUCTOR ? new this() : [];
    iterator = getIterator$5(O, iteratorMethod);
    next11 = iterator.next;
    for (; !(step = call$17(next11, iterator)).done; index++) {
      value = mapping ? callWithSafeIterationClosing$2(iterator, mapfn, [step.value, index], true) : step.value;
      createProperty$9(result, index, value);
    }
  } else {
    length = lengthOfArrayLike$p(O);
    result = IS_CONSTRUCTOR ? new this(length) : $Array$c(length);
    for (; length > index; index++) {
      value = mapping ? mapfn(O[index], index) : O[index];
      createProperty$9(result, index, value);
    }
  }
  result.length = index;
  return result;
};
var wellKnownSymbol$D = wellKnownSymbol$S;
var ITERATOR$a = wellKnownSymbol$D("iterator");
var SAFE_CLOSING = false;
try {
  var called = 0;
  var iteratorWithReturn = {
    next: function() {
      return {
        done: !!called++
      };
    },
    "return": function() {
      SAFE_CLOSING = true;
    }
  };
  iteratorWithReturn[ITERATOR$a] = function() {
    return this;
  };
  Array.from(iteratorWithReturn, function() {
    throw 2;
  });
} catch (error3) {
}
var checkCorrectnessOfIteration$4 = function(exec2, SKIP_CLOSING) {
  try {
    if (!SKIP_CLOSING && !SAFE_CLOSING) return false;
  } catch (error3) {
    return false;
  }
  var ITERATION_SUPPORT = false;
  try {
    var object = {};
    object[ITERATOR$a] = function() {
      return {
        next: function() {
          return {
            done: ITERATION_SUPPORT = true
          };
        }
      };
    };
    exec2(object);
  } catch (error3) {
  }
  return ITERATION_SUPPORT;
};
var $$5j = _export;
var from2 = arrayFrom$1;
var checkCorrectnessOfIteration$3 = checkCorrectnessOfIteration$4;
var INCORRECT_ITERATION = !checkCorrectnessOfIteration$3(function(iterable) {
  Array.from(iterable);
});
$$5j({
  target: "Array",
  stat: true,
  forced: INCORRECT_ITERATION
}, {
  from: from2
});
var $$5i = _export;
var $includes$1 = arrayIncludes.includes;
var fails$1f = fails$1z;
var addToUnscopables$f = addToUnscopables$n;
var BROKEN_ON_SPARSE = fails$1f(function() {
  return !Array(1).includes();
});
$$5i({
  target: "Array",
  proto: true,
  forced: BROKEN_ON_SPARSE
}, {
  includes: function includes(el) {
    return $includes$1(this, el, arguments.length > 1 ? arguments[1] : void 0);
  }
});
addToUnscopables$f("includes");
var $$5h = _export;
var uncurryThis$1D = functionUncurryThisClause;
var $indexOf$1 = arrayIncludes.indexOf;
var arrayMethodIsStrict$8 = arrayMethodIsStrict$b;
var nativeIndexOf = uncurryThis$1D([].indexOf);
var NEGATIVE_ZERO$1 = !!nativeIndexOf && 1 / nativeIndexOf([1], 1, -0) < 0;
var FORCED$E = NEGATIVE_ZERO$1 || !arrayMethodIsStrict$8("indexOf");
$$5h({
  target: "Array",
  proto: true,
  forced: FORCED$E
}, {
  indexOf: function indexOf(searchElement) {
    var fromIndex = arguments.length > 1 ? arguments[1] : void 0;
    return NEGATIVE_ZERO$1 ? nativeIndexOf(this, searchElement, fromIndex) || 0 : $indexOf$1(this, searchElement, fromIndex);
  }
});
var $$5g = _export;
var isArray$6 = isArray$b;
$$5g({
  target: "Array",
  stat: true
}, {
  isArray: isArray$6
});
var fails$1e = fails$1z;
var isCallable$q = isCallable$I;
var isObject$C = isObject$O;
var getPrototypeOf$f = objectGetPrototypeOf$2;
var defineBuiltIn$p = defineBuiltIn$u;
var wellKnownSymbol$C = wellKnownSymbol$S;
var ITERATOR$9 = wellKnownSymbol$C("iterator");
var BUGGY_SAFARI_ITERATORS$1 = false;
var IteratorPrototype$6, PrototypeOfArrayIteratorPrototype, arrayIterator$1;
if ([].keys) {
  arrayIterator$1 = [].keys();
  if (!("next" in arrayIterator$1)) BUGGY_SAFARI_ITERATORS$1 = true;
  else {
    PrototypeOfArrayIteratorPrototype = getPrototypeOf$f(getPrototypeOf$f(arrayIterator$1));
    if (PrototypeOfArrayIteratorPrototype !== Object.prototype) IteratorPrototype$6 = PrototypeOfArrayIteratorPrototype;
  }
}
var NEW_ITERATOR_PROTOTYPE = !isObject$C(IteratorPrototype$6) || fails$1e(function() {
  var test2 = {};
  return IteratorPrototype$6[ITERATOR$9].call(test2) !== test2;
});
if (NEW_ITERATOR_PROTOTYPE) IteratorPrototype$6 = {};
if (!isCallable$q(IteratorPrototype$6[ITERATOR$9])) {
  defineBuiltIn$p(IteratorPrototype$6, ITERATOR$9, function() {
    return this;
  });
}
var iteratorsCore = {
  IteratorPrototype: IteratorPrototype$6,
  BUGGY_SAFARI_ITERATORS: BUGGY_SAFARI_ITERATORS$1
};
var IteratorPrototype$5 = iteratorsCore.IteratorPrototype;
var create$g = objectCreate$1;
var createPropertyDescriptor$6 = createPropertyDescriptor$d;
var setToStringTag$b = setToStringTag$e;
var Iterators$3 = iterators;
var returnThis$1 = function() {
  return this;
};
var iteratorCreateConstructor = function(IteratorConstructor2, NAME2, next11, ENUMERABLE_NEXT) {
  var TO_STRING_TAG2 = NAME2 + " Iterator";
  IteratorConstructor2.prototype = create$g(IteratorPrototype$5, {
    next: createPropertyDescriptor$6(+!ENUMERABLE_NEXT, next11)
  });
  setToStringTag$b(IteratorConstructor2, TO_STRING_TAG2, false);
  Iterators$3[TO_STRING_TAG2] = returnThis$1;
  return IteratorConstructor2;
};
var $$5f = _export;
var call$16 = functionCall;
var FunctionName$1 = functionName;
var isCallable$p = isCallable$I;
var createIteratorConstructor$6 = iteratorCreateConstructor;
var getPrototypeOf$e = objectGetPrototypeOf$2;
var setPrototypeOf$7 = objectSetPrototypeOf$1;
var setToStringTag$a = setToStringTag$e;
var createNonEnumerableProperty$c = createNonEnumerableProperty$j;
var defineBuiltIn$o = defineBuiltIn$u;
var wellKnownSymbol$B = wellKnownSymbol$S;
var Iterators$2 = iterators;
var IteratorsCore = iteratorsCore;
var PROPER_FUNCTION_NAME$3 = FunctionName$1.PROPER;
var CONFIGURABLE_FUNCTION_NAME$1 = FunctionName$1.CONFIGURABLE;
var IteratorPrototype$4 = IteratorsCore.IteratorPrototype;
var BUGGY_SAFARI_ITERATORS = IteratorsCore.BUGGY_SAFARI_ITERATORS;
var ITERATOR$8 = wellKnownSymbol$B("iterator");
var KEYS = "keys";
var VALUES = "values";
var ENTRIES = "entries";
var returnThis = function() {
  return this;
};
var iteratorDefine = function(Iterable, NAME2, IteratorConstructor2, next11, DEFAULT, IS_SET, FORCED2) {
  createIteratorConstructor$6(IteratorConstructor2, NAME2, next11);
  var getIterationMethod = function(KIND) {
    if (KIND === DEFAULT && defaultIterator) return defaultIterator;
    if (!BUGGY_SAFARI_ITERATORS && KIND && KIND in IterablePrototype) return IterablePrototype[KIND];
    switch (KIND) {
      case KEYS:
        return function keys6() {
          return new IteratorConstructor2(this, KIND);
        };
      case VALUES:
        return function values5() {
          return new IteratorConstructor2(this, KIND);
        };
      case ENTRIES:
        return function entries5() {
          return new IteratorConstructor2(this, KIND);
        };
    }
    return function() {
      return new IteratorConstructor2(this);
    };
  };
  var TO_STRING_TAG2 = NAME2 + " Iterator";
  var INCORRECT_VALUES_NAME = false;
  var IterablePrototype = Iterable.prototype;
  var nativeIterator = IterablePrototype[ITERATOR$8] || IterablePrototype["@@iterator"] || DEFAULT && IterablePrototype[DEFAULT];
  var defaultIterator = !BUGGY_SAFARI_ITERATORS && nativeIterator || getIterationMethod(DEFAULT);
  var anyNativeIterator = NAME2 === "Array" ? IterablePrototype.entries || nativeIterator : nativeIterator;
  var CurrentIteratorPrototype, methods, KEY;
  if (anyNativeIterator) {
    CurrentIteratorPrototype = getPrototypeOf$e(anyNativeIterator.call(new Iterable()));
    if (CurrentIteratorPrototype !== Object.prototype && CurrentIteratorPrototype.next) {
      if (getPrototypeOf$e(CurrentIteratorPrototype) !== IteratorPrototype$4) {
        if (setPrototypeOf$7) {
          setPrototypeOf$7(CurrentIteratorPrototype, IteratorPrototype$4);
        } else if (!isCallable$p(CurrentIteratorPrototype[ITERATOR$8])) {
          defineBuiltIn$o(CurrentIteratorPrototype, ITERATOR$8, returnThis);
        }
      }
      setToStringTag$a(CurrentIteratorPrototype, TO_STRING_TAG2, true);
    }
  }
  if (PROPER_FUNCTION_NAME$3 && DEFAULT === VALUES && nativeIterator && nativeIterator.name !== VALUES) {
    if (CONFIGURABLE_FUNCTION_NAME$1) {
      createNonEnumerableProperty$c(IterablePrototype, "name", VALUES);
    } else {
      INCORRECT_VALUES_NAME = true;
      defaultIterator = function values5() {
        return call$16(nativeIterator, this);
      };
    }
  }
  if (DEFAULT) {
    methods = {
      values: getIterationMethod(VALUES),
      keys: IS_SET ? defaultIterator : getIterationMethod(KEYS),
      entries: getIterationMethod(ENTRIES)
    };
    if (FORCED2) for (KEY in methods) {
      if (BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME || !(KEY in IterablePrototype)) {
        defineBuiltIn$o(IterablePrototype, KEY, methods[KEY]);
      }
    }
    else $$5f({
      target: NAME2,
      proto: true,
      forced: BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME
    }, methods);
  }
  if (IterablePrototype[ITERATOR$8] !== defaultIterator) {
    defineBuiltIn$o(IterablePrototype, ITERATOR$8, defaultIterator, {
      name: DEFAULT
    });
  }
  Iterators$2[NAME2] = defaultIterator;
  return methods;
};
var createIterResultObject$i = function(value, done) {
  return {
    value,
    done
  };
};
var toIndexedObject$d = toIndexedObject$k;
var addToUnscopables$e = addToUnscopables$n;
var Iterators$1 = iterators;
var InternalStateModule$l = internalState;
var defineProperty$b = objectDefineProperty.f;
var defineIterator$2 = iteratorDefine;
var createIterResultObject$h = createIterResultObject$i;
var DESCRIPTORS$J = descriptors;
var ARRAY_ITERATOR = "Array Iterator";
var setInternalState$l = InternalStateModule$l.set;
var getInternalState$e = InternalStateModule$l.getterFor(ARRAY_ITERATOR);
var es_array_iterator = defineIterator$2(Array, "Array", function(iterated, kind) {
  setInternalState$l(this, {
    type: ARRAY_ITERATOR,
    target: toIndexedObject$d(iterated),
    // target
    index: 0,
    // next index
    kind
    // kind
  });
}, function() {
  var state = getInternalState$e(this);
  var target = state.target;
  var index = state.index++;
  if (!target || index >= target.length) {
    state.target = null;
    return createIterResultObject$h(void 0, true);
  }
  switch (state.kind) {
    case "keys":
      return createIterResultObject$h(index, false);
    case "values":
      return createIterResultObject$h(target[index], false);
  }
  return createIterResultObject$h([index, target[index]], false);
}, "values");
var values$1 = Iterators$1.Arguments = Iterators$1.Array;
addToUnscopables$e("keys");
addToUnscopables$e("values");
addToUnscopables$e("entries");
if (DESCRIPTORS$J && values$1.name !== "values") try {
  defineProperty$b(values$1, "name", {
    value: "values"
  });
} catch (error3) {
}
var $$5e = _export;
var uncurryThis$1C = functionUncurryThis;
var IndexedObject$4 = indexedObject;
var toIndexedObject$c = toIndexedObject$k;
var arrayMethodIsStrict$7 = arrayMethodIsStrict$b;
var nativeJoin = uncurryThis$1C([].join);
var ES3_STRINGS = IndexedObject$4 !== Object;
var FORCED$D = ES3_STRINGS || !arrayMethodIsStrict$7("join", ",");
$$5e({
  target: "Array",
  proto: true,
  forced: FORCED$D
}, {
  join: function join(separator) {
    return nativeJoin(toIndexedObject$c(this), separator === void 0 ? "," : separator);
  }
});
var apply$a = functionApply$1;
var toIndexedObject$b = toIndexedObject$k;
var toIntegerOrInfinity$k = toIntegerOrInfinity$p;
var lengthOfArrayLike$o = lengthOfArrayLike$B;
var arrayMethodIsStrict$6 = arrayMethodIsStrict$b;
var min$b = Math.min;
var $lastIndexOf$1 = [].lastIndexOf;
var NEGATIVE_ZERO = !!$lastIndexOf$1 && 1 / [1].lastIndexOf(1, -0) < 0;
var STRICT_METHOD$2 = arrayMethodIsStrict$6("lastIndexOf");
var FORCED$C = NEGATIVE_ZERO || !STRICT_METHOD$2;
var arrayLastIndexOf = FORCED$C ? function lastIndexOf(searchElement) {
  if (NEGATIVE_ZERO) return apply$a($lastIndexOf$1, this, arguments) || 0;
  var O = toIndexedObject$b(this);
  var length = lengthOfArrayLike$o(O);
  if (length === 0) return -1;
  var index = length - 1;
  if (arguments.length > 1) index = min$b(index, toIntegerOrInfinity$k(arguments[1]));
  if (index < 0) index = length + index;
  for (; index >= 0; index--) if (index in O && O[index] === searchElement) return index || 0;
  return -1;
} : $lastIndexOf$1;
var $$5d = _export;
var lastIndexOf2 = arrayLastIndexOf;
$$5d({
  target: "Array",
  proto: true,
  forced: lastIndexOf2 !== [].lastIndexOf
}, {
  lastIndexOf: lastIndexOf2
});
var $$5c = _export;
var $map$1 = arrayIteration.map;
var arrayMethodHasSpeciesSupport$2 = arrayMethodHasSpeciesSupport$5;
var HAS_SPECIES_SUPPORT$2 = arrayMethodHasSpeciesSupport$2("map");
$$5c({
  target: "Array",
  proto: true,
  forced: !HAS_SPECIES_SUPPORT$2
}, {
  map: function map(callbackfn) {
    return $map$1(this, callbackfn, arguments.length > 1 ? arguments[1] : void 0);
  }
});
var $$5b = _export;
var fails$1d = fails$1z;
var isConstructor$7 = isConstructor$a;
var createProperty$8 = createProperty$b;
var $Array$b = Array;
var ISNT_GENERIC = fails$1d(function() {
  function F() {
  }
  return !($Array$b.of.call(F) instanceof F);
});
$$5b({
  target: "Array",
  stat: true,
  forced: ISNT_GENERIC
}, {
  of: function of() {
    var index = 0;
    var argumentsLength = arguments.length;
    var result = new (isConstructor$7(this) ? this : $Array$b)(argumentsLength);
    while (argumentsLength > index) createProperty$8(result, index, arguments[index++]);
    result.length = argumentsLength;
    return result;
  }
});
var DESCRIPTORS$I = descriptors;
var isArray$5 = isArray$b;
var $TypeError$C = TypeError;
var getOwnPropertyDescriptor$b = Object.getOwnPropertyDescriptor;
var SILENT_ON_NON_WRITABLE_LENGTH_SET = DESCRIPTORS$I && !function() {
  if (this !== void 0) return true;
  try {
    Object.defineProperty([], "length", {
      writable: false
    }).length = 1;
  } catch (error3) {
    return error3 instanceof TypeError;
  }
}();
var arraySetLength = SILENT_ON_NON_WRITABLE_LENGTH_SET ? function(O, length) {
  if (isArray$5(O) && !getOwnPropertyDescriptor$b(O, "length").writable) {
    throw new $TypeError$C("Cannot set read only .length");
  }
  return O.length = length;
} : function(O, length) {
  return O.length = length;
};
var $$5a = _export;
var toObject$r = toObject$E;
var lengthOfArrayLike$n = lengthOfArrayLike$B;
var setArrayLength$2 = arraySetLength;
var doesNotExceedSafeInteger$4 = doesNotExceedSafeInteger$7;
var fails$1c = fails$1z;
var INCORRECT_TO_LENGTH = fails$1c(function() {
  return [].push.call({
    length: 4294967296
  }, 1) !== 4294967297;
});
var properErrorOnNonWritableLength$1 = function() {
  try {
    Object.defineProperty([], "length", {
      writable: false
    }).push();
  } catch (error3) {
    return error3 instanceof TypeError;
  }
};
var FORCED$B = INCORRECT_TO_LENGTH || !properErrorOnNonWritableLength$1();
$$5a({
  target: "Array",
  proto: true,
  arity: 1,
  forced: FORCED$B
}, {
  // eslint-disable-next-line no-unused-vars -- required for `.length`
  push: function push(item) {
    var O = toObject$r(this);
    var len = lengthOfArrayLike$n(O);
    var argCount = arguments.length;
    doesNotExceedSafeInteger$4(len + argCount);
    for (var i = 0; i < argCount; i++) {
      O[len] = arguments[i];
      len++;
    }
    setArrayLength$2(O, len);
    return len;
  }
});
var aCallable$K = aCallable$Q;
var toObject$q = toObject$E;
var IndexedObject$3 = indexedObject;
var lengthOfArrayLike$m = lengthOfArrayLike$B;
var $TypeError$B = TypeError;
var REDUCE_EMPTY = "Reduce of empty array with no initial value";
var createMethod$5 = function(IS_RIGHT) {
  return function(that, callbackfn, argumentsLength, memo) {
    var O = toObject$q(that);
    var self2 = IndexedObject$3(O);
    var length = lengthOfArrayLike$m(O);
    aCallable$K(callbackfn);
    if (length === 0 && argumentsLength < 2) throw new $TypeError$B(REDUCE_EMPTY);
    var index = IS_RIGHT ? length - 1 : 0;
    var i = IS_RIGHT ? -1 : 1;
    if (argumentsLength < 2) while (true) {
      if (index in self2) {
        memo = self2[index];
        index += i;
        break;
      }
      index += i;
      if (IS_RIGHT ? index < 0 : length <= index) {
        throw new $TypeError$B(REDUCE_EMPTY);
      }
    }
    for (; IS_RIGHT ? index >= 0 : length > index; index += i) if (index in self2) {
      memo = callbackfn(memo, self2[index], index, O);
    }
    return memo;
  };
};
var arrayReduce = {
  // `Array.prototype.reduce` method
  // https://tc39.es/ecma262/#sec-array.prototype.reduce
  left: createMethod$5(false),
  // `Array.prototype.reduceRight` method
  // https://tc39.es/ecma262/#sec-array.prototype.reduceright
  right: createMethod$5(true)
};
var globalThis$15 = globalThis_1;
var userAgent$6 = environmentUserAgent;
var classof$j = classofRaw$2;
var userAgentStartsWith = function(string) {
  return userAgent$6.slice(0, string.length) === string;
};
var environment = function() {
  if (userAgentStartsWith("Bun/")) return "BUN";
  if (userAgentStartsWith("Cloudflare-Workers")) return "CLOUDFLARE";
  if (userAgentStartsWith("Deno/")) return "DENO";
  if (userAgentStartsWith("Node.js/")) return "NODE";
  if (globalThis$15.Bun && typeof Bun.version == "string") return "BUN";
  if (globalThis$15.Deno && typeof Deno.version == "object") return "DENO";
  if (classof$j(globalThis$15.process) === "process") return "NODE";
  if (globalThis$15.window && globalThis$15.document) return "BROWSER";
  return "REST";
}();
var ENVIRONMENT$3 = environment;
var environmentIsNode = ENVIRONMENT$3 === "NODE";
var $$59 = _export;
var $reduce$1 = arrayReduce.left;
var arrayMethodIsStrict$5 = arrayMethodIsStrict$b;
var CHROME_VERSION$1 = environmentV8Version;
var IS_NODE$5 = environmentIsNode;
var CHROME_BUG$1 = !IS_NODE$5 && CHROME_VERSION$1 > 79 && CHROME_VERSION$1 < 83;
var FORCED$A = CHROME_BUG$1 || !arrayMethodIsStrict$5("reduce");
$$59({
  target: "Array",
  proto: true,
  forced: FORCED$A
}, {
  reduce: function reduce(callbackfn) {
    var length = arguments.length;
    return $reduce$1(this, callbackfn, length, length > 1 ? arguments[1] : void 0);
  }
});
var $$58 = _export;
var $reduceRight$1 = arrayReduce.right;
var arrayMethodIsStrict$4 = arrayMethodIsStrict$b;
var CHROME_VERSION = environmentV8Version;
var IS_NODE$4 = environmentIsNode;
var CHROME_BUG = !IS_NODE$4 && CHROME_VERSION > 79 && CHROME_VERSION < 83;
var FORCED$z = CHROME_BUG || !arrayMethodIsStrict$4("reduceRight");
$$58({
  target: "Array",
  proto: true,
  forced: FORCED$z
}, {
  reduceRight: function reduceRight(callbackfn) {
    return $reduceRight$1(this, callbackfn, arguments.length, arguments.length > 1 ? arguments[1] : void 0);
  }
});
var $$57 = _export;
var uncurryThis$1B = functionUncurryThis;
var isArray$4 = isArray$b;
var nativeReverse = uncurryThis$1B([].reverse);
var test$1 = [1, 2];
$$57({
  target: "Array",
  proto: true,
  forced: String(test$1) === String(test$1.reverse())
}, {
  reverse: function reverse() {
    if (isArray$4(this)) this.length = this.length;
    return nativeReverse(this);
  }
});
var $$56 = _export;
var isArray$3 = isArray$b;
var isConstructor$6 = isConstructor$a;
var isObject$B = isObject$O;
var toAbsoluteIndex$6 = toAbsoluteIndex$a;
var lengthOfArrayLike$l = lengthOfArrayLike$B;
var toIndexedObject$a = toIndexedObject$k;
var createProperty$7 = createProperty$b;
var wellKnownSymbol$A = wellKnownSymbol$S;
var arrayMethodHasSpeciesSupport$1 = arrayMethodHasSpeciesSupport$5;
var nativeSlice = arraySlice$a;
var HAS_SPECIES_SUPPORT$1 = arrayMethodHasSpeciesSupport$1("slice");
var SPECIES$4 = wellKnownSymbol$A("species");
var $Array$a = Array;
var max$7 = Math.max;
$$56({
  target: "Array",
  proto: true,
  forced: !HAS_SPECIES_SUPPORT$1
}, {
  slice: function slice(start2, end) {
    var O = toIndexedObject$a(this);
    var length = lengthOfArrayLike$l(O);
    var k = toAbsoluteIndex$6(start2, length);
    var fin = toAbsoluteIndex$6(end === void 0 ? length : end, length);
    var Constructor2, result, n;
    if (isArray$3(O)) {
      Constructor2 = O.constructor;
      if (isConstructor$6(Constructor2) && (Constructor2 === $Array$a || isArray$3(Constructor2.prototype))) {
        Constructor2 = void 0;
      } else if (isObject$B(Constructor2)) {
        Constructor2 = Constructor2[SPECIES$4];
        if (Constructor2 === null) Constructor2 = void 0;
      }
      if (Constructor2 === $Array$a || Constructor2 === void 0) {
        return nativeSlice(O, k, fin);
      }
    }
    result = new (Constructor2 === void 0 ? $Array$a : Constructor2)(max$7(fin - k, 0));
    for (n = 0; k < fin; k++, n++) if (k in O) createProperty$7(result, n, O[k]);
    result.length = n;
    return result;
  }
});
var $$55 = _export;
var $some$2 = arrayIteration.some;
var arrayMethodIsStrict$3 = arrayMethodIsStrict$b;
var STRICT_METHOD$1 = arrayMethodIsStrict$3("some");
$$55({
  target: "Array",
  proto: true,
  forced: !STRICT_METHOD$1
}, {
  some: function some(callbackfn) {
    return $some$2(this, callbackfn, arguments.length > 1 ? arguments[1] : void 0);
  }
});
var arraySlice$7 = arraySlice$a;
var floor$9 = Math.floor;
var sort$2 = function(array, comparefn) {
  var length = array.length;
  if (length < 8) {
    var i = 1;
    var element, j;
    while (i < length) {
      j = i;
      element = array[i];
      while (j && comparefn(array[j - 1], element) > 0) {
        array[j] = array[--j];
      }
      if (j !== i++) array[j] = element;
    }
  } else {
    var middle = floor$9(length / 2);
    var left = sort$2(arraySlice$7(array, 0, middle), comparefn);
    var right = sort$2(arraySlice$7(array, middle), comparefn);
    var llength = left.length;
    var rlength = right.length;
    var lindex = 0;
    var rindex = 0;
    while (lindex < llength || rindex < rlength) {
      array[lindex + rindex] = lindex < llength && rindex < rlength ? comparefn(left[lindex], right[rindex]) <= 0 ? left[lindex++] : right[rindex++] : lindex < llength ? left[lindex++] : right[rindex++];
    }
  }
  return array;
};
var arraySort$1 = sort$2;
var userAgent$5 = environmentUserAgent;
var firefox = userAgent$5.match(/firefox\/(\d+)/i);
var environmentFfVersion = !!firefox && +firefox[1];
var UA = environmentUserAgent;
var environmentIsIeOrEdge = /MSIE|Trident/.test(UA);
var userAgent$4 = environmentUserAgent;
var webkit = userAgent$4.match(/AppleWebKit\/(\d+)\./);
var environmentWebkitVersion = !!webkit && +webkit[1];
var $$54 = _export;
var uncurryThis$1A = functionUncurryThis;
var aCallable$J = aCallable$Q;
var toObject$p = toObject$E;
var lengthOfArrayLike$k = lengthOfArrayLike$B;
var deletePropertyOrThrow$2 = deletePropertyOrThrow$4;
var toString$E = toString$J;
var fails$1b = fails$1z;
var internalSort$1 = arraySort$1;
var arrayMethodIsStrict$2 = arrayMethodIsStrict$b;
var FF$1 = environmentFfVersion;
var IE_OR_EDGE$1 = environmentIsIeOrEdge;
var V8$2 = environmentV8Version;
var WEBKIT$2 = environmentWebkitVersion;
var test = [];
var nativeSort$1 = uncurryThis$1A(test.sort);
var push$n = uncurryThis$1A(test.push);
var FAILS_ON_UNDEFINED = fails$1b(function() {
  test.sort(void 0);
});
var FAILS_ON_NULL = fails$1b(function() {
  test.sort(null);
});
var STRICT_METHOD = arrayMethodIsStrict$2("sort");
var STABLE_SORT$1 = !fails$1b(function() {
  if (V8$2) return V8$2 < 70;
  if (FF$1 && FF$1 > 3) return;
  if (IE_OR_EDGE$1) return true;
  if (WEBKIT$2) return WEBKIT$2 < 603;
  var result = "";
  var code2, chr, value, index;
  for (code2 = 65; code2 < 76; code2++) {
    chr = String.fromCharCode(code2);
    switch (code2) {
      case 66:
      case 69:
      case 70:
      case 72:
        value = 3;
        break;
      case 68:
      case 71:
        value = 4;
        break;
      default:
        value = 2;
    }
    for (index = 0; index < 47; index++) {
      test.push({
        k: chr + index,
        v: value
      });
    }
  }
  test.sort(function(a, b) {
    return b.v - a.v;
  });
  for (index = 0; index < test.length; index++) {
    chr = test[index].k.charAt(0);
    if (result.charAt(result.length - 1) !== chr) result += chr;
  }
  return result !== "DGBEFHACIJK";
});
var FORCED$y = FAILS_ON_UNDEFINED || !FAILS_ON_NULL || !STRICT_METHOD || !STABLE_SORT$1;
var getSortCompare$1 = function(comparefn) {
  return function(x, y) {
    if (y === void 0) return -1;
    if (x === void 0) return 1;
    if (comparefn !== void 0) return +comparefn(x, y) || 0;
    return toString$E(x) > toString$E(y) ? 1 : -1;
  };
};
$$54({
  target: "Array",
  proto: true,
  forced: FORCED$y
}, {
  sort: function sort(comparefn) {
    if (comparefn !== void 0) aCallable$J(comparefn);
    var array = toObject$p(this);
    if (STABLE_SORT$1) return comparefn === void 0 ? nativeSort$1(array) : nativeSort$1(array, comparefn);
    var items = [];
    var arrayLength = lengthOfArrayLike$k(array);
    var itemsLength, index;
    for (index = 0; index < arrayLength; index++) {
      if (index in array) push$n(items, array[index]);
    }
    internalSort$1(items, getSortCompare$1(comparefn));
    itemsLength = lengthOfArrayLike$k(items);
    index = 0;
    while (index < itemsLength) array[index] = items[index++];
    while (index < arrayLength) deletePropertyOrThrow$2(array, index++);
    return array;
  }
});
var getBuiltIn$F = getBuiltIn$Q;
var defineBuiltInAccessor$m = defineBuiltInAccessor$p;
var wellKnownSymbol$z = wellKnownSymbol$S;
var DESCRIPTORS$H = descriptors;
var SPECIES$3 = wellKnownSymbol$z("species");
var setSpecies$7 = function(CONSTRUCTOR_NAME) {
  var Constructor2 = getBuiltIn$F(CONSTRUCTOR_NAME);
  if (DESCRIPTORS$H && Constructor2 && !Constructor2[SPECIES$3]) {
    defineBuiltInAccessor$m(Constructor2, SPECIES$3, {
      configurable: true,
      get: function() {
        return this;
      }
    });
  }
};
var setSpecies$6 = setSpecies$7;
setSpecies$6("Array");
var $$53 = _export;
var toObject$o = toObject$E;
var toAbsoluteIndex$5 = toAbsoluteIndex$a;
var toIntegerOrInfinity$j = toIntegerOrInfinity$p;
var lengthOfArrayLike$j = lengthOfArrayLike$B;
var setArrayLength$1 = arraySetLength;
var doesNotExceedSafeInteger$3 = doesNotExceedSafeInteger$7;
var arraySpeciesCreate = arraySpeciesCreate$5;
var createProperty$6 = createProperty$b;
var deletePropertyOrThrow$1 = deletePropertyOrThrow$4;
var arrayMethodHasSpeciesSupport = arrayMethodHasSpeciesSupport$5;
var HAS_SPECIES_SUPPORT = arrayMethodHasSpeciesSupport("splice");
var max$6 = Math.max;
var min$a = Math.min;
$$53({
  target: "Array",
  proto: true,
  forced: !HAS_SPECIES_SUPPORT
}, {
  splice: function splice(start2, deleteCount) {
    var O = toObject$o(this);
    var len = lengthOfArrayLike$j(O);
    var actualStart = toAbsoluteIndex$5(start2, len);
    var argumentsLength = arguments.length;
    var insertCount, actualDeleteCount, A, k, from7, to;
    if (argumentsLength === 0) {
      insertCount = actualDeleteCount = 0;
    } else if (argumentsLength === 1) {
      insertCount = 0;
      actualDeleteCount = len - actualStart;
    } else {
      insertCount = argumentsLength - 2;
      actualDeleteCount = min$a(max$6(toIntegerOrInfinity$j(deleteCount), 0), len - actualStart);
    }
    doesNotExceedSafeInteger$3(len + insertCount - actualDeleteCount);
    A = arraySpeciesCreate(O, actualDeleteCount);
    for (k = 0; k < actualDeleteCount; k++) {
      from7 = actualStart + k;
      if (from7 in O) createProperty$6(A, k, O[from7]);
    }
    A.length = actualDeleteCount;
    if (insertCount < actualDeleteCount) {
      for (k = actualStart; k < len - actualDeleteCount; k++) {
        from7 = k + actualDeleteCount;
        to = k + insertCount;
        if (from7 in O) O[to] = O[from7];
        else deletePropertyOrThrow$1(O, to);
      }
      for (k = len; k > len - actualDeleteCount + insertCount; k--) deletePropertyOrThrow$1(O, k - 1);
    } else if (insertCount > actualDeleteCount) {
      for (k = len - actualDeleteCount; k > actualStart; k--) {
        from7 = k + actualDeleteCount - 1;
        to = k + insertCount - 1;
        if (from7 in O) O[to] = O[from7];
        else deletePropertyOrThrow$1(O, to);
      }
    }
    for (k = 0; k < insertCount; k++) {
      O[k + actualStart] = arguments[k + 2];
    }
    setArrayLength$1(O, len - actualDeleteCount + insertCount);
    return A;
  }
});
var lengthOfArrayLike$i = lengthOfArrayLike$B;
var arrayToReversed$2 = function(O, C) {
  var len = lengthOfArrayLike$i(O);
  var A = new C(len);
  var k = 0;
  for (; k < len; k++) A[k] = O[len - k - 1];
  return A;
};
var $$52 = _export;
var arrayToReversed$1 = arrayToReversed$2;
var toIndexedObject$9 = toIndexedObject$k;
var addToUnscopables$d = addToUnscopables$n;
var $Array$9 = Array;
$$52({
  target: "Array",
  proto: true
}, {
  toReversed: function toReversed() {
    return arrayToReversed$1(toIndexedObject$9(this), $Array$9);
  }
});
addToUnscopables$d("toReversed");
var lengthOfArrayLike$h = lengthOfArrayLike$B;
var arrayFromConstructorAndList$8 = function(Constructor2, list, $length) {
  var index = 0;
  var length = arguments.length > 2 ? $length : lengthOfArrayLike$h(list);
  var result = new Constructor2(length);
  while (length > index) result[index] = list[index++];
  return result;
};
var globalThis$14 = globalThis_1;
var getBuiltInPrototypeMethod$2 = function(CONSTRUCTOR2, METHOD) {
  var Constructor2 = globalThis$14[CONSTRUCTOR2];
  var Prototype2 = Constructor2 && Constructor2.prototype;
  return Prototype2 && Prototype2[METHOD];
};
var $$51 = _export;
var uncurryThis$1z = functionUncurryThis;
var aCallable$I = aCallable$Q;
var toIndexedObject$8 = toIndexedObject$k;
var arrayFromConstructorAndList$7 = arrayFromConstructorAndList$8;
var getBuiltInPrototypeMethod$1 = getBuiltInPrototypeMethod$2;
var addToUnscopables$c = addToUnscopables$n;
var $Array$8 = Array;
var sort$1 = uncurryThis$1z(getBuiltInPrototypeMethod$1("Array", "sort"));
$$51({
  target: "Array",
  proto: true
}, {
  toSorted: function toSorted(compareFn) {
    if (compareFn !== void 0) aCallable$I(compareFn);
    var O = toIndexedObject$8(this);
    var A = arrayFromConstructorAndList$7($Array$8, O);
    return sort$1(A, compareFn);
  }
});
addToUnscopables$c("toSorted");
var $$50 = _export;
var addToUnscopables$b = addToUnscopables$n;
var doesNotExceedSafeInteger$2 = doesNotExceedSafeInteger$7;
var lengthOfArrayLike$g = lengthOfArrayLike$B;
var toAbsoluteIndex$4 = toAbsoluteIndex$a;
var toIndexedObject$7 = toIndexedObject$k;
var toIntegerOrInfinity$i = toIntegerOrInfinity$p;
var $Array$7 = Array;
var max$5 = Math.max;
var min$9 = Math.min;
$$50({
  target: "Array",
  proto: true
}, {
  toSpliced: function toSpliced(start2, deleteCount) {
    var O = toIndexedObject$7(this);
    var len = lengthOfArrayLike$g(O);
    var actualStart = toAbsoluteIndex$4(start2, len);
    var argumentsLength = arguments.length;
    var k = 0;
    var insertCount, actualDeleteCount, newLen, A;
    if (argumentsLength === 0) {
      insertCount = actualDeleteCount = 0;
    } else if (argumentsLength === 1) {
      insertCount = 0;
      actualDeleteCount = len - actualStart;
    } else {
      insertCount = argumentsLength - 2;
      actualDeleteCount = min$9(max$5(toIntegerOrInfinity$i(deleteCount), 0), len - actualStart);
    }
    newLen = doesNotExceedSafeInteger$2(len + insertCount - actualDeleteCount);
    A = $Array$7(newLen);
    for (; k < actualStart; k++) A[k] = O[k];
    for (; k < actualStart + insertCount; k++) A[k] = arguments[k - actualStart + 2];
    for (; k < newLen; k++) A[k] = O[k + actualDeleteCount - insertCount];
    return A;
  }
});
addToUnscopables$b("toSpliced");
var addToUnscopables$a = addToUnscopables$n;
addToUnscopables$a("flat");
var addToUnscopables$9 = addToUnscopables$n;
addToUnscopables$9("flatMap");
var $$4$ = _export;
var toObject$n = toObject$E;
var lengthOfArrayLike$f = lengthOfArrayLike$B;
var setArrayLength = arraySetLength;
var deletePropertyOrThrow = deletePropertyOrThrow$4;
var doesNotExceedSafeInteger$1 = doesNotExceedSafeInteger$7;
var INCORRECT_RESULT = [].unshift(0) !== 1;
var properErrorOnNonWritableLength = function() {
  try {
    Object.defineProperty([], "length", {
      writable: false
    }).unshift();
  } catch (error3) {
    return error3 instanceof TypeError;
  }
};
var FORCED$x = INCORRECT_RESULT || !properErrorOnNonWritableLength();
$$4$({
  target: "Array",
  proto: true,
  arity: 1,
  forced: FORCED$x
}, {
  // eslint-disable-next-line no-unused-vars -- required for `.length`
  unshift: function unshift(item) {
    var O = toObject$n(this);
    var len = lengthOfArrayLike$f(O);
    var argCount = arguments.length;
    if (argCount) {
      doesNotExceedSafeInteger$1(len + argCount);
      var k = len;
      while (k--) {
        var to = k + argCount;
        if (k in O) O[to] = O[k];
        else deletePropertyOrThrow(O, to);
      }
      for (var j = 0; j < argCount; j++) {
        O[j] = arguments[j];
      }
    }
    return setArrayLength(O, len + argCount);
  }
});
var lengthOfArrayLike$e = lengthOfArrayLike$B;
var toIntegerOrInfinity$h = toIntegerOrInfinity$p;
var $RangeError$f = RangeError;
var arrayWith$2 = function(O, C, index, value) {
  var len = lengthOfArrayLike$e(O);
  var relativeIndex = toIntegerOrInfinity$h(index);
  var actualIndex = relativeIndex < 0 ? len + relativeIndex : relativeIndex;
  if (actualIndex >= len || actualIndex < 0) throw new $RangeError$f("Incorrect index");
  var A = new C(len);
  var k = 0;
  for (; k < len; k++) A[k] = k === actualIndex ? value : O[k];
  return A;
};
var $$4_ = _export;
var arrayWith$1 = arrayWith$2;
var toIndexedObject$6 = toIndexedObject$k;
var $Array$6 = Array;
$$4_({
  target: "Array",
  proto: true
}, {
  "with": function(index, value) {
    return arrayWith$1(toIndexedObject$6(this), $Array$6, index, value);
  }
});
var arrayBufferBasicDetection = typeof ArrayBuffer != "undefined" && typeof DataView != "undefined";
var defineBuiltIn$n = defineBuiltIn$u;
var defineBuiltIns$b = function(target, src, options) {
  for (var key in src) defineBuiltIn$n(target, key, src[key], options);
  return target;
};
var isPrototypeOf$9 = objectIsPrototypeOf;
var $TypeError$A = TypeError;
var anInstance$f = function(it, Prototype2) {
  if (isPrototypeOf$9(Prototype2, it)) return it;
  throw new $TypeError$A("Incorrect invocation");
};
var toIntegerOrInfinity$g = toIntegerOrInfinity$p;
var toLength$b = toLength$d;
var $RangeError$e = RangeError;
var toIndex$5 = function(it) {
  if (it === void 0) return 0;
  var number = toIntegerOrInfinity$g(it);
  var length = toLength$b(number);
  if (number !== length) throw new $RangeError$e("Wrong length or index");
  return length;
};
var mathSign = Math.sign || function sign(x) {
  var n = +x;
  return n === 0 || n !== n ? n : n < 0 ? -1 : 1;
};
var EPSILON$1 = 2220446049250313e-31;
var INVERSE_EPSILON = 1 / EPSILON$1;
var mathRoundTiesToEven = function(n) {
  return n + INVERSE_EPSILON - INVERSE_EPSILON;
};
var sign$2 = mathSign;
var roundTiesToEven$1 = mathRoundTiesToEven;
var abs$9 = Math.abs;
var EPSILON = 2220446049250313e-31;
var mathFloatRound = function(x, FLOAT_EPSILON, FLOAT_MAX_VALUE, FLOAT_MIN_VALUE) {
  var n = +x;
  var absolute = abs$9(n);
  var s = sign$2(n);
  if (absolute < FLOAT_MIN_VALUE) return s * roundTiesToEven$1(absolute / FLOAT_MIN_VALUE / FLOAT_EPSILON) * FLOAT_MIN_VALUE * FLOAT_EPSILON;
  var a = (1 + FLOAT_EPSILON / EPSILON) * absolute;
  var result = a - (a - absolute);
  if (result > FLOAT_MAX_VALUE || result !== result) return s * Infinity;
  return s * result;
};
var floatRound$1 = mathFloatRound;
var FLOAT32_EPSILON = 11920928955078125e-23;
var FLOAT32_MAX_VALUE = 34028234663852886e22;
var FLOAT32_MIN_VALUE = 11754943508222875e-54;
var mathFround = Math.fround || function fround(x) {
  return floatRound$1(x, FLOAT32_EPSILON, FLOAT32_MAX_VALUE, FLOAT32_MIN_VALUE);
};
var $Array$5 = Array;
var abs$8 = Math.abs;
var pow$8 = Math.pow;
var floor$8 = Math.floor;
var log$8 = Math.log;
var LN2$2 = Math.LN2;
var pack = function(number, mantissaLength, bytes) {
  var buffer2 = $Array$5(bytes);
  var exponentLength = bytes * 8 - mantissaLength - 1;
  var eMax = (1 << exponentLength) - 1;
  var eBias = eMax >> 1;
  var rt = mantissaLength === 23 ? pow$8(2, -24) - pow$8(2, -77) : 0;
  var sign3 = number < 0 || number === 0 && 1 / number < 0 ? 1 : 0;
  var index = 0;
  var exponent, mantissa, c;
  number = abs$8(number);
  if (number !== number || number === Infinity) {
    mantissa = number !== number ? 1 : 0;
    exponent = eMax;
  } else {
    exponent = floor$8(log$8(number) / LN2$2);
    c = pow$8(2, -exponent);
    if (number * c < 1) {
      exponent--;
      c *= 2;
    }
    if (exponent + eBias >= 1) {
      number += rt / c;
    } else {
      number += rt * pow$8(2, 1 - eBias);
    }
    if (number * c >= 2) {
      exponent++;
      c /= 2;
    }
    if (exponent + eBias >= eMax) {
      mantissa = 0;
      exponent = eMax;
    } else if (exponent + eBias >= 1) {
      mantissa = (number * c - 1) * pow$8(2, mantissaLength);
      exponent += eBias;
    } else {
      mantissa = number * pow$8(2, eBias - 1) * pow$8(2, mantissaLength);
      exponent = 0;
    }
  }
  while (mantissaLength >= 8) {
    buffer2[index++] = mantissa & 255;
    mantissa /= 256;
    mantissaLength -= 8;
  }
  exponent = exponent << mantissaLength | mantissa;
  exponentLength += mantissaLength;
  while (exponentLength > 0) {
    buffer2[index++] = exponent & 255;
    exponent /= 256;
    exponentLength -= 8;
  }
  buffer2[index - 1] |= sign3 * 128;
  return buffer2;
};
var unpack = function(buffer2, mantissaLength) {
  var bytes = buffer2.length;
  var exponentLength = bytes * 8 - mantissaLength - 1;
  var eMax = (1 << exponentLength) - 1;
  var eBias = eMax >> 1;
  var nBits = exponentLength - 7;
  var index = bytes - 1;
  var sign3 = buffer2[index--];
  var exponent = sign3 & 127;
  var mantissa;
  sign3 >>= 7;
  while (nBits > 0) {
    exponent = exponent * 256 + buffer2[index--];
    nBits -= 8;
  }
  mantissa = exponent & (1 << -nBits) - 1;
  exponent >>= -nBits;
  nBits += mantissaLength;
  while (nBits > 0) {
    mantissa = mantissa * 256 + buffer2[index--];
    nBits -= 8;
  }
  if (exponent === 0) {
    exponent = 1 - eBias;
  } else if (exponent === eMax) {
    return mantissa ? NaN : sign3 ? -Infinity : Infinity;
  } else {
    mantissa += pow$8(2, mantissaLength);
    exponent -= eBias;
  }
  return (sign3 ? -1 : 1) * mantissa * pow$8(2, exponent - mantissaLength);
};
var ieee754 = {
  pack,
  unpack
};
var globalThis$13 = globalThis_1;
var uncurryThis$1y = functionUncurryThis;
var DESCRIPTORS$G = descriptors;
var NATIVE_ARRAY_BUFFER$3 = arrayBufferBasicDetection;
var FunctionName = functionName;
var createNonEnumerableProperty$b = createNonEnumerableProperty$j;
var defineBuiltInAccessor$l = defineBuiltInAccessor$p;
var defineBuiltIns$a = defineBuiltIns$b;
var fails$1a = fails$1z;
var anInstance$e = anInstance$f;
var toIntegerOrInfinity$f = toIntegerOrInfinity$p;
var toLength$a = toLength$d;
var toIndex$4 = toIndex$5;
var fround$2 = mathFround;
var IEEE754 = ieee754;
var getPrototypeOf$d = objectGetPrototypeOf$2;
var setPrototypeOf$6 = objectSetPrototypeOf$1;
var arrayFill = arrayFill$1;
var arraySlice$6 = arraySlice$a;
var inheritIfRequired$5 = inheritIfRequired$7;
var copyConstructorProperties$2 = copyConstructorProperties$7;
var setToStringTag$9 = setToStringTag$e;
var InternalStateModule$k = internalState;
var PROPER_FUNCTION_NAME$2 = FunctionName.PROPER;
var CONFIGURABLE_FUNCTION_NAME = FunctionName.CONFIGURABLE;
var ARRAY_BUFFER$1 = "ArrayBuffer";
var DATA_VIEW = "DataView";
var PROTOTYPE = "prototype";
var WRONG_LENGTH$1 = "Wrong length";
var WRONG_INDEX = "Wrong index";
var getInternalArrayBufferState = InternalStateModule$k.getterFor(ARRAY_BUFFER$1);
var getInternalDataViewState = InternalStateModule$k.getterFor(DATA_VIEW);
var setInternalState$k = InternalStateModule$k.set;
var NativeArrayBuffer$1 = globalThis$13[ARRAY_BUFFER$1];
var $ArrayBuffer$1 = NativeArrayBuffer$1;
var ArrayBufferPrototype$3 = $ArrayBuffer$1 && $ArrayBuffer$1[PROTOTYPE];
var $DataView = globalThis$13[DATA_VIEW];
var DataViewPrototype$2 = $DataView && $DataView[PROTOTYPE];
var ObjectPrototype$3 = Object.prototype;
var Array$3 = globalThis$13.Array;
var RangeError$3 = globalThis$13.RangeError;
var fill2 = uncurryThis$1y(arrayFill);
var reverse2 = uncurryThis$1y([].reverse);
var packIEEE754 = IEEE754.pack;
var unpackIEEE754 = IEEE754.unpack;
var packInt8 = function(number) {
  return [number & 255];
};
var packInt16 = function(number) {
  return [number & 255, number >> 8 & 255];
};
var packInt32 = function(number) {
  return [number & 255, number >> 8 & 255, number >> 16 & 255, number >> 24 & 255];
};
var unpackInt32 = function(buffer2) {
  return buffer2[3] << 24 | buffer2[2] << 16 | buffer2[1] << 8 | buffer2[0];
};
var packFloat32 = function(number) {
  return packIEEE754(fround$2(number), 23, 4);
};
var packFloat64 = function(number) {
  return packIEEE754(number, 52, 8);
};
var addGetter$2 = function(Constructor2, key, getInternalState2) {
  defineBuiltInAccessor$l(Constructor2[PROTOTYPE], key, {
    configurable: true,
    get: function() {
      return getInternalState2(this)[key];
    }
  });
};
var get$9 = function(view, count, index, isLittleEndian) {
  var store2 = getInternalDataViewState(view);
  var intIndex = toIndex$4(index);
  var boolIsLittleEndian = !!isLittleEndian;
  if (intIndex + count > store2.byteLength) throw new RangeError$3(WRONG_INDEX);
  var bytes = store2.bytes;
  var start2 = intIndex + store2.byteOffset;
  var pack2 = arraySlice$6(bytes, start2, start2 + count);
  return boolIsLittleEndian ? pack2 : reverse2(pack2);
};
var set$e = function(view, count, index, conversion, value, isLittleEndian) {
  var store2 = getInternalDataViewState(view);
  var intIndex = toIndex$4(index);
  var pack2 = conversion(+value);
  var boolIsLittleEndian = !!isLittleEndian;
  if (intIndex + count > store2.byteLength) throw new RangeError$3(WRONG_INDEX);
  var bytes = store2.bytes;
  var start2 = intIndex + store2.byteOffset;
  for (var i = 0; i < count; i++) bytes[start2 + i] = pack2[boolIsLittleEndian ? i : count - i - 1];
};
if (!NATIVE_ARRAY_BUFFER$3) {
  $ArrayBuffer$1 = function ArrayBuffer2(length) {
    anInstance$e(this, ArrayBufferPrototype$3);
    var byteLength2 = toIndex$4(length);
    setInternalState$k(this, {
      type: ARRAY_BUFFER$1,
      bytes: fill2(Array$3(byteLength2), 0),
      byteLength: byteLength2
    });
    if (!DESCRIPTORS$G) {
      this.byteLength = byteLength2;
      this.detached = false;
    }
  };
  ArrayBufferPrototype$3 = $ArrayBuffer$1[PROTOTYPE];
  $DataView = function DataView2(buffer2, byteOffset, byteLength2) {
    anInstance$e(this, DataViewPrototype$2);
    anInstance$e(buffer2, ArrayBufferPrototype$3);
    var bufferState = getInternalArrayBufferState(buffer2);
    var bufferLength = bufferState.byteLength;
    var offset = toIntegerOrInfinity$f(byteOffset);
    if (offset < 0 || offset > bufferLength) throw new RangeError$3("Wrong offset");
    byteLength2 = byteLength2 === void 0 ? bufferLength - offset : toLength$a(byteLength2);
    if (offset + byteLength2 > bufferLength) throw new RangeError$3(WRONG_LENGTH$1);
    setInternalState$k(this, {
      type: DATA_VIEW,
      buffer: buffer2,
      byteLength: byteLength2,
      byteOffset: offset,
      bytes: bufferState.bytes
    });
    if (!DESCRIPTORS$G) {
      this.buffer = buffer2;
      this.byteLength = byteLength2;
      this.byteOffset = offset;
    }
  };
  DataViewPrototype$2 = $DataView[PROTOTYPE];
  if (DESCRIPTORS$G) {
    addGetter$2($ArrayBuffer$1, "byteLength", getInternalArrayBufferState);
    addGetter$2($DataView, "buffer", getInternalDataViewState);
    addGetter$2($DataView, "byteLength", getInternalDataViewState);
    addGetter$2($DataView, "byteOffset", getInternalDataViewState);
  }
  defineBuiltIns$a(DataViewPrototype$2, {
    getInt8: function getInt82(byteOffset) {
      return get$9(this, 1, byteOffset)[0] << 24 >> 24;
    },
    getUint8: function getUint82(byteOffset) {
      return get$9(this, 1, byteOffset)[0];
    },
    getInt16: function getInt16(byteOffset) {
      var bytes = get$9(this, 2, byteOffset, arguments.length > 1 ? arguments[1] : false);
      return (bytes[1] << 8 | bytes[0]) << 16 >> 16;
    },
    getUint16: function getUint162(byteOffset) {
      var bytes = get$9(this, 2, byteOffset, arguments.length > 1 ? arguments[1] : false);
      return bytes[1] << 8 | bytes[0];
    },
    getInt32: function getInt32(byteOffset) {
      return unpackInt32(get$9(this, 4, byteOffset, arguments.length > 1 ? arguments[1] : false));
    },
    getUint32: function getUint32(byteOffset) {
      return unpackInt32(get$9(this, 4, byteOffset, arguments.length > 1 ? arguments[1] : false)) >>> 0;
    },
    getFloat32: function getFloat32(byteOffset) {
      return unpackIEEE754(get$9(this, 4, byteOffset, arguments.length > 1 ? arguments[1] : false), 23);
    },
    getFloat64: function getFloat64(byteOffset) {
      return unpackIEEE754(get$9(this, 8, byteOffset, arguments.length > 1 ? arguments[1] : false), 52);
    },
    setInt8: function setInt82(byteOffset, value) {
      set$e(this, 1, byteOffset, packInt8, value);
    },
    setUint8: function setUint82(byteOffset, value) {
      set$e(this, 1, byteOffset, packInt8, value);
    },
    setInt16: function setInt16(byteOffset, value) {
      set$e(this, 2, byteOffset, packInt16, value, arguments.length > 2 ? arguments[2] : false);
    },
    setUint16: function setUint162(byteOffset, value) {
      set$e(this, 2, byteOffset, packInt16, value, arguments.length > 2 ? arguments[2] : false);
    },
    setInt32: function setInt32(byteOffset, value) {
      set$e(this, 4, byteOffset, packInt32, value, arguments.length > 2 ? arguments[2] : false);
    },
    setUint32: function setUint32(byteOffset, value) {
      set$e(this, 4, byteOffset, packInt32, value, arguments.length > 2 ? arguments[2] : false);
    },
    setFloat32: function setFloat32(byteOffset, value) {
      set$e(this, 4, byteOffset, packFloat32, value, arguments.length > 2 ? arguments[2] : false);
    },
    setFloat64: function setFloat64(byteOffset, value) {
      set$e(this, 8, byteOffset, packFloat64, value, arguments.length > 2 ? arguments[2] : false);
    }
  });
} else {
  var INCORRECT_ARRAY_BUFFER_NAME = PROPER_FUNCTION_NAME$2 && NativeArrayBuffer$1.name !== ARRAY_BUFFER$1;
  if (!fails$1a(function() {
    NativeArrayBuffer$1(1);
  }) || !fails$1a(function() {
    new NativeArrayBuffer$1(-1);
  }) || fails$1a(function() {
    new NativeArrayBuffer$1();
    new NativeArrayBuffer$1(1.5);
    new NativeArrayBuffer$1(NaN);
    return NativeArrayBuffer$1.length !== 1 || INCORRECT_ARRAY_BUFFER_NAME && !CONFIGURABLE_FUNCTION_NAME;
  })) {
    $ArrayBuffer$1 = function ArrayBuffer2(length) {
      anInstance$e(this, ArrayBufferPrototype$3);
      return inheritIfRequired$5(new NativeArrayBuffer$1(toIndex$4(length)), this, $ArrayBuffer$1);
    };
    $ArrayBuffer$1[PROTOTYPE] = ArrayBufferPrototype$3;
    ArrayBufferPrototype$3.constructor = $ArrayBuffer$1;
    copyConstructorProperties$2($ArrayBuffer$1, NativeArrayBuffer$1);
  } else if (INCORRECT_ARRAY_BUFFER_NAME && CONFIGURABLE_FUNCTION_NAME) {
    createNonEnumerableProperty$b(NativeArrayBuffer$1, "name", ARRAY_BUFFER$1);
  }
  if (setPrototypeOf$6 && getPrototypeOf$d(DataViewPrototype$2) !== ObjectPrototype$3) {
    setPrototypeOf$6(DataViewPrototype$2, ObjectPrototype$3);
  }
  var testView = new $DataView(new $ArrayBuffer$1(2));
  var $setInt8 = uncurryThis$1y(DataViewPrototype$2.setInt8);
  testView.setInt8(0, 2147483648);
  testView.setInt8(1, 2147483649);
  if (testView.getInt8(0) || !testView.getInt8(1)) defineBuiltIns$a(DataViewPrototype$2, {
    setInt8: function setInt82(byteOffset, value) {
      $setInt8(this, byteOffset, value << 24 >> 24);
    },
    setUint8: function setUint82(byteOffset, value) {
      $setInt8(this, byteOffset, value << 24 >> 24);
    }
  }, {
    unsafe: true
  });
}
setToStringTag$9($ArrayBuffer$1, ARRAY_BUFFER$1);
setToStringTag$9($DataView, DATA_VIEW);
var arrayBuffer = {
  ArrayBuffer: $ArrayBuffer$1,
  DataView: $DataView
};
var $$4Z = _export;
var globalThis$12 = globalThis_1;
var arrayBufferModule = arrayBuffer;
var setSpecies$5 = setSpecies$7;
var ARRAY_BUFFER = "ArrayBuffer";
var ArrayBuffer$6 = arrayBufferModule[ARRAY_BUFFER];
var NativeArrayBuffer = globalThis$12[ARRAY_BUFFER];
$$4Z({
  global: true,
  constructor: true,
  forced: NativeArrayBuffer !== ArrayBuffer$6
}, {
  ArrayBuffer: ArrayBuffer$6
});
setSpecies$5(ARRAY_BUFFER);
var NATIVE_ARRAY_BUFFER$2 = arrayBufferBasicDetection;
var DESCRIPTORS$F = descriptors;
var globalThis$11 = globalThis_1;
var isCallable$o = isCallable$I;
var isObject$A = isObject$O;
var hasOwn$r = hasOwnProperty_1;
var classof$i = classof$q;
var tryToString$1 = tryToString$7;
var createNonEnumerableProperty$a = createNonEnumerableProperty$j;
var defineBuiltIn$m = defineBuiltIn$u;
var defineBuiltInAccessor$k = defineBuiltInAccessor$p;
var isPrototypeOf$8 = objectIsPrototypeOf;
var getPrototypeOf$c = objectGetPrototypeOf$2;
var setPrototypeOf$5 = objectSetPrototypeOf$1;
var wellKnownSymbol$y = wellKnownSymbol$S;
var uid$3 = uid$7;
var InternalStateModule$j = internalState;
var enforceInternalState$3 = InternalStateModule$j.enforce;
var getInternalState$d = InternalStateModule$j.get;
var Int8Array$4 = globalThis$11.Int8Array;
var Int8ArrayPrototype$1 = Int8Array$4 && Int8Array$4.prototype;
var Uint8ClampedArray$1 = globalThis$11.Uint8ClampedArray;
var Uint8ClampedArrayPrototype = Uint8ClampedArray$1 && Uint8ClampedArray$1.prototype;
var TypedArray$1 = Int8Array$4 && getPrototypeOf$c(Int8Array$4);
var TypedArrayPrototype$2 = Int8ArrayPrototype$1 && getPrototypeOf$c(Int8ArrayPrototype$1);
var ObjectPrototype$2 = Object.prototype;
var TypeError$8 = globalThis$11.TypeError;
var TO_STRING_TAG$7 = wellKnownSymbol$y("toStringTag");
var TYPED_ARRAY_TAG$1 = uid$3("TYPED_ARRAY_TAG");
var TYPED_ARRAY_CONSTRUCTOR = "TypedArrayConstructor";
var NATIVE_ARRAY_BUFFER_VIEWS$3 = NATIVE_ARRAY_BUFFER$2 && !!setPrototypeOf$5 && classof$i(globalThis$11.opera) !== "Opera";
var TYPED_ARRAY_TAG_REQUIRED = false;
var NAME$1, Constructor, Prototype;
var TypedArrayConstructorsList = {
  Int8Array: 1,
  Uint8Array: 1,
  Uint8ClampedArray: 1,
  Int16Array: 2,
  Uint16Array: 2,
  Int32Array: 4,
  Uint32Array: 4,
  Float32Array: 4,
  Float64Array: 8
};
var BigIntArrayConstructorsList = {
  BigInt64Array: 8,
  BigUint64Array: 8
};
var isView = function isView2(it) {
  if (!isObject$A(it)) return false;
  var klass = classof$i(it);
  return klass === "DataView" || hasOwn$r(TypedArrayConstructorsList, klass) || hasOwn$r(BigIntArrayConstructorsList, klass);
};
var getTypedArrayConstructor$a = function(it) {
  var proto = getPrototypeOf$c(it);
  if (!isObject$A(proto)) return;
  var state = getInternalState$d(proto);
  return state && hasOwn$r(state, TYPED_ARRAY_CONSTRUCTOR) ? state[TYPED_ARRAY_CONSTRUCTOR] : getTypedArrayConstructor$a(proto);
};
var isTypedArray$1 = function(it) {
  if (!isObject$A(it)) return false;
  var klass = classof$i(it);
  return hasOwn$r(TypedArrayConstructorsList, klass) || hasOwn$r(BigIntArrayConstructorsList, klass);
};
var aTypedArray$x = function(it) {
  if (isTypedArray$1(it)) return it;
  throw new TypeError$8("Target is not a typed array");
};
var aTypedArrayConstructor$3 = function(C) {
  if (isCallable$o(C) && (!setPrototypeOf$5 || isPrototypeOf$8(TypedArray$1, C))) return C;
  throw new TypeError$8(tryToString$1(C) + " is not a typed array constructor");
};
var exportTypedArrayMethod$y = function(KEY, property, forced, options) {
  if (!DESCRIPTORS$F) return;
  if (forced) for (var ARRAY in TypedArrayConstructorsList) {
    var TypedArrayConstructor = globalThis$11[ARRAY];
    if (TypedArrayConstructor && hasOwn$r(TypedArrayConstructor.prototype, KEY)) try {
      delete TypedArrayConstructor.prototype[KEY];
    } catch (error3) {
      try {
        TypedArrayConstructor.prototype[KEY] = property;
      } catch (error22) {
      }
    }
  }
  if (!TypedArrayPrototype$2[KEY] || forced) {
    defineBuiltIn$m(TypedArrayPrototype$2, KEY, forced ? property : NATIVE_ARRAY_BUFFER_VIEWS$3 && Int8ArrayPrototype$1[KEY] || property, options);
  }
};
var exportTypedArrayStaticMethod$3 = function(KEY, property, forced) {
  var ARRAY, TypedArrayConstructor;
  if (!DESCRIPTORS$F) return;
  if (setPrototypeOf$5) {
    if (forced) for (ARRAY in TypedArrayConstructorsList) {
      TypedArrayConstructor = globalThis$11[ARRAY];
      if (TypedArrayConstructor && hasOwn$r(TypedArrayConstructor, KEY)) try {
        delete TypedArrayConstructor[KEY];
      } catch (error3) {
      }
    }
    if (!TypedArray$1[KEY] || forced) {
      try {
        return defineBuiltIn$m(TypedArray$1, KEY, forced ? property : NATIVE_ARRAY_BUFFER_VIEWS$3 && TypedArray$1[KEY] || property);
      } catch (error3) {
      }
    } else return;
  }
  for (ARRAY in TypedArrayConstructorsList) {
    TypedArrayConstructor = globalThis$11[ARRAY];
    if (TypedArrayConstructor && (!TypedArrayConstructor[KEY] || forced)) {
      defineBuiltIn$m(TypedArrayConstructor, KEY, property);
    }
  }
};
for (NAME$1 in TypedArrayConstructorsList) {
  Constructor = globalThis$11[NAME$1];
  Prototype = Constructor && Constructor.prototype;
  if (Prototype) enforceInternalState$3(Prototype)[TYPED_ARRAY_CONSTRUCTOR] = Constructor;
  else NATIVE_ARRAY_BUFFER_VIEWS$3 = false;
}
for (NAME$1 in BigIntArrayConstructorsList) {
  Constructor = globalThis$11[NAME$1];
  Prototype = Constructor && Constructor.prototype;
  if (Prototype) enforceInternalState$3(Prototype)[TYPED_ARRAY_CONSTRUCTOR] = Constructor;
}
if (!NATIVE_ARRAY_BUFFER_VIEWS$3 || !isCallable$o(TypedArray$1) || TypedArray$1 === Function.prototype) {
  TypedArray$1 = function TypedArray2() {
    throw new TypeError$8("Incorrect invocation");
  };
  if (NATIVE_ARRAY_BUFFER_VIEWS$3) for (NAME$1 in TypedArrayConstructorsList) {
    if (globalThis$11[NAME$1]) setPrototypeOf$5(globalThis$11[NAME$1], TypedArray$1);
  }
}
if (!NATIVE_ARRAY_BUFFER_VIEWS$3 || !TypedArrayPrototype$2 || TypedArrayPrototype$2 === ObjectPrototype$2) {
  TypedArrayPrototype$2 = TypedArray$1.prototype;
  if (NATIVE_ARRAY_BUFFER_VIEWS$3) for (NAME$1 in TypedArrayConstructorsList) {
    if (globalThis$11[NAME$1]) setPrototypeOf$5(globalThis$11[NAME$1].prototype, TypedArrayPrototype$2);
  }
}
if (NATIVE_ARRAY_BUFFER_VIEWS$3 && getPrototypeOf$c(Uint8ClampedArrayPrototype) !== TypedArrayPrototype$2) {
  setPrototypeOf$5(Uint8ClampedArrayPrototype, TypedArrayPrototype$2);
}
if (DESCRIPTORS$F && !hasOwn$r(TypedArrayPrototype$2, TO_STRING_TAG$7)) {
  TYPED_ARRAY_TAG_REQUIRED = true;
  defineBuiltInAccessor$k(TypedArrayPrototype$2, TO_STRING_TAG$7, {
    configurable: true,
    get: function() {
      return isObject$A(this) ? this[TYPED_ARRAY_TAG$1] : void 0;
    }
  });
  for (NAME$1 in TypedArrayConstructorsList) if (globalThis$11[NAME$1]) {
    createNonEnumerableProperty$a(globalThis$11[NAME$1], TYPED_ARRAY_TAG$1, NAME$1);
  }
}
var arrayBufferViewCore = {
  NATIVE_ARRAY_BUFFER_VIEWS: NATIVE_ARRAY_BUFFER_VIEWS$3,
  TYPED_ARRAY_TAG: TYPED_ARRAY_TAG_REQUIRED && TYPED_ARRAY_TAG$1,
  aTypedArray: aTypedArray$x,
  aTypedArrayConstructor: aTypedArrayConstructor$3,
  exportTypedArrayMethod: exportTypedArrayMethod$y,
  exportTypedArrayStaticMethod: exportTypedArrayStaticMethod$3,
  getTypedArrayConstructor: getTypedArrayConstructor$a,
  isView,
  isTypedArray: isTypedArray$1,
  TypedArray: TypedArray$1,
  TypedArrayPrototype: TypedArrayPrototype$2
};
var $$4Y = _export;
var ArrayBufferViewCore$A = arrayBufferViewCore;
var NATIVE_ARRAY_BUFFER_VIEWS$2 = ArrayBufferViewCore$A.NATIVE_ARRAY_BUFFER_VIEWS;
$$4Y({
  target: "ArrayBuffer",
  stat: true,
  forced: !NATIVE_ARRAY_BUFFER_VIEWS$2
}, {
  isView: ArrayBufferViewCore$A.isView
});
var $$4X = _export;
var uncurryThis$1x = functionUncurryThisClause;
var fails$19 = fails$1z;
var ArrayBufferModule$2 = arrayBuffer;
var anObject$17 = anObject$1i;
var toAbsoluteIndex$3 = toAbsoluteIndex$a;
var toLength$9 = toLength$d;
var ArrayBuffer$5 = ArrayBufferModule$2.ArrayBuffer;
var DataView$4 = ArrayBufferModule$2.DataView;
var DataViewPrototype$1 = DataView$4.prototype;
var nativeArrayBufferSlice = uncurryThis$1x(ArrayBuffer$5.prototype.slice);
var getUint8$1 = uncurryThis$1x(DataViewPrototype$1.getUint8);
var setUint8$1 = uncurryThis$1x(DataViewPrototype$1.setUint8);
var INCORRECT_SLICE = fails$19(function() {
  return !new ArrayBuffer$5(2).slice(1, void 0).byteLength;
});
$$4X({
  target: "ArrayBuffer",
  proto: true,
  unsafe: true,
  forced: INCORRECT_SLICE
}, {
  slice: function slice2(start2, end) {
    if (nativeArrayBufferSlice && end === void 0) {
      return nativeArrayBufferSlice(anObject$17(this), start2);
    }
    var length = anObject$17(this).byteLength;
    var first = toAbsoluteIndex$3(start2, length);
    var fin = toAbsoluteIndex$3(end === void 0 ? length : end, length);
    var result = new ArrayBuffer$5(toLength$9(fin - first));
    var viewSource = new DataView$4(this);
    var viewTarget = new DataView$4(result);
    var index = 0;
    while (first < fin) {
      setUint8$1(viewTarget, index++, getUint8$1(viewSource, first++));
    }
    return result;
  }
});
var $$4W = _export;
var ArrayBufferModule$1 = arrayBuffer;
var NATIVE_ARRAY_BUFFER$1 = arrayBufferBasicDetection;
$$4W({
  global: true,
  constructor: true,
  forced: !NATIVE_ARRAY_BUFFER$1
}, {
  DataView: ArrayBufferModule$1.DataView
});
var $$4V = _export;
var uncurryThis$1w = functionUncurryThis;
var pow$7 = Math.pow;
var EXP_MASK16 = 31;
var SIGNIFICAND_MASK16 = 1023;
var MIN_SUBNORMAL16 = pow$7(2, -24);
var SIGNIFICAND_DENOM16 = 9765625e-10;
var unpackFloat16 = function(bytes) {
  var sign3 = bytes >>> 15;
  var exponent = bytes >>> 10 & EXP_MASK16;
  var significand = bytes & SIGNIFICAND_MASK16;
  if (exponent === EXP_MASK16) return significand === 0 ? sign3 === 0 ? Infinity : -Infinity : NaN;
  if (exponent === 0) return significand * (sign3 === 0 ? MIN_SUBNORMAL16 : -MIN_SUBNORMAL16);
  return pow$7(2, exponent - 15) * (sign3 === 0 ? 1 + significand * SIGNIFICAND_DENOM16 : -1 - significand * SIGNIFICAND_DENOM16);
};
var getUint16 = uncurryThis$1w(DataView.prototype.getUint16);
$$4V({
  target: "DataView",
  proto: true
}, {
  getFloat16: function getFloat16(byteOffset) {
    var uint16 = getUint16(this, byteOffset, arguments.length > 1 ? arguments[1] : false);
    return unpackFloat16(uint16);
  }
});
var classof$h = classof$q;
var $TypeError$z = TypeError;
var aDataView$2 = function(argument) {
  if (classof$h(argument) === "DataView") return argument;
  throw new $TypeError$z("Argument is not a DataView");
};
var log$7 = Math.log;
var LN2$1 = Math.LN2;
var mathLog2 = Math.log2 || function log2(x) {
  return log$7(x) / LN2$1;
};
var $$4U = _export;
var uncurryThis$1v = functionUncurryThis;
var aDataView$1 = aDataView$2;
var toIndex$3 = toIndex$5;
var log2$1 = mathLog2;
var roundTiesToEven = mathRoundTiesToEven;
var pow$6 = Math.pow;
var MIN_INFINITY16 = 65520;
var MIN_NORMAL16 = 61005353927612305e-21;
var REC_MIN_SUBNORMAL16 = 16777216;
var REC_SIGNIFICAND_DENOM16 = 1024;
var packFloat16 = function(value) {
  if (value !== value) return 32256;
  if (value === 0) return (1 / value === -Infinity) << 15;
  var neg = value < 0;
  if (neg) value = -value;
  if (value >= MIN_INFINITY16) return neg << 15 | 31744;
  if (value < MIN_NORMAL16) return neg << 15 | roundTiesToEven(value * REC_MIN_SUBNORMAL16);
  var exponent = log2$1(value) | 0;
  if (exponent === -15) {
    return neg << 15 | REC_SIGNIFICAND_DENOM16;
  }
  var significand = roundTiesToEven((value * pow$6(2, -exponent) - 1) * REC_SIGNIFICAND_DENOM16);
  if (significand === REC_SIGNIFICAND_DENOM16) {
    return neg << 15 | exponent + 16 << 10;
  }
  return neg << 15 | exponent + 15 << 10 | significand;
};
var setUint16 = uncurryThis$1v(DataView.prototype.setUint16);
$$4U({
  target: "DataView",
  proto: true
}, {
  setFloat16: function setFloat16(byteOffset, value) {
    aDataView$1(this);
    var offset = toIndex$3(byteOffset);
    var bytes = packFloat16(+value);
    return setUint16(this, offset, bytes, arguments.length > 2 ? arguments[2] : false);
  }
});
var globalThis$10 = globalThis_1;
var uncurryThisAccessor$2 = functionUncurryThisAccessor;
var classof$g = classofRaw$2;
var ArrayBuffer$4 = globalThis$10.ArrayBuffer;
var TypeError$7 = globalThis$10.TypeError;
var arrayBufferByteLength$2 = ArrayBuffer$4 && uncurryThisAccessor$2(ArrayBuffer$4.prototype, "byteLength", "get") || function(O) {
  if (classof$g(O) !== "ArrayBuffer") throw new TypeError$7("ArrayBuffer expected");
  return O.byteLength;
};
var globalThis$$ = globalThis_1;
var NATIVE_ARRAY_BUFFER = arrayBufferBasicDetection;
var arrayBufferByteLength$1 = arrayBufferByteLength$2;
var DataView$3 = globalThis$$.DataView;
var arrayBufferIsDetached = function(O) {
  if (!NATIVE_ARRAY_BUFFER || arrayBufferByteLength$1(O) !== 0) return false;
  try {
    new DataView$3(O);
    return false;
  } catch (error3) {
    return true;
  }
};
var DESCRIPTORS$E = descriptors;
var defineBuiltInAccessor$j = defineBuiltInAccessor$p;
var isDetached$1 = arrayBufferIsDetached;
var ArrayBufferPrototype$2 = ArrayBuffer.prototype;
if (DESCRIPTORS$E && !("detached" in ArrayBufferPrototype$2)) {
  defineBuiltInAccessor$j(ArrayBufferPrototype$2, "detached", {
    configurable: true,
    get: function detached() {
      return isDetached$1(this);
    }
  });
}
var isDetached = arrayBufferIsDetached;
var $TypeError$y = TypeError;
var arrayBufferNotDetached = function(it) {
  if (isDetached(it)) throw new $TypeError$y("ArrayBuffer is detached");
  return it;
};
var globalThis$_ = globalThis_1;
var IS_NODE$3 = environmentIsNode;
var getBuiltInNodeModule$2 = function(name) {
  if (IS_NODE$3) {
    try {
      return globalThis$_.process.getBuiltinModule(name);
    } catch (error3) {
    }
    try {
      return Function('return require("' + name + '")')();
    } catch (error3) {
    }
  }
};
var globalThis$Z = globalThis_1;
var fails$18 = fails$1z;
var V8$1 = environmentV8Version;
var ENVIRONMENT$2 = environment;
var structuredClone$2 = globalThis$Z.structuredClone;
var structuredCloneProperTransfer = !!structuredClone$2 && !fails$18(function() {
  if (ENVIRONMENT$2 === "DENO" && V8$1 > 92 || ENVIRONMENT$2 === "NODE" && V8$1 > 94 || ENVIRONMENT$2 === "BROWSER" && V8$1 > 97) return false;
  var buffer2 = new ArrayBuffer(8);
  var clone2 = structuredClone$2(buffer2, {
    transfer: [buffer2]
  });
  return buffer2.byteLength !== 0 || clone2.byteLength !== 8;
});
var globalThis$Y = globalThis_1;
var getBuiltInNodeModule$1 = getBuiltInNodeModule$2;
var PROPER_STRUCTURED_CLONE_TRANSFER$2 = structuredCloneProperTransfer;
var structuredClone$1 = globalThis$Y.structuredClone;
var $ArrayBuffer = globalThis$Y.ArrayBuffer;
var $MessageChannel = globalThis$Y.MessageChannel;
var detach = false;
var WorkerThreads, channel$1, buffer$1, $detach;
if (PROPER_STRUCTURED_CLONE_TRANSFER$2) {
  detach = function(transferable) {
    structuredClone$1(transferable, {
      transfer: [transferable]
    });
  };
} else if ($ArrayBuffer) try {
  if (!$MessageChannel) {
    WorkerThreads = getBuiltInNodeModule$1("worker_threads");
    if (WorkerThreads) $MessageChannel = WorkerThreads.MessageChannel;
  }
  if ($MessageChannel) {
    channel$1 = new $MessageChannel();
    buffer$1 = new $ArrayBuffer(2);
    $detach = function(transferable) {
      channel$1.port1.postMessage(null, [transferable]);
    };
    if (buffer$1.byteLength === 2) {
      $detach(buffer$1);
      if (buffer$1.byteLength === 0) detach = $detach;
    }
  }
} catch (error3) {
}
var detachTransferable$2 = detach;
var globalThis$X = globalThis_1;
var uncurryThis$1u = functionUncurryThis;
var uncurryThisAccessor$1 = functionUncurryThisAccessor;
var toIndex$2 = toIndex$5;
var notDetached$4 = arrayBufferNotDetached;
var arrayBufferByteLength = arrayBufferByteLength$2;
var detachTransferable$1 = detachTransferable$2;
var PROPER_STRUCTURED_CLONE_TRANSFER$1 = structuredCloneProperTransfer;
var structuredClone = globalThis$X.structuredClone;
var ArrayBuffer$3 = globalThis$X.ArrayBuffer;
var DataView$2 = globalThis$X.DataView;
var min$8 = Math.min;
var ArrayBufferPrototype$1 = ArrayBuffer$3.prototype;
var DataViewPrototype = DataView$2.prototype;
var slice$6 = uncurryThis$1u(ArrayBufferPrototype$1.slice);
var isResizable = uncurryThisAccessor$1(ArrayBufferPrototype$1, "resizable", "get");
var maxByteLength = uncurryThisAccessor$1(ArrayBufferPrototype$1, "maxByteLength", "get");
var getInt8 = uncurryThis$1u(DataViewPrototype.getInt8);
var setInt8 = uncurryThis$1u(DataViewPrototype.setInt8);
var arrayBufferTransfer = (PROPER_STRUCTURED_CLONE_TRANSFER$1 || detachTransferable$1) && function(arrayBuffer2, newLength, preserveResizability) {
  var byteLength2 = arrayBufferByteLength(arrayBuffer2);
  var newByteLength = newLength === void 0 ? byteLength2 : toIndex$2(newLength);
  var fixedLength = !isResizable || !isResizable(arrayBuffer2);
  var newBuffer;
  notDetached$4(arrayBuffer2);
  if (PROPER_STRUCTURED_CLONE_TRANSFER$1) {
    arrayBuffer2 = structuredClone(arrayBuffer2, {
      transfer: [arrayBuffer2]
    });
    if (byteLength2 === newByteLength && (preserveResizability || fixedLength)) return arrayBuffer2;
  }
  if (byteLength2 >= newByteLength && (!preserveResizability || fixedLength)) {
    newBuffer = slice$6(arrayBuffer2, 0, newByteLength);
  } else {
    var options = preserveResizability && !fixedLength && maxByteLength ? {
      maxByteLength: maxByteLength(arrayBuffer2)
    } : void 0;
    newBuffer = new ArrayBuffer$3(newByteLength, options);
    var a = new DataView$2(arrayBuffer2);
    var b = new DataView$2(newBuffer);
    var copyLength = min$8(newByteLength, byteLength2);
    for (var i = 0; i < copyLength; i++) setInt8(b, i, getInt8(a, i));
  }
  if (!PROPER_STRUCTURED_CLONE_TRANSFER$1) detachTransferable$1(arrayBuffer2);
  return newBuffer;
};
var $$4T = _export;
var $transfer$1 = arrayBufferTransfer;
if ($transfer$1) $$4T({
  target: "ArrayBuffer",
  proto: true
}, {
  transfer: function transfer() {
    return $transfer$1(this, arguments.length ? arguments[0] : void 0, true);
  }
});
var $$4S = _export;
var $transfer = arrayBufferTransfer;
if ($transfer) $$4S({
  target: "ArrayBuffer",
  proto: true
}, {
  transferToFixedLength: function transferToFixedLength() {
    return $transfer(this, arguments.length ? arguments[0] : void 0, false);
  }
});
var $$4R = _export;
var uncurryThis$1t = functionUncurryThis;
var fails$17 = fails$1z;
var FORCED$w = fails$17(function() {
  return (/* @__PURE__ */ new Date(16e11)).getYear() !== 120;
});
var getFullYear = uncurryThis$1t(Date.prototype.getFullYear);
$$4R({
  target: "Date",
  proto: true,
  forced: FORCED$w
}, {
  getYear: function getYear() {
    return getFullYear(this) - 1900;
  }
});
var $$4Q = _export;
var uncurryThis$1s = functionUncurryThis;
var $Date = Date;
var thisTimeValue$4 = uncurryThis$1s($Date.prototype.getTime);
$$4Q({
  target: "Date",
  stat: true
}, {
  now: function now() {
    return thisTimeValue$4(new $Date());
  }
});
var $$4P = _export;
var uncurryThis$1r = functionUncurryThis;
var toIntegerOrInfinity$e = toIntegerOrInfinity$p;
var DatePrototype$3 = Date.prototype;
var thisTimeValue$3 = uncurryThis$1r(DatePrototype$3.getTime);
var setFullYear = uncurryThis$1r(DatePrototype$3.setFullYear);
$$4P({
  target: "Date",
  proto: true
}, {
  setYear: function setYear(year) {
    thisTimeValue$3(this);
    var yi = toIntegerOrInfinity$e(year);
    var yyyy = yi >= 0 && yi <= 99 ? yi + 1900 : yi;
    return setFullYear(this, yyyy);
  }
});
var $$4O = _export;
$$4O({
  target: "Date",
  proto: true
}, {
  toGMTString: Date.prototype.toUTCString
});
var toIntegerOrInfinity$d = toIntegerOrInfinity$p;
var toString$D = toString$J;
var requireObjectCoercible$m = requireObjectCoercible$q;
var $RangeError$d = RangeError;
var stringRepeat = function repeat(count) {
  var str = toString$D(requireObjectCoercible$m(this));
  var result = "";
  var n = toIntegerOrInfinity$d(count);
  if (n < 0 || n === Infinity) throw new $RangeError$d("Wrong number of repetitions");
  for (; n > 0; (n >>>= 1) && (str += str)) if (n & 1) result += str;
  return result;
};
var uncurryThis$1q = functionUncurryThis;
var toLength$8 = toLength$d;
var toString$C = toString$J;
var $repeat$2 = stringRepeat;
var requireObjectCoercible$l = requireObjectCoercible$q;
var repeat$3 = uncurryThis$1q($repeat$2);
var stringSlice$j = uncurryThis$1q("".slice);
var ceil = Math.ceil;
var createMethod$4 = function(IS_END) {
  return function($this, maxLength, fillString) {
    var S = toString$C(requireObjectCoercible$l($this));
    var intMaxLength = toLength$8(maxLength);
    var stringLength = S.length;
    var fillStr = fillString === void 0 ? " " : toString$C(fillString);
    var fillLen, stringFiller;
    if (intMaxLength <= stringLength || fillStr === "") return S;
    fillLen = intMaxLength - stringLength;
    stringFiller = repeat$3(fillStr, ceil(fillLen / fillStr.length));
    if (stringFiller.length > fillLen) stringFiller = stringSlice$j(stringFiller, 0, fillLen);
    return IS_END ? S + stringFiller : stringFiller + S;
  };
};
var stringPad = {
  // `String.prototype.padStart` method
  // https://tc39.es/ecma262/#sec-string.prototype.padstart
  start: createMethod$4(false),
  // `String.prototype.padEnd` method
  // https://tc39.es/ecma262/#sec-string.prototype.padend
  end: createMethod$4(true)
};
var uncurryThis$1p = functionUncurryThis;
var fails$16 = fails$1z;
var padStart$1 = stringPad.start;
var $RangeError$c = RangeError;
var $isFinite$1 = isFinite;
var abs$7 = Math.abs;
var DatePrototype$2 = Date.prototype;
var nativeDateToISOString = DatePrototype$2.toISOString;
var thisTimeValue$2 = uncurryThis$1p(DatePrototype$2.getTime);
var getUTCDate = uncurryThis$1p(DatePrototype$2.getUTCDate);
var getUTCFullYear = uncurryThis$1p(DatePrototype$2.getUTCFullYear);
var getUTCHours = uncurryThis$1p(DatePrototype$2.getUTCHours);
var getUTCMilliseconds = uncurryThis$1p(DatePrototype$2.getUTCMilliseconds);
var getUTCMinutes = uncurryThis$1p(DatePrototype$2.getUTCMinutes);
var getUTCMonth = uncurryThis$1p(DatePrototype$2.getUTCMonth);
var getUTCSeconds = uncurryThis$1p(DatePrototype$2.getUTCSeconds);
var dateToIsoString = fails$16(function() {
  return nativeDateToISOString.call(new Date(-5e13 - 1)) !== "0385-07-25T07:06:39.999Z";
}) || !fails$16(function() {
  nativeDateToISOString.call(/* @__PURE__ */ new Date(NaN));
}) ? function toISOString() {
  if (!$isFinite$1(thisTimeValue$2(this))) throw new $RangeError$c("Invalid time value");
  var date = this;
  var year = getUTCFullYear(date);
  var milliseconds = getUTCMilliseconds(date);
  var sign3 = year < 0 ? "-" : year > 9999 ? "+" : "";
  return sign3 + padStart$1(abs$7(year), sign3 ? 6 : 4, 0) + "-" + padStart$1(getUTCMonth(date) + 1, 2, 0) + "-" + padStart$1(getUTCDate(date), 2, 0) + "T" + padStart$1(getUTCHours(date), 2, 0) + ":" + padStart$1(getUTCMinutes(date), 2, 0) + ":" + padStart$1(getUTCSeconds(date), 2, 0) + "." + padStart$1(milliseconds, 3, 0) + "Z";
} : nativeDateToISOString;
var $$4N = _export;
var toISOString2 = dateToIsoString;
$$4N({
  target: "Date",
  proto: true,
  forced: Date.prototype.toISOString !== toISOString2
}, {
  toISOString: toISOString2
});
var $$4M = _export;
var fails$15 = fails$1z;
var toObject$m = toObject$E;
var toPrimitive$2 = toPrimitive$4;
var FORCED$v = fails$15(function() {
  return (/* @__PURE__ */ new Date(NaN)).toJSON() !== null || Date.prototype.toJSON.call({
    toISOString: function() {
      return 1;
    }
  }) !== 1;
});
$$4M({
  target: "Date",
  proto: true,
  arity: 1,
  forced: FORCED$v
}, {
  // eslint-disable-next-line no-unused-vars -- required for `.length`
  toJSON: function toJSON(key) {
    var O = toObject$m(this);
    var pv = toPrimitive$2(O, "number");
    return typeof pv == "number" && !isFinite(pv) ? null : O.toISOString();
  }
});
var anObject$16 = anObject$1i;
var ordinaryToPrimitive = ordinaryToPrimitive$2;
var $TypeError$x = TypeError;
var dateToPrimitive$1 = function(hint) {
  anObject$16(this);
  if (hint === "string" || hint === "default") hint = "string";
  else if (hint !== "number") throw new $TypeError$x("Incorrect hint");
  return ordinaryToPrimitive(this, hint);
};
var hasOwn$q = hasOwnProperty_1;
var defineBuiltIn$l = defineBuiltIn$u;
var dateToPrimitive = dateToPrimitive$1;
var wellKnownSymbol$x = wellKnownSymbol$S;
var TO_PRIMITIVE = wellKnownSymbol$x("toPrimitive");
var DatePrototype$1 = Date.prototype;
if (!hasOwn$q(DatePrototype$1, TO_PRIMITIVE)) {
  defineBuiltIn$l(DatePrototype$1, TO_PRIMITIVE, dateToPrimitive);
}
var uncurryThis$1o = functionUncurryThis;
var defineBuiltIn$k = defineBuiltIn$u;
var DatePrototype = Date.prototype;
var INVALID_DATE = "Invalid Date";
var TO_STRING$1 = "toString";
var nativeDateToString = uncurryThis$1o(DatePrototype[TO_STRING$1]);
var thisTimeValue$1 = uncurryThis$1o(DatePrototype.getTime);
if (String(/* @__PURE__ */ new Date(NaN)) !== INVALID_DATE) {
  defineBuiltIn$k(DatePrototype, TO_STRING$1, function toString7() {
    var value = thisTimeValue$1(this);
    return value === value ? nativeDateToString(this) : INVALID_DATE;
  });
}
var $$4L = _export;
var uncurryThis$1n = functionUncurryThis;
var toString$B = toString$J;
var charAt$l = uncurryThis$1n("".charAt);
var charCodeAt$8 = uncurryThis$1n("".charCodeAt);
var exec$f = uncurryThis$1n(/./.exec);
var numberToString$4 = uncurryThis$1n(1 .toString);
var toUpperCase = uncurryThis$1n("".toUpperCase);
var raw$1 = /[\w*+\-./@]/;
var hex$1 = function(code2, length) {
  var result = numberToString$4(code2, 16);
  while (result.length < length) result = "0" + result;
  return result;
};
$$4L({
  global: true
}, {
  escape: function escape(string) {
    var str = toString$B(string);
    var result = "";
    var length = str.length;
    var index = 0;
    var chr, code2;
    while (index < length) {
      chr = charAt$l(str, index++);
      if (exec$f(raw$1, chr)) {
        result += chr;
      } else {
        code2 = charCodeAt$8(chr, 0);
        if (code2 < 256) {
          result += "%" + hex$1(code2, 2);
        } else {
          result += "%u" + toUpperCase(hex$1(code2, 4));
        }
      }
    }
    return result;
  }
});
var uncurryThis$1m = functionUncurryThis;
var aCallable$H = aCallable$Q;
var isObject$z = isObject$O;
var hasOwn$p = hasOwnProperty_1;
var arraySlice$5 = arraySlice$a;
var NATIVE_BIND = functionBindNative;
var $Function = Function;
var concat$3 = uncurryThis$1m([].concat);
var join$9 = uncurryThis$1m([].join);
var factories = {};
var construct = function(C, argsLength, args) {
  if (!hasOwn$p(factories, argsLength)) {
    var list = [];
    var i = 0;
    for (; i < argsLength; i++) list[i] = "a[" + i + "]";
    factories[argsLength] = $Function("C,a", "return new C(" + join$9(list, ",") + ")");
  }
  return factories[argsLength](C, args);
};
var functionBind = NATIVE_BIND ? $Function.bind : function bind(that) {
  var F = aCallable$H(this);
  var Prototype2 = F.prototype;
  var partArgs = arraySlice$5(arguments, 1);
  var boundFunction = function bound() {
    var args = concat$3(partArgs, arraySlice$5(arguments));
    return this instanceof boundFunction ? construct(F, args.length, args) : F.apply(that, args);
  };
  if (isObject$z(Prototype2)) boundFunction.prototype = Prototype2;
  return boundFunction;
};
var $$4K = _export;
var bind$p = functionBind;
$$4K({
  target: "Function",
  proto: true,
  forced: Function.bind !== bind$p
}, {
  bind: bind$p
});
var isCallable$n = isCallable$I;
var isObject$y = isObject$O;
var definePropertyModule$5 = objectDefineProperty;
var isPrototypeOf$7 = objectIsPrototypeOf;
var wellKnownSymbol$w = wellKnownSymbol$S;
var makeBuiltIn$1 = makeBuiltInExports;
var HAS_INSTANCE = wellKnownSymbol$w("hasInstance");
var FunctionPrototype$2 = Function.prototype;
if (!(HAS_INSTANCE in FunctionPrototype$2)) {
  definePropertyModule$5.f(FunctionPrototype$2, HAS_INSTANCE, {
    value: makeBuiltIn$1(function(O) {
      if (!isCallable$n(this) || !isObject$y(O)) return false;
      var P = this.prototype;
      return isObject$y(P) ? isPrototypeOf$7(P, O) : O instanceof this;
    }, HAS_INSTANCE)
  });
}
var DESCRIPTORS$D = descriptors;
var FUNCTION_NAME_EXISTS = functionName.EXISTS;
var uncurryThis$1l = functionUncurryThis;
var defineBuiltInAccessor$i = defineBuiltInAccessor$p;
var FunctionPrototype$1 = Function.prototype;
var functionToString = uncurryThis$1l(FunctionPrototype$1.toString);
var nameRE = /function\b(?:\s|\/\*[\S\s]*?\*\/|\/\/[^\n\r]*[\n\r]+)*([^\s(/]*)/;
var regExpExec$5 = uncurryThis$1l(nameRE.exec);
var NAME = "name";
if (DESCRIPTORS$D && !FUNCTION_NAME_EXISTS) {
  defineBuiltInAccessor$i(FunctionPrototype$1, NAME, {
    configurable: true,
    get: function() {
      try {
        return regExpExec$5(nameRE, functionToString(this))[1];
      } catch (error3) {
        return "";
      }
    }
  });
}
var $$4J = _export;
var globalThis$W = globalThis_1;
$$4J({
  global: true,
  forced: globalThis$W.globalThis !== globalThis$W
}, {
  globalThis: globalThis$W
});
var $$4I = _export;
var globalThis$V = globalThis_1;
var anInstance$d = anInstance$f;
var anObject$15 = anObject$1i;
var isCallable$m = isCallable$I;
var getPrototypeOf$b = objectGetPrototypeOf$2;
var defineBuiltInAccessor$h = defineBuiltInAccessor$p;
var createProperty$5 = createProperty$b;
var fails$14 = fails$1z;
var hasOwn$o = hasOwnProperty_1;
var wellKnownSymbol$v = wellKnownSymbol$S;
var IteratorPrototype$3 = iteratorsCore.IteratorPrototype;
var DESCRIPTORS$C = descriptors;
var CONSTRUCTOR = "constructor";
var ITERATOR$7 = "Iterator";
var TO_STRING_TAG$6 = wellKnownSymbol$v("toStringTag");
var $TypeError$w = TypeError;
var NativeIterator = globalThis$V[ITERATOR$7];
var FORCED$u = !isCallable$m(NativeIterator) || NativeIterator.prototype !== IteratorPrototype$3 || !fails$14(function() {
  NativeIterator({});
});
var IteratorConstructor = function Iterator() {
  anInstance$d(this, IteratorPrototype$3);
  if (getPrototypeOf$b(this) === IteratorPrototype$3) throw new $TypeError$w("Abstract class Iterator not directly constructable");
};
var defineIteratorPrototypeAccessor = function(key, value) {
  if (DESCRIPTORS$C) {
    defineBuiltInAccessor$h(IteratorPrototype$3, key, {
      configurable: true,
      get: function() {
        return value;
      },
      set: function(replacement2) {
        anObject$15(this);
        if (this === IteratorPrototype$3) throw new $TypeError$w("You can't redefine this property");
        if (hasOwn$o(this, key)) this[key] = replacement2;
        else createProperty$5(this, key, replacement2);
      }
    });
  } else IteratorPrototype$3[key] = value;
};
if (!hasOwn$o(IteratorPrototype$3, TO_STRING_TAG$6)) defineIteratorPrototypeAccessor(TO_STRING_TAG$6, ITERATOR$7);
if (FORCED$u || !hasOwn$o(IteratorPrototype$3, CONSTRUCTOR) || IteratorPrototype$3[CONSTRUCTOR] === Object) {
  defineIteratorPrototypeAccessor(CONSTRUCTOR, IteratorConstructor);
}
IteratorConstructor.prototype = IteratorPrototype$3;
$$4I({
  global: true,
  constructor: true,
  forced: FORCED$u
}, {
  Iterator: IteratorConstructor
});
var getIteratorDirect$o = function(obj) {
  return {
    iterator: obj,
    next: obj.next,
    done: false
  };
};
var $RangeError$b = RangeError;
var notANan = function(it) {
  if (it === it) return it;
  throw new $RangeError$b("NaN is not allowed");
};
var toIntegerOrInfinity$c = toIntegerOrInfinity$p;
var $RangeError$a = RangeError;
var toPositiveInteger$5 = function(it) {
  var result = toIntegerOrInfinity$c(it);
  if (result < 0) throw new $RangeError$a("The argument can't be less than 0");
  return result;
};
var call$15 = functionCall;
var create$f = objectCreate$1;
var createNonEnumerableProperty$9 = createNonEnumerableProperty$j;
var defineBuiltIns$9 = defineBuiltIns$b;
var wellKnownSymbol$u = wellKnownSymbol$S;
var InternalStateModule$i = internalState;
var getMethod$h = getMethod$l;
var IteratorPrototype$2 = iteratorsCore.IteratorPrototype;
var createIterResultObject$g = createIterResultObject$i;
var iteratorClose$5 = iteratorClose$8;
var TO_STRING_TAG$5 = wellKnownSymbol$u("toStringTag");
var ITERATOR_HELPER = "IteratorHelper";
var WRAP_FOR_VALID_ITERATOR = "WrapForValidIterator";
var setInternalState$j = InternalStateModule$i.set;
var createIteratorProxyPrototype = function(IS_ITERATOR) {
  var getInternalState2 = InternalStateModule$i.getterFor(IS_ITERATOR ? WRAP_FOR_VALID_ITERATOR : ITERATOR_HELPER);
  return defineBuiltIns$9(create$f(IteratorPrototype$2), {
    next: function next11() {
      var state = getInternalState2(this);
      if (IS_ITERATOR) return state.nextHandler();
      if (state.done) return createIterResultObject$g(void 0, true);
      try {
        var result = state.nextHandler();
        return state.returnHandlerResult ? result : createIterResultObject$g(result, state.done);
      } catch (error3) {
        state.done = true;
        throw error3;
      }
    },
    "return": function() {
      var state = getInternalState2(this);
      var iterator = state.iterator;
      state.done = true;
      if (IS_ITERATOR) {
        var returnMethod = getMethod$h(iterator, "return");
        return returnMethod ? call$15(returnMethod, iterator) : createIterResultObject$g(void 0, true);
      }
      if (state.inner) try {
        iteratorClose$5(state.inner.iterator, "normal");
      } catch (error3) {
        return iteratorClose$5(iterator, "throw", error3);
      }
      if (iterator) iteratorClose$5(iterator, "normal");
      return createIterResultObject$g(void 0, true);
    }
  });
};
var WrapForValidIteratorPrototype = createIteratorProxyPrototype(true);
var IteratorHelperPrototype = createIteratorProxyPrototype(false);
createNonEnumerableProperty$9(IteratorHelperPrototype, TO_STRING_TAG$5, "Iterator Helper");
var iteratorCreateProxy = function(nextHandler, IS_ITERATOR, RETURN_HANDLER_RESULT) {
  var IteratorProxy2 = function Iterator3(record, state) {
    if (state) {
      state.iterator = record.iterator;
      state.next = record.next;
    } else state = record;
    state.type = IS_ITERATOR ? WRAP_FOR_VALID_ITERATOR : ITERATOR_HELPER;
    state.returnHandlerResult = !!RETURN_HANDLER_RESULT;
    state.nextHandler = nextHandler;
    state.counter = 0;
    state.done = false;
    setInternalState$j(this, state);
  };
  IteratorProxy2.prototype = IS_ITERATOR ? WrapForValidIteratorPrototype : IteratorHelperPrototype;
  return IteratorProxy2;
};
var $$4H = _export;
var call$14 = functionCall;
var anObject$14 = anObject$1i;
var getIteratorDirect$n = getIteratorDirect$o;
var notANaN$4 = notANan;
var toPositiveInteger$4 = toPositiveInteger$5;
var createIteratorProxy$6 = iteratorCreateProxy;
var IS_PURE$g = isPure;
var IteratorProxy$6 = createIteratorProxy$6(function() {
  var iterator = this.iterator;
  var next11 = this.next;
  var result, done;
  while (this.remaining) {
    this.remaining--;
    result = anObject$14(call$14(next11, iterator));
    done = this.done = !!result.done;
    if (done) return;
  }
  result = anObject$14(call$14(next11, iterator));
  done = this.done = !!result.done;
  if (!done) return result.value;
});
$$4H({
  target: "Iterator",
  proto: true,
  real: true,
  forced: IS_PURE$g
}, {
  drop: function drop(limit) {
    anObject$14(this);
    var remaining = toPositiveInteger$4(notANaN$4(+limit));
    return new IteratorProxy$6(getIteratorDirect$n(this), {
      remaining
    });
  }
});
var $$4G = _export;
var iterate$F = iterate$H;
var aCallable$G = aCallable$Q;
var anObject$13 = anObject$1i;
var getIteratorDirect$m = getIteratorDirect$o;
$$4G({
  target: "Iterator",
  proto: true,
  real: true
}, {
  every: function every2(predicate) {
    anObject$13(this);
    aCallable$G(predicate);
    var record = getIteratorDirect$m(this);
    var counter2 = 0;
    return !iterate$F(record, function(value, stop) {
      if (!predicate(value, counter2++)) return stop();
    }, {
      IS_RECORD: true,
      INTERRUPTED: true
    }).stopped;
  }
});
var $$4F = _export;
var call$13 = functionCall;
var aCallable$F = aCallable$Q;
var anObject$12 = anObject$1i;
var getIteratorDirect$l = getIteratorDirect$o;
var createIteratorProxy$5 = iteratorCreateProxy;
var callWithSafeIterationClosing$1 = callWithSafeIterationClosing$3;
var IS_PURE$f = isPure;
var IteratorProxy$5 = createIteratorProxy$5(function() {
  var iterator = this.iterator;
  var predicate = this.predicate;
  var next11 = this.next;
  var result, done, value;
  while (true) {
    result = anObject$12(call$13(next11, iterator));
    done = this.done = !!result.done;
    if (done) return;
    value = result.value;
    if (callWithSafeIterationClosing$1(iterator, predicate, [value, this.counter++], true)) return value;
  }
});
$$4F({
  target: "Iterator",
  proto: true,
  real: true,
  forced: IS_PURE$f
}, {
  filter: function filter2(predicate) {
    anObject$12(this);
    aCallable$F(predicate);
    return new IteratorProxy$5(getIteratorDirect$l(this), {
      predicate
    });
  }
});
var $$4E = _export;
var iterate$E = iterate$H;
var aCallable$E = aCallable$Q;
var anObject$11 = anObject$1i;
var getIteratorDirect$k = getIteratorDirect$o;
$$4E({
  target: "Iterator",
  proto: true,
  real: true
}, {
  find: function find2(predicate) {
    anObject$11(this);
    aCallable$E(predicate);
    var record = getIteratorDirect$k(this);
    var counter2 = 0;
    return iterate$E(record, function(value, stop) {
      if (predicate(value, counter2++)) return stop(value);
    }, {
      IS_RECORD: true,
      INTERRUPTED: true
    }).result;
  }
});
var call$12 = functionCall;
var anObject$10 = anObject$1i;
var getIteratorDirect$j = getIteratorDirect$o;
var getIteratorMethod$5 = getIteratorMethod$9;
var getIteratorFlattenable$2 = function(obj, stringHandling) {
  if (!stringHandling || typeof obj !== "string") anObject$10(obj);
  var method = getIteratorMethod$5(obj);
  return getIteratorDirect$j(anObject$10(method !== void 0 ? call$12(method, obj) : obj));
};
var $$4D = _export;
var call$11 = functionCall;
var aCallable$D = aCallable$Q;
var anObject$$ = anObject$1i;
var getIteratorDirect$i = getIteratorDirect$o;
var getIteratorFlattenable$1 = getIteratorFlattenable$2;
var createIteratorProxy$4 = iteratorCreateProxy;
var iteratorClose$4 = iteratorClose$8;
var IS_PURE$e = isPure;
var IteratorProxy$4 = createIteratorProxy$4(function() {
  var iterator = this.iterator;
  var mapper = this.mapper;
  var result, inner;
  while (true) {
    if (inner = this.inner) try {
      result = anObject$$(call$11(inner.next, inner.iterator));
      if (!result.done) return result.value;
      this.inner = null;
    } catch (error3) {
      iteratorClose$4(iterator, "throw", error3);
    }
    result = anObject$$(call$11(this.next, iterator));
    if (this.done = !!result.done) return;
    try {
      this.inner = getIteratorFlattenable$1(mapper(result.value, this.counter++), false);
    } catch (error3) {
      iteratorClose$4(iterator, "throw", error3);
    }
  }
});
$$4D({
  target: "Iterator",
  proto: true,
  real: true,
  forced: IS_PURE$e
}, {
  flatMap: function flatMap2(mapper) {
    anObject$$(this);
    aCallable$D(mapper);
    return new IteratorProxy$4(getIteratorDirect$i(this), {
      mapper,
      inner: null
    });
  }
});
var $$4C = _export;
var iterate$D = iterate$H;
var aCallable$C = aCallable$Q;
var anObject$_ = anObject$1i;
var getIteratorDirect$h = getIteratorDirect$o;
$$4C({
  target: "Iterator",
  proto: true,
  real: true
}, {
  forEach: function forEach2(fn) {
    anObject$_(this);
    aCallable$C(fn);
    var record = getIteratorDirect$h(this);
    var counter2 = 0;
    iterate$D(record, function(value) {
      fn(value, counter2++);
    }, {
      IS_RECORD: true
    });
  }
});
var $$4B = _export;
var call$10 = functionCall;
var toObject$l = toObject$E;
var isPrototypeOf$6 = objectIsPrototypeOf;
var IteratorPrototype$1 = iteratorsCore.IteratorPrototype;
var createIteratorProxy$3 = iteratorCreateProxy;
var getIteratorFlattenable = getIteratorFlattenable$2;
var IS_PURE$d = isPure;
var IteratorProxy$3 = createIteratorProxy$3(function() {
  return call$10(this.next, this.iterator);
}, true);
$$4B({
  target: "Iterator",
  stat: true,
  forced: IS_PURE$d
}, {
  from: function from3(O) {
    var iteratorRecord = getIteratorFlattenable(typeof O == "string" ? toObject$l(O) : O, true);
    return isPrototypeOf$6(IteratorPrototype$1, iteratorRecord.iterator) ? iteratorRecord.iterator : new IteratorProxy$3(iteratorRecord);
  }
});
var call$$ = functionCall;
var aCallable$B = aCallable$Q;
var anObject$Z = anObject$1i;
var getIteratorDirect$g = getIteratorDirect$o;
var createIteratorProxy$2 = iteratorCreateProxy;
var callWithSafeIterationClosing = callWithSafeIterationClosing$3;
var IteratorProxy$2 = createIteratorProxy$2(function() {
  var iterator = this.iterator;
  var result = anObject$Z(call$$(this.next, iterator));
  var done = this.done = !!result.done;
  if (!done) return callWithSafeIterationClosing(iterator, this.mapper, [result.value, this.counter++], true);
});
var iteratorMap = function map2(mapper) {
  anObject$Z(this);
  aCallable$B(mapper);
  return new IteratorProxy$2(getIteratorDirect$g(this), {
    mapper
  });
};
var $$4A = _export;
var map$3 = iteratorMap;
var IS_PURE$c = isPure;
$$4A({
  target: "Iterator",
  proto: true,
  real: true,
  forced: IS_PURE$c
}, {
  map: map$3
});
var $$4z = _export;
var iterate$C = iterate$H;
var aCallable$A = aCallable$Q;
var anObject$Y = anObject$1i;
var getIteratorDirect$f = getIteratorDirect$o;
var $TypeError$v = TypeError;
$$4z({
  target: "Iterator",
  proto: true,
  real: true
}, {
  reduce: function reduce2(reducer) {
    anObject$Y(this);
    aCallable$A(reducer);
    var record = getIteratorDirect$f(this);
    var noInitial = arguments.length < 2;
    var accumulator = noInitial ? void 0 : arguments[1];
    var counter2 = 0;
    iterate$C(record, function(value) {
      if (noInitial) {
        noInitial = false;
        accumulator = value;
      } else {
        accumulator = reducer(accumulator, value, counter2);
      }
      counter2++;
    }, {
      IS_RECORD: true
    });
    if (noInitial) throw new $TypeError$v("Reduce of empty iterator with no initial value");
    return accumulator;
  }
});
var $$4y = _export;
var iterate$B = iterate$H;
var aCallable$z = aCallable$Q;
var anObject$X = anObject$1i;
var getIteratorDirect$e = getIteratorDirect$o;
$$4y({
  target: "Iterator",
  proto: true,
  real: true
}, {
  some: function some2(predicate) {
    anObject$X(this);
    aCallable$z(predicate);
    var record = getIteratorDirect$e(this);
    var counter2 = 0;
    return iterate$B(record, function(value, stop) {
      if (predicate(value, counter2++)) return stop();
    }, {
      IS_RECORD: true,
      INTERRUPTED: true
    }).stopped;
  }
});
var $$4x = _export;
var call$_ = functionCall;
var anObject$W = anObject$1i;
var getIteratorDirect$d = getIteratorDirect$o;
var notANaN$3 = notANan;
var toPositiveInteger$3 = toPositiveInteger$5;
var createIteratorProxy$1 = iteratorCreateProxy;
var iteratorClose$3 = iteratorClose$8;
var IS_PURE$b = isPure;
var IteratorProxy$1 = createIteratorProxy$1(function() {
  var iterator = this.iterator;
  if (!this.remaining--) {
    this.done = true;
    return iteratorClose$3(iterator, "normal", void 0);
  }
  var result = anObject$W(call$_(this.next, iterator));
  var done = this.done = !!result.done;
  if (!done) return result.value;
});
$$4x({
  target: "Iterator",
  proto: true,
  real: true,
  forced: IS_PURE$b
}, {
  take: function take(limit) {
    anObject$W(this);
    var remaining = toPositiveInteger$3(notANaN$3(+limit));
    return new IteratorProxy$1(getIteratorDirect$d(this), {
      remaining
    });
  }
});
var $$4w = _export;
var anObject$V = anObject$1i;
var iterate$A = iterate$H;
var getIteratorDirect$c = getIteratorDirect$o;
var push$m = [].push;
$$4w({
  target: "Iterator",
  proto: true,
  real: true
}, {
  toArray: function toArray() {
    var result = [];
    iterate$A(getIteratorDirect$c(anObject$V(this)), push$m, {
      that: result,
      IS_RECORD: true
    });
    return result;
  }
});
var globalThis$U = globalThis_1;
var setToStringTag$8 = setToStringTag$e;
setToStringTag$8(globalThis$U.JSON, "JSON", true);
var internalMetadata = { exports: {} };
var fails$13 = fails$1z;
var arrayBufferNonExtensible = fails$13(function() {
  if (typeof ArrayBuffer == "function") {
    var buffer2 = new ArrayBuffer(8);
    if (Object.isExtensible(buffer2)) Object.defineProperty(buffer2, "a", {
      value: 8
    });
  }
});
var fails$12 = fails$1z;
var isObject$x = isObject$O;
var classof$f = classofRaw$2;
var ARRAY_BUFFER_NON_EXTENSIBLE$2 = arrayBufferNonExtensible;
var $isExtensible$2 = Object.isExtensible;
var FAILS_ON_PRIMITIVES$6 = fails$12(function() {
  $isExtensible$2(1);
});
var objectIsExtensible = FAILS_ON_PRIMITIVES$6 || ARRAY_BUFFER_NON_EXTENSIBLE$2 ? function isExtensible(it) {
  if (!isObject$x(it)) return false;
  if (ARRAY_BUFFER_NON_EXTENSIBLE$2 && classof$f(it) === "ArrayBuffer") return false;
  return $isExtensible$2 ? $isExtensible$2(it) : true;
} : $isExtensible$2;
var fails$11 = fails$1z;
var freezing = !fails$11(function() {
  return Object.isExtensible(Object.preventExtensions({}));
});
var $$4v = _export;
var uncurryThis$1k = functionUncurryThis;
var hiddenKeys = hiddenKeys$6;
var isObject$w = isObject$O;
var hasOwn$n = hasOwnProperty_1;
var defineProperty$a = objectDefineProperty.f;
var getOwnPropertyNamesModule = objectGetOwnPropertyNames;
var getOwnPropertyNamesExternalModule = objectGetOwnPropertyNamesExternal;
var isExtensible$1 = objectIsExtensible;
var uid$2 = uid$7;
var FREEZING$7 = freezing;
var REQUIRED = false;
var METADATA$1 = uid$2("meta");
var id$1 = 0;
var setMetadata = function(it) {
  defineProperty$a(it, METADATA$1, {
    value: {
      objectID: "O" + id$1++,
      // object ID
      weakData: {}
      // weak collections IDs
    }
  });
};
var fastKey$1 = function(it, create4) {
  if (!isObject$w(it)) return typeof it == "symbol" ? it : (typeof it == "string" ? "S" : "P") + it;
  if (!hasOwn$n(it, METADATA$1)) {
    if (!isExtensible$1(it)) return "F";
    if (!create4) return "E";
    setMetadata(it);
  }
  return it[METADATA$1].objectID;
};
var getWeakData$1 = function(it, create4) {
  if (!hasOwn$n(it, METADATA$1)) {
    if (!isExtensible$1(it)) return true;
    if (!create4) return false;
    setMetadata(it);
  }
  return it[METADATA$1].weakData;
};
var onFreeze$3 = function(it) {
  if (FREEZING$7 && REQUIRED && isExtensible$1(it) && !hasOwn$n(it, METADATA$1)) setMetadata(it);
  return it;
};
var enable = function() {
  meta.enable = function() {
  };
  REQUIRED = true;
  var getOwnPropertyNames5 = getOwnPropertyNamesModule.f;
  var splice3 = uncurryThis$1k([].splice);
  var test2 = {};
  test2[METADATA$1] = 1;
  if (getOwnPropertyNames5(test2).length) {
    getOwnPropertyNamesModule.f = function(it) {
      var result = getOwnPropertyNames5(it);
      for (var i = 0, length = result.length; i < length; i++) {
        if (result[i] === METADATA$1) {
          splice3(result, i, 1);
          break;
        }
      }
      return result;
    };
    $$4v({
      target: "Object",
      stat: true,
      forced: true
    }, {
      getOwnPropertyNames: getOwnPropertyNamesExternalModule.f
    });
  }
};
var meta = internalMetadata.exports = {
  enable,
  fastKey: fastKey$1,
  getWeakData: getWeakData$1,
  onFreeze: onFreeze$3
};
hiddenKeys[METADATA$1] = true;
var internalMetadataExports = internalMetadata.exports;
var $$4u = _export;
var globalThis$T = globalThis_1;
var uncurryThis$1j = functionUncurryThis;
var isForced$3 = isForced_1;
var defineBuiltIn$j = defineBuiltIn$u;
var InternalMetadataModule$1 = internalMetadataExports;
var iterate$z = iterate$H;
var anInstance$c = anInstance$f;
var isCallable$l = isCallable$I;
var isNullOrUndefined$f = isNullOrUndefined$j;
var isObject$v = isObject$O;
var fails$10 = fails$1z;
var checkCorrectnessOfIteration$2 = checkCorrectnessOfIteration$4;
var setToStringTag$7 = setToStringTag$e;
var inheritIfRequired$4 = inheritIfRequired$7;
var collection$4 = function(CONSTRUCTOR_NAME, wrapper2, common) {
  var IS_MAP = CONSTRUCTOR_NAME.indexOf("Map") !== -1;
  var IS_WEAK = CONSTRUCTOR_NAME.indexOf("Weak") !== -1;
  var ADDER = IS_MAP ? "set" : "add";
  var NativeConstructor = globalThis$T[CONSTRUCTOR_NAME];
  var NativePrototype = NativeConstructor && NativeConstructor.prototype;
  var Constructor2 = NativeConstructor;
  var exported = {};
  var fixMethod = function(KEY) {
    var uncurriedNativeMethod = uncurryThis$1j(NativePrototype[KEY]);
    defineBuiltIn$j(NativePrototype, KEY, KEY === "add" ? function add2(value) {
      uncurriedNativeMethod(this, value === 0 ? 0 : value);
      return this;
    } : KEY === "delete" ? function(key) {
      return IS_WEAK && !isObject$v(key) ? false : uncurriedNativeMethod(this, key === 0 ? 0 : key);
    } : KEY === "get" ? function get3(key) {
      return IS_WEAK && !isObject$v(key) ? void 0 : uncurriedNativeMethod(this, key === 0 ? 0 : key);
    } : KEY === "has" ? function has4(key) {
      return IS_WEAK && !isObject$v(key) ? false : uncurriedNativeMethod(this, key === 0 ? 0 : key);
    } : function set4(key, value) {
      uncurriedNativeMethod(this, key === 0 ? 0 : key, value);
      return this;
    });
  };
  var REPLACE2 = isForced$3(CONSTRUCTOR_NAME, !isCallable$l(NativeConstructor) || !(IS_WEAK || NativePrototype.forEach && !fails$10(function() {
    new NativeConstructor().entries().next();
  })));
  if (REPLACE2) {
    Constructor2 = common.getConstructor(wrapper2, CONSTRUCTOR_NAME, IS_MAP, ADDER);
    InternalMetadataModule$1.enable();
  } else if (isForced$3(CONSTRUCTOR_NAME, true)) {
    var instance = new Constructor2();
    var HASNT_CHAINING = instance[ADDER](IS_WEAK ? {} : -0, 1) !== instance;
    var THROWS_ON_PRIMITIVES = fails$10(function() {
      instance.has(1);
    });
    var ACCEPT_ITERABLES = checkCorrectnessOfIteration$2(function(iterable) {
      new NativeConstructor(iterable);
    });
    var BUGGY_ZERO = !IS_WEAK && fails$10(function() {
      var $instance = new NativeConstructor();
      var index = 5;
      while (index--) $instance[ADDER](index, index);
      return !$instance.has(-0);
    });
    if (!ACCEPT_ITERABLES) {
      Constructor2 = wrapper2(function(dummy, iterable) {
        anInstance$c(dummy, NativePrototype);
        var that = inheritIfRequired$4(new NativeConstructor(), dummy, Constructor2);
        if (!isNullOrUndefined$f(iterable)) iterate$z(iterable, that[ADDER], {
          that,
          AS_ENTRIES: IS_MAP
        });
        return that;
      });
      Constructor2.prototype = NativePrototype;
      NativePrototype.constructor = Constructor2;
    }
    if (THROWS_ON_PRIMITIVES || BUGGY_ZERO) {
      fixMethod("delete");
      fixMethod("has");
      IS_MAP && fixMethod("get");
    }
    if (BUGGY_ZERO || HASNT_CHAINING) fixMethod(ADDER);
    if (IS_WEAK && NativePrototype.clear) delete NativePrototype.clear;
  }
  exported[CONSTRUCTOR_NAME] = Constructor2;
  $$4u({
    global: true,
    constructor: true,
    forced: Constructor2 !== NativeConstructor
  }, exported);
  setToStringTag$7(Constructor2, CONSTRUCTOR_NAME);
  if (!IS_WEAK) common.setStrong(Constructor2, CONSTRUCTOR_NAME, IS_MAP);
  return Constructor2;
};
var create$e = objectCreate$1;
var defineBuiltInAccessor$g = defineBuiltInAccessor$p;
var defineBuiltIns$8 = defineBuiltIns$b;
var bind$o = functionBindContext;
var anInstance$b = anInstance$f;
var isNullOrUndefined$e = isNullOrUndefined$j;
var iterate$y = iterate$H;
var defineIterator$1 = iteratorDefine;
var createIterResultObject$f = createIterResultObject$i;
var setSpecies$4 = setSpecies$7;
var DESCRIPTORS$B = descriptors;
var fastKey = internalMetadataExports.fastKey;
var InternalStateModule$h = internalState;
var setInternalState$i = InternalStateModule$h.set;
var internalStateGetterFor$1 = InternalStateModule$h.getterFor;
var collectionStrong$2 = {
  getConstructor: function(wrapper2, CONSTRUCTOR_NAME, IS_MAP, ADDER) {
    var Constructor2 = wrapper2(function(that, iterable) {
      anInstance$b(that, Prototype2);
      setInternalState$i(that, {
        type: CONSTRUCTOR_NAME,
        index: create$e(null),
        first: null,
        last: null,
        size: 0
      });
      if (!DESCRIPTORS$B) that.size = 0;
      if (!isNullOrUndefined$e(iterable)) iterate$y(iterable, that[ADDER], {
        that,
        AS_ENTRIES: IS_MAP
      });
    });
    var Prototype2 = Constructor2.prototype;
    var getInternalState2 = internalStateGetterFor$1(CONSTRUCTOR_NAME);
    var define = function(that, key, value) {
      var state = getInternalState2(that);
      var entry = getEntry(that, key);
      var previous, index;
      if (entry) {
        entry.value = value;
      } else {
        state.last = entry = {
          index: index = fastKey(key, true),
          key,
          value,
          previous: previous = state.last,
          next: null,
          removed: false
        };
        if (!state.first) state.first = entry;
        if (previous) previous.next = entry;
        if (DESCRIPTORS$B) state.size++;
        else that.size++;
        if (index !== "F") state.index[index] = entry;
      }
      return that;
    };
    var getEntry = function(that, key) {
      var state = getInternalState2(that);
      var index = fastKey(key);
      var entry;
      if (index !== "F") return state.index[index];
      for (entry = state.first; entry; entry = entry.next) {
        if (entry.key === key) return entry;
      }
    };
    defineBuiltIns$8(Prototype2, {
      // `{ Map, Set }.prototype.clear()` methods
      // https://tc39.es/ecma262/#sec-map.prototype.clear
      // https://tc39.es/ecma262/#sec-set.prototype.clear
      clear: function clear2() {
        var that = this;
        var state = getInternalState2(that);
        var entry = state.first;
        while (entry) {
          entry.removed = true;
          if (entry.previous) entry.previous = entry.previous.next = null;
          entry = entry.next;
        }
        state.first = state.last = null;
        state.index = create$e(null);
        if (DESCRIPTORS$B) state.size = 0;
        else that.size = 0;
      },
      // `{ Map, Set }.prototype.delete(key)` methods
      // https://tc39.es/ecma262/#sec-map.prototype.delete
      // https://tc39.es/ecma262/#sec-set.prototype.delete
      "delete": function(key) {
        var that = this;
        var state = getInternalState2(that);
        var entry = getEntry(that, key);
        if (entry) {
          var next11 = entry.next;
          var prev = entry.previous;
          delete state.index[entry.index];
          entry.removed = true;
          if (prev) prev.next = next11;
          if (next11) next11.previous = prev;
          if (state.first === entry) state.first = next11;
          if (state.last === entry) state.last = prev;
          if (DESCRIPTORS$B) state.size--;
          else that.size--;
        }
        return !!entry;
      },
      // `{ Map, Set }.prototype.forEach(callbackfn, thisArg = undefined)` methods
      // https://tc39.es/ecma262/#sec-map.prototype.foreach
      // https://tc39.es/ecma262/#sec-set.prototype.foreach
      forEach: function forEach7(callbackfn) {
        var state = getInternalState2(this);
        var boundFunction = bind$o(callbackfn, arguments.length > 1 ? arguments[1] : void 0);
        var entry;
        while (entry = entry ? entry.next : state.first) {
          boundFunction(entry.value, entry.key, this);
          while (entry && entry.removed) entry = entry.previous;
        }
      },
      // `{ Map, Set}.prototype.has(key)` methods
      // https://tc39.es/ecma262/#sec-map.prototype.has
      // https://tc39.es/ecma262/#sec-set.prototype.has
      has: function has4(key) {
        return !!getEntry(this, key);
      }
    });
    defineBuiltIns$8(Prototype2, IS_MAP ? {
      // `Map.prototype.get(key)` method
      // https://tc39.es/ecma262/#sec-map.prototype.get
      get: function get3(key) {
        var entry = getEntry(this, key);
        return entry && entry.value;
      },
      // `Map.prototype.set(key, value)` method
      // https://tc39.es/ecma262/#sec-map.prototype.set
      set: function set4(key, value) {
        return define(this, key === 0 ? 0 : key, value);
      }
    } : {
      // `Set.prototype.add(value)` method
      // https://tc39.es/ecma262/#sec-set.prototype.add
      add: function add2(value) {
        return define(this, value = value === 0 ? 0 : value, value);
      }
    });
    if (DESCRIPTORS$B) defineBuiltInAccessor$g(Prototype2, "size", {
      configurable: true,
      get: function() {
        return getInternalState2(this).size;
      }
    });
    return Constructor2;
  },
  setStrong: function(Constructor2, CONSTRUCTOR_NAME, IS_MAP) {
    var ITERATOR_NAME = CONSTRUCTOR_NAME + " Iterator";
    var getInternalCollectionState = internalStateGetterFor$1(CONSTRUCTOR_NAME);
    var getInternalIteratorState2 = internalStateGetterFor$1(ITERATOR_NAME);
    defineIterator$1(Constructor2, CONSTRUCTOR_NAME, function(iterated, kind) {
      setInternalState$i(this, {
        type: ITERATOR_NAME,
        target: iterated,
        state: getInternalCollectionState(iterated),
        kind,
        last: null
      });
    }, function() {
      var state = getInternalIteratorState2(this);
      var kind = state.kind;
      var entry = state.last;
      while (entry && entry.removed) entry = entry.previous;
      if (!state.target || !(state.last = entry = entry ? entry.next : state.state.first)) {
        state.target = null;
        return createIterResultObject$f(void 0, true);
      }
      if (kind === "keys") return createIterResultObject$f(entry.key, false);
      if (kind === "values") return createIterResultObject$f(entry.value, false);
      return createIterResultObject$f([entry.key, entry.value], false);
    }, IS_MAP ? "entries" : "values", !IS_MAP, true);
    setSpecies$4(CONSTRUCTOR_NAME);
  }
};
var collection$3 = collection$4;
var collectionStrong$1 = collectionStrong$2;
collection$3("Map", function(init) {
  return function Map2() {
    return init(this, arguments.length ? arguments[0] : void 0);
  };
}, collectionStrong$1);
var uncurryThis$1i = functionUncurryThis;
var MapPrototype$1 = Map.prototype;
var mapHelpers = {
  // eslint-disable-next-line es/no-map -- safe
  Map,
  set: uncurryThis$1i(MapPrototype$1.set),
  get: uncurryThis$1i(MapPrototype$1.get),
  has: uncurryThis$1i(MapPrototype$1.has),
  remove: uncurryThis$1i(MapPrototype$1["delete"]),
  proto: MapPrototype$1
};
var $$4t = _export;
var uncurryThis$1h = functionUncurryThis;
var aCallable$y = aCallable$Q;
var requireObjectCoercible$k = requireObjectCoercible$q;
var iterate$x = iterate$H;
var MapHelpers$d = mapHelpers;
var fails$$ = fails$1z;
var Map$b = MapHelpers$d.Map;
var has$h = MapHelpers$d.has;
var get$8 = MapHelpers$d.get;
var set$d = MapHelpers$d.set;
var push$l = uncurryThis$1h([].push);
var DOES_NOT_WORK_WITH_PRIMITIVES$1 = fails$$(function() {
  return Map$b.groupBy("ab", function(it) {
    return it;
  }).get("a").length !== 1;
});
$$4t({
  target: "Map",
  stat: true,
  forced: DOES_NOT_WORK_WITH_PRIMITIVES$1
}, {
  groupBy: function groupBy(items, callbackfn) {
    requireObjectCoercible$k(items);
    aCallable$y(callbackfn);
    var map7 = new Map$b();
    var k = 0;
    iterate$x(items, function(value) {
      var key = callbackfn(value, k++);
      if (!has$h(map7, key)) set$d(map7, key, [value]);
      else push$l(get$8(map7, key), value);
    });
    return map7;
  }
});
var log$6 = Math.log;
var mathLog1p = Math.log1p || function log1p(x) {
  var n = +x;
  return n > -1e-8 && n < 1e-8 ? n - n * n / 2 : log$6(1 + n);
};
var $$4s = _export;
var log1p$1 = mathLog1p;
var $acosh = Math.acosh;
var log$5 = Math.log;
var sqrt$2 = Math.sqrt;
var LN2 = Math.LN2;
var FORCED$t = !$acosh || Math.floor($acosh(Number.MAX_VALUE)) !== 710 || $acosh(Infinity) !== Infinity;
$$4s({
  target: "Math",
  stat: true,
  forced: FORCED$t
}, {
  acosh: function acosh(x) {
    var n = +x;
    return n < 1 ? NaN : n > 9490626562425156e-8 ? log$5(n) + LN2 : log1p$1(n - 1 + sqrt$2(n - 1) * sqrt$2(n + 1));
  }
});
var $$4r = _export;
var $asinh = Math.asinh;
var log$4 = Math.log;
var sqrt$1 = Math.sqrt;
function asinh(x) {
  var n = +x;
  return !isFinite(n) || n === 0 ? n : n < 0 ? -asinh(-n) : log$4(n + sqrt$1(n * n + 1));
}
var FORCED$s = !($asinh && 1 / $asinh(0) > 0);
$$4r({
  target: "Math",
  stat: true,
  forced: FORCED$s
}, {
  asinh
});
var $$4q = _export;
var $atanh = Math.atanh;
var log$3 = Math.log;
var FORCED$r = !($atanh && 1 / $atanh(-0) < 0);
$$4q({
  target: "Math",
  stat: true,
  forced: FORCED$r
}, {
  atanh: function atanh(x) {
    var n = +x;
    return n === 0 ? n : log$3((1 + n) / (1 - n)) / 2;
  }
});
var $$4p = _export;
var sign$1 = mathSign;
var abs$6 = Math.abs;
var pow$5 = Math.pow;
$$4p({
  target: "Math",
  stat: true
}, {
  cbrt: function cbrt(x) {
    var n = +x;
    return sign$1(n) * pow$5(abs$6(n), 1 / 3);
  }
});
var $$4o = _export;
var floor$7 = Math.floor;
var log$2 = Math.log;
var LOG2E = Math.LOG2E;
$$4o({
  target: "Math",
  stat: true
}, {
  clz32: function clz32(x) {
    var n = x >>> 0;
    return n ? 31 - floor$7(log$2(n + 0.5) * LOG2E) : 32;
  }
});
var $expm1 = Math.expm1;
var exp$2 = Math.exp;
var mathExpm1 = !$expm1 || $expm1(10) > 22025.465794806718 || $expm1(10) < 22025.465794806718 || $expm1(-2e-17) !== -2e-17 ? function expm1(x) {
  var n = +x;
  return n === 0 ? n : n > -1e-6 && n < 1e-6 ? n + n * n / 2 : exp$2(n) - 1;
} : $expm1;
var $$4n = _export;
var expm1$3 = mathExpm1;
var $cosh = Math.cosh;
var abs$5 = Math.abs;
var E$1 = Math.E;
var FORCED$q = !$cosh || $cosh(710) === Infinity;
$$4n({
  target: "Math",
  stat: true,
  forced: FORCED$q
}, {
  cosh: function cosh(x) {
    var t = expm1$3(abs$5(x) - 1) + 1;
    return (t + 1 / (t * E$1 * E$1)) * (E$1 / 2);
  }
});
var $$4m = _export;
var expm1$2 = mathExpm1;
$$4m({
  target: "Math",
  stat: true,
  forced: expm1$2 !== Math.expm1
}, {
  expm1: expm1$2
});
var $$4l = _export;
var fround$1 = mathFround;
$$4l({
  target: "Math",
  stat: true
}, {
  fround: fround$1
});
var $$4k = _export;
var floatRound = mathFloatRound;
var FLOAT16_EPSILON = 9765625e-10;
var FLOAT16_MAX_VALUE = 65504;
var FLOAT16_MIN_VALUE = 6103515625e-14;
$$4k({
  target: "Math",
  stat: true
}, {
  f16round: function f16round(x) {
    return floatRound(x, FLOAT16_EPSILON, FLOAT16_MAX_VALUE, FLOAT16_MIN_VALUE);
  }
});
var $$4j = _export;
var $hypot = Math.hypot;
var abs$4 = Math.abs;
var sqrt = Math.sqrt;
var FORCED$p = !!$hypot && $hypot(Infinity, NaN) !== Infinity;
$$4j({
  target: "Math",
  stat: true,
  arity: 2,
  forced: FORCED$p
}, {
  // eslint-disable-next-line no-unused-vars -- required for `.length`
  hypot: function hypot(value1, value2) {
    var sum = 0;
    var i = 0;
    var aLen = arguments.length;
    var larg = 0;
    var arg, div;
    while (i < aLen) {
      arg = abs$4(arguments[i++]);
      if (larg < arg) {
        div = larg / arg;
        sum = sum * div * div + 1;
        larg = arg;
      } else if (arg > 0) {
        div = arg / larg;
        sum += div * div;
      } else sum += arg;
    }
    return larg === Infinity ? Infinity : larg * sqrt(sum);
  }
});
var $$4i = _export;
var fails$_ = fails$1z;
var $imul = Math.imul;
var FORCED$o = fails$_(function() {
  return $imul(4294967295, 5) !== -5 || $imul.length !== 2;
});
$$4i({
  target: "Math",
  stat: true,
  forced: FORCED$o
}, {
  imul: function imul(x, y) {
    var UINT16 = 65535;
    var xn = +x;
    var yn = +y;
    var xl = UINT16 & xn;
    var yl = UINT16 & yn;
    return 0 | xl * yl + ((UINT16 & xn >>> 16) * yl + xl * (UINT16 & yn >>> 16) << 16 >>> 0);
  }
});
var log$1 = Math.log;
var LOG10E = Math.LOG10E;
var mathLog10 = Math.log10 || function log10(x) {
  return log$1(x) * LOG10E;
};
var $$4h = _export;
var log10$1 = mathLog10;
$$4h({
  target: "Math",
  stat: true
}, {
  log10: log10$1
});
var $$4g = _export;
var log1p2 = mathLog1p;
$$4g({
  target: "Math",
  stat: true
}, {
  log1p: log1p2
});
var $$4f = _export;
var log22 = mathLog2;
$$4f({
  target: "Math",
  stat: true
}, {
  log2: log22
});
var $$4e = _export;
var sign2 = mathSign;
$$4e({
  target: "Math",
  stat: true
}, {
  sign: sign2
});
var $$4d = _export;
var fails$Z = fails$1z;
var expm1$1 = mathExpm1;
var abs$3 = Math.abs;
var exp$1 = Math.exp;
var E = Math.E;
var FORCED$n = fails$Z(function() {
  return Math.sinh(-2e-17) !== -2e-17;
});
$$4d({
  target: "Math",
  stat: true,
  forced: FORCED$n
}, {
  sinh: function sinh(x) {
    var n = +x;
    return abs$3(n) < 1 ? (expm1$1(n) - expm1$1(-n)) / 2 : (exp$1(n - 1) - exp$1(-n - 1)) * (E / 2);
  }
});
var $$4c = _export;
var expm12 = mathExpm1;
var exp = Math.exp;
$$4c({
  target: "Math",
  stat: true
}, {
  tanh: function tanh(x) {
    var n = +x;
    var a = expm12(n);
    var b = expm12(-n);
    return a === Infinity ? 1 : b === Infinity ? -1 : (a - b) / (exp(n) + exp(-n));
  }
});
var setToStringTag$6 = setToStringTag$e;
setToStringTag$6(Math, "Math", true);
var $$4b = _export;
var trunc2 = mathTrunc;
$$4b({
  target: "Math",
  stat: true
}, {
  trunc: trunc2
});
var uncurryThis$1g = functionUncurryThis;
var thisNumberValue$5 = uncurryThis$1g(1 .valueOf);
var whitespaces$6 = "	\n\v\f\r \u2028\u2029\uFEFF";
var uncurryThis$1f = functionUncurryThis;
var requireObjectCoercible$j = requireObjectCoercible$q;
var toString$A = toString$J;
var whitespaces$5 = whitespaces$6;
var replace$8 = uncurryThis$1f("".replace);
var ltrim = RegExp("^[" + whitespaces$5 + "]+");
var rtrim = RegExp("(^|[^" + whitespaces$5 + "])[" + whitespaces$5 + "]+$");
var createMethod$3 = function(TYPE) {
  return function($this) {
    var string = toString$A(requireObjectCoercible$j($this));
    if (TYPE & 1) string = replace$8(string, ltrim, "");
    if (TYPE & 2) string = replace$8(string, rtrim, "$1");
    return string;
  };
};
var stringTrim = {
  // `String.prototype.{ trimLeft, trimStart }` methods
  // https://tc39.es/ecma262/#sec-string.prototype.trimstart
  start: createMethod$3(1),
  // `String.prototype.{ trimRight, trimEnd }` methods
  // https://tc39.es/ecma262/#sec-string.prototype.trimend
  end: createMethod$3(2),
  // `String.prototype.trim` method
  // https://tc39.es/ecma262/#sec-string.prototype.trim
  trim: createMethod$3(3)
};
var $$4a = _export;
var IS_PURE$a = isPure;
var DESCRIPTORS$A = descriptors;
var globalThis$S = globalThis_1;
var path = path$2;
var uncurryThis$1e = functionUncurryThis;
var isForced$2 = isForced_1;
var hasOwn$m = hasOwnProperty_1;
var inheritIfRequired$3 = inheritIfRequired$7;
var isPrototypeOf$5 = objectIsPrototypeOf;
var isSymbol$3 = isSymbol$8;
var toPrimitive$1 = toPrimitive$4;
var fails$Y = fails$1z;
var getOwnPropertyNames$4 = objectGetOwnPropertyNames.f;
var getOwnPropertyDescriptor$a = objectGetOwnPropertyDescriptor.f;
var defineProperty$9 = objectDefineProperty.f;
var thisNumberValue$4 = thisNumberValue$5;
var trim$2 = stringTrim.trim;
var NUMBER$1 = "Number";
var NativeNumber = globalThis$S[NUMBER$1];
path[NUMBER$1];
var NumberPrototype = NativeNumber.prototype;
var TypeError$6 = globalThis$S.TypeError;
var stringSlice$i = uncurryThis$1e("".slice);
var charCodeAt$7 = uncurryThis$1e("".charCodeAt);
var toNumeric = function(value) {
  var primValue = toPrimitive$1(value, "number");
  return typeof primValue == "bigint" ? primValue : toNumber(primValue);
};
var toNumber = function(argument) {
  var it = toPrimitive$1(argument, "number");
  var first, third, radix, maxCode, digits, length, index, code2;
  if (isSymbol$3(it)) throw new TypeError$6("Cannot convert a Symbol value to a number");
  if (typeof it == "string" && it.length > 2) {
    it = trim$2(it);
    first = charCodeAt$7(it, 0);
    if (first === 43 || first === 45) {
      third = charCodeAt$7(it, 2);
      if (third === 88 || third === 120) return NaN;
    } else if (first === 48) {
      switch (charCodeAt$7(it, 1)) {
        case 66:
        case 98:
          radix = 2;
          maxCode = 49;
          break;
        case 79:
        case 111:
          radix = 8;
          maxCode = 55;
          break;
        default:
          return +it;
      }
      digits = stringSlice$i(it, 2);
      length = digits.length;
      for (index = 0; index < length; index++) {
        code2 = charCodeAt$7(digits, index);
        if (code2 < 48 || code2 > maxCode) return NaN;
      }
      return parseInt(digits, radix);
    }
  }
  return +it;
};
var FORCED$m = isForced$2(NUMBER$1, !NativeNumber(" 0o1") || !NativeNumber("0b1") || NativeNumber("+0x1"));
var calledWithNew = function(dummy) {
  return isPrototypeOf$5(NumberPrototype, dummy) && fails$Y(function() {
    thisNumberValue$4(dummy);
  });
};
var NumberWrapper = function Number2(value) {
  var n = arguments.length < 1 ? 0 : NativeNumber(toNumeric(value));
  return calledWithNew(this) ? inheritIfRequired$3(Object(n), this, NumberWrapper) : n;
};
NumberWrapper.prototype = NumberPrototype;
if (FORCED$m && !IS_PURE$a) NumberPrototype.constructor = NumberWrapper;
$$4a({
  global: true,
  constructor: true,
  wrap: true,
  forced: FORCED$m
}, {
  Number: NumberWrapper
});
var copyConstructorProperties$1 = function(target, source) {
  for (var keys6 = DESCRIPTORS$A ? getOwnPropertyNames$4(source) : (
    // ES3:
    "MAX_VALUE,MIN_VALUE,NaN,NEGATIVE_INFINITY,POSITIVE_INFINITY,EPSILON,MAX_SAFE_INTEGER,MIN_SAFE_INTEGER,isFinite,isInteger,isNaN,isSafeInteger,parseFloat,parseInt,fromString,range".split(",")
  ), j = 0, key; keys6.length > j; j++) {
    if (hasOwn$m(source, key = keys6[j]) && !hasOwn$m(target, key)) {
      defineProperty$9(target, key, getOwnPropertyDescriptor$a(source, key));
    }
  }
};
if (FORCED$m || IS_PURE$a) copyConstructorProperties$1(path[NUMBER$1], NativeNumber);
var $$49 = _export;
$$49({
  target: "Number",
  stat: true,
  nonConfigurable: true,
  nonWritable: true
}, {
  EPSILON: Math.pow(2, -52)
});
var globalThis$R = globalThis_1;
var globalIsFinite = globalThis$R.isFinite;
var numberIsFinite$2 = Number.isFinite || function isFinite2(it) {
  return typeof it == "number" && globalIsFinite(it);
};
var $$48 = _export;
var numberIsFinite$1 = numberIsFinite$2;
$$48({
  target: "Number",
  stat: true
}, {
  isFinite: numberIsFinite$1
});
var isObject$u = isObject$O;
var floor$6 = Math.floor;
var isIntegralNumber$3 = Number.isInteger || function isInteger(it) {
  return !isObject$u(it) && isFinite(it) && floor$6(it) === it;
};
var $$47 = _export;
var isIntegralNumber$2 = isIntegralNumber$3;
$$47({
  target: "Number",
  stat: true
}, {
  isInteger: isIntegralNumber$2
});
var $$46 = _export;
$$46({
  target: "Number",
  stat: true
}, {
  isNaN: function isNaN2(number) {
    return number !== number;
  }
});
var $$45 = _export;
var isIntegralNumber$1 = isIntegralNumber$3;
var abs$2 = Math.abs;
$$45({
  target: "Number",
  stat: true
}, {
  isSafeInteger: function isSafeInteger(number) {
    return isIntegralNumber$1(number) && abs$2(number) <= 9007199254740991;
  }
});
var $$44 = _export;
$$44({
  target: "Number",
  stat: true,
  nonConfigurable: true,
  nonWritable: true
}, {
  MAX_SAFE_INTEGER: 9007199254740991
});
var $$43 = _export;
$$43({
  target: "Number",
  stat: true,
  nonConfigurable: true,
  nonWritable: true
}, {
  MIN_SAFE_INTEGER: -9007199254740991
});
var globalThis$Q = globalThis_1;
var fails$X = fails$1z;
var uncurryThis$1d = functionUncurryThis;
var toString$z = toString$J;
var trim$1 = stringTrim.trim;
var whitespaces$4 = whitespaces$6;
var charAt$k = uncurryThis$1d("".charAt);
var $parseFloat$1 = globalThis$Q.parseFloat;
var Symbol$6 = globalThis$Q.Symbol;
var ITERATOR$6 = Symbol$6 && Symbol$6.iterator;
var FORCED$l = 1 / $parseFloat$1(whitespaces$4 + "-0") !== -Infinity || ITERATOR$6 && !fails$X(function() {
  $parseFloat$1(Object(ITERATOR$6));
});
var numberParseFloat = FORCED$l ? function parseFloat2(string) {
  var trimmedString = trim$1(toString$z(string));
  var result = $parseFloat$1(trimmedString);
  return result === 0 && charAt$k(trimmedString, 0) === "-" ? -0 : result;
} : $parseFloat$1;
var $$42 = _export;
var parseFloat$1 = numberParseFloat;
$$42({
  target: "Number",
  stat: true,
  forced: Number.parseFloat !== parseFloat$1
}, {
  parseFloat: parseFloat$1
});
var globalThis$P = globalThis_1;
var fails$W = fails$1z;
var uncurryThis$1c = functionUncurryThis;
var toString$y = toString$J;
var trim = stringTrim.trim;
var whitespaces$3 = whitespaces$6;
var $parseInt$4 = globalThis$P.parseInt;
var Symbol$5 = globalThis$P.Symbol;
var ITERATOR$5 = Symbol$5 && Symbol$5.iterator;
var hex = /^[+-]?0x/i;
var exec$e = uncurryThis$1c(hex.exec);
var FORCED$k = $parseInt$4(whitespaces$3 + "08") !== 8 || $parseInt$4(whitespaces$3 + "0x16") !== 22 || ITERATOR$5 && !fails$W(function() {
  $parseInt$4(Object(ITERATOR$5));
});
var numberParseInt = FORCED$k ? function parseInt2(string, radix) {
  var S = trim(toString$y(string));
  return $parseInt$4(S, radix >>> 0 || (exec$e(hex, S) ? 16 : 10));
} : $parseInt$4;
var $$41 = _export;
var parseInt$3 = numberParseInt;
$$41({
  target: "Number",
  stat: true,
  forced: Number.parseInt !== parseInt$3
}, {
  parseInt: parseInt$3
});
var $$40 = _export;
var uncurryThis$1b = functionUncurryThis;
var toIntegerOrInfinity$b = toIntegerOrInfinity$p;
var thisNumberValue$3 = thisNumberValue$5;
var $repeat$1 = stringRepeat;
var log102 = mathLog10;
var fails$V = fails$1z;
var $RangeError$9 = RangeError;
var $String$3 = String;
var $isFinite = isFinite;
var abs$1 = Math.abs;
var floor$5 = Math.floor;
var pow$4 = Math.pow;
var round$1 = Math.round;
var nativeToExponential = uncurryThis$1b(1 .toExponential);
var repeat$2 = uncurryThis$1b($repeat$1);
var stringSlice$h = uncurryThis$1b("".slice);
var ROUNDS_PROPERLY = nativeToExponential(-69e-12, 4) === "-6.9000e-11" && nativeToExponential(1.255, 2) === "1.25e+0" && nativeToExponential(12345, 3) === "1.235e+4" && nativeToExponential(25, 0) === "3e+1";
var throwsOnInfinityFraction = function() {
  return fails$V(function() {
    nativeToExponential(1, Infinity);
  }) && fails$V(function() {
    nativeToExponential(1, -Infinity);
  });
};
var properNonFiniteThisCheck = function() {
  return !fails$V(function() {
    nativeToExponential(Infinity, Infinity);
    nativeToExponential(NaN, Infinity);
  });
};
var FORCED$j = !ROUNDS_PROPERLY || !throwsOnInfinityFraction() || !properNonFiniteThisCheck();
$$40({
  target: "Number",
  proto: true,
  forced: FORCED$j
}, {
  toExponential: function toExponential(fractionDigits) {
    var x = thisNumberValue$3(this);
    if (fractionDigits === void 0) return nativeToExponential(x);
    var f = toIntegerOrInfinity$b(fractionDigits);
    if (!$isFinite(x)) return String(x);
    if (f < 0 || f > 20) throw new $RangeError$9("Incorrect fraction digits");
    if (ROUNDS_PROPERLY) return nativeToExponential(x, f);
    var s = "";
    var m, e, c, d;
    if (x < 0) {
      s = "-";
      x = -x;
    }
    if (x === 0) {
      e = 0;
      m = repeat$2("0", f + 1);
    } else {
      var l = log102(x);
      e = floor$5(l);
      var w = pow$4(10, e - f);
      var n = round$1(x / w);
      if (2 * x >= (2 * n + 1) * w) {
        n += 1;
      }
      if (n >= pow$4(10, f + 1)) {
        n /= 10;
        e += 1;
      }
      m = $String$3(n);
    }
    if (f !== 0) {
      m = stringSlice$h(m, 0, 1) + "." + stringSlice$h(m, 1);
    }
    if (e === 0) {
      c = "+";
      d = "0";
    } else {
      c = e > 0 ? "+" : "-";
      d = $String$3(abs$1(e));
    }
    m += "e" + c + d;
    return s + m;
  }
});
var $$3$ = _export;
var uncurryThis$1a = functionUncurryThis;
var toIntegerOrInfinity$a = toIntegerOrInfinity$p;
var thisNumberValue$2 = thisNumberValue$5;
var $repeat = stringRepeat;
var fails$U = fails$1z;
var $RangeError$8 = RangeError;
var $String$2 = String;
var floor$4 = Math.floor;
var repeat$1 = uncurryThis$1a($repeat);
var stringSlice$g = uncurryThis$1a("".slice);
var nativeToFixed = uncurryThis$1a(1 .toFixed);
var pow$3 = function(x, n, acc) {
  return n === 0 ? acc : n % 2 === 1 ? pow$3(x, n - 1, acc * x) : pow$3(x * x, n / 2, acc);
};
var log = function(x) {
  var n = 0;
  var x2 = x;
  while (x2 >= 4096) {
    n += 12;
    x2 /= 4096;
  }
  while (x2 >= 2) {
    n += 1;
    x2 /= 2;
  }
  return n;
};
var multiply = function(data2, n, c) {
  var index = -1;
  var c2 = c;
  while (++index < 6) {
    c2 += n * data2[index];
    data2[index] = c2 % 1e7;
    c2 = floor$4(c2 / 1e7);
  }
};
var divide = function(data2, n) {
  var index = 6;
  var c = 0;
  while (--index >= 0) {
    c += data2[index];
    data2[index] = floor$4(c / n);
    c = c % n * 1e7;
  }
};
var dataToString = function(data2) {
  var index = 6;
  var s = "";
  while (--index >= 0) {
    if (s !== "" || index === 0 || data2[index] !== 0) {
      var t = $String$2(data2[index]);
      s = s === "" ? t : s + repeat$1("0", 7 - t.length) + t;
    }
  }
  return s;
};
var FORCED$i = fails$U(function() {
  return nativeToFixed(8e-5, 3) !== "0.000" || nativeToFixed(0.9, 0) !== "1" || nativeToFixed(1.255, 2) !== "1.25" || nativeToFixed(1000000000000000100, 0) !== "1000000000000000128";
}) || !fails$U(function() {
  nativeToFixed({});
});
$$3$({
  target: "Number",
  proto: true,
  forced: FORCED$i
}, {
  toFixed: function toFixed(fractionDigits) {
    var number = thisNumberValue$2(this);
    var fractDigits = toIntegerOrInfinity$a(fractionDigits);
    var data2 = [0, 0, 0, 0, 0, 0];
    var sign3 = "";
    var result = "0";
    var e, z, j, k;
    if (fractDigits < 0 || fractDigits > 20) throw new $RangeError$8("Incorrect fraction digits");
    if (number !== number) return "NaN";
    if (number <= -1e21 || number >= 1e21) return $String$2(number);
    if (number < 0) {
      sign3 = "-";
      number = -number;
    }
    if (number > 1e-21) {
      e = log(number * pow$3(2, 69, 1)) - 69;
      z = e < 0 ? number * pow$3(2, -e, 1) : number / pow$3(2, e, 1);
      z *= 4503599627370496;
      e = 52 - e;
      if (e > 0) {
        multiply(data2, 0, z);
        j = fractDigits;
        while (j >= 7) {
          multiply(data2, 1e7, 0);
          j -= 7;
        }
        multiply(data2, pow$3(10, j, 1), 0);
        j = e - 1;
        while (j >= 23) {
          divide(data2, 1 << 23);
          j -= 23;
        }
        divide(data2, 1 << j);
        multiply(data2, 1, 1);
        divide(data2, 2);
        result = dataToString(data2);
      } else {
        multiply(data2, 0, z);
        multiply(data2, 1 << -e, 0);
        result = dataToString(data2) + repeat$1("0", fractDigits);
      }
    }
    if (fractDigits > 0) {
      k = result.length;
      result = sign3 + (k <= fractDigits ? "0." + repeat$1("0", fractDigits - k) + result : stringSlice$g(result, 0, k - fractDigits) + "." + stringSlice$g(result, k - fractDigits));
    } else {
      result = sign3 + result;
    }
    return result;
  }
});
var $$3_ = _export;
var uncurryThis$19 = functionUncurryThis;
var fails$T = fails$1z;
var thisNumberValue$1 = thisNumberValue$5;
var nativeToPrecision = uncurryThis$19(1 .toPrecision);
var FORCED$h = fails$T(function() {
  return nativeToPrecision(1, void 0) !== "1";
}) || !fails$T(function() {
  nativeToPrecision({});
});
$$3_({
  target: "Number",
  proto: true,
  forced: FORCED$h
}, {
  toPrecision: function toPrecision(precision) {
    return precision === void 0 ? nativeToPrecision(thisNumberValue$1(this)) : nativeToPrecision(thisNumberValue$1(this), precision);
  }
});
var DESCRIPTORS$z = descriptors;
var uncurryThis$18 = functionUncurryThis;
var call$Z = functionCall;
var fails$S = fails$1z;
var objectKeys$3 = objectKeys$6;
var getOwnPropertySymbolsModule = objectGetOwnPropertySymbols;
var propertyIsEnumerableModule = objectPropertyIsEnumerable;
var toObject$k = toObject$E;
var IndexedObject$2 = indexedObject;
var $assign = Object.assign;
var defineProperty$8 = Object.defineProperty;
var concat$2 = uncurryThis$18([].concat);
var objectAssign = !$assign || fails$S(function() {
  if (DESCRIPTORS$z && $assign({
    b: 1
  }, $assign(defineProperty$8({}, "a", {
    enumerable: true,
    get: function() {
      defineProperty$8(this, "b", {
        value: 3,
        enumerable: false
      });
    }
  }), {
    b: 2
  })).b !== 1) return true;
  var A = {};
  var B = {};
  var symbol = Symbol("assign detection");
  var alphabet = "abcdefghijklmnopqrst";
  A[symbol] = 7;
  alphabet.split("").forEach(function(chr) {
    B[chr] = chr;
  });
  return $assign({}, A)[symbol] !== 7 || objectKeys$3($assign({}, B)).join("") !== alphabet;
}) ? function assign(target, source) {
  var T = toObject$k(target);
  var argumentsLength = arguments.length;
  var index = 1;
  var getOwnPropertySymbols2 = getOwnPropertySymbolsModule.f;
  var propertyIsEnumerable4 = propertyIsEnumerableModule.f;
  while (argumentsLength > index) {
    var S = IndexedObject$2(arguments[index++]);
    var keys6 = getOwnPropertySymbols2 ? concat$2(objectKeys$3(S), getOwnPropertySymbols2(S)) : objectKeys$3(S);
    var length = keys6.length;
    var j = 0;
    var key;
    while (length > j) {
      key = keys6[j++];
      if (!DESCRIPTORS$z || call$Z(propertyIsEnumerable4, S, key)) T[key] = S[key];
    }
  }
  return T;
} : $assign;
var $$3Z = _export;
var assign$1 = objectAssign;
$$3Z({
  target: "Object",
  stat: true,
  arity: 2,
  forced: Object.assign !== assign$1
}, {
  assign: assign$1
});
var $$3Y = _export;
var DESCRIPTORS$y = descriptors;
var create$d = objectCreate$1;
$$3Y({
  target: "Object",
  stat: true,
  sham: !DESCRIPTORS$y
}, {
  create: create$d
});
var globalThis$O = globalThis_1;
var fails$R = fails$1z;
var WEBKIT$1 = environmentWebkitVersion;
var objectPrototypeAccessorsForced = !fails$R(function() {
  if (WEBKIT$1 && WEBKIT$1 < 535) return;
  var key = Math.random();
  __defineSetter__.call(null, key, function() {
  });
  delete globalThis$O[key];
});
var $$3X = _export;
var DESCRIPTORS$x = descriptors;
var FORCED$g = objectPrototypeAccessorsForced;
var aCallable$x = aCallable$Q;
var toObject$j = toObject$E;
var definePropertyModule$4 = objectDefineProperty;
if (DESCRIPTORS$x) {
  $$3X({
    target: "Object",
    proto: true,
    forced: FORCED$g
  }, {
    __defineGetter__: function __defineGetter__(P, getter) {
      definePropertyModule$4.f(toObject$j(this), P, {
        get: aCallable$x(getter),
        enumerable: true,
        configurable: true
      });
    }
  });
}
var $$3W = _export;
var DESCRIPTORS$w = descriptors;
var defineProperties3 = objectDefineProperties.f;
$$3W({
  target: "Object",
  stat: true,
  forced: Object.defineProperties !== defineProperties3,
  sham: !DESCRIPTORS$w
}, {
  defineProperties: defineProperties3
});
var $$3V = _export;
var DESCRIPTORS$v = descriptors;
var defineProperty$7 = objectDefineProperty.f;
$$3V({
  target: "Object",
  stat: true,
  forced: Object.defineProperty !== defineProperty$7,
  sham: !DESCRIPTORS$v
}, {
  defineProperty: defineProperty$7
});
var $$3U = _export;
var DESCRIPTORS$u = descriptors;
var FORCED$f = objectPrototypeAccessorsForced;
var aCallable$w = aCallable$Q;
var toObject$i = toObject$E;
var definePropertyModule$3 = objectDefineProperty;
if (DESCRIPTORS$u) {
  $$3U({
    target: "Object",
    proto: true,
    forced: FORCED$f
  }, {
    __defineSetter__: function __defineSetter__2(P, setter) {
      definePropertyModule$3.f(toObject$i(this), P, {
        set: aCallable$w(setter),
        enumerable: true,
        configurable: true
      });
    }
  });
}
var DESCRIPTORS$t = descriptors;
var fails$Q = fails$1z;
var uncurryThis$17 = functionUncurryThis;
var objectGetPrototypeOf$1 = objectGetPrototypeOf$2;
var objectKeys$2 = objectKeys$6;
var toIndexedObject$5 = toIndexedObject$k;
var $propertyIsEnumerable = objectPropertyIsEnumerable.f;
var propertyIsEnumerable3 = uncurryThis$17($propertyIsEnumerable);
var push$k = uncurryThis$17([].push);
var IE_BUG = DESCRIPTORS$t && fails$Q(function() {
  var O = /* @__PURE__ */ Object.create(null);
  O[2] = 2;
  return !propertyIsEnumerable3(O, 2);
});
var createMethod$2 = function(TO_ENTRIES) {
  return function(it) {
    var O = toIndexedObject$5(it);
    var keys6 = objectKeys$2(O);
    var IE_WORKAROUND = IE_BUG && objectGetPrototypeOf$1(O) === null;
    var length = keys6.length;
    var i = 0;
    var result = [];
    var key;
    while (length > i) {
      key = keys6[i++];
      if (!DESCRIPTORS$t || (IE_WORKAROUND ? key in O : propertyIsEnumerable3(O, key))) {
        push$k(result, TO_ENTRIES ? [key, O[key]] : O[key]);
      }
    }
    return result;
  };
};
var objectToArray = {
  // `Object.entries` method
  // https://tc39.es/ecma262/#sec-object.entries
  entries: createMethod$2(true),
  // `Object.values` method
  // https://tc39.es/ecma262/#sec-object.values
  values: createMethod$2(false)
};
var $$3T = _export;
var $entries = objectToArray.entries;
$$3T({
  target: "Object",
  stat: true
}, {
  entries: function entries(O) {
    return $entries(O);
  }
});
var $$3S = _export;
var FREEZING$6 = freezing;
var fails$P = fails$1z;
var isObject$t = isObject$O;
var onFreeze$2 = internalMetadataExports.onFreeze;
var $freeze = Object.freeze;
var FAILS_ON_PRIMITIVES$5 = fails$P(function() {
  $freeze(1);
});
$$3S({
  target: "Object",
  stat: true,
  forced: FAILS_ON_PRIMITIVES$5,
  sham: !FREEZING$6
}, {
  freeze: function freeze(it) {
    return $freeze && isObject$t(it) ? $freeze(onFreeze$2(it)) : it;
  }
});
var $$3R = _export;
var iterate$w = iterate$H;
var createProperty$4 = createProperty$b;
$$3R({
  target: "Object",
  stat: true
}, {
  fromEntries: function fromEntries(iterable) {
    var obj = {};
    iterate$w(iterable, function(k, v) {
      createProperty$4(obj, k, v);
    }, {
      AS_ENTRIES: true
    });
    return obj;
  }
});
var $$3Q = _export;
var fails$O = fails$1z;
var toIndexedObject$4 = toIndexedObject$k;
var nativeGetOwnPropertyDescriptor$1 = objectGetOwnPropertyDescriptor.f;
var DESCRIPTORS$s = descriptors;
var FORCED$e = !DESCRIPTORS$s || fails$O(function() {
  nativeGetOwnPropertyDescriptor$1(1);
});
$$3Q({
  target: "Object",
  stat: true,
  forced: FORCED$e,
  sham: !DESCRIPTORS$s
}, {
  getOwnPropertyDescriptor: function getOwnPropertyDescriptor3(it, key) {
    return nativeGetOwnPropertyDescriptor$1(toIndexedObject$4(it), key);
  }
});
var $$3P = _export;
var DESCRIPTORS$r = descriptors;
var ownKeys$1 = ownKeys$3;
var toIndexedObject$3 = toIndexedObject$k;
var getOwnPropertyDescriptorModule$4 = objectGetOwnPropertyDescriptor;
var createProperty$3 = createProperty$b;
$$3P({
  target: "Object",
  stat: true,
  sham: !DESCRIPTORS$r
}, {
  getOwnPropertyDescriptors: function getOwnPropertyDescriptors(object) {
    var O = toIndexedObject$3(object);
    var getOwnPropertyDescriptor7 = getOwnPropertyDescriptorModule$4.f;
    var keys6 = ownKeys$1(O);
    var result = {};
    var index = 0;
    var key, descriptor;
    while (keys6.length > index) {
      descriptor = getOwnPropertyDescriptor7(O, key = keys6[index++]);
      if (descriptor !== void 0) createProperty$3(result, key, descriptor);
    }
    return result;
  }
});
var $$3O = _export;
var fails$N = fails$1z;
var getOwnPropertyNames$3 = objectGetOwnPropertyNamesExternal.f;
var FAILS_ON_PRIMITIVES$4 = fails$N(function() {
  return !Object.getOwnPropertyNames(1);
});
$$3O({
  target: "Object",
  stat: true,
  forced: FAILS_ON_PRIMITIVES$4
}, {
  getOwnPropertyNames: getOwnPropertyNames$3
});
var $$3N = _export;
var fails$M = fails$1z;
var toObject$h = toObject$E;
var nativeGetPrototypeOf = objectGetPrototypeOf$2;
var CORRECT_PROTOTYPE_GETTER$1 = correctPrototypeGetter;
var FAILS_ON_PRIMITIVES$3 = fails$M(function() {
  nativeGetPrototypeOf(1);
});
$$3N({
  target: "Object",
  stat: true,
  forced: FAILS_ON_PRIMITIVES$3,
  sham: !CORRECT_PROTOTYPE_GETTER$1
}, {
  getPrototypeOf: function getPrototypeOf(it) {
    return nativeGetPrototypeOf(toObject$h(it));
  }
});
var $$3M = _export;
var getBuiltIn$E = getBuiltIn$Q;
var uncurryThis$16 = functionUncurryThis;
var aCallable$v = aCallable$Q;
var requireObjectCoercible$i = requireObjectCoercible$q;
var toPropertyKey$5 = toPropertyKey$9;
var iterate$v = iterate$H;
var fails$L = fails$1z;
var nativeGroupBy = Object.groupBy;
var create$c = getBuiltIn$E("Object", "create");
var push$j = uncurryThis$16([].push);
var DOES_NOT_WORK_WITH_PRIMITIVES = !nativeGroupBy || fails$L(function() {
  return nativeGroupBy("ab", function(it) {
    return it;
  }).a.length !== 1;
});
$$3M({
  target: "Object",
  stat: true,
  forced: DOES_NOT_WORK_WITH_PRIMITIVES
}, {
  groupBy: function groupBy2(items, callbackfn) {
    requireObjectCoercible$i(items);
    aCallable$v(callbackfn);
    var obj = create$c(null);
    var k = 0;
    iterate$v(items, function(value) {
      var key = toPropertyKey$5(callbackfn(value, k++));
      if (key in obj) push$j(obj[key], value);
      else obj[key] = [value];
    });
    return obj;
  }
});
var $$3L = _export;
var hasOwn$l = hasOwnProperty_1;
$$3L({
  target: "Object",
  stat: true
}, {
  hasOwn: hasOwn$l
});
var sameValue$2 = Object.is || function is(x, y) {
  return x === y ? x !== 0 || 1 / x === 1 / y : x !== x && y !== y;
};
var $$3K = _export;
var is2 = sameValue$2;
$$3K({
  target: "Object",
  stat: true
}, {
  is: is2
});
var $$3J = _export;
var $isExtensible$1 = objectIsExtensible;
$$3J({
  target: "Object",
  stat: true,
  forced: Object.isExtensible !== $isExtensible$1
}, {
  isExtensible: $isExtensible$1
});
var $$3I = _export;
var fails$K = fails$1z;
var isObject$s = isObject$O;
var classof$e = classofRaw$2;
var ARRAY_BUFFER_NON_EXTENSIBLE$1 = arrayBufferNonExtensible;
var $isFrozen = Object.isFrozen;
var FORCED$d = ARRAY_BUFFER_NON_EXTENSIBLE$1 || fails$K(function() {
  $isFrozen(1);
});
$$3I({
  target: "Object",
  stat: true,
  forced: FORCED$d
}, {
  isFrozen: function isFrozen(it) {
    if (!isObject$s(it)) return true;
    if (ARRAY_BUFFER_NON_EXTENSIBLE$1 && classof$e(it) === "ArrayBuffer") return true;
    return $isFrozen ? $isFrozen(it) : false;
  }
});
var $$3H = _export;
var fails$J = fails$1z;
var isObject$r = isObject$O;
var classof$d = classofRaw$2;
var ARRAY_BUFFER_NON_EXTENSIBLE = arrayBufferNonExtensible;
var $isSealed = Object.isSealed;
var FORCED$c = ARRAY_BUFFER_NON_EXTENSIBLE || fails$J(function() {
  $isSealed(1);
});
$$3H({
  target: "Object",
  stat: true,
  forced: FORCED$c
}, {
  isSealed: function isSealed(it) {
    if (!isObject$r(it)) return true;
    if (ARRAY_BUFFER_NON_EXTENSIBLE && classof$d(it) === "ArrayBuffer") return true;
    return $isSealed ? $isSealed(it) : false;
  }
});
var $$3G = _export;
var toObject$g = toObject$E;
var nativeKeys = objectKeys$6;
var fails$I = fails$1z;
var FAILS_ON_PRIMITIVES$2 = fails$I(function() {
  nativeKeys(1);
});
$$3G({
  target: "Object",
  stat: true,
  forced: FAILS_ON_PRIMITIVES$2
}, {
  keys: function keys2(it) {
    return nativeKeys(toObject$g(it));
  }
});
var $$3F = _export;
var DESCRIPTORS$q = descriptors;
var FORCED$b = objectPrototypeAccessorsForced;
var toObject$f = toObject$E;
var toPropertyKey$4 = toPropertyKey$9;
var getPrototypeOf$a = objectGetPrototypeOf$2;
var getOwnPropertyDescriptor$9 = objectGetOwnPropertyDescriptor.f;
if (DESCRIPTORS$q) {
  $$3F({
    target: "Object",
    proto: true,
    forced: FORCED$b
  }, {
    __lookupGetter__: function __lookupGetter__(P) {
      var O = toObject$f(this);
      var key = toPropertyKey$4(P);
      var desc;
      do {
        if (desc = getOwnPropertyDescriptor$9(O, key)) return desc.get;
      } while (O = getPrototypeOf$a(O));
    }
  });
}
var $$3E = _export;
var DESCRIPTORS$p = descriptors;
var FORCED$a = objectPrototypeAccessorsForced;
var toObject$e = toObject$E;
var toPropertyKey$3 = toPropertyKey$9;
var getPrototypeOf$9 = objectGetPrototypeOf$2;
var getOwnPropertyDescriptor$8 = objectGetOwnPropertyDescriptor.f;
if (DESCRIPTORS$p) {
  $$3E({
    target: "Object",
    proto: true,
    forced: FORCED$a
  }, {
    __lookupSetter__: function __lookupSetter__(P) {
      var O = toObject$e(this);
      var key = toPropertyKey$3(P);
      var desc;
      do {
        if (desc = getOwnPropertyDescriptor$8(O, key)) return desc.set;
      } while (O = getPrototypeOf$9(O));
    }
  });
}
var $$3D = _export;
var isObject$q = isObject$O;
var onFreeze$1 = internalMetadataExports.onFreeze;
var FREEZING$5 = freezing;
var fails$H = fails$1z;
var $preventExtensions = Object.preventExtensions;
var FAILS_ON_PRIMITIVES$1 = fails$H(function() {
  $preventExtensions(1);
});
$$3D({
  target: "Object",
  stat: true,
  forced: FAILS_ON_PRIMITIVES$1,
  sham: !FREEZING$5
}, {
  preventExtensions: function preventExtensions(it) {
    return $preventExtensions && isObject$q(it) ? $preventExtensions(onFreeze$1(it)) : it;
  }
});
var DESCRIPTORS$o = descriptors;
var defineBuiltInAccessor$f = defineBuiltInAccessor$p;
var isObject$p = isObject$O;
var isPossiblePrototype = isPossiblePrototype$2;
var toObject$d = toObject$E;
var requireObjectCoercible$h = requireObjectCoercible$q;
var getPrototypeOf$8 = Object.getPrototypeOf;
var setPrototypeOf$4 = Object.setPrototypeOf;
var ObjectPrototype$1 = Object.prototype;
var PROTO = "__proto__";
if (DESCRIPTORS$o && getPrototypeOf$8 && setPrototypeOf$4 && !(PROTO in ObjectPrototype$1)) try {
  defineBuiltInAccessor$f(ObjectPrototype$1, PROTO, {
    configurable: true,
    get: function __proto__() {
      return getPrototypeOf$8(toObject$d(this));
    },
    set: function __proto__(proto) {
      var O = requireObjectCoercible$h(this);
      if (isPossiblePrototype(proto) && isObject$p(O)) {
        setPrototypeOf$4(O, proto);
      }
    }
  });
} catch (error3) {
}
var $$3C = _export;
var isObject$o = isObject$O;
var onFreeze = internalMetadataExports.onFreeze;
var FREEZING$4 = freezing;
var fails$G = fails$1z;
var $seal = Object.seal;
var FAILS_ON_PRIMITIVES = fails$G(function() {
  $seal(1);
});
$$3C({
  target: "Object",
  stat: true,
  forced: FAILS_ON_PRIMITIVES,
  sham: !FREEZING$4
}, {
  seal: function seal(it) {
    return $seal && isObject$o(it) ? $seal(onFreeze(it)) : it;
  }
});
var $$3B = _export;
var setPrototypeOf$3 = objectSetPrototypeOf$1;
$$3B({
  target: "Object",
  stat: true
}, {
  setPrototypeOf: setPrototypeOf$3
});
var TO_STRING_TAG_SUPPORT$1 = toStringTagSupport;
var classof$c = classof$q;
var objectToString = TO_STRING_TAG_SUPPORT$1 ? {}.toString : function toString3() {
  return "[object " + classof$c(this) + "]";
};
var TO_STRING_TAG_SUPPORT = toStringTagSupport;
var defineBuiltIn$i = defineBuiltIn$u;
var toString$x = objectToString;
if (!TO_STRING_TAG_SUPPORT) {
  defineBuiltIn$i(Object.prototype, "toString", toString$x, {
    unsafe: true
  });
}
var $$3A = _export;
var $values = objectToArray.values;
$$3A({
  target: "Object",
  stat: true
}, {
  values: function values(O) {
    return $values(O);
  }
});
var $$3z = _export;
var $parseFloat = numberParseFloat;
$$3z({
  global: true,
  forced: parseFloat !== $parseFloat
}, {
  parseFloat: $parseFloat
});
var $$3y = _export;
var $parseInt$3 = numberParseInt;
$$3y({
  global: true,
  forced: parseInt !== $parseInt$3
}, {
  parseInt: $parseInt$3
});
var isConstructor$5 = isConstructor$a;
var tryToString = tryToString$7;
var $TypeError$u = TypeError;
var aConstructor$4 = function(argument) {
  if (isConstructor$5(argument)) return argument;
  throw new $TypeError$u(tryToString(argument) + " is not a constructor");
};
var anObject$U = anObject$1i;
var aConstructor$3 = aConstructor$4;
var isNullOrUndefined$d = isNullOrUndefined$j;
var wellKnownSymbol$t = wellKnownSymbol$S;
var SPECIES$2 = wellKnownSymbol$t("species");
var speciesConstructor$4 = function(O, defaultConstructor) {
  var C = anObject$U(O).constructor;
  var S;
  return C === void 0 || isNullOrUndefined$d(S = anObject$U(C)[SPECIES$2]) ? defaultConstructor : aConstructor$3(S);
};
var $TypeError$t = TypeError;
var validateArgumentsLength$c = function(passed, required) {
  if (passed < required) throw new $TypeError$t("Not enough arguments");
  return passed;
};
var userAgent$3 = environmentUserAgent;
var environmentIsIos = /(?:ipad|iphone|ipod).*applewebkit/i.test(userAgent$3);
var globalThis$N = globalThis_1;
var apply$9 = functionApply$1;
var bind$n = functionBindContext;
var isCallable$k = isCallable$I;
var hasOwn$k = hasOwnProperty_1;
var fails$F = fails$1z;
var html$1 = html$3;
var arraySlice$4 = arraySlice$a;
var createElement = documentCreateElement$2;
var validateArgumentsLength$b = validateArgumentsLength$c;
var IS_IOS$1 = environmentIsIos;
var IS_NODE$2 = environmentIsNode;
var set$c = globalThis$N.setImmediate;
var clear = globalThis$N.clearImmediate;
var process$2 = globalThis$N.process;
var Dispatch = globalThis$N.Dispatch;
var Function$2 = globalThis$N.Function;
var MessageChannel$1 = globalThis$N.MessageChannel;
var String$1 = globalThis$N.String;
var counter = 0;
var queue$2 = {};
var ONREADYSTATECHANGE = "onreadystatechange";
var $location, defer, channel, port;
fails$F(function() {
  $location = globalThis$N.location;
});
var run = function(id2) {
  if (hasOwn$k(queue$2, id2)) {
    var fn = queue$2[id2];
    delete queue$2[id2];
    fn();
  }
};
var runner = function(id2) {
  return function() {
    run(id2);
  };
};
var eventListener = function(event) {
  run(event.data);
};
var globalPostMessageDefer = function(id2) {
  globalThis$N.postMessage(String$1(id2), $location.protocol + "//" + $location.host);
};
if (!set$c || !clear) {
  set$c = function setImmediate2(handler) {
    validateArgumentsLength$b(arguments.length, 1);
    var fn = isCallable$k(handler) ? handler : Function$2(handler);
    var args = arraySlice$4(arguments, 1);
    queue$2[++counter] = function() {
      apply$9(fn, void 0, args);
    };
    defer(counter);
    return counter;
  };
  clear = function clearImmediate2(id2) {
    delete queue$2[id2];
  };
  if (IS_NODE$2) {
    defer = function(id2) {
      process$2.nextTick(runner(id2));
    };
  } else if (Dispatch && Dispatch.now) {
    defer = function(id2) {
      Dispatch.now(runner(id2));
    };
  } else if (MessageChannel$1 && !IS_IOS$1) {
    channel = new MessageChannel$1();
    port = channel.port2;
    channel.port1.onmessage = eventListener;
    defer = bind$n(port.postMessage, port);
  } else if (globalThis$N.addEventListener && isCallable$k(globalThis$N.postMessage) && !globalThis$N.importScripts && $location && $location.protocol !== "file:" && !fails$F(globalPostMessageDefer)) {
    defer = globalPostMessageDefer;
    globalThis$N.addEventListener("message", eventListener, false);
  } else if (ONREADYSTATECHANGE in createElement("script")) {
    defer = function(id2) {
      html$1.appendChild(createElement("script"))[ONREADYSTATECHANGE] = function() {
        html$1.removeChild(this);
        run(id2);
      };
    };
  } else {
    defer = function(id2) {
      setTimeout(runner(id2), 0);
    };
  }
}
var task$1 = {
  set: set$c,
  clear
};
var globalThis$M = globalThis_1;
var DESCRIPTORS$n = descriptors;
var getOwnPropertyDescriptor$7 = Object.getOwnPropertyDescriptor;
var safeGetBuiltIn$2 = function(name) {
  if (!DESCRIPTORS$n) return globalThis$M[name];
  var descriptor = getOwnPropertyDescriptor$7(globalThis$M, name);
  return descriptor && descriptor.value;
};
var Queue$2 = function() {
  this.head = null;
  this.tail = null;
};
Queue$2.prototype = {
  add: function(item) {
    var entry = {
      item,
      next: null
    };
    var tail = this.tail;
    if (tail) tail.next = entry;
    else this.head = entry;
    this.tail = entry;
  },
  get: function() {
    var entry = this.head;
    if (entry) {
      var next11 = this.head = entry.next;
      if (next11 === null) this.tail = null;
      return entry.item;
    }
  }
};
var queue$1 = Queue$2;
var userAgent$2 = environmentUserAgent;
var environmentIsIosPebble = /ipad|iphone|ipod/i.test(userAgent$2) && typeof Pebble != "undefined";
var userAgent$1 = environmentUserAgent;
var environmentIsWebosWebkit = /web0s(?!.*chrome)/i.test(userAgent$1);
var globalThis$L = globalThis_1;
var safeGetBuiltIn$1 = safeGetBuiltIn$2;
var bind$m = functionBindContext;
var macrotask = task$1.set;
var Queue$1 = queue$1;
var IS_IOS = environmentIsIos;
var IS_IOS_PEBBLE = environmentIsIosPebble;
var IS_WEBOS_WEBKIT = environmentIsWebosWebkit;
var IS_NODE$1 = environmentIsNode;
var MutationObserver = globalThis$L.MutationObserver || globalThis$L.WebKitMutationObserver;
var document$2 = globalThis$L.document;
var process$1 = globalThis$L.process;
var Promise$7 = globalThis$L.Promise;
var microtask$2 = safeGetBuiltIn$1("queueMicrotask");
var notify$1, toggle, node, promise, then;
if (!microtask$2) {
  var queue = new Queue$1();
  var flush = function() {
    var parent, fn;
    if (IS_NODE$1 && (parent = process$1.domain)) parent.exit();
    while (fn = queue.get()) try {
      fn();
    } catch (error3) {
      if (queue.head) notify$1();
      throw error3;
    }
    if (parent) parent.enter();
  };
  if (!IS_IOS && !IS_NODE$1 && !IS_WEBOS_WEBKIT && MutationObserver && document$2) {
    toggle = true;
    node = document$2.createTextNode("");
    new MutationObserver(flush).observe(node, {
      characterData: true
    });
    notify$1 = function() {
      node.data = toggle = !toggle;
    };
  } else if (!IS_IOS_PEBBLE && Promise$7 && Promise$7.resolve) {
    promise = Promise$7.resolve(void 0);
    promise.constructor = Promise$7;
    then = bind$m(promise.then, promise);
    notify$1 = function() {
      then(flush);
    };
  } else if (IS_NODE$1) {
    notify$1 = function() {
      process$1.nextTick(flush);
    };
  } else {
    macrotask = bind$m(macrotask, globalThis$L);
    notify$1 = function() {
      macrotask(flush);
    };
  }
  microtask$2 = function(fn) {
    if (!queue.head) notify$1();
    queue.add(fn);
  };
}
var microtask_1 = microtask$2;
var hostReportErrors$2 = function(a, b) {
  try {
    arguments.length === 1 ? console.error(a) : console.error(a, b);
  } catch (error3) {
  }
};
var perform$7 = function(exec2) {
  try {
    return {
      error: false,
      value: exec2()
    };
  } catch (error3) {
    return {
      error: true,
      value: error3
    };
  }
};
var globalThis$K = globalThis_1;
var promiseNativeConstructor = globalThis$K.Promise;
var globalThis$J = globalThis_1;
var NativePromiseConstructor$4 = promiseNativeConstructor;
var isCallable$j = isCallable$I;
var isForced$1 = isForced_1;
var inspectSource$1 = inspectSource$4;
var wellKnownSymbol$s = wellKnownSymbol$S;
var ENVIRONMENT$1 = environment;
var V8_VERSION$1 = environmentV8Version;
NativePromiseConstructor$4 && NativePromiseConstructor$4.prototype;
var SPECIES$1 = wellKnownSymbol$s("species");
var SUBCLASSING = false;
var NATIVE_PROMISE_REJECTION_EVENT$1 = isCallable$j(globalThis$J.PromiseRejectionEvent);
var FORCED_PROMISE_CONSTRUCTOR$5 = isForced$1("Promise", function() {
  var PROMISE_CONSTRUCTOR_SOURCE = inspectSource$1(NativePromiseConstructor$4);
  var GLOBAL_CORE_JS_PROMISE = PROMISE_CONSTRUCTOR_SOURCE !== String(NativePromiseConstructor$4);
  if (!GLOBAL_CORE_JS_PROMISE && V8_VERSION$1 === 66) return true;
  if (!V8_VERSION$1 || V8_VERSION$1 < 51 || !/native code/.test(PROMISE_CONSTRUCTOR_SOURCE)) {
    var promise2 = new NativePromiseConstructor$4(function(resolve2) {
      resolve2(1);
    });
    var FakePromise = function(exec2) {
      exec2(function() {
      }, function() {
      });
    };
    var constructor = promise2.constructor = {};
    constructor[SPECIES$1] = FakePromise;
    SUBCLASSING = promise2.then(function() {
    }) instanceof FakePromise;
    if (!SUBCLASSING) return true;
  }
  return !GLOBAL_CORE_JS_PROMISE && (ENVIRONMENT$1 === "BROWSER" || ENVIRONMENT$1 === "DENO") && !NATIVE_PROMISE_REJECTION_EVENT$1;
});
var promiseConstructorDetection = {
  CONSTRUCTOR: FORCED_PROMISE_CONSTRUCTOR$5,
  REJECTION_EVENT: NATIVE_PROMISE_REJECTION_EVENT$1,
  SUBCLASSING
};
var newPromiseCapability$2 = {};
var aCallable$u = aCallable$Q;
var $TypeError$s = TypeError;
var PromiseCapability = function(C) {
  var resolve2, reject2;
  this.promise = new C(function($$resolve, $$reject) {
    if (resolve2 !== void 0 || reject2 !== void 0) throw new $TypeError$s("Bad Promise constructor");
    resolve2 = $$resolve;
    reject2 = $$reject;
  });
  this.resolve = aCallable$u(resolve2);
  this.reject = aCallable$u(reject2);
};
newPromiseCapability$2.f = function(C) {
  return new PromiseCapability(C);
};
var $$3x = _export;
var IS_NODE = environmentIsNode;
var globalThis$I = globalThis_1;
var call$Y = functionCall;
var defineBuiltIn$h = defineBuiltIn$u;
var setPrototypeOf$2 = objectSetPrototypeOf$1;
var setToStringTag$5 = setToStringTag$e;
var setSpecies$3 = setSpecies$7;
var aCallable$t = aCallable$Q;
var isCallable$i = isCallable$I;
var isObject$n = isObject$O;
var anInstance$a = anInstance$f;
var speciesConstructor$3 = speciesConstructor$4;
var task = task$1.set;
var microtask$1 = microtask_1;
var hostReportErrors$1 = hostReportErrors$2;
var perform$6 = perform$7;
var Queue = queue$1;
var InternalStateModule$g = internalState;
var NativePromiseConstructor$3 = promiseNativeConstructor;
var PromiseConstructorDetection = promiseConstructorDetection;
var newPromiseCapabilityModule$7 = newPromiseCapability$2;
var PROMISE = "Promise";
var FORCED_PROMISE_CONSTRUCTOR$4 = PromiseConstructorDetection.CONSTRUCTOR;
var NATIVE_PROMISE_REJECTION_EVENT = PromiseConstructorDetection.REJECTION_EVENT;
var NATIVE_PROMISE_SUBCLASSING = PromiseConstructorDetection.SUBCLASSING;
var getInternalPromiseState = InternalStateModule$g.getterFor(PROMISE);
var setInternalState$h = InternalStateModule$g.set;
var NativePromisePrototype$2 = NativePromiseConstructor$3 && NativePromiseConstructor$3.prototype;
var PromiseConstructor = NativePromiseConstructor$3;
var PromisePrototype = NativePromisePrototype$2;
var TypeError$5 = globalThis$I.TypeError;
var document$1 = globalThis$I.document;
var process = globalThis$I.process;
var newPromiseCapability$1 = newPromiseCapabilityModule$7.f;
var newGenericPromiseCapability = newPromiseCapability$1;
var DISPATCH_EVENT = !!(document$1 && document$1.createEvent && globalThis$I.dispatchEvent);
var UNHANDLED_REJECTION = "unhandledrejection";
var REJECTION_HANDLED = "rejectionhandled";
var PENDING$2 = 0;
var FULFILLED = 1;
var REJECTED = 2;
var HANDLED = 1;
var UNHANDLED = 2;
var Internal, OwnPromiseCapability, PromiseWrapper, nativeThen;
var isThenable = function(it) {
  var then2;
  return isObject$n(it) && isCallable$i(then2 = it.then) ? then2 : false;
};
var callReaction = function(reaction, state) {
  var value = state.value;
  var ok = state.state === FULFILLED;
  var handler = ok ? reaction.ok : reaction.fail;
  var resolve2 = reaction.resolve;
  var reject2 = reaction.reject;
  var domain2 = reaction.domain;
  var result, then2, exited;
  try {
    if (handler) {
      if (!ok) {
        if (state.rejection === UNHANDLED) onHandleUnhandled(state);
        state.rejection = HANDLED;
      }
      if (handler === true) result = value;
      else {
        if (domain2) domain2.enter();
        result = handler(value);
        if (domain2) {
          domain2.exit();
          exited = true;
        }
      }
      if (result === reaction.promise) {
        reject2(new TypeError$5("Promise-chain cycle"));
      } else if (then2 = isThenable(result)) {
        call$Y(then2, result, resolve2, reject2);
      } else resolve2(result);
    } else reject2(value);
  } catch (error3) {
    if (domain2 && !exited) domain2.exit();
    reject2(error3);
  }
};
var notify = function(state, isReject) {
  if (state.notified) return;
  state.notified = true;
  microtask$1(function() {
    var reactions = state.reactions;
    var reaction;
    while (reaction = reactions.get()) {
      callReaction(reaction, state);
    }
    state.notified = false;
    if (isReject && !state.rejection) onUnhandled(state);
  });
};
var dispatchEvent = function(name, promise2, reason) {
  var event, handler;
  if (DISPATCH_EVENT) {
    event = document$1.createEvent("Event");
    event.promise = promise2;
    event.reason = reason;
    event.initEvent(name, false, true);
    globalThis$I.dispatchEvent(event);
  } else event = {
    promise: promise2,
    reason
  };
  if (!NATIVE_PROMISE_REJECTION_EVENT && (handler = globalThis$I["on" + name])) handler(event);
  else if (name === UNHANDLED_REJECTION) hostReportErrors$1("Unhandled promise rejection", reason);
};
var onUnhandled = function(state) {
  call$Y(task, globalThis$I, function() {
    var promise2 = state.facade;
    var value = state.value;
    var IS_UNHANDLED = isUnhandled(state);
    var result;
    if (IS_UNHANDLED) {
      result = perform$6(function() {
        if (IS_NODE) {
          process.emit("unhandledRejection", value, promise2);
        } else dispatchEvent(UNHANDLED_REJECTION, promise2, value);
      });
      state.rejection = IS_NODE || isUnhandled(state) ? UNHANDLED : HANDLED;
      if (result.error) throw result.value;
    }
  });
};
var isUnhandled = function(state) {
  return state.rejection !== HANDLED && !state.parent;
};
var onHandleUnhandled = function(state) {
  call$Y(task, globalThis$I, function() {
    var promise2 = state.facade;
    if (IS_NODE) {
      process.emit("rejectionHandled", promise2);
    } else dispatchEvent(REJECTION_HANDLED, promise2, state.value);
  });
};
var bind$l = function(fn, state, unwrap) {
  return function(value) {
    fn(state, value, unwrap);
  };
};
var internalReject = function(state, value, unwrap) {
  if (state.done) return;
  state.done = true;
  if (unwrap) state = unwrap;
  state.value = value;
  state.state = REJECTED;
  notify(state, true);
};
var internalResolve = function(state, value, unwrap) {
  if (state.done) return;
  state.done = true;
  if (unwrap) state = unwrap;
  try {
    if (state.facade === value) throw new TypeError$5("Promise can't be resolved itself");
    var then2 = isThenable(value);
    if (then2) {
      microtask$1(function() {
        var wrapper2 = {
          done: false
        };
        try {
          call$Y(then2, value, bind$l(internalResolve, wrapper2, state), bind$l(internalReject, wrapper2, state));
        } catch (error3) {
          internalReject(wrapper2, error3, state);
        }
      });
    } else {
      state.value = value;
      state.state = FULFILLED;
      notify(state, false);
    }
  } catch (error3) {
    internalReject({
      done: false
    }, error3, state);
  }
};
if (FORCED_PROMISE_CONSTRUCTOR$4) {
  PromiseConstructor = function Promise2(executor) {
    anInstance$a(this, PromisePrototype);
    aCallable$t(executor);
    call$Y(Internal, this);
    var state = getInternalPromiseState(this);
    try {
      executor(bind$l(internalResolve, state), bind$l(internalReject, state));
    } catch (error3) {
      internalReject(state, error3);
    }
  };
  PromisePrototype = PromiseConstructor.prototype;
  Internal = function Promise2(executor) {
    setInternalState$h(this, {
      type: PROMISE,
      done: false,
      notified: false,
      parent: false,
      reactions: new Queue(),
      rejection: false,
      state: PENDING$2,
      value: null
    });
  };
  Internal.prototype = defineBuiltIn$h(PromisePrototype, "then", function then2(onFulfilled, onRejected) {
    var state = getInternalPromiseState(this);
    var reaction = newPromiseCapability$1(speciesConstructor$3(this, PromiseConstructor));
    state.parent = true;
    reaction.ok = isCallable$i(onFulfilled) ? onFulfilled : true;
    reaction.fail = isCallable$i(onRejected) && onRejected;
    reaction.domain = IS_NODE ? process.domain : void 0;
    if (state.state === PENDING$2) state.reactions.add(reaction);
    else microtask$1(function() {
      callReaction(reaction, state);
    });
    return reaction.promise;
  });
  OwnPromiseCapability = function() {
    var promise2 = new Internal();
    var state = getInternalPromiseState(promise2);
    this.promise = promise2;
    this.resolve = bind$l(internalResolve, state);
    this.reject = bind$l(internalReject, state);
  };
  newPromiseCapabilityModule$7.f = newPromiseCapability$1 = function(C) {
    return C === PromiseConstructor || C === PromiseWrapper ? new OwnPromiseCapability(C) : newGenericPromiseCapability(C);
  };
  if (isCallable$i(NativePromiseConstructor$3) && NativePromisePrototype$2 !== Object.prototype) {
    nativeThen = NativePromisePrototype$2.then;
    if (!NATIVE_PROMISE_SUBCLASSING) {
      defineBuiltIn$h(NativePromisePrototype$2, "then", function then2(onFulfilled, onRejected) {
        var that = this;
        return new PromiseConstructor(function(resolve2, reject2) {
          call$Y(nativeThen, that, resolve2, reject2);
        }).then(onFulfilled, onRejected);
      }, {
        unsafe: true
      });
    }
    try {
      delete NativePromisePrototype$2.constructor;
    } catch (error3) {
    }
    if (setPrototypeOf$2) {
      setPrototypeOf$2(NativePromisePrototype$2, PromisePrototype);
    }
  }
}
$$3x({
  global: true,
  constructor: true,
  wrap: true,
  forced: FORCED_PROMISE_CONSTRUCTOR$4
}, {
  Promise: PromiseConstructor
});
setToStringTag$5(PromiseConstructor, PROMISE, false);
setSpecies$3(PROMISE);
var NativePromiseConstructor$2 = promiseNativeConstructor;
var checkCorrectnessOfIteration$1 = checkCorrectnessOfIteration$4;
var FORCED_PROMISE_CONSTRUCTOR$3 = promiseConstructorDetection.CONSTRUCTOR;
var promiseStaticsIncorrectIteration = FORCED_PROMISE_CONSTRUCTOR$3 || !checkCorrectnessOfIteration$1(function(iterable) {
  NativePromiseConstructor$2.all(iterable).then(void 0, function() {
  });
});
var $$3w = _export;
var call$X = functionCall;
var aCallable$s = aCallable$Q;
var newPromiseCapabilityModule$6 = newPromiseCapability$2;
var perform$5 = perform$7;
var iterate$u = iterate$H;
var PROMISE_STATICS_INCORRECT_ITERATION$3 = promiseStaticsIncorrectIteration;
$$3w({
  target: "Promise",
  stat: true,
  forced: PROMISE_STATICS_INCORRECT_ITERATION$3
}, {
  all: function all(iterable) {
    var C = this;
    var capability = newPromiseCapabilityModule$6.f(C);
    var resolve2 = capability.resolve;
    var reject2 = capability.reject;
    var result = perform$5(function() {
      var $promiseResolve = aCallable$s(C.resolve);
      var values5 = [];
      var counter2 = 0;
      var remaining = 1;
      iterate$u(iterable, function(promise2) {
        var index = counter2++;
        var alreadyCalled = false;
        remaining++;
        call$X($promiseResolve, C, promise2).then(function(value) {
          if (alreadyCalled) return;
          alreadyCalled = true;
          values5[index] = value;
          --remaining || resolve2(values5);
        }, reject2);
      });
      --remaining || resolve2(values5);
    });
    if (result.error) reject2(result.value);
    return capability.promise;
  }
});
var $$3v = _export;
var FORCED_PROMISE_CONSTRUCTOR$2 = promiseConstructorDetection.CONSTRUCTOR;
var NativePromiseConstructor$1 = promiseNativeConstructor;
var getBuiltIn$D = getBuiltIn$Q;
var isCallable$h = isCallable$I;
var defineBuiltIn$g = defineBuiltIn$u;
var NativePromisePrototype$1 = NativePromiseConstructor$1 && NativePromiseConstructor$1.prototype;
$$3v({
  target: "Promise",
  proto: true,
  forced: FORCED_PROMISE_CONSTRUCTOR$2,
  real: true
}, {
  "catch": function(onRejected) {
    return this.then(void 0, onRejected);
  }
});
if (isCallable$h(NativePromiseConstructor$1)) {
  var method$1 = getBuiltIn$D("Promise").prototype["catch"];
  if (NativePromisePrototype$1["catch"] !== method$1) {
    defineBuiltIn$g(NativePromisePrototype$1, "catch", method$1, {
      unsafe: true
    });
  }
}
var $$3u = _export;
var call$W = functionCall;
var aCallable$r = aCallable$Q;
var newPromiseCapabilityModule$5 = newPromiseCapability$2;
var perform$4 = perform$7;
var iterate$t = iterate$H;
var PROMISE_STATICS_INCORRECT_ITERATION$2 = promiseStaticsIncorrectIteration;
$$3u({
  target: "Promise",
  stat: true,
  forced: PROMISE_STATICS_INCORRECT_ITERATION$2
}, {
  race: function race(iterable) {
    var C = this;
    var capability = newPromiseCapabilityModule$5.f(C);
    var reject2 = capability.reject;
    var result = perform$4(function() {
      var $promiseResolve = aCallable$r(C.resolve);
      iterate$t(iterable, function(promise2) {
        call$W($promiseResolve, C, promise2).then(capability.resolve, reject2);
      });
    });
    if (result.error) reject2(result.value);
    return capability.promise;
  }
});
var $$3t = _export;
var newPromiseCapabilityModule$4 = newPromiseCapability$2;
var FORCED_PROMISE_CONSTRUCTOR$1 = promiseConstructorDetection.CONSTRUCTOR;
$$3t({
  target: "Promise",
  stat: true,
  forced: FORCED_PROMISE_CONSTRUCTOR$1
}, {
  reject: function reject(r) {
    var capability = newPromiseCapabilityModule$4.f(this);
    var capabilityReject = capability.reject;
    capabilityReject(r);
    return capability.promise;
  }
});
var anObject$T = anObject$1i;
var isObject$m = isObject$O;
var newPromiseCapability = newPromiseCapability$2;
var promiseResolve$2 = function(C, x) {
  anObject$T(C);
  if (isObject$m(x) && x.constructor === C) return x;
  var promiseCapability = newPromiseCapability.f(C);
  var resolve2 = promiseCapability.resolve;
  resolve2(x);
  return promiseCapability.promise;
};
var $$3s = _export;
var getBuiltIn$C = getBuiltIn$Q;
var FORCED_PROMISE_CONSTRUCTOR = promiseConstructorDetection.CONSTRUCTOR;
var promiseResolve$1 = promiseResolve$2;
getBuiltIn$C("Promise");
$$3s({
  target: "Promise",
  stat: true,
  forced: FORCED_PROMISE_CONSTRUCTOR
}, {
  resolve: function resolve(x) {
    return promiseResolve$1(this, x);
  }
});
var $$3r = _export;
var call$V = functionCall;
var aCallable$q = aCallable$Q;
var newPromiseCapabilityModule$3 = newPromiseCapability$2;
var perform$3 = perform$7;
var iterate$s = iterate$H;
var PROMISE_STATICS_INCORRECT_ITERATION$1 = promiseStaticsIncorrectIteration;
$$3r({
  target: "Promise",
  stat: true,
  forced: PROMISE_STATICS_INCORRECT_ITERATION$1
}, {
  allSettled: function allSettled(iterable) {
    var C = this;
    var capability = newPromiseCapabilityModule$3.f(C);
    var resolve2 = capability.resolve;
    var reject2 = capability.reject;
    var result = perform$3(function() {
      var promiseResolve2 = aCallable$q(C.resolve);
      var values5 = [];
      var counter2 = 0;
      var remaining = 1;
      iterate$s(iterable, function(promise2) {
        var index = counter2++;
        var alreadyCalled = false;
        remaining++;
        call$V(promiseResolve2, C, promise2).then(function(value) {
          if (alreadyCalled) return;
          alreadyCalled = true;
          values5[index] = {
            status: "fulfilled",
            value
          };
          --remaining || resolve2(values5);
        }, function(error3) {
          if (alreadyCalled) return;
          alreadyCalled = true;
          values5[index] = {
            status: "rejected",
            reason: error3
          };
          --remaining || resolve2(values5);
        });
      });
      --remaining || resolve2(values5);
    });
    if (result.error) reject2(result.value);
    return capability.promise;
  }
});
var $$3q = _export;
var call$U = functionCall;
var aCallable$p = aCallable$Q;
var getBuiltIn$B = getBuiltIn$Q;
var newPromiseCapabilityModule$2 = newPromiseCapability$2;
var perform$2 = perform$7;
var iterate$r = iterate$H;
var PROMISE_STATICS_INCORRECT_ITERATION = promiseStaticsIncorrectIteration;
var PROMISE_ANY_ERROR = "No one promise resolved";
$$3q({
  target: "Promise",
  stat: true,
  forced: PROMISE_STATICS_INCORRECT_ITERATION
}, {
  any: function any(iterable) {
    var C = this;
    var AggregateError2 = getBuiltIn$B("AggregateError");
    var capability = newPromiseCapabilityModule$2.f(C);
    var resolve2 = capability.resolve;
    var reject2 = capability.reject;
    var result = perform$2(function() {
      var promiseResolve2 = aCallable$p(C.resolve);
      var errors = [];
      var counter2 = 0;
      var remaining = 1;
      var alreadyResolved = false;
      iterate$r(iterable, function(promise2) {
        var index = counter2++;
        var alreadyRejected = false;
        remaining++;
        call$U(promiseResolve2, C, promise2).then(function(value) {
          if (alreadyRejected || alreadyResolved) return;
          alreadyResolved = true;
          resolve2(value);
        }, function(error3) {
          if (alreadyRejected || alreadyResolved) return;
          alreadyRejected = true;
          errors[index] = error3;
          --remaining || reject2(new AggregateError2(errors, PROMISE_ANY_ERROR));
        });
      });
      --remaining || reject2(new AggregateError2(errors, PROMISE_ANY_ERROR));
    });
    if (result.error) reject2(result.value);
    return capability.promise;
  }
});
var $$3p = _export;
var NativePromiseConstructor = promiseNativeConstructor;
var fails$E = fails$1z;
var getBuiltIn$A = getBuiltIn$Q;
var isCallable$g = isCallable$I;
var speciesConstructor$2 = speciesConstructor$4;
var promiseResolve = promiseResolve$2;
var defineBuiltIn$f = defineBuiltIn$u;
var NativePromisePrototype = NativePromiseConstructor && NativePromiseConstructor.prototype;
var NON_GENERIC = !!NativePromiseConstructor && fails$E(function() {
  NativePromisePrototype["finally"].call({
    then: function() {
    }
  }, function() {
  });
});
$$3p({
  target: "Promise",
  proto: true,
  real: true,
  forced: NON_GENERIC
}, {
  "finally": function(onFinally) {
    var C = speciesConstructor$2(this, getBuiltIn$A("Promise"));
    var isFunction = isCallable$g(onFinally);
    return this.then(isFunction ? function(x) {
      return promiseResolve(C, onFinally()).then(function() {
        return x;
      });
    } : onFinally, isFunction ? function(e) {
      return promiseResolve(C, onFinally()).then(function() {
        throw e;
      });
    } : onFinally);
  }
});
if (isCallable$g(NativePromiseConstructor)) {
  var method = getBuiltIn$A("Promise").prototype["finally"];
  if (NativePromisePrototype["finally"] !== method) {
    defineBuiltIn$f(NativePromisePrototype, "finally", method, {
      unsafe: true
    });
  }
}
var $$3o = _export;
var globalThis$H = globalThis_1;
var apply$8 = functionApply$1;
var slice$5 = arraySlice$a;
var newPromiseCapabilityModule$1 = newPromiseCapability$2;
var aCallable$o = aCallable$Q;
var perform$1 = perform$7;
var Promise$6 = globalThis$H.Promise;
var ACCEPT_ARGUMENTS = false;
var FORCED$9 = !Promise$6 || !Promise$6["try"] || perform$1(function() {
  Promise$6["try"](function(argument) {
    ACCEPT_ARGUMENTS = argument === 8;
  }, 8);
}).error || !ACCEPT_ARGUMENTS;
$$3o({
  target: "Promise",
  stat: true,
  forced: FORCED$9
}, {
  "try": function(callbackfn) {
    var args = arguments.length > 1 ? slice$5(arguments, 1) : [];
    var promiseCapability = newPromiseCapabilityModule$1.f(this);
    var result = perform$1(function() {
      return apply$8(aCallable$o(callbackfn), void 0, args);
    });
    (result.error ? promiseCapability.reject : promiseCapability.resolve)(result.value);
    return promiseCapability.promise;
  }
});
var $$3n = _export;
var newPromiseCapabilityModule = newPromiseCapability$2;
$$3n({
  target: "Promise",
  stat: true
}, {
  withResolvers: function withResolvers() {
    var promiseCapability = newPromiseCapabilityModule.f(this);
    return {
      promise: promiseCapability.promise,
      resolve: promiseCapability.resolve,
      reject: promiseCapability.reject
    };
  }
});
var $$3m = _export;
var functionApply = functionApply$1;
var aCallable$n = aCallable$Q;
var anObject$S = anObject$1i;
var fails$D = fails$1z;
var OPTIONAL_ARGUMENTS_LIST = !fails$D(function() {
  Reflect.apply(function() {
  });
});
$$3m({
  target: "Reflect",
  stat: true,
  forced: OPTIONAL_ARGUMENTS_LIST
}, {
  apply: function apply(target, thisArgument, argumentsList) {
    return functionApply(aCallable$n(target), thisArgument, anObject$S(argumentsList));
  }
});
var $$3l = _export;
var getBuiltIn$z = getBuiltIn$Q;
var apply$7 = functionApply$1;
var bind$k = functionBind;
var aConstructor$2 = aConstructor$4;
var anObject$R = anObject$1i;
var isObject$l = isObject$O;
var create$b = objectCreate$1;
var fails$C = fails$1z;
var nativeConstruct = getBuiltIn$z("Reflect", "construct");
var ObjectPrototype = Object.prototype;
var push$i = [].push;
var NEW_TARGET_BUG = fails$C(function() {
  function F() {
  }
  return !(nativeConstruct(function() {
  }, [], F) instanceof F);
});
var ARGS_BUG = !fails$C(function() {
  nativeConstruct(function() {
  });
});
var FORCED$8 = NEW_TARGET_BUG || ARGS_BUG;
$$3l({
  target: "Reflect",
  stat: true,
  forced: FORCED$8,
  sham: FORCED$8
}, {
  construct: function construct2(Target, args) {
    aConstructor$2(Target);
    anObject$R(args);
    var newTarget = arguments.length < 3 ? Target : aConstructor$2(arguments[2]);
    if (ARGS_BUG && !NEW_TARGET_BUG) return nativeConstruct(Target, args, newTarget);
    if (Target === newTarget) {
      switch (args.length) {
        case 0:
          return new Target();
        case 1:
          return new Target(args[0]);
        case 2:
          return new Target(args[0], args[1]);
        case 3:
          return new Target(args[0], args[1], args[2]);
        case 4:
          return new Target(args[0], args[1], args[2], args[3]);
      }
      var $args = [null];
      apply$7(push$i, $args, args);
      return new (apply$7(bind$k, Target, $args))();
    }
    var proto = newTarget.prototype;
    var instance = create$b(isObject$l(proto) ? proto : ObjectPrototype);
    var result = apply$7(Target, instance, args);
    return isObject$l(result) ? result : instance;
  }
});
var $$3k = _export;
var DESCRIPTORS$m = descriptors;
var anObject$Q = anObject$1i;
var toPropertyKey$2 = toPropertyKey$9;
var definePropertyModule$2 = objectDefineProperty;
var fails$B = fails$1z;
var ERROR_INSTEAD_OF_FALSE = fails$B(function() {
  Reflect.defineProperty(definePropertyModule$2.f({}, 1, {
    value: 1
  }), 1, {
    value: 2
  });
});
$$3k({
  target: "Reflect",
  stat: true,
  forced: ERROR_INSTEAD_OF_FALSE,
  sham: !DESCRIPTORS$m
}, {
  defineProperty: function defineProperty4(target, propertyKey, attributes) {
    anObject$Q(target);
    var key = toPropertyKey$2(propertyKey);
    anObject$Q(attributes);
    try {
      definePropertyModule$2.f(target, key, attributes);
      return true;
    } catch (error3) {
      return false;
    }
  }
});
var $$3j = _export;
var anObject$P = anObject$1i;
var getOwnPropertyDescriptor$6 = objectGetOwnPropertyDescriptor.f;
$$3j({
  target: "Reflect",
  stat: true
}, {
  deleteProperty: function deleteProperty(target, propertyKey) {
    var descriptor = getOwnPropertyDescriptor$6(anObject$P(target), propertyKey);
    return descriptor && !descriptor.configurable ? false : delete target[propertyKey];
  }
});
var hasOwn$j = hasOwnProperty_1;
var isDataDescriptor$2 = function(descriptor) {
  return descriptor !== void 0 && (hasOwn$j(descriptor, "value") || hasOwn$j(descriptor, "writable"));
};
var $$3i = _export;
var call$T = functionCall;
var isObject$k = isObject$O;
var anObject$O = anObject$1i;
var isDataDescriptor$1 = isDataDescriptor$2;
var getOwnPropertyDescriptorModule$3 = objectGetOwnPropertyDescriptor;
var getPrototypeOf$7 = objectGetPrototypeOf$2;
function get$7(target, propertyKey) {
  var receiver = arguments.length < 3 ? target : arguments[2];
  var descriptor, prototype2;
  if (anObject$O(target) === receiver) return target[propertyKey];
  descriptor = getOwnPropertyDescriptorModule$3.f(target, propertyKey);
  if (descriptor) return isDataDescriptor$1(descriptor) ? descriptor.value : descriptor.get === void 0 ? void 0 : call$T(descriptor.get, receiver);
  if (isObject$k(prototype2 = getPrototypeOf$7(target))) return get$7(prototype2, propertyKey, receiver);
}
$$3i({
  target: "Reflect",
  stat: true
}, {
  get: get$7
});
var $$3h = _export;
var DESCRIPTORS$l = descriptors;
var anObject$N = anObject$1i;
var getOwnPropertyDescriptorModule$2 = objectGetOwnPropertyDescriptor;
$$3h({
  target: "Reflect",
  stat: true,
  sham: !DESCRIPTORS$l
}, {
  getOwnPropertyDescriptor: function getOwnPropertyDescriptor4(target, propertyKey) {
    return getOwnPropertyDescriptorModule$2.f(anObject$N(target), propertyKey);
  }
});
var $$3g = _export;
var anObject$M = anObject$1i;
var objectGetPrototypeOf = objectGetPrototypeOf$2;
var CORRECT_PROTOTYPE_GETTER = correctPrototypeGetter;
$$3g({
  target: "Reflect",
  stat: true,
  sham: !CORRECT_PROTOTYPE_GETTER
}, {
  getPrototypeOf: function getPrototypeOf2(target) {
    return objectGetPrototypeOf(anObject$M(target));
  }
});
var $$3f = _export;
$$3f({
  target: "Reflect",
  stat: true
}, {
  has: function has(target, propertyKey) {
    return propertyKey in target;
  }
});
var $$3e = _export;
var anObject$L = anObject$1i;
var $isExtensible = objectIsExtensible;
$$3e({
  target: "Reflect",
  stat: true
}, {
  isExtensible: function isExtensible2(target) {
    anObject$L(target);
    return $isExtensible(target);
  }
});
var $$3d = _export;
var ownKeys2 = ownKeys$3;
$$3d({
  target: "Reflect",
  stat: true
}, {
  ownKeys: ownKeys2
});
var $$3c = _export;
var getBuiltIn$y = getBuiltIn$Q;
var anObject$K = anObject$1i;
var FREEZING$3 = freezing;
$$3c({
  target: "Reflect",
  stat: true,
  sham: !FREEZING$3
}, {
  preventExtensions: function preventExtensions2(target) {
    anObject$K(target);
    try {
      var objectPreventExtensions = getBuiltIn$y("Object", "preventExtensions");
      if (objectPreventExtensions) objectPreventExtensions(target);
      return true;
    } catch (error3) {
      return false;
    }
  }
});
var $$3b = _export;
var call$S = functionCall;
var anObject$J = anObject$1i;
var isObject$j = isObject$O;
var isDataDescriptor = isDataDescriptor$2;
var fails$A = fails$1z;
var definePropertyModule$1 = objectDefineProperty;
var getOwnPropertyDescriptorModule$1 = objectGetOwnPropertyDescriptor;
var getPrototypeOf$6 = objectGetPrototypeOf$2;
var createPropertyDescriptor$5 = createPropertyDescriptor$d;
function set$b(target, propertyKey, V) {
  var receiver = arguments.length < 4 ? target : arguments[3];
  var ownDescriptor = getOwnPropertyDescriptorModule$1.f(anObject$J(target), propertyKey);
  var existingDescriptor, prototype2, setter;
  if (!ownDescriptor) {
    if (isObject$j(prototype2 = getPrototypeOf$6(target))) {
      return set$b(prototype2, propertyKey, V, receiver);
    }
    ownDescriptor = createPropertyDescriptor$5(0);
  }
  if (isDataDescriptor(ownDescriptor)) {
    if (ownDescriptor.writable === false || !isObject$j(receiver)) return false;
    if (existingDescriptor = getOwnPropertyDescriptorModule$1.f(receiver, propertyKey)) {
      if (existingDescriptor.get || existingDescriptor.set || existingDescriptor.writable === false) return false;
      existingDescriptor.value = V;
      definePropertyModule$1.f(receiver, propertyKey, existingDescriptor);
    } else definePropertyModule$1.f(receiver, propertyKey, createPropertyDescriptor$5(0, V));
  } else {
    setter = ownDescriptor.set;
    if (setter === void 0) return false;
    call$S(setter, receiver, V);
  }
  return true;
}
var MS_EDGE_BUG = fails$A(function() {
  var Constructor2 = function() {
  };
  var object = definePropertyModule$1.f(new Constructor2(), "a", {
    configurable: true
  });
  return Reflect.set(Constructor2.prototype, "a", 1, object) !== false;
});
$$3b({
  target: "Reflect",
  stat: true,
  forced: MS_EDGE_BUG
}, {
  set: set$b
});
var $$3a = _export;
var anObject$I = anObject$1i;
var aPossiblePrototype = aPossiblePrototype$2;
var objectSetPrototypeOf = objectSetPrototypeOf$1;
if (objectSetPrototypeOf) $$3a({
  target: "Reflect",
  stat: true
}, {
  setPrototypeOf: function setPrototypeOf(target, proto) {
    anObject$I(target);
    aPossiblePrototype(proto);
    try {
      objectSetPrototypeOf(target, proto);
      return true;
    } catch (error3) {
      return false;
    }
  }
});
var $$39 = _export;
var globalThis$G = globalThis_1;
var setToStringTag$4 = setToStringTag$e;
$$39({
  global: true
}, {
  Reflect: {}
});
setToStringTag$4(globalThis$G.Reflect, "Reflect", true);
var isObject$i = isObject$O;
var classof$b = classofRaw$2;
var wellKnownSymbol$r = wellKnownSymbol$S;
var MATCH$2 = wellKnownSymbol$r("match");
var isRegexp = function(it) {
  var isRegExp2;
  return isObject$i(it) && ((isRegExp2 = it[MATCH$2]) !== void 0 ? !!isRegExp2 : classof$b(it) === "RegExp");
};
var anObject$H = anObject$1i;
var regexpFlags$1 = function() {
  var that = anObject$H(this);
  var result = "";
  if (that.hasIndices) result += "d";
  if (that.global) result += "g";
  if (that.ignoreCase) result += "i";
  if (that.multiline) result += "m";
  if (that.dotAll) result += "s";
  if (that.unicode) result += "u";
  if (that.unicodeSets) result += "v";
  if (that.sticky) result += "y";
  return result;
};
var call$R = functionCall;
var hasOwn$i = hasOwnProperty_1;
var isPrototypeOf$4 = objectIsPrototypeOf;
var regExpFlags$1 = regexpFlags$1;
var RegExpPrototype$7 = RegExp.prototype;
var regexpGetFlags = function(R) {
  var flags = R.flags;
  return flags === void 0 && !("flags" in RegExpPrototype$7) && !hasOwn$i(R, "flags") && isPrototypeOf$4(RegExpPrototype$7, R) ? call$R(regExpFlags$1, R) : flags;
};
var fails$z = fails$1z;
var globalThis$F = globalThis_1;
var $RegExp$2 = globalThis$F.RegExp;
var UNSUPPORTED_Y$3 = fails$z(function() {
  var re = $RegExp$2("a", "y");
  re.lastIndex = 2;
  return re.exec("abcd") !== null;
});
var MISSED_STICKY$2 = UNSUPPORTED_Y$3 || fails$z(function() {
  return !$RegExp$2("a", "y").sticky;
});
var BROKEN_CARET = UNSUPPORTED_Y$3 || fails$z(function() {
  var re = $RegExp$2("^r", "gy");
  re.lastIndex = 2;
  return re.exec("str") !== null;
});
var regexpStickyHelpers = {
  BROKEN_CARET,
  MISSED_STICKY: MISSED_STICKY$2,
  UNSUPPORTED_Y: UNSUPPORTED_Y$3
};
var fails$y = fails$1z;
var globalThis$E = globalThis_1;
var $RegExp$1 = globalThis$E.RegExp;
var regexpUnsupportedDotAll = fails$y(function() {
  var re = $RegExp$1(".", "s");
  return !(re.dotAll && re.test("\n") && re.flags === "s");
});
var fails$x = fails$1z;
var globalThis$D = globalThis_1;
var $RegExp = globalThis$D.RegExp;
var regexpUnsupportedNcg = fails$x(function() {
  var re = $RegExp("(?<a>b)", "g");
  return re.exec("b").groups.a !== "b" || "b".replace(re, "$<a>c") !== "bc";
});
var DESCRIPTORS$k = descriptors;
var globalThis$C = globalThis_1;
var uncurryThis$15 = functionUncurryThis;
var isForced = isForced_1;
var inheritIfRequired$2 = inheritIfRequired$7;
var createNonEnumerableProperty$8 = createNonEnumerableProperty$j;
var create$a = objectCreate$1;
var getOwnPropertyNames$2 = objectGetOwnPropertyNames.f;
var isPrototypeOf$3 = objectIsPrototypeOf;
var isRegExp$3 = isRegexp;
var toString$w = toString$J;
var getRegExpFlags$4 = regexpGetFlags;
var stickyHelpers$2 = regexpStickyHelpers;
var proxyAccessor = proxyAccessor$2;
var defineBuiltIn$e = defineBuiltIn$u;
var fails$w = fails$1z;
var hasOwn$h = hasOwnProperty_1;
var enforceInternalState$2 = internalState.enforce;
var setSpecies$2 = setSpecies$7;
var wellKnownSymbol$q = wellKnownSymbol$S;
var UNSUPPORTED_DOT_ALL$2 = regexpUnsupportedDotAll;
var UNSUPPORTED_NCG$1 = regexpUnsupportedNcg;
var MATCH$1 = wellKnownSymbol$q("match");
var NativeRegExp = globalThis$C.RegExp;
var RegExpPrototype$6 = NativeRegExp.prototype;
var SyntaxError$4 = globalThis$C.SyntaxError;
var exec$d = uncurryThis$15(RegExpPrototype$6.exec);
var charAt$j = uncurryThis$15("".charAt);
var replace$7 = uncurryThis$15("".replace);
var stringIndexOf$4 = uncurryThis$15("".indexOf);
var stringSlice$f = uncurryThis$15("".slice);
var IS_NCG = /^\?<[^\s\d!#%&*+<=>@^][^\s!#%&*+<=>@^]*>/;
var re1 = /a/g;
var re2 = /a/g;
var CORRECT_NEW = new NativeRegExp(re1) !== re1;
var MISSED_STICKY$1 = stickyHelpers$2.MISSED_STICKY;
var UNSUPPORTED_Y$2 = stickyHelpers$2.UNSUPPORTED_Y;
var BASE_FORCED = DESCRIPTORS$k && (!CORRECT_NEW || MISSED_STICKY$1 || UNSUPPORTED_DOT_ALL$2 || UNSUPPORTED_NCG$1 || fails$w(function() {
  re2[MATCH$1] = false;
  return NativeRegExp(re1) !== re1 || NativeRegExp(re2) === re2 || String(NativeRegExp(re1, "i")) !== "/a/i";
}));
var handleDotAll = function(string) {
  var length = string.length;
  var index2 = 0;
  var result = "";
  var brackets = false;
  var chr;
  for (; index2 <= length; index2++) {
    chr = charAt$j(string, index2);
    if (chr === "\\") {
      result += chr + charAt$j(string, ++index2);
      continue;
    }
    if (!brackets && chr === ".") {
      result += "[\\s\\S]";
    } else {
      if (chr === "[") {
        brackets = true;
      } else if (chr === "]") {
        brackets = false;
      }
      result += chr;
    }
  }
  return result;
};
var handleNCG = function(string) {
  var length = string.length;
  var index2 = 0;
  var result = "";
  var named = [];
  var names = create$a(null);
  var brackets = false;
  var ncg = false;
  var groupid = 0;
  var groupname = "";
  var chr;
  for (; index2 <= length; index2++) {
    chr = charAt$j(string, index2);
    if (chr === "\\") {
      chr += charAt$j(string, ++index2);
    } else if (chr === "]") {
      brackets = false;
    } else if (!brackets) switch (true) {
      case chr === "[":
        brackets = true;
        break;
      case chr === "(":
        result += chr;
        if (stringSlice$f(string, index2 + 1, index2 + 3) === "?:") {
          continue;
        }
        if (exec$d(IS_NCG, stringSlice$f(string, index2 + 1))) {
          index2 += 2;
          ncg = true;
        }
        groupid++;
        continue;
      case (chr === ">" && ncg):
        if (groupname === "" || hasOwn$h(names, groupname)) {
          throw new SyntaxError$4("Invalid capture group name");
        }
        names[groupname] = true;
        named[named.length] = [groupname, groupid];
        ncg = false;
        groupname = "";
        continue;
    }
    if (ncg) groupname += chr;
    else result += chr;
  }
  return [result, named];
};
if (isForced("RegExp", BASE_FORCED)) {
  var RegExpWrapper = function RegExp2(pattern, flags) {
    var thisIsRegExp = isPrototypeOf$3(RegExpPrototype$6, this);
    var patternIsRegExp = isRegExp$3(pattern);
    var flagsAreUndefined = flags === void 0;
    var groups = [];
    var rawPattern = pattern;
    var rawFlags, dotAll, sticky, handled, result, state;
    if (!thisIsRegExp && patternIsRegExp && flagsAreUndefined && pattern.constructor === RegExpWrapper) {
      return pattern;
    }
    if (patternIsRegExp || isPrototypeOf$3(RegExpPrototype$6, pattern)) {
      pattern = pattern.source;
      if (flagsAreUndefined) flags = getRegExpFlags$4(rawPattern);
    }
    pattern = pattern === void 0 ? "" : toString$w(pattern);
    flags = flags === void 0 ? "" : toString$w(flags);
    rawPattern = pattern;
    if (UNSUPPORTED_DOT_ALL$2 && "dotAll" in re1) {
      dotAll = !!flags && stringIndexOf$4(flags, "s") > -1;
      if (dotAll) flags = replace$7(flags, /s/g, "");
    }
    rawFlags = flags;
    if (MISSED_STICKY$1 && "sticky" in re1) {
      sticky = !!flags && stringIndexOf$4(flags, "y") > -1;
      if (sticky && UNSUPPORTED_Y$2) flags = replace$7(flags, /y/g, "");
    }
    if (UNSUPPORTED_NCG$1) {
      handled = handleNCG(pattern);
      pattern = handled[0];
      groups = handled[1];
    }
    result = inheritIfRequired$2(NativeRegExp(pattern, flags), thisIsRegExp ? this : RegExpPrototype$6, RegExpWrapper);
    if (dotAll || sticky || groups.length) {
      state = enforceInternalState$2(result);
      if (dotAll) {
        state.dotAll = true;
        state.raw = RegExpWrapper(handleDotAll(pattern), rawFlags);
      }
      if (sticky) state.sticky = true;
      if (groups.length) state.groups = groups;
    }
    if (pattern !== rawPattern) try {
      createNonEnumerableProperty$8(result, "source", rawPattern === "" ? "(?:)" : rawPattern);
    } catch (error3) {
    }
    return result;
  };
  for (var keys$1 = getOwnPropertyNames$2(NativeRegExp), index = 0; keys$1.length > index; ) {
    proxyAccessor(RegExpWrapper, NativeRegExp, keys$1[index++]);
  }
  RegExpPrototype$6.constructor = RegExpWrapper;
  RegExpWrapper.prototype = RegExpPrototype$6;
  defineBuiltIn$e(globalThis$C, "RegExp", RegExpWrapper, {
    constructor: true
  });
}
setSpecies$2("RegExp");
var $TypeError$r = TypeError;
var aString$4 = function(argument) {
  if (typeof argument == "string") return argument;
  throw new $TypeError$r("Argument is not a string");
};
var $$38 = _export;
var uncurryThis$14 = functionUncurryThis;
var aString$3 = aString$4;
var hasOwn$g = hasOwnProperty_1;
var padStart = stringPad.start;
var WHITESPACES = whitespaces$6;
var $Array$4 = Array;
var $escape = RegExp.escape;
var charAt$i = uncurryThis$14("".charAt);
var charCodeAt$6 = uncurryThis$14("".charCodeAt);
var numberToString$3 = uncurryThis$14(1.1.toString);
var join$8 = uncurryThis$14([].join);
var FIRST_DIGIT_OR_ASCII = /^[0-9a-z]/i;
var SYNTAX_SOLIDUS = /^[$()*+./?[\\\]^{|}]/;
var OTHER_PUNCTUATORS_AND_WHITESPACES = RegExp("^[!\"#%&',\\-:;<=>@`~" + WHITESPACES + "]");
var exec$c = uncurryThis$14(FIRST_DIGIT_OR_ASCII.exec);
var ControlEscape = {
  "	": "t",
  "\n": "n",
  "\v": "v",
  "\f": "f",
  "\r": "r"
};
var escapeChar = function(chr) {
  var hex3 = numberToString$3(charCodeAt$6(chr, 0), 16);
  return hex3.length < 3 ? "\\x" + padStart(hex3, 2, "0") : "\\u" + padStart(hex3, 4, "0");
};
var FORCED$7 = !$escape || $escape("ab") !== "\\x61b";
$$38({
  target: "RegExp",
  stat: true,
  forced: FORCED$7
}, {
  escape: function escape2(S) {
    aString$3(S);
    var length = S.length;
    var result = $Array$4(length);
    for (var i = 0; i < length; i++) {
      var chr = charAt$i(S, i);
      if (i === 0 && exec$c(FIRST_DIGIT_OR_ASCII, chr)) {
        result[i] = escapeChar(chr);
      } else if (hasOwn$g(ControlEscape, chr)) {
        result[i] = "\\" + ControlEscape[chr];
      } else if (exec$c(SYNTAX_SOLIDUS, chr)) {
        result[i] = "\\" + chr;
      } else if (exec$c(OTHER_PUNCTUATORS_AND_WHITESPACES, chr)) {
        result[i] = escapeChar(chr);
      } else {
        var charCode = charCodeAt$6(chr, 0);
        if ((charCode & 63488) !== 55296) result[i] = chr;
        else if (charCode >= 56320 || i + 1 >= length || (charCodeAt$6(S, i + 1) & 64512) !== 56320) result[i] = escapeChar(chr);
        else {
          result[i] = chr;
          result[++i] = charAt$i(S, i);
        }
      }
    }
    return join$8(result, "");
  }
});
var DESCRIPTORS$j = descriptors;
var UNSUPPORTED_DOT_ALL$1 = regexpUnsupportedDotAll;
var classof$a = classofRaw$2;
var defineBuiltInAccessor$e = defineBuiltInAccessor$p;
var getInternalState$c = internalState.get;
var RegExpPrototype$5 = RegExp.prototype;
var $TypeError$q = TypeError;
if (DESCRIPTORS$j && UNSUPPORTED_DOT_ALL$1) {
  defineBuiltInAccessor$e(RegExpPrototype$5, "dotAll", {
    configurable: true,
    get: function dotAll() {
      if (this === RegExpPrototype$5) return;
      if (classof$a(this) === "RegExp") {
        return !!getInternalState$c(this).dotAll;
      }
      throw new $TypeError$q("Incompatible receiver, RegExp required");
    }
  });
}
var call$Q = functionCall;
var uncurryThis$13 = functionUncurryThis;
var toString$v = toString$J;
var regexpFlags = regexpFlags$1;
var stickyHelpers$1 = regexpStickyHelpers;
var shared$3 = shared$a;
var create$9 = objectCreate$1;
var getInternalState$b = internalState.get;
var UNSUPPORTED_DOT_ALL = regexpUnsupportedDotAll;
var UNSUPPORTED_NCG = regexpUnsupportedNcg;
var nativeReplace = shared$3("native-string-replace", String.prototype.replace);
var nativeExec = RegExp.prototype.exec;
var patchedExec = nativeExec;
var charAt$h = uncurryThis$13("".charAt);
var indexOf$1 = uncurryThis$13("".indexOf);
var replace$6 = uncurryThis$13("".replace);
var stringSlice$e = uncurryThis$13("".slice);
var UPDATES_LAST_INDEX_WRONG = function() {
  var re12 = /a/;
  var re22 = /b*/g;
  call$Q(nativeExec, re12, "a");
  call$Q(nativeExec, re22, "a");
  return re12.lastIndex !== 0 || re22.lastIndex !== 0;
}();
var UNSUPPORTED_Y$1 = stickyHelpers$1.BROKEN_CARET;
var NPCG_INCLUDED = /()??/.exec("")[1] !== void 0;
var PATCH$1 = UPDATES_LAST_INDEX_WRONG || NPCG_INCLUDED || UNSUPPORTED_Y$1 || UNSUPPORTED_DOT_ALL || UNSUPPORTED_NCG;
if (PATCH$1) {
  patchedExec = function exec2(string) {
    var re = this;
    var state = getInternalState$b(re);
    var str = toString$v(string);
    var raw3 = state.raw;
    var result, reCopy, lastIndex, match2, i, object, group2;
    if (raw3) {
      raw3.lastIndex = re.lastIndex;
      result = call$Q(patchedExec, raw3, str);
      re.lastIndex = raw3.lastIndex;
      return result;
    }
    var groups = state.groups;
    var sticky = UNSUPPORTED_Y$1 && re.sticky;
    var flags = call$Q(regexpFlags, re);
    var source = re.source;
    var charsAdded = 0;
    var strCopy = str;
    if (sticky) {
      flags = replace$6(flags, "y", "");
      if (indexOf$1(flags, "g") === -1) {
        flags += "g";
      }
      strCopy = stringSlice$e(str, re.lastIndex);
      if (re.lastIndex > 0 && (!re.multiline || re.multiline && charAt$h(str, re.lastIndex - 1) !== "\n")) {
        source = "(?: " + source + ")";
        strCopy = " " + strCopy;
        charsAdded++;
      }
      reCopy = new RegExp("^(?:" + source + ")", flags);
    }
    if (NPCG_INCLUDED) {
      reCopy = new RegExp("^" + source + "$(?!\\s)", flags);
    }
    if (UPDATES_LAST_INDEX_WRONG) lastIndex = re.lastIndex;
    match2 = call$Q(nativeExec, sticky ? reCopy : re, strCopy);
    if (sticky) {
      if (match2) {
        match2.input = stringSlice$e(match2.input, charsAdded);
        match2[0] = stringSlice$e(match2[0], charsAdded);
        match2.index = re.lastIndex;
        re.lastIndex += match2[0].length;
      } else re.lastIndex = 0;
    } else if (UPDATES_LAST_INDEX_WRONG && match2) {
      re.lastIndex = re.global ? match2.index + match2[0].length : lastIndex;
    }
    if (NPCG_INCLUDED && match2 && match2.length > 1) {
      call$Q(nativeReplace, match2[0], reCopy, function() {
        for (i = 1; i < arguments.length - 2; i++) {
          if (arguments[i] === void 0) match2[i] = void 0;
        }
      });
    }
    if (match2 && groups) {
      match2.groups = object = create$9(null);
      for (i = 0; i < groups.length; i++) {
        group2 = groups[i];
        object[group2[0]] = match2[group2[1]];
      }
    }
    return match2;
  };
}
var regexpExec$2 = patchedExec;
var $$37 = _export;
var exec$b = regexpExec$2;
$$37({
  target: "RegExp",
  proto: true,
  forced: /./.exec !== exec$b
}, {
  exec: exec$b
});
var globalThis$B = globalThis_1;
var DESCRIPTORS$i = descriptors;
var defineBuiltInAccessor$d = defineBuiltInAccessor$p;
var regExpFlags = regexpFlags$1;
var fails$v = fails$1z;
var RegExp$1 = globalThis$B.RegExp;
var RegExpPrototype$4 = RegExp$1.prototype;
var FORCED$6 = DESCRIPTORS$i && fails$v(function() {
  var INDICES_SUPPORT = true;
  try {
    RegExp$1(".", "d");
  } catch (error3) {
    INDICES_SUPPORT = false;
  }
  var O = {};
  var calls = "";
  var expected = INDICES_SUPPORT ? "dgimsy" : "gimsy";
  var addGetter2 = function(key2, chr) {
    Object.defineProperty(O, key2, {
      get: function() {
        calls += chr;
        return true;
      }
    });
  };
  var pairs = {
    dotAll: "s",
    global: "g",
    ignoreCase: "i",
    multiline: "m",
    sticky: "y"
  };
  if (INDICES_SUPPORT) pairs.hasIndices = "d";
  for (var key in pairs) addGetter2(key, pairs[key]);
  var result = Object.getOwnPropertyDescriptor(RegExpPrototype$4, "flags").get.call(O);
  return result !== expected || calls !== expected;
});
if (FORCED$6) defineBuiltInAccessor$d(RegExpPrototype$4, "flags", {
  configurable: true,
  get: regExpFlags
});
var DESCRIPTORS$h = descriptors;
var MISSED_STICKY = regexpStickyHelpers.MISSED_STICKY;
var classof$9 = classofRaw$2;
var defineBuiltInAccessor$c = defineBuiltInAccessor$p;
var getInternalState$a = internalState.get;
var RegExpPrototype$3 = RegExp.prototype;
var $TypeError$p = TypeError;
if (DESCRIPTORS$h && MISSED_STICKY) {
  defineBuiltInAccessor$c(RegExpPrototype$3, "sticky", {
    configurable: true,
    get: function sticky() {
      if (this === RegExpPrototype$3) return;
      if (classof$9(this) === "RegExp") {
        return !!getInternalState$a(this).sticky;
      }
      throw new $TypeError$p("Incompatible receiver, RegExp required");
    }
  });
}
var $$36 = _export;
var call$P = functionCall;
var isCallable$f = isCallable$I;
var anObject$G = anObject$1i;
var toString$u = toString$J;
var DELEGATES_TO_EXEC = function() {
  var execCalled = false;
  var re = /[ac]/;
  re.exec = function() {
    execCalled = true;
    return /./.exec.apply(this, arguments);
  };
  return re.test("abc") === true && execCalled;
}();
var nativeTest = /./.test;
$$36({
  target: "RegExp",
  proto: true,
  forced: !DELEGATES_TO_EXEC
}, {
  test: function(S) {
    var R = anObject$G(this);
    var string = toString$u(S);
    var exec2 = R.exec;
    if (!isCallable$f(exec2)) return call$P(nativeTest, R, string);
    var result = call$P(exec2, R, string);
    if (result === null) return false;
    anObject$G(result);
    return true;
  }
});
var PROPER_FUNCTION_NAME$1 = functionName.PROPER;
var defineBuiltIn$d = defineBuiltIn$u;
var anObject$F = anObject$1i;
var $toString$2 = toString$J;
var fails$u = fails$1z;
var getRegExpFlags$3 = regexpGetFlags;
var TO_STRING = "toString";
var RegExpPrototype$2 = RegExp.prototype;
var nativeToString = RegExpPrototype$2[TO_STRING];
var NOT_GENERIC = fails$u(function() {
  return nativeToString.call({
    source: "a",
    flags: "b"
  }) !== "/a/b";
});
var INCORRECT_NAME = PROPER_FUNCTION_NAME$1 && nativeToString.name !== TO_STRING;
if (NOT_GENERIC || INCORRECT_NAME) {
  defineBuiltIn$d(RegExpPrototype$2, TO_STRING, function toString7() {
    var R = anObject$F(this);
    var pattern = $toString$2(R.source);
    var flags = $toString$2(getRegExpFlags$3(R));
    return "/" + pattern + "/" + flags;
  }, {
    unsafe: true
  });
}
var collection$2 = collection$4;
var collectionStrong = collectionStrong$2;
collection$2("Set", function(init) {
  return function Set2() {
    return init(this, arguments.length ? arguments[0] : void 0);
  };
}, collectionStrong);
var uncurryThis$12 = functionUncurryThis;
var SetPrototype$1 = Set.prototype;
var setHelpers = {
  // eslint-disable-next-line es/no-set -- safe
  Set,
  add: uncurryThis$12(SetPrototype$1.add),
  has: uncurryThis$12(SetPrototype$1.has),
  remove: uncurryThis$12(SetPrototype$1["delete"]),
  proto: SetPrototype$1
};
var has$g = setHelpers.has;
var aSet$g = function(it) {
  has$g(it);
  return it;
};
var call$O = functionCall;
var iterateSimple$8 = function(record, fn, ITERATOR_INSTEAD_OF_RECORD) {
  var iterator = ITERATOR_INSTEAD_OF_RECORD ? record : record.iterator;
  var next11 = record.next;
  var step, result;
  while (!(step = call$O(next11, iterator)).done) {
    result = fn(step.value);
    if (result !== void 0) return result;
  }
};
var uncurryThis$11 = functionUncurryThis;
var iterateSimple$7 = iterateSimple$8;
var SetHelpers$a = setHelpers;
var Set$7 = SetHelpers$a.Set;
var SetPrototype = SetHelpers$a.proto;
var forEach$5 = uncurryThis$11(SetPrototype.forEach);
var keys3 = uncurryThis$11(SetPrototype.keys);
var next$1 = keys3(new Set$7()).next;
var setIterate$1 = function(set4, fn, interruptible) {
  return interruptible ? iterateSimple$7({
    iterator: keys3(set4),
    next: next$1
  }, fn) : forEach$5(set4, fn);
};
var SetHelpers$9 = setHelpers;
var iterate$q = setIterate$1;
var Set$6 = SetHelpers$9.Set;
var add$7 = SetHelpers$9.add;
var setClone = function(set4) {
  var result = new Set$6();
  iterate$q(set4, function(it) {
    add$7(result, it);
  });
  return result;
};
var uncurryThisAccessor = functionUncurryThisAccessor;
var SetHelpers$8 = setHelpers;
var setSize = uncurryThisAccessor(SetHelpers$8.proto, "size", "get") || function(set4) {
  return set4.size;
};
var aCallable$m = aCallable$Q;
var anObject$E = anObject$1i;
var call$N = functionCall;
var toIntegerOrInfinity$9 = toIntegerOrInfinity$p;
var getIteratorDirect$b = getIteratorDirect$o;
var INVALID_SIZE = "Invalid size";
var $RangeError$7 = RangeError;
var $TypeError$o = TypeError;
var max$4 = Math.max;
var SetRecord = function(set4, intSize) {
  this.set = set4;
  this.size = max$4(intSize, 0);
  this.has = aCallable$m(set4.has);
  this.keys = aCallable$m(set4.keys);
};
SetRecord.prototype = {
  getIterator: function() {
    return getIteratorDirect$b(anObject$E(call$N(this.keys, this.set)));
  },
  includes: function(it) {
    return call$N(this.has, this.set, it);
  }
};
var getSetRecord$7 = function(obj) {
  anObject$E(obj);
  var numSize = +obj.size;
  if (numSize !== numSize) throw new $TypeError$o(INVALID_SIZE);
  var intSize = toIntegerOrInfinity$9(numSize);
  if (intSize < 0) throw new $RangeError$7(INVALID_SIZE);
  return new SetRecord(obj, intSize);
};
var aSet$f = aSet$g;
var SetHelpers$7 = setHelpers;
var clone$2 = setClone;
var size$4 = setSize;
var getSetRecord$6 = getSetRecord$7;
var iterateSet$2 = setIterate$1;
var iterateSimple$6 = iterateSimple$8;
var has$f = SetHelpers$7.has;
var remove$5 = SetHelpers$7.remove;
var setDifference = function difference(other) {
  var O = aSet$f(this);
  var otherRec = getSetRecord$6(other);
  var result = clone$2(O);
  if (size$4(O) <= otherRec.size) iterateSet$2(O, function(e) {
    if (otherRec.includes(e)) remove$5(result, e);
  });
  else iterateSimple$6(otherRec.getIterator(), function(e) {
    if (has$f(O, e)) remove$5(result, e);
  });
  return result;
};
var getBuiltIn$x = getBuiltIn$Q;
var createSetLike = function(size3) {
  return {
    size: size3,
    has: function() {
      return false;
    },
    keys: function() {
      return {
        next: function() {
          return {
            done: true
          };
        }
      };
    }
  };
};
var createSetLikeWithInfinitySize = function(size3) {
  return {
    size: size3,
    has: function() {
      return true;
    },
    keys: function() {
      throw new Error("e");
    }
  };
};
var setMethodAcceptSetLike$7 = function(name, callback2) {
  var Set2 = getBuiltIn$x("Set");
  try {
    new Set2()[name](createSetLike(0));
    try {
      new Set2()[name](createSetLike(-1));
      return false;
    } catch (error22) {
      if (!callback2) return true;
      try {
        new Set2()[name](createSetLikeWithInfinitySize(-Infinity));
        return false;
      } catch (error3) {
        var set4 = new Set2();
        set4.add(1);
        set4.add(2);
        return callback2(set4[name](createSetLikeWithInfinitySize(Infinity)));
      }
    }
  } catch (error3) {
    return false;
  }
};
var $$35 = _export;
var difference2 = setDifference;
var setMethodAcceptSetLike$6 = setMethodAcceptSetLike$7;
var INCORRECT$4 = !setMethodAcceptSetLike$6("difference", function(result) {
  return result.size === 0;
});
$$35({
  target: "Set",
  proto: true,
  real: true,
  forced: INCORRECT$4
}, {
  difference: difference2
});
var aSet$e = aSet$g;
var SetHelpers$6 = setHelpers;
var size$3 = setSize;
var getSetRecord$5 = getSetRecord$7;
var iterateSet$1 = setIterate$1;
var iterateSimple$5 = iterateSimple$8;
var Set$5 = SetHelpers$6.Set;
var add$6 = SetHelpers$6.add;
var has$e = SetHelpers$6.has;
var setIntersection = function intersection(other) {
  var O = aSet$e(this);
  var otherRec = getSetRecord$5(other);
  var result = new Set$5();
  if (size$3(O) > otherRec.size) {
    iterateSimple$5(otherRec.getIterator(), function(e) {
      if (has$e(O, e)) add$6(result, e);
    });
  } else {
    iterateSet$1(O, function(e) {
      if (otherRec.includes(e)) add$6(result, e);
    });
  }
  return result;
};
var $$34 = _export;
var fails$t = fails$1z;
var intersection2 = setIntersection;
var setMethodAcceptSetLike$5 = setMethodAcceptSetLike$7;
var INCORRECT$3 = !setMethodAcceptSetLike$5("intersection", function(result) {
  return result.size === 2 && result.has(1) && result.has(2);
}) || fails$t(function() {
  return String(Array.from((/* @__PURE__ */ new Set([1, 2, 3])).intersection(/* @__PURE__ */ new Set([3, 2])))) !== "3,2";
});
$$34({
  target: "Set",
  proto: true,
  real: true,
  forced: INCORRECT$3
}, {
  intersection: intersection2
});
var aSet$d = aSet$g;
var has$d = setHelpers.has;
var size$2 = setSize;
var getSetRecord$4 = getSetRecord$7;
var iterateSet = setIterate$1;
var iterateSimple$4 = iterateSimple$8;
var iteratorClose$2 = iteratorClose$8;
var setIsDisjointFrom = function isDisjointFrom(other) {
  var O = aSet$d(this);
  var otherRec = getSetRecord$4(other);
  if (size$2(O) <= otherRec.size) return iterateSet(O, function(e) {
    if (otherRec.includes(e)) return false;
  }, true) !== false;
  var iterator = otherRec.getIterator();
  return iterateSimple$4(iterator, function(e) {
    if (has$d(O, e)) return iteratorClose$2(iterator, "normal", false);
  }) !== false;
};
var $$33 = _export;
var isDisjointFrom2 = setIsDisjointFrom;
var setMethodAcceptSetLike$4 = setMethodAcceptSetLike$7;
var INCORRECT$2 = !setMethodAcceptSetLike$4("isDisjointFrom", function(result) {
  return !result;
});
$$33({
  target: "Set",
  proto: true,
  real: true,
  forced: INCORRECT$2
}, {
  isDisjointFrom: isDisjointFrom2
});
var aSet$c = aSet$g;
var size$1 = setSize;
var iterate$p = setIterate$1;
var getSetRecord$3 = getSetRecord$7;
var setIsSubsetOf = function isSubsetOf(other) {
  var O = aSet$c(this);
  var otherRec = getSetRecord$3(other);
  if (size$1(O) > otherRec.size) return false;
  return iterate$p(O, function(e) {
    if (!otherRec.includes(e)) return false;
  }, true) !== false;
};
var $$32 = _export;
var isSubsetOf2 = setIsSubsetOf;
var setMethodAcceptSetLike$3 = setMethodAcceptSetLike$7;
var INCORRECT$1 = !setMethodAcceptSetLike$3("isSubsetOf", function(result) {
  return result;
});
$$32({
  target: "Set",
  proto: true,
  real: true,
  forced: INCORRECT$1
}, {
  isSubsetOf: isSubsetOf2
});
var aSet$b = aSet$g;
var has$c = setHelpers.has;
var size = setSize;
var getSetRecord$2 = getSetRecord$7;
var iterateSimple$3 = iterateSimple$8;
var iteratorClose$1 = iteratorClose$8;
var setIsSupersetOf = function isSupersetOf(other) {
  var O = aSet$b(this);
  var otherRec = getSetRecord$2(other);
  if (size(O) < otherRec.size) return false;
  var iterator = otherRec.getIterator();
  return iterateSimple$3(iterator, function(e) {
    if (!has$c(O, e)) return iteratorClose$1(iterator, "normal", false);
  }) !== false;
};
var $$31 = _export;
var isSupersetOf2 = setIsSupersetOf;
var setMethodAcceptSetLike$2 = setMethodAcceptSetLike$7;
var INCORRECT = !setMethodAcceptSetLike$2("isSupersetOf", function(result) {
  return !result;
});
$$31({
  target: "Set",
  proto: true,
  real: true,
  forced: INCORRECT
}, {
  isSupersetOf: isSupersetOf2
});
var aSet$a = aSet$g;
var SetHelpers$5 = setHelpers;
var clone$1 = setClone;
var getSetRecord$1 = getSetRecord$7;
var iterateSimple$2 = iterateSimple$8;
var add$5 = SetHelpers$5.add;
var has$b = SetHelpers$5.has;
var remove$4 = SetHelpers$5.remove;
var setSymmetricDifference = function symmetricDifference(other) {
  var O = aSet$a(this);
  var keysIter = getSetRecord$1(other).getIterator();
  var result = clone$1(O);
  iterateSimple$2(keysIter, function(e) {
    if (has$b(O, e)) remove$4(result, e);
    else add$5(result, e);
  });
  return result;
};
var $$30 = _export;
var symmetricDifference2 = setSymmetricDifference;
var setMethodAcceptSetLike$1 = setMethodAcceptSetLike$7;
$$30({
  target: "Set",
  proto: true,
  real: true,
  forced: !setMethodAcceptSetLike$1("symmetricDifference")
}, {
  symmetricDifference: symmetricDifference2
});
var aSet$9 = aSet$g;
var add$4 = setHelpers.add;
var clone = setClone;
var getSetRecord = getSetRecord$7;
var iterateSimple$1 = iterateSimple$8;
var setUnion = function union(other) {
  var O = aSet$9(this);
  var keysIter = getSetRecord(other).getIterator();
  var result = clone(O);
  iterateSimple$1(keysIter, function(it) {
    add$4(result, it);
  });
  return result;
};
var $$2$ = _export;
var union2 = setUnion;
var setMethodAcceptSetLike = setMethodAcceptSetLike$7;
$$2$({
  target: "Set",
  proto: true,
  real: true,
  forced: !setMethodAcceptSetLike("union")
}, {
  union: union2
});
var $$2_ = _export;
var uncurryThis$10 = functionUncurryThis;
var requireObjectCoercible$g = requireObjectCoercible$q;
var toIntegerOrInfinity$8 = toIntegerOrInfinity$p;
var toString$t = toString$J;
var fails$s = fails$1z;
var charAt$g = uncurryThis$10("".charAt);
var FORCED$5 = fails$s(function() {
  return "".at(-2) !== "\uD842";
});
$$2_({
  target: "String",
  proto: true,
  forced: FORCED$5
}, {
  at: function at2(index) {
    var S = toString$t(requireObjectCoercible$g(this));
    var len = S.length;
    var relativeIndex = toIntegerOrInfinity$8(index);
    var k = relativeIndex >= 0 ? relativeIndex : len + relativeIndex;
    return k < 0 || k >= len ? void 0 : charAt$g(S, k);
  }
});
var uncurryThis$$ = functionUncurryThis;
var toIntegerOrInfinity$7 = toIntegerOrInfinity$p;
var toString$s = toString$J;
var requireObjectCoercible$f = requireObjectCoercible$q;
var charAt$f = uncurryThis$$("".charAt);
var charCodeAt$5 = uncurryThis$$("".charCodeAt);
var stringSlice$d = uncurryThis$$("".slice);
var createMethod$1 = function(CONVERT_TO_STRING) {
  return function($this, pos) {
    var S = toString$s(requireObjectCoercible$f($this));
    var position = toIntegerOrInfinity$7(pos);
    var size3 = S.length;
    var first, second;
    if (position < 0 || position >= size3) return CONVERT_TO_STRING ? "" : void 0;
    first = charCodeAt$5(S, position);
    return first < 55296 || first > 56319 || position + 1 === size3 || (second = charCodeAt$5(S, position + 1)) < 56320 || second > 57343 ? CONVERT_TO_STRING ? charAt$f(S, position) : first : CONVERT_TO_STRING ? stringSlice$d(S, position, position + 2) : (first - 55296 << 10) + (second - 56320) + 65536;
  };
};
var stringMultibyte = {
  // `String.prototype.codePointAt` method
  // https://tc39.es/ecma262/#sec-string.prototype.codepointat
  codeAt: createMethod$1(false),
  // `String.prototype.at` method
  // https://github.com/mathiasbynens/String.prototype.at
  charAt: createMethod$1(true)
};
var $$2Z = _export;
var codeAt$2 = stringMultibyte.codeAt;
$$2Z({
  target: "String",
  proto: true
}, {
  codePointAt: function codePointAt(pos) {
    return codeAt$2(this, pos);
  }
});
var isRegExp$2 = isRegexp;
var $TypeError$n = TypeError;
var notARegexp = function(it) {
  if (isRegExp$2(it)) {
    throw new $TypeError$n("The method doesn't accept regular expressions");
  }
  return it;
};
var wellKnownSymbol$p = wellKnownSymbol$S;
var MATCH = wellKnownSymbol$p("match");
var correctIsRegexpLogic = function(METHOD_NAME) {
  var regexp = /./;
  try {
    "/./"[METHOD_NAME](regexp);
  } catch (error1) {
    try {
      regexp[MATCH] = false;
      return "/./"[METHOD_NAME](regexp);
    } catch (error22) {
    }
  }
  return false;
};
var $$2Y = _export;
var uncurryThis$_ = functionUncurryThisClause;
var getOwnPropertyDescriptor$5 = objectGetOwnPropertyDescriptor.f;
var toLength$7 = toLength$d;
var toString$r = toString$J;
var notARegExp$2 = notARegexp;
var requireObjectCoercible$e = requireObjectCoercible$q;
var correctIsRegExpLogic$2 = correctIsRegexpLogic;
var slice$4 = uncurryThis$_("".slice);
var min$7 = Math.min;
var CORRECT_IS_REGEXP_LOGIC$1 = correctIsRegExpLogic$2("endsWith");
var MDN_POLYFILL_BUG$1 = !CORRECT_IS_REGEXP_LOGIC$1 && !!function() {
  var descriptor = getOwnPropertyDescriptor$5(String.prototype, "endsWith");
  return descriptor && !descriptor.writable;
}();
$$2Y({
  target: "String",
  proto: true,
  forced: !MDN_POLYFILL_BUG$1 && !CORRECT_IS_REGEXP_LOGIC$1
}, {
  endsWith: function endsWith(searchString) {
    var that = toString$r(requireObjectCoercible$e(this));
    notARegExp$2(searchString);
    var endPosition = arguments.length > 1 ? arguments[1] : void 0;
    var len = that.length;
    var end = endPosition === void 0 ? len : min$7(toLength$7(endPosition), len);
    var search = toString$r(searchString);
    return slice$4(that, end - search.length, end) === search;
  }
});
var $$2X = _export;
var uncurryThis$Z = functionUncurryThis;
var toAbsoluteIndex$2 = toAbsoluteIndex$a;
var $RangeError$6 = RangeError;
var fromCharCode$6 = String.fromCharCode;
var $fromCodePoint = String.fromCodePoint;
var join$7 = uncurryThis$Z([].join);
var INCORRECT_LENGTH = !!$fromCodePoint && $fromCodePoint.length !== 1;
$$2X({
  target: "String",
  stat: true,
  arity: 1,
  forced: INCORRECT_LENGTH
}, {
  // eslint-disable-next-line no-unused-vars -- required for `.length`
  fromCodePoint: function fromCodePoint(x) {
    var elements = [];
    var length = arguments.length;
    var i = 0;
    var code2;
    while (length > i) {
      code2 = +arguments[i++];
      if (toAbsoluteIndex$2(code2, 1114111) !== code2) throw new $RangeError$6(code2 + " is not a valid code point");
      elements[i] = code2 < 65536 ? fromCharCode$6(code2) : fromCharCode$6(((code2 -= 65536) >> 10) + 55296, code2 % 1024 + 56320);
    }
    return join$7(elements, "");
  }
});
var $$2W = _export;
var uncurryThis$Y = functionUncurryThis;
var notARegExp$1 = notARegexp;
var requireObjectCoercible$d = requireObjectCoercible$q;
var toString$q = toString$J;
var correctIsRegExpLogic$1 = correctIsRegexpLogic;
var stringIndexOf$3 = uncurryThis$Y("".indexOf);
$$2W({
  target: "String",
  proto: true,
  forced: !correctIsRegExpLogic$1("includes")
}, {
  includes: function includes2(searchString) {
    return !!~stringIndexOf$3(toString$q(requireObjectCoercible$d(this)), toString$q(notARegExp$1(searchString)), arguments.length > 1 ? arguments[1] : void 0);
  }
});
var $$2V = _export;
var uncurryThis$X = functionUncurryThis;
var requireObjectCoercible$c = requireObjectCoercible$q;
var toString$p = toString$J;
var charCodeAt$4 = uncurryThis$X("".charCodeAt);
$$2V({
  target: "String",
  proto: true
}, {
  isWellFormed: function isWellFormed() {
    var S = toString$p(requireObjectCoercible$c(this));
    var length = S.length;
    for (var i = 0; i < length; i++) {
      var charCode = charCodeAt$4(S, i);
      if ((charCode & 63488) !== 55296) continue;
      if (charCode >= 56320 || ++i >= length || (charCodeAt$4(S, i) & 64512) !== 56320) return false;
    }
    return true;
  }
});
var charAt$e = stringMultibyte.charAt;
var toString$o = toString$J;
var InternalStateModule$f = internalState;
var defineIterator = iteratorDefine;
var createIterResultObject$e = createIterResultObject$i;
var STRING_ITERATOR$1 = "String Iterator";
var setInternalState$g = InternalStateModule$f.set;
var getInternalState$9 = InternalStateModule$f.getterFor(STRING_ITERATOR$1);
defineIterator(String, "String", function(iterated) {
  setInternalState$g(this, {
    type: STRING_ITERATOR$1,
    string: toString$o(iterated),
    index: 0
  });
}, function next() {
  var state = getInternalState$9(this);
  var string = state.string;
  var index = state.index;
  var point;
  if (index >= string.length) return createIterResultObject$e(void 0, true);
  point = charAt$e(string, index);
  state.index += point.length;
  return createIterResultObject$e(point, false);
});
var call$M = functionCall;
var defineBuiltIn$c = defineBuiltIn$u;
var regexpExec$1 = regexpExec$2;
var fails$r = fails$1z;
var wellKnownSymbol$o = wellKnownSymbol$S;
var createNonEnumerableProperty$7 = createNonEnumerableProperty$j;
var SPECIES = wellKnownSymbol$o("species");
var RegExpPrototype$1 = RegExp.prototype;
var fixRegexpWellKnownSymbolLogic = function(KEY, exec2, FORCED2, SHAM) {
  var SYMBOL2 = wellKnownSymbol$o(KEY);
  var DELEGATES_TO_SYMBOL = !fails$r(function() {
    var O = {};
    O[SYMBOL2] = function() {
      return 7;
    };
    return ""[KEY](O) !== 7;
  });
  var DELEGATES_TO_EXEC2 = DELEGATES_TO_SYMBOL && !fails$r(function() {
    var execCalled = false;
    var re = /a/;
    if (KEY === "split") {
      re = {};
      re.constructor = {};
      re.constructor[SPECIES] = function() {
        return re;
      };
      re.flags = "";
      re[SYMBOL2] = /./[SYMBOL2];
    }
    re.exec = function() {
      execCalled = true;
      return null;
    };
    re[SYMBOL2]("");
    return !execCalled;
  });
  if (!DELEGATES_TO_SYMBOL || !DELEGATES_TO_EXEC2 || FORCED2) {
    var nativeRegExpMethod = /./[SYMBOL2];
    var methods = exec2(SYMBOL2, ""[KEY], function(nativeMethod, regexp, str, arg2, forceStringMethod) {
      var $exec = regexp.exec;
      if ($exec === regexpExec$1 || $exec === RegExpPrototype$1.exec) {
        if (DELEGATES_TO_SYMBOL && !forceStringMethod) {
          return {
            done: true,
            value: call$M(nativeRegExpMethod, regexp, str, arg2)
          };
        }
        return {
          done: true,
          value: call$M(nativeMethod, str, regexp, arg2)
        };
      }
      return {
        done: false
      };
    });
    defineBuiltIn$c(String.prototype, KEY, methods[0]);
    defineBuiltIn$c(RegExpPrototype$1, SYMBOL2, methods[1]);
  }
  if (SHAM) createNonEnumerableProperty$7(RegExpPrototype$1[SYMBOL2], "sham", true);
};
var charAt$d = stringMultibyte.charAt;
var advanceStringIndex$4 = function(S, index, unicode) {
  return index + (unicode ? charAt$d(S, index).length : 1);
};
var call$L = functionCall;
var anObject$D = anObject$1i;
var isCallable$e = isCallable$I;
var classof$8 = classofRaw$2;
var regexpExec = regexpExec$2;
var $TypeError$m = TypeError;
var regexpExecAbstract = function(R, S) {
  var exec2 = R.exec;
  if (isCallable$e(exec2)) {
    var result = call$L(exec2, R, S);
    if (result !== null) anObject$D(result);
    return result;
  }
  if (classof$8(R) === "RegExp") return call$L(regexpExec, R, S);
  throw new $TypeError$m("RegExp#exec called on incompatible receiver");
};
var call$K = functionCall;
var fixRegExpWellKnownSymbolLogic$3 = fixRegexpWellKnownSymbolLogic;
var anObject$C = anObject$1i;
var isNullOrUndefined$c = isNullOrUndefined$j;
var toLength$6 = toLength$d;
var toString$n = toString$J;
var requireObjectCoercible$b = requireObjectCoercible$q;
var getMethod$g = getMethod$l;
var advanceStringIndex$3 = advanceStringIndex$4;
var regExpExec$4 = regexpExecAbstract;
fixRegExpWellKnownSymbolLogic$3("match", function(MATCH2, nativeMatch, maybeCallNative) {
  return [
    // `String.prototype.match` method
    // https://tc39.es/ecma262/#sec-string.prototype.match
    function match2(regexp) {
      var O = requireObjectCoercible$b(this);
      var matcher = isNullOrUndefined$c(regexp) ? void 0 : getMethod$g(regexp, MATCH2);
      return matcher ? call$K(matcher, regexp, O) : new RegExp(regexp)[MATCH2](toString$n(O));
    },
    // `RegExp.prototype[@@match]` method
    // https://tc39.es/ecma262/#sec-regexp.prototype-@@match
    function(string) {
      var rx = anObject$C(this);
      var S = toString$n(string);
      var res = maybeCallNative(nativeMatch, rx, S);
      if (res.done) return res.value;
      if (!rx.global) return regExpExec$4(rx, S);
      var fullUnicode = rx.unicode;
      rx.lastIndex = 0;
      var A = [];
      var n = 0;
      var result;
      while ((result = regExpExec$4(rx, S)) !== null) {
        var matchStr = toString$n(result[0]);
        A[n] = matchStr;
        if (matchStr === "") rx.lastIndex = advanceStringIndex$3(S, toLength$6(rx.lastIndex), fullUnicode);
        n++;
      }
      return n === 0 ? null : A;
    }
  ];
});
var $$2U = _export;
var call$J = functionCall;
var uncurryThis$W = functionUncurryThisClause;
var createIteratorConstructor$5 = iteratorCreateConstructor;
var createIterResultObject$d = createIterResultObject$i;
var requireObjectCoercible$a = requireObjectCoercible$q;
var toLength$5 = toLength$d;
var toString$m = toString$J;
var anObject$B = anObject$1i;
var isNullOrUndefined$b = isNullOrUndefined$j;
var isRegExp$1 = isRegexp;
var getRegExpFlags$2 = regexpGetFlags;
var getMethod$f = getMethod$l;
var defineBuiltIn$b = defineBuiltIn$u;
var fails$q = fails$1z;
var wellKnownSymbol$n = wellKnownSymbol$S;
var speciesConstructor$1 = speciesConstructor$4;
var advanceStringIndex$2 = advanceStringIndex$4;
var regExpExec$3 = regexpExecAbstract;
var InternalStateModule$e = internalState;
var MATCH_ALL = wellKnownSymbol$n("matchAll");
var REGEXP_STRING = "RegExp String";
var REGEXP_STRING_ITERATOR = REGEXP_STRING + " Iterator";
var setInternalState$f = InternalStateModule$e.set;
var getInternalState$8 = InternalStateModule$e.getterFor(REGEXP_STRING_ITERATOR);
var RegExpPrototype = RegExp.prototype;
var $TypeError$l = TypeError;
var stringIndexOf$2 = uncurryThis$W("".indexOf);
var nativeMatchAll = uncurryThis$W("".matchAll);
var WORKS_WITH_NON_GLOBAL_REGEX = !!nativeMatchAll && !fails$q(function() {
  nativeMatchAll("a", /./);
});
var $RegExpStringIterator = createIteratorConstructor$5(function RegExpStringIterator(regexp, string, $global, fullUnicode) {
  setInternalState$f(this, {
    type: REGEXP_STRING_ITERATOR,
    regexp,
    string,
    global: $global,
    unicode: fullUnicode,
    done: false
  });
}, REGEXP_STRING, function next2() {
  var state = getInternalState$8(this);
  if (state.done) return createIterResultObject$d(void 0, true);
  var R = state.regexp;
  var S = state.string;
  var match2 = regExpExec$3(R, S);
  if (match2 === null) {
    state.done = true;
    return createIterResultObject$d(void 0, true);
  }
  if (state.global) {
    if (toString$m(match2[0]) === "") R.lastIndex = advanceStringIndex$2(S, toLength$5(R.lastIndex), state.unicode);
    return createIterResultObject$d(match2, false);
  }
  state.done = true;
  return createIterResultObject$d(match2, false);
});
var $matchAll = function(string) {
  var R = anObject$B(this);
  var S = toString$m(string);
  var C = speciesConstructor$1(R, RegExp);
  var flags = toString$m(getRegExpFlags$2(R));
  var matcher, $global, fullUnicode;
  matcher = new C(C === RegExp ? R.source : R, flags);
  $global = !!~stringIndexOf$2(flags, "g");
  fullUnicode = !!~stringIndexOf$2(flags, "u");
  matcher.lastIndex = toLength$5(R.lastIndex);
  return new $RegExpStringIterator(matcher, S, $global, fullUnicode);
};
$$2U({
  target: "String",
  proto: true,
  forced: WORKS_WITH_NON_GLOBAL_REGEX
}, {
  matchAll: function matchAll(regexp) {
    var O = requireObjectCoercible$a(this);
    var flags, S, matcher, rx;
    if (!isNullOrUndefined$b(regexp)) {
      if (isRegExp$1(regexp)) {
        flags = toString$m(requireObjectCoercible$a(getRegExpFlags$2(regexp)));
        if (!~stringIndexOf$2(flags, "g")) throw new $TypeError$l("`.matchAll` does not allow non-global regexes");
      }
      if (WORKS_WITH_NON_GLOBAL_REGEX) return nativeMatchAll(O, regexp);
      matcher = getMethod$f(regexp, MATCH_ALL);
      if (matcher) return call$J(matcher, regexp, O);
    } else if (WORKS_WITH_NON_GLOBAL_REGEX) return nativeMatchAll(O, regexp);
    S = toString$m(O);
    rx = new RegExp(regexp, "g");
    return rx[MATCH_ALL](S);
  }
});
MATCH_ALL in RegExpPrototype || defineBuiltIn$b(RegExpPrototype, MATCH_ALL, $matchAll);
var userAgent = environmentUserAgent;
var stringPadWebkitBug = /Version\/10(?:\.\d+){1,2}(?: [\w./]+)?(?: Mobile\/\w+)? Safari\//.test(userAgent);
var $$2T = _export;
var $padEnd = stringPad.end;
var WEBKIT_BUG$1 = stringPadWebkitBug;
$$2T({
  target: "String",
  proto: true,
  forced: WEBKIT_BUG$1
}, {
  padEnd: function padEnd(maxLength) {
    return $padEnd(this, maxLength, arguments.length > 1 ? arguments[1] : void 0);
  }
});
var $$2S = _export;
var $padStart = stringPad.start;
var WEBKIT_BUG = stringPadWebkitBug;
$$2S({
  target: "String",
  proto: true,
  forced: WEBKIT_BUG
}, {
  padStart: function padStart2(maxLength) {
    return $padStart(this, maxLength, arguments.length > 1 ? arguments[1] : void 0);
  }
});
var $$2R = _export;
var uncurryThis$V = functionUncurryThis;
var toIndexedObject$2 = toIndexedObject$k;
var toObject$c = toObject$E;
var toString$l = toString$J;
var lengthOfArrayLike$d = lengthOfArrayLike$B;
var push$h = uncurryThis$V([].push);
var join$6 = uncurryThis$V([].join);
$$2R({
  target: "String",
  stat: true
}, {
  raw: function raw(template) {
    var rawTemplate = toIndexedObject$2(toObject$c(template).raw);
    var literalSegments = lengthOfArrayLike$d(rawTemplate);
    if (!literalSegments) return "";
    var argumentsLength = arguments.length;
    var elements = [];
    var i = 0;
    while (true) {
      push$h(elements, toString$l(rawTemplate[i++]));
      if (i === literalSegments) return join$6(elements, "");
      if (i < argumentsLength) push$h(elements, toString$l(arguments[i]));
    }
  }
});
var $$2Q = _export;
var repeat2 = stringRepeat;
$$2Q({
  target: "String",
  proto: true
}, {
  repeat: repeat2
});
var uncurryThis$U = functionUncurryThis;
var toObject$b = toObject$E;
var floor$3 = Math.floor;
var charAt$c = uncurryThis$U("".charAt);
var replace$5 = uncurryThis$U("".replace);
var stringSlice$c = uncurryThis$U("".slice);
var SUBSTITUTION_SYMBOLS = /\$([$&'`]|\d{1,2}|<[^>]*>)/g;
var SUBSTITUTION_SYMBOLS_NO_NAMED = /\$([$&'`]|\d{1,2})/g;
var getSubstitution$2 = function(matched, str, position, captures, namedCaptures, replacement2) {
  var tailPos = position + matched.length;
  var m = captures.length;
  var symbols = SUBSTITUTION_SYMBOLS_NO_NAMED;
  if (namedCaptures !== void 0) {
    namedCaptures = toObject$b(namedCaptures);
    symbols = SUBSTITUTION_SYMBOLS;
  }
  return replace$5(replacement2, symbols, function(match2, ch) {
    var capture;
    switch (charAt$c(ch, 0)) {
      case "$":
        return "$";
      case "&":
        return matched;
      case "`":
        return stringSlice$c(str, 0, position);
      case "'":
        return stringSlice$c(str, tailPos);
      case "<":
        capture = namedCaptures[stringSlice$c(ch, 1, -1)];
        break;
      default:
        var n = +ch;
        if (n === 0) return match2;
        if (n > m) {
          var f = floor$3(n / 10);
          if (f === 0) return match2;
          if (f <= m) return captures[f - 1] === void 0 ? charAt$c(ch, 1) : captures[f - 1] + charAt$c(ch, 1);
          return match2;
        }
        capture = captures[n - 1];
    }
    return capture === void 0 ? "" : capture;
  });
};
var apply$6 = functionApply$1;
var call$I = functionCall;
var uncurryThis$T = functionUncurryThis;
var fixRegExpWellKnownSymbolLogic$2 = fixRegexpWellKnownSymbolLogic;
var fails$p = fails$1z;
var anObject$A = anObject$1i;
var isCallable$d = isCallable$I;
var isNullOrUndefined$a = isNullOrUndefined$j;
var toIntegerOrInfinity$6 = toIntegerOrInfinity$p;
var toLength$4 = toLength$d;
var toString$k = toString$J;
var requireObjectCoercible$9 = requireObjectCoercible$q;
var advanceStringIndex$1 = advanceStringIndex$4;
var getMethod$e = getMethod$l;
var getSubstitution$1 = getSubstitution$2;
var regExpExec$2 = regexpExecAbstract;
var wellKnownSymbol$m = wellKnownSymbol$S;
var REPLACE$1 = wellKnownSymbol$m("replace");
var max$3 = Math.max;
var min$6 = Math.min;
var concat$1 = uncurryThis$T([].concat);
var push$g = uncurryThis$T([].push);
var stringIndexOf$1 = uncurryThis$T("".indexOf);
var stringSlice$b = uncurryThis$T("".slice);
var maybeToString = function(it) {
  return it === void 0 ? it : String(it);
};
var REPLACE_KEEPS_$0 = function() {
  return "a".replace(/./, "$0") === "$0";
}();
var REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE = function() {
  if (/./[REPLACE$1]) {
    return /./[REPLACE$1]("a", "$0") === "";
  }
  return false;
}();
var REPLACE_SUPPORTS_NAMED_GROUPS = !fails$p(function() {
  var re = /./;
  re.exec = function() {
    var result = [];
    result.groups = {
      a: "7"
    };
    return result;
  };
  return "".replace(re, "$<a>") !== "7";
});
fixRegExpWellKnownSymbolLogic$2("replace", function(_, nativeReplace2, maybeCallNative) {
  var UNSAFE_SUBSTITUTE = REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE ? "$" : "$0";
  return [
    // `String.prototype.replace` method
    // https://tc39.es/ecma262/#sec-string.prototype.replace
    function replace2(searchValue, replaceValue) {
      var O = requireObjectCoercible$9(this);
      var replacer2 = isNullOrUndefined$a(searchValue) ? void 0 : getMethod$e(searchValue, REPLACE$1);
      return replacer2 ? call$I(replacer2, searchValue, O, replaceValue) : call$I(nativeReplace2, toString$k(O), searchValue, replaceValue);
    },
    // `RegExp.prototype[@@replace]` method
    // https://tc39.es/ecma262/#sec-regexp.prototype-@@replace
    function(string, replaceValue) {
      var rx = anObject$A(this);
      var S = toString$k(string);
      if (typeof replaceValue == "string" && stringIndexOf$1(replaceValue, UNSAFE_SUBSTITUTE) === -1 && stringIndexOf$1(replaceValue, "$<") === -1) {
        var res = maybeCallNative(nativeReplace2, rx, S, replaceValue);
        if (res.done) return res.value;
      }
      var functionalReplace = isCallable$d(replaceValue);
      if (!functionalReplace) replaceValue = toString$k(replaceValue);
      var global = rx.global;
      var fullUnicode;
      if (global) {
        fullUnicode = rx.unicode;
        rx.lastIndex = 0;
      }
      var results = [];
      var result;
      while (true) {
        result = regExpExec$2(rx, S);
        if (result === null) break;
        push$g(results, result);
        if (!global) break;
        var matchStr = toString$k(result[0]);
        if (matchStr === "") rx.lastIndex = advanceStringIndex$1(S, toLength$4(rx.lastIndex), fullUnicode);
      }
      var accumulatedResult = "";
      var nextSourcePosition = 0;
      for (var i = 0; i < results.length; i++) {
        result = results[i];
        var matched = toString$k(result[0]);
        var position = max$3(min$6(toIntegerOrInfinity$6(result.index), S.length), 0);
        var captures = [];
        var replacement2;
        for (var j = 1; j < result.length; j++) push$g(captures, maybeToString(result[j]));
        var namedCaptures = result.groups;
        if (functionalReplace) {
          var replacerArgs = concat$1([matched], captures, position, S);
          if (namedCaptures !== void 0) push$g(replacerArgs, namedCaptures);
          replacement2 = toString$k(apply$6(replaceValue, void 0, replacerArgs));
        } else {
          replacement2 = getSubstitution$1(matched, S, position, captures, namedCaptures, replaceValue);
        }
        if (position >= nextSourcePosition) {
          accumulatedResult += stringSlice$b(S, nextSourcePosition, position) + replacement2;
          nextSourcePosition = position + matched.length;
        }
      }
      return accumulatedResult + stringSlice$b(S, nextSourcePosition);
    }
  ];
}, !REPLACE_SUPPORTS_NAMED_GROUPS || !REPLACE_KEEPS_$0 || REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE);
var $$2P = _export;
var call$H = functionCall;
var uncurryThis$S = functionUncurryThis;
var requireObjectCoercible$8 = requireObjectCoercible$q;
var isCallable$c = isCallable$I;
var isNullOrUndefined$9 = isNullOrUndefined$j;
var isRegExp = isRegexp;
var toString$j = toString$J;
var getMethod$d = getMethod$l;
var getRegExpFlags$1 = regexpGetFlags;
var getSubstitution = getSubstitution$2;
var wellKnownSymbol$l = wellKnownSymbol$S;
var REPLACE = wellKnownSymbol$l("replace");
var $TypeError$k = TypeError;
var indexOf2 = uncurryThis$S("".indexOf);
uncurryThis$S("".replace);
var stringSlice$a = uncurryThis$S("".slice);
var max$2 = Math.max;
$$2P({
  target: "String",
  proto: true
}, {
  replaceAll: function replaceAll(searchValue, replaceValue) {
    var O = requireObjectCoercible$8(this);
    var IS_REG_EXP, flags, replacer2, string, searchString, functionalReplace, searchLength, advanceBy, position, replacement2;
    var endOfLastMatch = 0;
    var result = "";
    if (!isNullOrUndefined$9(searchValue)) {
      IS_REG_EXP = isRegExp(searchValue);
      if (IS_REG_EXP) {
        flags = toString$j(requireObjectCoercible$8(getRegExpFlags$1(searchValue)));
        if (!~indexOf2(flags, "g")) throw new $TypeError$k("`.replaceAll` does not allow non-global regexes");
      }
      replacer2 = getMethod$d(searchValue, REPLACE);
      if (replacer2) return call$H(replacer2, searchValue, O, replaceValue);
    }
    string = toString$j(O);
    searchString = toString$j(searchValue);
    functionalReplace = isCallable$c(replaceValue);
    if (!functionalReplace) replaceValue = toString$j(replaceValue);
    searchLength = searchString.length;
    advanceBy = max$2(1, searchLength);
    position = indexOf2(string, searchString);
    while (position !== -1) {
      replacement2 = functionalReplace ? toString$j(replaceValue(searchString, position, string)) : getSubstitution(searchString, string, position, [], void 0, replaceValue);
      result += stringSlice$a(string, endOfLastMatch, position) + replacement2;
      endOfLastMatch = position + searchLength;
      position = position + advanceBy > string.length ? -1 : indexOf2(string, searchString, position + advanceBy);
    }
    if (endOfLastMatch < string.length) {
      result += stringSlice$a(string, endOfLastMatch);
    }
    return result;
  }
});
var call$G = functionCall;
var fixRegExpWellKnownSymbolLogic$1 = fixRegexpWellKnownSymbolLogic;
var anObject$z = anObject$1i;
var isNullOrUndefined$8 = isNullOrUndefined$j;
var requireObjectCoercible$7 = requireObjectCoercible$q;
var sameValue$1 = sameValue$2;
var toString$i = toString$J;
var getMethod$c = getMethod$l;
var regExpExec$1 = regexpExecAbstract;
fixRegExpWellKnownSymbolLogic$1("search", function(SEARCH, nativeSearch, maybeCallNative) {
  return [
    // `String.prototype.search` method
    // https://tc39.es/ecma262/#sec-string.prototype.search
    function search(regexp) {
      var O = requireObjectCoercible$7(this);
      var searcher = isNullOrUndefined$8(regexp) ? void 0 : getMethod$c(regexp, SEARCH);
      return searcher ? call$G(searcher, regexp, O) : new RegExp(regexp)[SEARCH](toString$i(O));
    },
    // `RegExp.prototype[@@search]` method
    // https://tc39.es/ecma262/#sec-regexp.prototype-@@search
    function(string) {
      var rx = anObject$z(this);
      var S = toString$i(string);
      var res = maybeCallNative(nativeSearch, rx, S);
      if (res.done) return res.value;
      var previousLastIndex = rx.lastIndex;
      if (!sameValue$1(previousLastIndex, 0)) rx.lastIndex = 0;
      var result = regExpExec$1(rx, S);
      if (!sameValue$1(rx.lastIndex, previousLastIndex)) rx.lastIndex = previousLastIndex;
      return result === null ? -1 : result.index;
    }
  ];
});
var call$F = functionCall;
var uncurryThis$R = functionUncurryThis;
var fixRegExpWellKnownSymbolLogic = fixRegexpWellKnownSymbolLogic;
var anObject$y = anObject$1i;
var isNullOrUndefined$7 = isNullOrUndefined$j;
var requireObjectCoercible$6 = requireObjectCoercible$q;
var speciesConstructor = speciesConstructor$4;
var advanceStringIndex = advanceStringIndex$4;
var toLength$3 = toLength$d;
var toString$h = toString$J;
var getMethod$b = getMethod$l;
var regExpExec = regexpExecAbstract;
var stickyHelpers = regexpStickyHelpers;
var fails$o = fails$1z;
var UNSUPPORTED_Y = stickyHelpers.UNSUPPORTED_Y;
var MAX_UINT32 = 4294967295;
var min$5 = Math.min;
var push$f = uncurryThis$R([].push);
var stringSlice$9 = uncurryThis$R("".slice);
var SPLIT_WORKS_WITH_OVERWRITTEN_EXEC = !fails$o(function() {
  var re = /(?:)/;
  var originalExec = re.exec;
  re.exec = function() {
    return originalExec.apply(this, arguments);
  };
  var result = "ab".split(re);
  return result.length !== 2 || result[0] !== "a" || result[1] !== "b";
});
var BUGGY = "abbc".split(/(b)*/)[1] === "c" || // eslint-disable-next-line regexp/no-empty-group -- required for testing
"test".split(/(?:)/, -1).length !== 4 || "ab".split(/(?:ab)*/).length !== 2 || ".".split(/(.?)(.?)/).length !== 4 || // eslint-disable-next-line regexp/no-empty-capturing-group, regexp/no-empty-group -- required for testing
".".split(/()()/).length > 1 || "".split(/.?/).length;
fixRegExpWellKnownSymbolLogic("split", function(SPLIT, nativeSplit, maybeCallNative) {
  var internalSplit = "0".split(void 0, 0).length ? function(separator, limit) {
    return separator === void 0 && limit === 0 ? [] : call$F(nativeSplit, this, separator, limit);
  } : nativeSplit;
  return [
    // `String.prototype.split` method
    // https://tc39.es/ecma262/#sec-string.prototype.split
    function split2(separator, limit) {
      var O = requireObjectCoercible$6(this);
      var splitter = isNullOrUndefined$7(separator) ? void 0 : getMethod$b(separator, SPLIT);
      return splitter ? call$F(splitter, separator, O, limit) : call$F(internalSplit, toString$h(O), separator, limit);
    },
    // `RegExp.prototype[@@split]` method
    // https://tc39.es/ecma262/#sec-regexp.prototype-@@split
    //
    // NOTE: This cannot be properly polyfilled in engines that don't support
    // the 'y' flag.
    function(string, limit) {
      var rx = anObject$y(this);
      var S = toString$h(string);
      if (!BUGGY) {
        var res = maybeCallNative(internalSplit, rx, S, limit, internalSplit !== nativeSplit);
        if (res.done) return res.value;
      }
      var C = speciesConstructor(rx, RegExp);
      var unicodeMatching = rx.unicode;
      var flags = (rx.ignoreCase ? "i" : "") + (rx.multiline ? "m" : "") + (rx.unicode ? "u" : "") + (UNSUPPORTED_Y ? "g" : "y");
      var splitter = new C(UNSUPPORTED_Y ? "^(?:" + rx.source + ")" : rx, flags);
      var lim = limit === void 0 ? MAX_UINT32 : limit >>> 0;
      if (lim === 0) return [];
      if (S.length === 0) return regExpExec(splitter, S) === null ? [S] : [];
      var p = 0;
      var q = 0;
      var A = [];
      while (q < S.length) {
        splitter.lastIndex = UNSUPPORTED_Y ? 0 : q;
        var z = regExpExec(splitter, UNSUPPORTED_Y ? stringSlice$9(S, q) : S);
        var e;
        if (z === null || (e = min$5(toLength$3(splitter.lastIndex + (UNSUPPORTED_Y ? q : 0)), S.length)) === p) {
          q = advanceStringIndex(S, q, unicodeMatching);
        } else {
          push$f(A, stringSlice$9(S, p, q));
          if (A.length === lim) return A;
          for (var i = 1; i <= z.length - 1; i++) {
            push$f(A, z[i]);
            if (A.length === lim) return A;
          }
          q = p = e;
        }
      }
      push$f(A, stringSlice$9(S, p));
      return A;
    }
  ];
}, BUGGY || !SPLIT_WORKS_WITH_OVERWRITTEN_EXEC, UNSUPPORTED_Y);
var $$2O = _export;
var uncurryThis$Q = functionUncurryThisClause;
var getOwnPropertyDescriptor$4 = objectGetOwnPropertyDescriptor.f;
var toLength$2 = toLength$d;
var toString$g = toString$J;
var notARegExp = notARegexp;
var requireObjectCoercible$5 = requireObjectCoercible$q;
var correctIsRegExpLogic = correctIsRegexpLogic;
var stringSlice$8 = uncurryThis$Q("".slice);
var min$4 = Math.min;
var CORRECT_IS_REGEXP_LOGIC = correctIsRegExpLogic("startsWith");
var MDN_POLYFILL_BUG = !CORRECT_IS_REGEXP_LOGIC && !!function() {
  var descriptor = getOwnPropertyDescriptor$4(String.prototype, "startsWith");
  return descriptor && !descriptor.writable;
}();
$$2O({
  target: "String",
  proto: true,
  forced: !MDN_POLYFILL_BUG && !CORRECT_IS_REGEXP_LOGIC
}, {
  startsWith: function startsWith(searchString) {
    var that = toString$g(requireObjectCoercible$5(this));
    notARegExp(searchString);
    var index = toLength$2(min$4(arguments.length > 1 ? arguments[1] : void 0, that.length));
    var search = toString$g(searchString);
    return stringSlice$8(that, index, index + search.length) === search;
  }
});
var $$2N = _export;
var uncurryThis$P = functionUncurryThis;
var requireObjectCoercible$4 = requireObjectCoercible$q;
var toIntegerOrInfinity$5 = toIntegerOrInfinity$p;
var toString$f = toString$J;
var stringSlice$7 = uncurryThis$P("".slice);
var max$1 = Math.max;
var min$3 = Math.min;
var FORCED$4 = !"".substr || "ab".substr(-1) !== "b";
$$2N({
  target: "String",
  proto: true,
  forced: FORCED$4
}, {
  substr: function substr(start2, length) {
    var that = toString$f(requireObjectCoercible$4(this));
    var size3 = that.length;
    var intStart = toIntegerOrInfinity$5(start2);
    var intLength, intEnd;
    if (intStart === Infinity) intStart = 0;
    if (intStart < 0) intStart = max$1(size3 + intStart, 0);
    intLength = length === void 0 ? size3 : toIntegerOrInfinity$5(length);
    if (intLength <= 0 || intLength === Infinity) return "";
    intEnd = min$3(intStart + intLength, size3);
    return intStart >= intEnd ? "" : stringSlice$7(that, intStart, intEnd);
  }
});
var $$2M = _export;
var call$E = functionCall;
var uncurryThis$O = functionUncurryThis;
var requireObjectCoercible$3 = requireObjectCoercible$q;
var toString$e = toString$J;
var fails$n = fails$1z;
var $Array$3 = Array;
var charAt$b = uncurryThis$O("".charAt);
var charCodeAt$3 = uncurryThis$O("".charCodeAt);
var join$5 = uncurryThis$O([].join);
var $toWellFormed = "".toWellFormed;
var REPLACEMENT_CHARACTER = "";
var TO_STRING_CONVERSION_BUG = $toWellFormed && fails$n(function() {
  return call$E($toWellFormed, 1) !== "1";
});
$$2M({
  target: "String",
  proto: true,
  forced: TO_STRING_CONVERSION_BUG
}, {
  toWellFormed: function toWellFormed() {
    var S = toString$e(requireObjectCoercible$3(this));
    if (TO_STRING_CONVERSION_BUG) return call$E($toWellFormed, S);
    var length = S.length;
    var result = $Array$3(length);
    for (var i = 0; i < length; i++) {
      var charCode = charCodeAt$3(S, i);
      if ((charCode & 63488) !== 55296) result[i] = charAt$b(S, i);
      else if (charCode >= 56320 || i + 1 >= length || (charCodeAt$3(S, i + 1) & 64512) !== 56320) result[i] = REPLACEMENT_CHARACTER;
      else {
        result[i] = charAt$b(S, i);
        result[++i] = charAt$b(S, i);
      }
    }
    return join$5(result, "");
  }
});
var PROPER_FUNCTION_NAME = functionName.PROPER;
var fails$m = fails$1z;
var whitespaces$2 = whitespaces$6;
var non = "";
var stringTrimForced = function(METHOD_NAME) {
  return fails$m(function() {
    return !!whitespaces$2[METHOD_NAME]() || non[METHOD_NAME]() !== non || PROPER_FUNCTION_NAME && whitespaces$2[METHOD_NAME].name !== METHOD_NAME;
  });
};
var $$2L = _export;
var $trim = stringTrim.trim;
var forcedStringTrimMethod$2 = stringTrimForced;
$$2L({
  target: "String",
  proto: true,
  forced: forcedStringTrimMethod$2("trim")
}, {
  trim: function trim2() {
    return $trim(this);
  }
});
var $trimEnd = stringTrim.end;
var forcedStringTrimMethod$1 = stringTrimForced;
var stringTrimEnd = forcedStringTrimMethod$1("trimEnd") ? function trimEnd() {
  return $trimEnd(this);
} : "".trimEnd;
var $$2K = _export;
var trimEnd$1 = stringTrimEnd;
$$2K({
  target: "String",
  proto: true,
  name: "trimEnd",
  forced: "".trimRight !== trimEnd$1
}, {
  trimRight: trimEnd$1
});
var $$2J = _export;
var trimEnd2 = stringTrimEnd;
$$2J({
  target: "String",
  proto: true,
  name: "trimEnd",
  forced: "".trimEnd !== trimEnd2
}, {
  trimEnd: trimEnd2
});
var $trimStart = stringTrim.start;
var forcedStringTrimMethod = stringTrimForced;
var stringTrimStart = forcedStringTrimMethod("trimStart") ? function trimStart() {
  return $trimStart(this);
} : "".trimStart;
var $$2I = _export;
var trimStart$1 = stringTrimStart;
$$2I({
  target: "String",
  proto: true,
  name: "trimStart",
  forced: "".trimLeft !== trimStart$1
}, {
  trimLeft: trimStart$1
});
var $$2H = _export;
var trimStart2 = stringTrimStart;
$$2H({
  target: "String",
  proto: true,
  name: "trimStart",
  forced: "".trimStart !== trimStart2
}, {
  trimStart: trimStart2
});
var uncurryThis$N = functionUncurryThis;
var requireObjectCoercible$2 = requireObjectCoercible$q;
var toString$d = toString$J;
var quot$1 = /"/g;
var replace$4 = uncurryThis$N("".replace);
var createHtml = function(string, tag, attribute, value) {
  var S = toString$d(requireObjectCoercible$2(string));
  var p1 = "<" + tag;
  if (attribute !== "") p1 += " " + attribute + '="' + replace$4(toString$d(value), quot$1, "&quot;") + '"';
  return p1 + ">" + S + "</" + tag + ">";
};
var fails$l = fails$1z;
var stringHtmlForced = function(METHOD_NAME) {
  return fails$l(function() {
    var test2 = ""[METHOD_NAME]('"');
    return test2 !== test2.toLowerCase() || test2.split('"').length > 3;
  });
};
var $$2G = _export;
var createHTML$c = createHtml;
var forcedStringHTMLMethod$c = stringHtmlForced;
$$2G({
  target: "String",
  proto: true,
  forced: forcedStringHTMLMethod$c("anchor")
}, {
  anchor: function anchor(name) {
    return createHTML$c(this, "a", "name", name);
  }
});
var $$2F = _export;
var createHTML$b = createHtml;
var forcedStringHTMLMethod$b = stringHtmlForced;
$$2F({
  target: "String",
  proto: true,
  forced: forcedStringHTMLMethod$b("big")
}, {
  big: function big() {
    return createHTML$b(this, "big", "", "");
  }
});
var $$2E = _export;
var createHTML$a = createHtml;
var forcedStringHTMLMethod$a = stringHtmlForced;
$$2E({
  target: "String",
  proto: true,
  forced: forcedStringHTMLMethod$a("blink")
}, {
  blink: function blink() {
    return createHTML$a(this, "blink", "", "");
  }
});
var $$2D = _export;
var createHTML$9 = createHtml;
var forcedStringHTMLMethod$9 = stringHtmlForced;
$$2D({
  target: "String",
  proto: true,
  forced: forcedStringHTMLMethod$9("bold")
}, {
  bold: function bold() {
    return createHTML$9(this, "b", "", "");
  }
});
var $$2C = _export;
var createHTML$8 = createHtml;
var forcedStringHTMLMethod$8 = stringHtmlForced;
$$2C({
  target: "String",
  proto: true,
  forced: forcedStringHTMLMethod$8("fixed")
}, {
  fixed: function fixed() {
    return createHTML$8(this, "tt", "", "");
  }
});
var $$2B = _export;
var createHTML$7 = createHtml;
var forcedStringHTMLMethod$7 = stringHtmlForced;
$$2B({
  target: "String",
  proto: true,
  forced: forcedStringHTMLMethod$7("fontcolor")
}, {
  fontcolor: function fontcolor(color) {
    return createHTML$7(this, "font", "color", color);
  }
});
var $$2A = _export;
var createHTML$6 = createHtml;
var forcedStringHTMLMethod$6 = stringHtmlForced;
$$2A({
  target: "String",
  proto: true,
  forced: forcedStringHTMLMethod$6("fontsize")
}, {
  fontsize: function fontsize(size3) {
    return createHTML$6(this, "font", "size", size3);
  }
});
var $$2z = _export;
var createHTML$5 = createHtml;
var forcedStringHTMLMethod$5 = stringHtmlForced;
$$2z({
  target: "String",
  proto: true,
  forced: forcedStringHTMLMethod$5("italics")
}, {
  italics: function italics() {
    return createHTML$5(this, "i", "", "");
  }
});
var $$2y = _export;
var createHTML$4 = createHtml;
var forcedStringHTMLMethod$4 = stringHtmlForced;
$$2y({
  target: "String",
  proto: true,
  forced: forcedStringHTMLMethod$4("link")
}, {
  link: function link(url) {
    return createHTML$4(this, "a", "href", url);
  }
});
var $$2x = _export;
var createHTML$3 = createHtml;
var forcedStringHTMLMethod$3 = stringHtmlForced;
$$2x({
  target: "String",
  proto: true,
  forced: forcedStringHTMLMethod$3("small")
}, {
  small: function small() {
    return createHTML$3(this, "small", "", "");
  }
});
var $$2w = _export;
var createHTML$2 = createHtml;
var forcedStringHTMLMethod$2 = stringHtmlForced;
$$2w({
  target: "String",
  proto: true,
  forced: forcedStringHTMLMethod$2("strike")
}, {
  strike: function strike() {
    return createHTML$2(this, "strike", "", "");
  }
});
var $$2v = _export;
var createHTML$1 = createHtml;
var forcedStringHTMLMethod$1 = stringHtmlForced;
$$2v({
  target: "String",
  proto: true,
  forced: forcedStringHTMLMethod$1("sub")
}, {
  sub: function sub() {
    return createHTML$1(this, "sub", "", "");
  }
});
var $$2u = _export;
var createHTML = createHtml;
var forcedStringHTMLMethod = stringHtmlForced;
$$2u({
  target: "String",
  proto: true,
  forced: forcedStringHTMLMethod("sup")
}, {
  sup: function sup() {
    return createHTML(this, "sup", "", "");
  }
});
var typedArrayConstructor = { exports: {} };
var globalThis$A = globalThis_1;
var fails$k = fails$1z;
var checkCorrectnessOfIteration = checkCorrectnessOfIteration$4;
var NATIVE_ARRAY_BUFFER_VIEWS$1 = arrayBufferViewCore.NATIVE_ARRAY_BUFFER_VIEWS;
var ArrayBuffer$2 = globalThis$A.ArrayBuffer;
var Int8Array$3 = globalThis$A.Int8Array;
var typedArrayConstructorsRequireWrappers = !NATIVE_ARRAY_BUFFER_VIEWS$1 || !fails$k(function() {
  Int8Array$3(1);
}) || !fails$k(function() {
  new Int8Array$3(-1);
}) || !checkCorrectnessOfIteration(function(iterable) {
  new Int8Array$3();
  new Int8Array$3(null);
  new Int8Array$3(1.5);
  new Int8Array$3(iterable);
}, true) || fails$k(function() {
  return new Int8Array$3(new ArrayBuffer$2(2), 1, void 0).length !== 1;
});
var toPositiveInteger$2 = toPositiveInteger$5;
var $RangeError$5 = RangeError;
var toOffset$2 = function(it, BYTES) {
  var offset = toPositiveInteger$2(it);
  if (offset % BYTES) throw new $RangeError$5("Wrong offset");
  return offset;
};
var round = Math.round;
var toUint8Clamped$2 = function(it) {
  var value = round(it);
  return value < 0 ? 0 : value > 255 ? 255 : value & 255;
};
var classof$7 = classof$q;
var isBigIntArray$3 = function(it) {
  var klass = classof$7(it);
  return klass === "BigInt64Array" || klass === "BigUint64Array";
};
var toPrimitive = toPrimitive$4;
var $TypeError$j = TypeError;
var toBigInt$4 = function(argument) {
  var prim = toPrimitive(argument, "number");
  if (typeof prim == "number") throw new $TypeError$j("Can't convert number to bigint");
  return BigInt(prim);
};
var bind$j = functionBindContext;
var call$D = functionCall;
var aConstructor$1 = aConstructor$4;
var toObject$a = toObject$E;
var lengthOfArrayLike$c = lengthOfArrayLike$B;
var getIterator$4 = getIterator$7;
var getIteratorMethod$4 = getIteratorMethod$9;
var isArrayIteratorMethod = isArrayIteratorMethod$3;
var isBigIntArray$2 = isBigIntArray$3;
var aTypedArrayConstructor$2 = arrayBufferViewCore.aTypedArrayConstructor;
var toBigInt$3 = toBigInt$4;
var typedArrayFrom$2 = function from4(source) {
  var C = aConstructor$1(this);
  var O = toObject$a(source);
  var argumentsLength = arguments.length;
  var mapfn = argumentsLength > 1 ? arguments[1] : void 0;
  var mapping = mapfn !== void 0;
  var iteratorMethod = getIteratorMethod$4(O);
  var i, length, result, thisIsBigIntArray, value, step, iterator, next11;
  if (iteratorMethod && !isArrayIteratorMethod(iteratorMethod)) {
    iterator = getIterator$4(O, iteratorMethod);
    next11 = iterator.next;
    O = [];
    while (!(step = call$D(next11, iterator)).done) {
      O.push(step.value);
    }
  }
  if (mapping && argumentsLength > 2) {
    mapfn = bind$j(mapfn, arguments[2]);
  }
  length = lengthOfArrayLike$c(O);
  result = new (aTypedArrayConstructor$2(C))(length);
  thisIsBigIntArray = isBigIntArray$2(result);
  for (i = 0; length > i; i++) {
    value = mapping ? mapfn(O[i], i) : O[i];
    result[i] = thisIsBigIntArray ? toBigInt$3(value) : +value;
  }
  return result;
};
var $$2t = _export;
var globalThis$z = globalThis_1;
var call$C = functionCall;
var DESCRIPTORS$g = descriptors;
var TYPED_ARRAYS_CONSTRUCTORS_REQUIRES_WRAPPERS$2 = typedArrayConstructorsRequireWrappers;
var ArrayBufferViewCore$z = arrayBufferViewCore;
var ArrayBufferModule = arrayBuffer;
var anInstance$9 = anInstance$f;
var createPropertyDescriptor$4 = createPropertyDescriptor$d;
var createNonEnumerableProperty$6 = createNonEnumerableProperty$j;
var isIntegralNumber = isIntegralNumber$3;
var toLength$1 = toLength$d;
var toIndex$1 = toIndex$5;
var toOffset$1 = toOffset$2;
var toUint8Clamped$1 = toUint8Clamped$2;
var toPropertyKey$1 = toPropertyKey$9;
var hasOwn$f = hasOwnProperty_1;
var classof$6 = classof$q;
var isObject$h = isObject$O;
var isSymbol$2 = isSymbol$8;
var create$8 = objectCreate$1;
var isPrototypeOf$2 = objectIsPrototypeOf;
var setPrototypeOf$1 = objectSetPrototypeOf$1;
var getOwnPropertyNames$1 = objectGetOwnPropertyNames.f;
var typedArrayFrom$1 = typedArrayFrom$2;
var forEach$4 = arrayIteration.forEach;
var setSpecies$1 = setSpecies$7;
var defineBuiltInAccessor$b = defineBuiltInAccessor$p;
var definePropertyModule = objectDefineProperty;
var getOwnPropertyDescriptorModule = objectGetOwnPropertyDescriptor;
var arrayFromConstructorAndList$6 = arrayFromConstructorAndList$8;
var InternalStateModule$d = internalState;
var inheritIfRequired$1 = inheritIfRequired$7;
var getInternalState$7 = InternalStateModule$d.get;
var setInternalState$e = InternalStateModule$d.set;
var enforceInternalState$1 = InternalStateModule$d.enforce;
var nativeDefineProperty = definePropertyModule.f;
var nativeGetOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;
var RangeError$2 = globalThis$z.RangeError;
var ArrayBuffer$1 = ArrayBufferModule.ArrayBuffer;
var ArrayBufferPrototype = ArrayBuffer$1.prototype;
var DataView$1 = ArrayBufferModule.DataView;
var NATIVE_ARRAY_BUFFER_VIEWS = ArrayBufferViewCore$z.NATIVE_ARRAY_BUFFER_VIEWS;
var TYPED_ARRAY_TAG = ArrayBufferViewCore$z.TYPED_ARRAY_TAG;
var TypedArray = ArrayBufferViewCore$z.TypedArray;
var TypedArrayPrototype$1 = ArrayBufferViewCore$z.TypedArrayPrototype;
var isTypedArray = ArrayBufferViewCore$z.isTypedArray;
var BYTES_PER_ELEMENT = "BYTES_PER_ELEMENT";
var WRONG_LENGTH = "Wrong length";
var addGetter$1 = function(it, key) {
  defineBuiltInAccessor$b(it, key, {
    configurable: true,
    get: function() {
      return getInternalState$7(this)[key];
    }
  });
};
var isArrayBuffer = function(it) {
  var klass;
  return isPrototypeOf$2(ArrayBufferPrototype, it) || (klass = classof$6(it)) === "ArrayBuffer" || klass === "SharedArrayBuffer";
};
var isTypedArrayIndex = function(target, key) {
  return isTypedArray(target) && !isSymbol$2(key) && key in target && isIntegralNumber(+key) && key >= 0;
};
var wrappedGetOwnPropertyDescriptor = function getOwnPropertyDescriptor5(target, key) {
  key = toPropertyKey$1(key);
  return isTypedArrayIndex(target, key) ? createPropertyDescriptor$4(2, target[key]) : nativeGetOwnPropertyDescriptor(target, key);
};
var wrappedDefineProperty = function defineProperty5(target, key, descriptor) {
  key = toPropertyKey$1(key);
  if (isTypedArrayIndex(target, key) && isObject$h(descriptor) && hasOwn$f(descriptor, "value") && !hasOwn$f(descriptor, "get") && !hasOwn$f(descriptor, "set") && !descriptor.configurable && (!hasOwn$f(descriptor, "writable") || descriptor.writable) && (!hasOwn$f(descriptor, "enumerable") || descriptor.enumerable)) {
    target[key] = descriptor.value;
    return target;
  }
  return nativeDefineProperty(target, key, descriptor);
};
if (DESCRIPTORS$g) {
  if (!NATIVE_ARRAY_BUFFER_VIEWS) {
    getOwnPropertyDescriptorModule.f = wrappedGetOwnPropertyDescriptor;
    definePropertyModule.f = wrappedDefineProperty;
    addGetter$1(TypedArrayPrototype$1, "buffer");
    addGetter$1(TypedArrayPrototype$1, "byteOffset");
    addGetter$1(TypedArrayPrototype$1, "byteLength");
    addGetter$1(TypedArrayPrototype$1, "length");
  }
  $$2t({
    target: "Object",
    stat: true,
    forced: !NATIVE_ARRAY_BUFFER_VIEWS
  }, {
    getOwnPropertyDescriptor: wrappedGetOwnPropertyDescriptor,
    defineProperty: wrappedDefineProperty
  });
  typedArrayConstructor.exports = function(TYPE, wrapper2, CLAMPED) {
    var BYTES = TYPE.match(/\d+/)[0] / 8;
    var CONSTRUCTOR_NAME = TYPE + (CLAMPED ? "Clamped" : "") + "Array";
    var GETTER = "get" + TYPE;
    var SETTER = "set" + TYPE;
    var NativeTypedArrayConstructor = globalThis$z[CONSTRUCTOR_NAME];
    var TypedArrayConstructor = NativeTypedArrayConstructor;
    var TypedArrayConstructorPrototype = TypedArrayConstructor && TypedArrayConstructor.prototype;
    var exported = {};
    var getter = function(that, index) {
      var data2 = getInternalState$7(that);
      return data2.view[GETTER](index * BYTES + data2.byteOffset, true);
    };
    var setter = function(that, index, value) {
      var data2 = getInternalState$7(that);
      data2.view[SETTER](index * BYTES + data2.byteOffset, CLAMPED ? toUint8Clamped$1(value) : value, true);
    };
    var addElement = function(that, index) {
      nativeDefineProperty(that, index, {
        get: function() {
          return getter(this, index);
        },
        set: function(value) {
          return setter(this, index, value);
        },
        enumerable: true
      });
    };
    if (!NATIVE_ARRAY_BUFFER_VIEWS) {
      TypedArrayConstructor = wrapper2(function(that, data2, offset, $length) {
        anInstance$9(that, TypedArrayConstructorPrototype);
        var index = 0;
        var byteOffset = 0;
        var buffer2, byteLength2, length;
        if (!isObject$h(data2)) {
          length = toIndex$1(data2);
          byteLength2 = length * BYTES;
          buffer2 = new ArrayBuffer$1(byteLength2);
        } else if (isArrayBuffer(data2)) {
          buffer2 = data2;
          byteOffset = toOffset$1(offset, BYTES);
          var $len = data2.byteLength;
          if ($length === void 0) {
            if ($len % BYTES) throw new RangeError$2(WRONG_LENGTH);
            byteLength2 = $len - byteOffset;
            if (byteLength2 < 0) throw new RangeError$2(WRONG_LENGTH);
          } else {
            byteLength2 = toLength$1($length) * BYTES;
            if (byteLength2 + byteOffset > $len) throw new RangeError$2(WRONG_LENGTH);
          }
          length = byteLength2 / BYTES;
        } else if (isTypedArray(data2)) {
          return arrayFromConstructorAndList$6(TypedArrayConstructor, data2);
        } else {
          return call$C(typedArrayFrom$1, TypedArrayConstructor, data2);
        }
        setInternalState$e(that, {
          buffer: buffer2,
          byteOffset,
          byteLength: byteLength2,
          length,
          view: new DataView$1(buffer2)
        });
        while (index < length) addElement(that, index++);
      });
      if (setPrototypeOf$1) setPrototypeOf$1(TypedArrayConstructor, TypedArray);
      TypedArrayConstructorPrototype = TypedArrayConstructor.prototype = create$8(TypedArrayPrototype$1);
    } else if (TYPED_ARRAYS_CONSTRUCTORS_REQUIRES_WRAPPERS$2) {
      TypedArrayConstructor = wrapper2(function(dummy, data2, typedArrayOffset, $length) {
        anInstance$9(dummy, TypedArrayConstructorPrototype);
        return inheritIfRequired$1(function() {
          if (!isObject$h(data2)) return new NativeTypedArrayConstructor(toIndex$1(data2));
          if (isArrayBuffer(data2)) return $length !== void 0 ? new NativeTypedArrayConstructor(data2, toOffset$1(typedArrayOffset, BYTES), $length) : typedArrayOffset !== void 0 ? new NativeTypedArrayConstructor(data2, toOffset$1(typedArrayOffset, BYTES)) : new NativeTypedArrayConstructor(data2);
          if (isTypedArray(data2)) return arrayFromConstructorAndList$6(TypedArrayConstructor, data2);
          return call$C(typedArrayFrom$1, TypedArrayConstructor, data2);
        }(), dummy, TypedArrayConstructor);
      });
      if (setPrototypeOf$1) setPrototypeOf$1(TypedArrayConstructor, TypedArray);
      forEach$4(getOwnPropertyNames$1(NativeTypedArrayConstructor), function(key) {
        if (!(key in TypedArrayConstructor)) {
          createNonEnumerableProperty$6(TypedArrayConstructor, key, NativeTypedArrayConstructor[key]);
        }
      });
      TypedArrayConstructor.prototype = TypedArrayConstructorPrototype;
    }
    if (TypedArrayConstructorPrototype.constructor !== TypedArrayConstructor) {
      createNonEnumerableProperty$6(TypedArrayConstructorPrototype, "constructor", TypedArrayConstructor);
    }
    enforceInternalState$1(TypedArrayConstructorPrototype).TypedArrayConstructor = TypedArrayConstructor;
    if (TYPED_ARRAY_TAG) {
      createNonEnumerableProperty$6(TypedArrayConstructorPrototype, TYPED_ARRAY_TAG, CONSTRUCTOR_NAME);
    }
    var FORCED2 = TypedArrayConstructor !== NativeTypedArrayConstructor;
    exported[CONSTRUCTOR_NAME] = TypedArrayConstructor;
    $$2t({
      global: true,
      constructor: true,
      forced: FORCED2,
      sham: !NATIVE_ARRAY_BUFFER_VIEWS
    }, exported);
    if (!(BYTES_PER_ELEMENT in TypedArrayConstructor)) {
      createNonEnumerableProperty$6(TypedArrayConstructor, BYTES_PER_ELEMENT, BYTES);
    }
    if (!(BYTES_PER_ELEMENT in TypedArrayConstructorPrototype)) {
      createNonEnumerableProperty$6(TypedArrayConstructorPrototype, BYTES_PER_ELEMENT, BYTES);
    }
    setSpecies$1(CONSTRUCTOR_NAME);
  };
} else typedArrayConstructor.exports = function() {
};
var typedArrayConstructorExports = typedArrayConstructor.exports;
var createTypedArrayConstructor$8 = typedArrayConstructorExports;
createTypedArrayConstructor$8("Float32", function(init) {
  return function Float32Array(data2, byteOffset, length) {
    return init(this, data2, byteOffset, length);
  };
});
var createTypedArrayConstructor$7 = typedArrayConstructorExports;
createTypedArrayConstructor$7("Float64", function(init) {
  return function Float64Array(data2, byteOffset, length) {
    return init(this, data2, byteOffset, length);
  };
});
var createTypedArrayConstructor$6 = typedArrayConstructorExports;
createTypedArrayConstructor$6("Int8", function(init) {
  return function Int8Array2(data2, byteOffset, length) {
    return init(this, data2, byteOffset, length);
  };
});
var createTypedArrayConstructor$5 = typedArrayConstructorExports;
createTypedArrayConstructor$5("Int16", function(init) {
  return function Int16Array(data2, byteOffset, length) {
    return init(this, data2, byteOffset, length);
  };
});
var createTypedArrayConstructor$4 = typedArrayConstructorExports;
createTypedArrayConstructor$4("Int32", function(init) {
  return function Int32Array2(data2, byteOffset, length) {
    return init(this, data2, byteOffset, length);
  };
});
var createTypedArrayConstructor$3 = typedArrayConstructorExports;
createTypedArrayConstructor$3("Uint8", function(init) {
  return function Uint8Array2(data2, byteOffset, length) {
    return init(this, data2, byteOffset, length);
  };
});
var createTypedArrayConstructor$2 = typedArrayConstructorExports;
createTypedArrayConstructor$2("Uint8", function(init) {
  return function Uint8ClampedArray2(data2, byteOffset, length) {
    return init(this, data2, byteOffset, length);
  };
}, true);
var createTypedArrayConstructor$1 = typedArrayConstructorExports;
createTypedArrayConstructor$1("Uint16", function(init) {
  return function Uint16Array2(data2, byteOffset, length) {
    return init(this, data2, byteOffset, length);
  };
});
var createTypedArrayConstructor = typedArrayConstructorExports;
createTypedArrayConstructor("Uint32", function(init) {
  return function Uint32Array(data2, byteOffset, length) {
    return init(this, data2, byteOffset, length);
  };
});
var ArrayBufferViewCore$y = arrayBufferViewCore;
var lengthOfArrayLike$b = lengthOfArrayLike$B;
var toIntegerOrInfinity$4 = toIntegerOrInfinity$p;
var aTypedArray$w = ArrayBufferViewCore$y.aTypedArray;
var exportTypedArrayMethod$x = ArrayBufferViewCore$y.exportTypedArrayMethod;
exportTypedArrayMethod$x("at", function at3(index) {
  var O = aTypedArray$w(this);
  var len = lengthOfArrayLike$b(O);
  var relativeIndex = toIntegerOrInfinity$4(index);
  var k = relativeIndex >= 0 ? relativeIndex : len + relativeIndex;
  return k < 0 || k >= len ? void 0 : O[k];
});
var uncurryThis$M = functionUncurryThis;
var ArrayBufferViewCore$x = arrayBufferViewCore;
var $ArrayCopyWithin = arrayCopyWithin;
var u$ArrayCopyWithin = uncurryThis$M($ArrayCopyWithin);
var aTypedArray$v = ArrayBufferViewCore$x.aTypedArray;
var exportTypedArrayMethod$w = ArrayBufferViewCore$x.exportTypedArrayMethod;
exportTypedArrayMethod$w("copyWithin", function copyWithin3(target, start2) {
  return u$ArrayCopyWithin(aTypedArray$v(this), target, start2, arguments.length > 2 ? arguments[2] : void 0);
});
var ArrayBufferViewCore$w = arrayBufferViewCore;
var $every$1 = arrayIteration.every;
var aTypedArray$u = ArrayBufferViewCore$w.aTypedArray;
var exportTypedArrayMethod$v = ArrayBufferViewCore$w.exportTypedArrayMethod;
exportTypedArrayMethod$v("every", function every3(callbackfn) {
  return $every$1(aTypedArray$u(this), callbackfn, arguments.length > 1 ? arguments[1] : void 0);
});
var ArrayBufferViewCore$v = arrayBufferViewCore;
var $fill = arrayFill$1;
var toBigInt$2 = toBigInt$4;
var classof$5 = classof$q;
var call$B = functionCall;
var uncurryThis$L = functionUncurryThis;
var fails$j = fails$1z;
var aTypedArray$t = ArrayBufferViewCore$v.aTypedArray;
var exportTypedArrayMethod$u = ArrayBufferViewCore$v.exportTypedArrayMethod;
var slice$3 = uncurryThis$L("".slice);
var CONVERSION_BUG = fails$j(function() {
  var count = 0;
  new Int8Array(2).fill({
    valueOf: function() {
      return count++;
    }
  });
  return count !== 1;
});
exportTypedArrayMethod$u("fill", function fill3(value) {
  var length = arguments.length;
  aTypedArray$t(this);
  var actualValue = slice$3(classof$5(this), 0, 3) === "Big" ? toBigInt$2(value) : +value;
  return call$B($fill, this, actualValue, length > 1 ? arguments[1] : void 0, length > 2 ? arguments[2] : void 0);
}, CONVERSION_BUG);
var arrayFromConstructorAndList$5 = arrayFromConstructorAndList$8;
var getTypedArrayConstructor$9 = arrayBufferViewCore.getTypedArrayConstructor;
var typedArrayFromSameTypeAndList = function(instance, list) {
  return arrayFromConstructorAndList$5(getTypedArrayConstructor$9(instance), list);
};
var ArrayBufferViewCore$u = arrayBufferViewCore;
var $filter = arrayIteration.filter;
var fromSameTypeAndList$2 = typedArrayFromSameTypeAndList;
var aTypedArray$s = ArrayBufferViewCore$u.aTypedArray;
var exportTypedArrayMethod$t = ArrayBufferViewCore$u.exportTypedArrayMethod;
exportTypedArrayMethod$t("filter", function filter3(callbackfn) {
  var list = $filter(aTypedArray$s(this), callbackfn, arguments.length > 1 ? arguments[1] : void 0);
  return fromSameTypeAndList$2(this, list);
});
var ArrayBufferViewCore$t = arrayBufferViewCore;
var $find$1 = arrayIteration.find;
var aTypedArray$r = ArrayBufferViewCore$t.aTypedArray;
var exportTypedArrayMethod$s = ArrayBufferViewCore$t.exportTypedArrayMethod;
exportTypedArrayMethod$s("find", function find3(predicate) {
  return $find$1(aTypedArray$r(this), predicate, arguments.length > 1 ? arguments[1] : void 0);
});
var ArrayBufferViewCore$s = arrayBufferViewCore;
var $findIndex = arrayIteration.findIndex;
var aTypedArray$q = ArrayBufferViewCore$s.aTypedArray;
var exportTypedArrayMethod$r = ArrayBufferViewCore$s.exportTypedArrayMethod;
exportTypedArrayMethod$r("findIndex", function findIndex2(predicate) {
  return $findIndex(aTypedArray$q(this), predicate, arguments.length > 1 ? arguments[1] : void 0);
});
var ArrayBufferViewCore$r = arrayBufferViewCore;
var $findLast = arrayIterationFromLast.findLast;
var aTypedArray$p = ArrayBufferViewCore$r.aTypedArray;
var exportTypedArrayMethod$q = ArrayBufferViewCore$r.exportTypedArrayMethod;
exportTypedArrayMethod$q("findLast", function findLast2(predicate) {
  return $findLast(aTypedArray$p(this), predicate, arguments.length > 1 ? arguments[1] : void 0);
});
var ArrayBufferViewCore$q = arrayBufferViewCore;
var $findLastIndex = arrayIterationFromLast.findLastIndex;
var aTypedArray$o = ArrayBufferViewCore$q.aTypedArray;
var exportTypedArrayMethod$p = ArrayBufferViewCore$q.exportTypedArrayMethod;
exportTypedArrayMethod$p("findLastIndex", function findLastIndex2(predicate) {
  return $findLastIndex(aTypedArray$o(this), predicate, arguments.length > 1 ? arguments[1] : void 0);
});
var ArrayBufferViewCore$p = arrayBufferViewCore;
var $forEach$1 = arrayIteration.forEach;
var aTypedArray$n = ArrayBufferViewCore$p.aTypedArray;
var exportTypedArrayMethod$o = ArrayBufferViewCore$p.exportTypedArrayMethod;
exportTypedArrayMethod$o("forEach", function forEach3(callbackfn) {
  $forEach$1(aTypedArray$n(this), callbackfn, arguments.length > 1 ? arguments[1] : void 0);
});
var TYPED_ARRAYS_CONSTRUCTORS_REQUIRES_WRAPPERS$1 = typedArrayConstructorsRequireWrappers;
var exportTypedArrayStaticMethod$2 = arrayBufferViewCore.exportTypedArrayStaticMethod;
var typedArrayFrom = typedArrayFrom$2;
exportTypedArrayStaticMethod$2("from", typedArrayFrom, TYPED_ARRAYS_CONSTRUCTORS_REQUIRES_WRAPPERS$1);
var ArrayBufferViewCore$o = arrayBufferViewCore;
var $includes = arrayIncludes.includes;
var aTypedArray$m = ArrayBufferViewCore$o.aTypedArray;
var exportTypedArrayMethod$n = ArrayBufferViewCore$o.exportTypedArrayMethod;
exportTypedArrayMethod$n("includes", function includes3(searchElement) {
  return $includes(aTypedArray$m(this), searchElement, arguments.length > 1 ? arguments[1] : void 0);
});
var ArrayBufferViewCore$n = arrayBufferViewCore;
var $indexOf = arrayIncludes.indexOf;
var aTypedArray$l = ArrayBufferViewCore$n.aTypedArray;
var exportTypedArrayMethod$m = ArrayBufferViewCore$n.exportTypedArrayMethod;
exportTypedArrayMethod$m("indexOf", function indexOf3(searchElement) {
  return $indexOf(aTypedArray$l(this), searchElement, arguments.length > 1 ? arguments[1] : void 0);
});
var globalThis$y = globalThis_1;
var fails$i = fails$1z;
var uncurryThis$K = functionUncurryThis;
var ArrayBufferViewCore$m = arrayBufferViewCore;
var ArrayIterators = es_array_iterator;
var wellKnownSymbol$k = wellKnownSymbol$S;
var ITERATOR$4 = wellKnownSymbol$k("iterator");
var Uint8Array$5 = globalThis$y.Uint8Array;
var arrayValues = uncurryThis$K(ArrayIterators.values);
var arrayKeys = uncurryThis$K(ArrayIterators.keys);
var arrayEntries = uncurryThis$K(ArrayIterators.entries);
var aTypedArray$k = ArrayBufferViewCore$m.aTypedArray;
var exportTypedArrayMethod$l = ArrayBufferViewCore$m.exportTypedArrayMethod;
var TypedArrayPrototype = Uint8Array$5 && Uint8Array$5.prototype;
var GENERIC = !fails$i(function() {
  TypedArrayPrototype[ITERATOR$4].call([1]);
});
var ITERATOR_IS_VALUES = !!TypedArrayPrototype && TypedArrayPrototype.values && TypedArrayPrototype[ITERATOR$4] === TypedArrayPrototype.values && TypedArrayPrototype.values.name === "values";
var typedArrayValues = function values2() {
  return arrayValues(aTypedArray$k(this));
};
exportTypedArrayMethod$l("entries", function entries2() {
  return arrayEntries(aTypedArray$k(this));
}, GENERIC);
exportTypedArrayMethod$l("keys", function keys4() {
  return arrayKeys(aTypedArray$k(this));
}, GENERIC);
exportTypedArrayMethod$l("values", typedArrayValues, GENERIC || !ITERATOR_IS_VALUES, {
  name: "values"
});
exportTypedArrayMethod$l(ITERATOR$4, typedArrayValues, GENERIC || !ITERATOR_IS_VALUES, {
  name: "values"
});
var ArrayBufferViewCore$l = arrayBufferViewCore;
var uncurryThis$J = functionUncurryThis;
var aTypedArray$j = ArrayBufferViewCore$l.aTypedArray;
var exportTypedArrayMethod$k = ArrayBufferViewCore$l.exportTypedArrayMethod;
var $join = uncurryThis$J([].join);
exportTypedArrayMethod$k("join", function join2(separator) {
  return $join(aTypedArray$j(this), separator);
});
var ArrayBufferViewCore$k = arrayBufferViewCore;
var apply$5 = functionApply$1;
var $lastIndexOf = arrayLastIndexOf;
var aTypedArray$i = ArrayBufferViewCore$k.aTypedArray;
var exportTypedArrayMethod$j = ArrayBufferViewCore$k.exportTypedArrayMethod;
exportTypedArrayMethod$j("lastIndexOf", function lastIndexOf3(searchElement) {
  var length = arguments.length;
  return apply$5($lastIndexOf, aTypedArray$i(this), length > 1 ? [searchElement, arguments[1]] : [searchElement]);
});
var ArrayBufferViewCore$j = arrayBufferViewCore;
var $map = arrayIteration.map;
var aTypedArray$h = ArrayBufferViewCore$j.aTypedArray;
var getTypedArrayConstructor$8 = ArrayBufferViewCore$j.getTypedArrayConstructor;
var exportTypedArrayMethod$i = ArrayBufferViewCore$j.exportTypedArrayMethod;
exportTypedArrayMethod$i("map", function map3(mapfn) {
  return $map(aTypedArray$h(this), mapfn, arguments.length > 1 ? arguments[1] : void 0, function(O, length) {
    return new (getTypedArrayConstructor$8(O))(length);
  });
});
var ArrayBufferViewCore$i = arrayBufferViewCore;
var TYPED_ARRAYS_CONSTRUCTORS_REQUIRES_WRAPPERS = typedArrayConstructorsRequireWrappers;
var aTypedArrayConstructor$1 = ArrayBufferViewCore$i.aTypedArrayConstructor;
var exportTypedArrayStaticMethod$1 = ArrayBufferViewCore$i.exportTypedArrayStaticMethod;
exportTypedArrayStaticMethod$1("of", function of2() {
  var index = 0;
  var length = arguments.length;
  var result = new (aTypedArrayConstructor$1(this))(length);
  while (length > index) result[index] = arguments[index++];
  return result;
}, TYPED_ARRAYS_CONSTRUCTORS_REQUIRES_WRAPPERS);
var ArrayBufferViewCore$h = arrayBufferViewCore;
var $reduce = arrayReduce.left;
var aTypedArray$g = ArrayBufferViewCore$h.aTypedArray;
var exportTypedArrayMethod$h = ArrayBufferViewCore$h.exportTypedArrayMethod;
exportTypedArrayMethod$h("reduce", function reduce3(callbackfn) {
  var length = arguments.length;
  return $reduce(aTypedArray$g(this), callbackfn, length, length > 1 ? arguments[1] : void 0);
});
var ArrayBufferViewCore$g = arrayBufferViewCore;
var $reduceRight = arrayReduce.right;
var aTypedArray$f = ArrayBufferViewCore$g.aTypedArray;
var exportTypedArrayMethod$g = ArrayBufferViewCore$g.exportTypedArrayMethod;
exportTypedArrayMethod$g("reduceRight", function reduceRight2(callbackfn) {
  var length = arguments.length;
  return $reduceRight(aTypedArray$f(this), callbackfn, length, length > 1 ? arguments[1] : void 0);
});
var ArrayBufferViewCore$f = arrayBufferViewCore;
var aTypedArray$e = ArrayBufferViewCore$f.aTypedArray;
var exportTypedArrayMethod$f = ArrayBufferViewCore$f.exportTypedArrayMethod;
var floor$2 = Math.floor;
exportTypedArrayMethod$f("reverse", function reverse3() {
  var that = this;
  var length = aTypedArray$e(that).length;
  var middle = floor$2(length / 2);
  var index = 0;
  var value;
  while (index < middle) {
    value = that[index];
    that[index++] = that[--length];
    that[length] = value;
  }
  return that;
});
var globalThis$x = globalThis_1;
var call$A = functionCall;
var ArrayBufferViewCore$e = arrayBufferViewCore;
var lengthOfArrayLike$a = lengthOfArrayLike$B;
var toOffset = toOffset$2;
var toIndexedObject$1 = toObject$E;
var fails$h = fails$1z;
var RangeError$1 = globalThis$x.RangeError;
var Int8Array$2 = globalThis$x.Int8Array;
var Int8ArrayPrototype = Int8Array$2 && Int8Array$2.prototype;
var $set = Int8ArrayPrototype && Int8ArrayPrototype.set;
var aTypedArray$d = ArrayBufferViewCore$e.aTypedArray;
var exportTypedArrayMethod$e = ArrayBufferViewCore$e.exportTypedArrayMethod;
var WORKS_WITH_OBJECTS_AND_GENERIC_ON_TYPED_ARRAYS = !fails$h(function() {
  var array = new Uint8ClampedArray(2);
  call$A($set, array, {
    length: 1,
    0: 3
  }, 1);
  return array[1] !== 3;
});
var TO_OBJECT_BUG = WORKS_WITH_OBJECTS_AND_GENERIC_ON_TYPED_ARRAYS && ArrayBufferViewCore$e.NATIVE_ARRAY_BUFFER_VIEWS && fails$h(function() {
  var array = new Int8Array$2(2);
  array.set(1);
  array.set("2", 1);
  return array[0] !== 0 || array[1] !== 2;
});
exportTypedArrayMethod$e("set", function set(arrayLike) {
  aTypedArray$d(this);
  var offset = toOffset(arguments.length > 1 ? arguments[1] : void 0, 1);
  var src = toIndexedObject$1(arrayLike);
  if (WORKS_WITH_OBJECTS_AND_GENERIC_ON_TYPED_ARRAYS) return call$A($set, this, src, offset);
  var length = this.length;
  var len = lengthOfArrayLike$a(src);
  var index = 0;
  if (len + offset > length) throw new RangeError$1("Wrong length");
  while (index < len) this[offset + index] = src[index++];
}, !WORKS_WITH_OBJECTS_AND_GENERIC_ON_TYPED_ARRAYS || TO_OBJECT_BUG);
var ArrayBufferViewCore$d = arrayBufferViewCore;
var fails$g = fails$1z;
var arraySlice$3 = arraySlice$a;
var aTypedArray$c = ArrayBufferViewCore$d.aTypedArray;
var getTypedArrayConstructor$7 = ArrayBufferViewCore$d.getTypedArrayConstructor;
var exportTypedArrayMethod$d = ArrayBufferViewCore$d.exportTypedArrayMethod;
var FORCED$3 = fails$g(function() {
  new Int8Array(1).slice();
});
exportTypedArrayMethod$d("slice", function slice3(start2, end) {
  var list = arraySlice$3(aTypedArray$c(this), start2, end);
  var C = getTypedArrayConstructor$7(this);
  var index = 0;
  var length = list.length;
  var result = new C(length);
  while (length > index) result[index] = list[index++];
  return result;
}, FORCED$3);
var ArrayBufferViewCore$c = arrayBufferViewCore;
var $some$1 = arrayIteration.some;
var aTypedArray$b = ArrayBufferViewCore$c.aTypedArray;
var exportTypedArrayMethod$c = ArrayBufferViewCore$c.exportTypedArrayMethod;
exportTypedArrayMethod$c("some", function some3(callbackfn) {
  return $some$1(aTypedArray$b(this), callbackfn, arguments.length > 1 ? arguments[1] : void 0);
});
var globalThis$w = globalThis_1;
var uncurryThis$I = functionUncurryThisClause;
var fails$f = fails$1z;
var aCallable$l = aCallable$Q;
var internalSort = arraySort$1;
var ArrayBufferViewCore$b = arrayBufferViewCore;
var FF = environmentFfVersion;
var IE_OR_EDGE = environmentIsIeOrEdge;
var V8 = environmentV8Version;
var WEBKIT = environmentWebkitVersion;
var aTypedArray$a = ArrayBufferViewCore$b.aTypedArray;
var exportTypedArrayMethod$b = ArrayBufferViewCore$b.exportTypedArrayMethod;
var Uint16Array = globalThis$w.Uint16Array;
var nativeSort = Uint16Array && uncurryThis$I(Uint16Array.prototype.sort);
var ACCEPT_INCORRECT_ARGUMENTS = !!nativeSort && !(fails$f(function() {
  nativeSort(new Uint16Array(2), null);
}) && fails$f(function() {
  nativeSort(new Uint16Array(2), {});
}));
var STABLE_SORT = !!nativeSort && !fails$f(function() {
  if (V8) return V8 < 74;
  if (FF) return FF < 67;
  if (IE_OR_EDGE) return true;
  if (WEBKIT) return WEBKIT < 602;
  var array = new Uint16Array(516);
  var expected = Array(516);
  var index, mod;
  for (index = 0; index < 516; index++) {
    mod = index % 4;
    array[index] = 515 - index;
    expected[index] = index - 2 * mod + 3;
  }
  nativeSort(array, function(a, b) {
    return (a / 4 | 0) - (b / 4 | 0);
  });
  for (index = 0; index < 516; index++) {
    if (array[index] !== expected[index]) return true;
  }
});
var getSortCompare = function(comparefn) {
  return function(x, y) {
    if (comparefn !== void 0) return +comparefn(x, y) || 0;
    if (y !== y) return -1;
    if (x !== x) return 1;
    if (x === 0 && y === 0) return 1 / x > 0 && 1 / y < 0 ? 1 : -1;
    return x > y;
  };
};
exportTypedArrayMethod$b("sort", function sort2(comparefn) {
  if (comparefn !== void 0) aCallable$l(comparefn);
  if (STABLE_SORT) return nativeSort(this, comparefn);
  return internalSort(aTypedArray$a(this), getSortCompare(comparefn));
}, !STABLE_SORT || ACCEPT_INCORRECT_ARGUMENTS);
var ArrayBufferViewCore$a = arrayBufferViewCore;
var toLength = toLength$d;
var toAbsoluteIndex$1 = toAbsoluteIndex$a;
var aTypedArray$9 = ArrayBufferViewCore$a.aTypedArray;
var getTypedArrayConstructor$6 = ArrayBufferViewCore$a.getTypedArrayConstructor;
var exportTypedArrayMethod$a = ArrayBufferViewCore$a.exportTypedArrayMethod;
exportTypedArrayMethod$a("subarray", function subarray(begin, end) {
  var O = aTypedArray$9(this);
  var length = O.length;
  var beginIndex = toAbsoluteIndex$1(begin, length);
  var C = getTypedArrayConstructor$6(O);
  return new C(O.buffer, O.byteOffset + beginIndex * O.BYTES_PER_ELEMENT, toLength((end === void 0 ? length : toAbsoluteIndex$1(end, length)) - beginIndex));
});
var globalThis$v = globalThis_1;
var apply$4 = functionApply$1;
var ArrayBufferViewCore$9 = arrayBufferViewCore;
var fails$e = fails$1z;
var arraySlice$2 = arraySlice$a;
var Int8Array$1 = globalThis$v.Int8Array;
var aTypedArray$8 = ArrayBufferViewCore$9.aTypedArray;
var exportTypedArrayMethod$9 = ArrayBufferViewCore$9.exportTypedArrayMethod;
var $toLocaleString = [].toLocaleString;
var TO_LOCALE_STRING_BUG = !!Int8Array$1 && fails$e(function() {
  $toLocaleString.call(new Int8Array$1(1));
});
var FORCED$2 = fails$e(function() {
  return [1, 2].toLocaleString() !== new Int8Array$1([1, 2]).toLocaleString();
}) || !fails$e(function() {
  Int8Array$1.prototype.toLocaleString.call([1, 2]);
});
exportTypedArrayMethod$9("toLocaleString", function toLocaleString() {
  return apply$4($toLocaleString, TO_LOCALE_STRING_BUG ? arraySlice$2(aTypedArray$8(this)) : aTypedArray$8(this), arraySlice$2(arguments));
}, FORCED$2);
var arrayToReversed = arrayToReversed$2;
var ArrayBufferViewCore$8 = arrayBufferViewCore;
var aTypedArray$7 = ArrayBufferViewCore$8.aTypedArray;
var exportTypedArrayMethod$8 = ArrayBufferViewCore$8.exportTypedArrayMethod;
var getTypedArrayConstructor$5 = ArrayBufferViewCore$8.getTypedArrayConstructor;
exportTypedArrayMethod$8("toReversed", function toReversed2() {
  return arrayToReversed(aTypedArray$7(this), getTypedArrayConstructor$5(this));
});
var ArrayBufferViewCore$7 = arrayBufferViewCore;
var uncurryThis$H = functionUncurryThis;
var aCallable$k = aCallable$Q;
var arrayFromConstructorAndList$4 = arrayFromConstructorAndList$8;
var aTypedArray$6 = ArrayBufferViewCore$7.aTypedArray;
var getTypedArrayConstructor$4 = ArrayBufferViewCore$7.getTypedArrayConstructor;
var exportTypedArrayMethod$7 = ArrayBufferViewCore$7.exportTypedArrayMethod;
var sort3 = uncurryThis$H(ArrayBufferViewCore$7.TypedArrayPrototype.sort);
exportTypedArrayMethod$7("toSorted", function toSorted2(compareFn) {
  if (compareFn !== void 0) aCallable$k(compareFn);
  var O = aTypedArray$6(this);
  var A = arrayFromConstructorAndList$4(getTypedArrayConstructor$4(O), O);
  return sort3(A, compareFn);
});
var exportTypedArrayMethod$6 = arrayBufferViewCore.exportTypedArrayMethod;
var fails$d = fails$1z;
var globalThis$u = globalThis_1;
var uncurryThis$G = functionUncurryThis;
var Uint8Array$4 = globalThis$u.Uint8Array;
var Uint8ArrayPrototype = Uint8Array$4 && Uint8Array$4.prototype || {};
var arrayToString = [].toString;
var join$4 = uncurryThis$G([].join);
if (fails$d(function() {
  arrayToString.call({});
})) {
  arrayToString = function toString7() {
    return join$4(this);
  };
}
var IS_NOT_ARRAY_METHOD = Uint8ArrayPrototype.toString !== arrayToString;
exportTypedArrayMethod$6("toString", arrayToString, IS_NOT_ARRAY_METHOD);
var arrayWith = arrayWith$2;
var ArrayBufferViewCore$6 = arrayBufferViewCore;
var isBigIntArray$1 = isBigIntArray$3;
var toIntegerOrInfinity$3 = toIntegerOrInfinity$p;
var toBigInt$1 = toBigInt$4;
var aTypedArray$5 = ArrayBufferViewCore$6.aTypedArray;
var getTypedArrayConstructor$3 = ArrayBufferViewCore$6.getTypedArrayConstructor;
var exportTypedArrayMethod$5 = ArrayBufferViewCore$6.exportTypedArrayMethod;
var PROPER_ORDER = !!function() {
  try {
    new Int8Array(1)["with"](2, {
      valueOf: function() {
        throw 8;
      }
    });
  } catch (error3) {
    return error3 === 8;
  }
}();
exportTypedArrayMethod$5("with", {
  "with": function(index, value) {
    var O = aTypedArray$5(this);
    var relativeIndex = toIntegerOrInfinity$3(index);
    var actualValue = isBigIntArray$1(O) ? toBigInt$1(value) : +value;
    return arrayWith(O, getTypedArrayConstructor$3(O), relativeIndex, actualValue);
  }
}["with"], !PROPER_ORDER);
var $$2s = _export;
var uncurryThis$F = functionUncurryThis;
var toString$c = toString$J;
var fromCharCode$5 = String.fromCharCode;
var charAt$a = uncurryThis$F("".charAt);
var exec$a = uncurryThis$F(/./.exec);
var stringSlice$6 = uncurryThis$F("".slice);
var hex2 = /^[\da-f]{2}$/i;
var hex4 = /^[\da-f]{4}$/i;
$$2s({
  global: true
}, {
  unescape: function unescape(string) {
    var str = toString$c(string);
    var result = "";
    var length = str.length;
    var index = 0;
    var chr, part;
    while (index < length) {
      chr = charAt$a(str, index++);
      if (chr === "%") {
        if (charAt$a(str, index) === "u") {
          part = stringSlice$6(str, index + 1, index + 5);
          if (exec$a(hex4, part)) {
            result += fromCharCode$5(parseInt(part, 16));
            index += 5;
            continue;
          }
        } else {
          part = stringSlice$6(str, index, index + 2);
          if (exec$a(hex2, part)) {
            result += fromCharCode$5(parseInt(part, 16));
            index += 2;
            continue;
          }
        }
      }
      result += chr;
    }
    return result;
  }
});
var uncurryThis$E = functionUncurryThis;
var defineBuiltIns$7 = defineBuiltIns$b;
var getWeakData = internalMetadataExports.getWeakData;
var anInstance$8 = anInstance$f;
var anObject$x = anObject$1i;
var isNullOrUndefined$6 = isNullOrUndefined$j;
var isObject$g = isObject$O;
var iterate$o = iterate$H;
var ArrayIterationModule = arrayIteration;
var hasOwn$e = hasOwnProperty_1;
var InternalStateModule$c = internalState;
var setInternalState$d = InternalStateModule$c.set;
var internalStateGetterFor = InternalStateModule$c.getterFor;
var find$1 = ArrayIterationModule.find;
var findIndex3 = ArrayIterationModule.findIndex;
var splice$2 = uncurryThis$E([].splice);
var id = 0;
var uncaughtFrozenStore = function(state) {
  return state.frozen || (state.frozen = new UncaughtFrozenStore());
};
var UncaughtFrozenStore = function() {
  this.entries = [];
};
var findUncaughtFrozen = function(store2, key) {
  return find$1(store2.entries, function(it) {
    return it[0] === key;
  });
};
UncaughtFrozenStore.prototype = {
  get: function(key) {
    var entry = findUncaughtFrozen(this, key);
    if (entry) return entry[1];
  },
  has: function(key) {
    return !!findUncaughtFrozen(this, key);
  },
  set: function(key, value) {
    var entry = findUncaughtFrozen(this, key);
    if (entry) entry[1] = value;
    else this.entries.push([key, value]);
  },
  "delete": function(key) {
    var index = findIndex3(this.entries, function(it) {
      return it[0] === key;
    });
    if (~index) splice$2(this.entries, index, 1);
    return !!~index;
  }
};
var collectionWeak$2 = {
  getConstructor: function(wrapper2, CONSTRUCTOR_NAME, IS_MAP, ADDER) {
    var Constructor2 = wrapper2(function(that, iterable) {
      anInstance$8(that, Prototype2);
      setInternalState$d(that, {
        type: CONSTRUCTOR_NAME,
        id: id++,
        frozen: null
      });
      if (!isNullOrUndefined$6(iterable)) iterate$o(iterable, that[ADDER], {
        that,
        AS_ENTRIES: IS_MAP
      });
    });
    var Prototype2 = Constructor2.prototype;
    var getInternalState2 = internalStateGetterFor(CONSTRUCTOR_NAME);
    var define = function(that, key, value) {
      var state = getInternalState2(that);
      var data2 = getWeakData(anObject$x(key), true);
      if (data2 === true) uncaughtFrozenStore(state).set(key, value);
      else data2[state.id] = value;
      return that;
    };
    defineBuiltIns$7(Prototype2, {
      // `{ WeakMap, WeakSet }.prototype.delete(key)` methods
      // https://tc39.es/ecma262/#sec-weakmap.prototype.delete
      // https://tc39.es/ecma262/#sec-weakset.prototype.delete
      "delete": function(key) {
        var state = getInternalState2(this);
        if (!isObject$g(key)) return false;
        var data2 = getWeakData(key);
        if (data2 === true) return uncaughtFrozenStore(state)["delete"](key);
        return data2 && hasOwn$e(data2, state.id) && delete data2[state.id];
      },
      // `{ WeakMap, WeakSet }.prototype.has(key)` methods
      // https://tc39.es/ecma262/#sec-weakmap.prototype.has
      // https://tc39.es/ecma262/#sec-weakset.prototype.has
      has: function has4(key) {
        var state = getInternalState2(this);
        if (!isObject$g(key)) return false;
        var data2 = getWeakData(key);
        if (data2 === true) return uncaughtFrozenStore(state).has(key);
        return data2 && hasOwn$e(data2, state.id);
      }
    });
    defineBuiltIns$7(Prototype2, IS_MAP ? {
      // `WeakMap.prototype.get(key)` method
      // https://tc39.es/ecma262/#sec-weakmap.prototype.get
      get: function get3(key) {
        var state = getInternalState2(this);
        if (isObject$g(key)) {
          var data2 = getWeakData(key);
          if (data2 === true) return uncaughtFrozenStore(state).get(key);
          if (data2) return data2[state.id];
        }
      },
      // `WeakMap.prototype.set(key, value)` method
      // https://tc39.es/ecma262/#sec-weakmap.prototype.set
      set: function set4(key, value) {
        return define(this, key, value);
      }
    } : {
      // `WeakSet.prototype.add(value)` method
      // https://tc39.es/ecma262/#sec-weakset.prototype.add
      add: function add2(value) {
        return define(this, value, true);
      }
    });
    return Constructor2;
  }
};
var FREEZING$2 = freezing;
var globalThis$t = globalThis_1;
var uncurryThis$D = functionUncurryThis;
var defineBuiltIns$6 = defineBuiltIns$b;
var InternalMetadataModule = internalMetadataExports;
var collection$1 = collection$4;
var collectionWeak$1 = collectionWeak$2;
var isObject$f = isObject$O;
var enforceInternalState = internalState.enforce;
var fails$c = fails$1z;
var NATIVE_WEAK_MAP = weakMapBasicDetection;
var $Object$3 = Object;
var isArray$2 = Array.isArray;
var isExtensible3 = $Object$3.isExtensible;
var isFrozen$2 = $Object$3.isFrozen;
var isSealed2 = $Object$3.isSealed;
var freeze$2 = $Object$3.freeze;
var seal2 = $Object$3.seal;
var IS_IE11 = !globalThis$t.ActiveXObject && "ActiveXObject" in globalThis$t;
var InternalWeakMap;
var wrapper = function(init) {
  return function WeakMap2() {
    return init(this, arguments.length ? arguments[0] : void 0);
  };
};
var $WeakMap = collection$1("WeakMap", wrapper, collectionWeak$1);
var WeakMapPrototype$1 = $WeakMap.prototype;
var nativeSet = uncurryThis$D(WeakMapPrototype$1.set);
var hasMSEdgeFreezingBug = function() {
  return FREEZING$2 && fails$c(function() {
    var frozenArray = freeze$2([]);
    nativeSet(new $WeakMap(), frozenArray, 1);
    return !isFrozen$2(frozenArray);
  });
};
if (NATIVE_WEAK_MAP) {
  if (IS_IE11) {
    InternalWeakMap = collectionWeak$1.getConstructor(wrapper, "WeakMap", true);
    InternalMetadataModule.enable();
    var nativeDelete = uncurryThis$D(WeakMapPrototype$1["delete"]);
    var nativeHas = uncurryThis$D(WeakMapPrototype$1.has);
    var nativeGet = uncurryThis$D(WeakMapPrototype$1.get);
    defineBuiltIns$6(WeakMapPrototype$1, {
      "delete": function(key) {
        if (isObject$f(key) && !isExtensible3(key)) {
          var state = enforceInternalState(this);
          if (!state.frozen) state.frozen = new InternalWeakMap();
          return nativeDelete(this, key) || state.frozen["delete"](key);
        }
        return nativeDelete(this, key);
      },
      has: function has4(key) {
        if (isObject$f(key) && !isExtensible3(key)) {
          var state = enforceInternalState(this);
          if (!state.frozen) state.frozen = new InternalWeakMap();
          return nativeHas(this, key) || state.frozen.has(key);
        }
        return nativeHas(this, key);
      },
      get: function get3(key) {
        if (isObject$f(key) && !isExtensible3(key)) {
          var state = enforceInternalState(this);
          if (!state.frozen) state.frozen = new InternalWeakMap();
          return nativeHas(this, key) ? nativeGet(this, key) : state.frozen.get(key);
        }
        return nativeGet(this, key);
      },
      set: function set4(key, value) {
        if (isObject$f(key) && !isExtensible3(key)) {
          var state = enforceInternalState(this);
          if (!state.frozen) state.frozen = new InternalWeakMap();
          nativeHas(this, key) ? nativeSet(this, key, value) : state.frozen.set(key, value);
        } else nativeSet(this, key, value);
        return this;
      }
    });
  } else if (hasMSEdgeFreezingBug()) {
    defineBuiltIns$6(WeakMapPrototype$1, {
      set: function set4(key, value) {
        var arrayIntegrityLevel;
        if (isArray$2(key)) {
          if (isFrozen$2(key)) arrayIntegrityLevel = freeze$2;
          else if (isSealed2(key)) arrayIntegrityLevel = seal2;
        }
        nativeSet(this, key, value);
        if (arrayIntegrityLevel) arrayIntegrityLevel(key);
        return this;
      }
    });
  }
}
var collection = collection$4;
var collectionWeak = collectionWeak$2;
collection("WeakSet", function(init) {
  return function WeakSet2() {
    return init(this, arguments.length ? arguments[0] : void 0);
  };
}, collectionWeak);
var $$2r = _export;
var globalThis$s = globalThis_1;
var isPrototypeOf$1 = objectIsPrototypeOf;
var getPrototypeOf$5 = objectGetPrototypeOf$2;
var setPrototypeOf2 = objectSetPrototypeOf$1;
var copyConstructorProperties = copyConstructorProperties$7;
var create$7 = objectCreate$1;
var createNonEnumerableProperty$5 = createNonEnumerableProperty$j;
var createPropertyDescriptor$3 = createPropertyDescriptor$d;
var installErrorStack = errorStackInstall;
var normalizeStringArgument$2 = normalizeStringArgument$6;
var wellKnownSymbol$j = wellKnownSymbol$S;
var fails$b = fails$1z;
var NativeSuppressedError = globalThis$s.SuppressedError;
var TO_STRING_TAG$4 = wellKnownSymbol$j("toStringTag");
var $Error$1 = Error;
var WRONG_ARITY$4 = !!NativeSuppressedError && NativeSuppressedError.length !== 3;
var EXTRA_ARGS_SUPPORT = !!NativeSuppressedError && fails$b(function() {
  return new NativeSuppressedError(1, 2, 3, {
    cause: 4
  }).cause === 4;
});
var PATCH = WRONG_ARITY$4 || EXTRA_ARGS_SUPPORT;
var $SuppressedError = function SuppressedError(error3, suppressed, message) {
  var isInstance = isPrototypeOf$1(SuppressedErrorPrototype, this);
  var that;
  if (setPrototypeOf2) {
    that = PATCH && (!isInstance || getPrototypeOf$5(this) === SuppressedErrorPrototype) ? new NativeSuppressedError() : setPrototypeOf2(new $Error$1(), isInstance ? getPrototypeOf$5(this) : SuppressedErrorPrototype);
  } else {
    that = isInstance ? this : create$7(SuppressedErrorPrototype);
    createNonEnumerableProperty$5(that, TO_STRING_TAG$4, "Error");
  }
  if (message !== void 0) createNonEnumerableProperty$5(that, "message", normalizeStringArgument$2(message));
  installErrorStack(that, $SuppressedError, that.stack, 1);
  createNonEnumerableProperty$5(that, "error", error3);
  createNonEnumerableProperty$5(that, "suppressed", suppressed);
  return that;
};
if (setPrototypeOf2) setPrototypeOf2($SuppressedError, $Error$1);
else copyConstructorProperties($SuppressedError, $Error$1, {
  name: true
});
var SuppressedErrorPrototype = $SuppressedError.prototype = PATCH ? NativeSuppressedError.prototype : create$7($Error$1.prototype, {
  constructor: createPropertyDescriptor$3(1, $SuppressedError),
  message: createPropertyDescriptor$3(1, ""),
  name: createPropertyDescriptor$3(1, "SuppressedError")
});
if (PATCH && true) SuppressedErrorPrototype.constructor = $SuppressedError;
$$2r({
  global: true,
  constructor: true,
  arity: 3,
  forced: PATCH
}, {
  SuppressedError: $SuppressedError
});
var globalThis$r = globalThis_1;
var shared$2 = sharedStoreExports;
var isCallable$b = isCallable$I;
var getPrototypeOf$4 = objectGetPrototypeOf$2;
var defineBuiltIn$a = defineBuiltIn$u;
var wellKnownSymbol$i = wellKnownSymbol$S;
var USE_FUNCTION_CONSTRUCTOR = "USE_FUNCTION_CONSTRUCTOR";
var ASYNC_ITERATOR$3 = wellKnownSymbol$i("asyncIterator");
var AsyncIterator = globalThis$r.AsyncIterator;
var PassedAsyncIteratorPrototype = shared$2.AsyncIteratorPrototype;
var AsyncIteratorPrototype$5, prototype;
if (PassedAsyncIteratorPrototype) {
  AsyncIteratorPrototype$5 = PassedAsyncIteratorPrototype;
} else if (isCallable$b(AsyncIterator)) {
  AsyncIteratorPrototype$5 = AsyncIterator.prototype;
} else if (shared$2[USE_FUNCTION_CONSTRUCTOR] || globalThis$r[USE_FUNCTION_CONSTRUCTOR]) {
  try {
    prototype = getPrototypeOf$4(getPrototypeOf$4(getPrototypeOf$4(Function("return async function*(){}()")())));
    if (getPrototypeOf$4(prototype) === Object.prototype) AsyncIteratorPrototype$5 = prototype;
  } catch (error3) {
  }
}
if (!AsyncIteratorPrototype$5) AsyncIteratorPrototype$5 = {};
if (!isCallable$b(AsyncIteratorPrototype$5[ASYNC_ITERATOR$3])) {
  defineBuiltIn$a(AsyncIteratorPrototype$5, ASYNC_ITERATOR$3, function() {
    return this;
  });
}
var asyncIteratorPrototype = AsyncIteratorPrototype$5;
var call$z = functionCall;
var anObject$w = anObject$1i;
var create$6 = objectCreate$1;
var getMethod$a = getMethod$l;
var defineBuiltIns$5 = defineBuiltIns$b;
var InternalStateModule$b = internalState;
var getBuiltIn$w = getBuiltIn$Q;
var AsyncIteratorPrototype$4 = asyncIteratorPrototype;
var createIterResultObject$c = createIterResultObject$i;
var Promise$5 = getBuiltIn$w("Promise");
var ASYNC_FROM_SYNC_ITERATOR = "AsyncFromSyncIterator";
var setInternalState$c = InternalStateModule$b.set;
var getInternalState$6 = InternalStateModule$b.getterFor(ASYNC_FROM_SYNC_ITERATOR);
var asyncFromSyncIteratorContinuation = function(result, resolve2, reject2) {
  var done = result.done;
  Promise$5.resolve(result.value).then(function(value) {
    resolve2(createIterResultObject$c(value, done));
  }, reject2);
};
var AsyncFromSyncIterator$4 = function AsyncIterator2(iteratorRecord) {
  iteratorRecord.type = ASYNC_FROM_SYNC_ITERATOR;
  setInternalState$c(this, iteratorRecord);
};
AsyncFromSyncIterator$4.prototype = defineBuiltIns$5(create$6(AsyncIteratorPrototype$4), {
  next: function next3() {
    var state = getInternalState$6(this);
    return new Promise$5(function(resolve2, reject2) {
      var result = anObject$w(call$z(state.next, state.iterator));
      asyncFromSyncIteratorContinuation(result, resolve2, reject2);
    });
  },
  "return": function() {
    var iterator = getInternalState$6(this).iterator;
    return new Promise$5(function(resolve2, reject2) {
      var $return = getMethod$a(iterator, "return");
      if ($return === void 0) return resolve2(createIterResultObject$c(void 0, true));
      var result = anObject$w(call$z($return, iterator));
      asyncFromSyncIteratorContinuation(result, resolve2, reject2);
    });
  }
});
var asyncFromSyncIterator = AsyncFromSyncIterator$4;
var call$y = functionCall;
var AsyncFromSyncIterator$3 = asyncFromSyncIterator;
var anObject$v = anObject$1i;
var getIterator$3 = getIterator$7;
var getIteratorDirect$a = getIteratorDirect$o;
var getMethod$9 = getMethod$l;
var wellKnownSymbol$h = wellKnownSymbol$S;
var ASYNC_ITERATOR$2 = wellKnownSymbol$h("asyncIterator");
var getAsyncIterator$1 = function(it, usingIterator) {
  var method = arguments.length < 2 ? getMethod$9(it, ASYNC_ITERATOR$2) : usingIterator;
  return method ? anObject$v(call$y(method, it)) : new AsyncFromSyncIterator$3(getIteratorDirect$a(getIterator$3(it)));
};
var call$x = functionCall;
var getBuiltIn$v = getBuiltIn$Q;
var getMethod$8 = getMethod$l;
var asyncIteratorClose = function(iterator, method, argument, reject2) {
  try {
    var returnMethod = getMethod$8(iterator, "return");
    if (returnMethod) {
      return getBuiltIn$v("Promise").resolve(call$x(returnMethod, iterator)).then(function() {
        method(argument);
      }, function(error3) {
        reject2(error3);
      });
    }
  } catch (error22) {
    return reject2(error22);
  }
  method(argument);
};
var call$w = functionCall;
var aCallable$j = aCallable$Q;
var anObject$u = anObject$1i;
var isObject$e = isObject$O;
var doesNotExceedSafeInteger = doesNotExceedSafeInteger$7;
var getBuiltIn$u = getBuiltIn$Q;
var getIteratorDirect$9 = getIteratorDirect$o;
var closeAsyncIteration$4 = asyncIteratorClose;
var createMethod = function(TYPE) {
  var IS_TO_ARRAY = TYPE === 0;
  var IS_FOR_EACH = TYPE === 1;
  var IS_EVERY = TYPE === 2;
  var IS_SOME = TYPE === 3;
  return function(object, fn, target) {
    anObject$u(object);
    var MAPPING = fn !== void 0;
    if (MAPPING || !IS_TO_ARRAY) aCallable$j(fn);
    var record = getIteratorDirect$9(object);
    var Promise2 = getBuiltIn$u("Promise");
    var iterator = record.iterator;
    var next11 = record.next;
    var counter2 = 0;
    return new Promise2(function(resolve2, reject2) {
      var ifAbruptCloseAsyncIterator = function(error3) {
        closeAsyncIteration$4(iterator, reject2, error3, reject2);
      };
      var loop = function() {
        try {
          if (MAPPING) try {
            doesNotExceedSafeInteger(counter2);
          } catch (error5) {
            ifAbruptCloseAsyncIterator(error5);
          }
          Promise2.resolve(anObject$u(call$w(next11, iterator))).then(function(step) {
            try {
              if (anObject$u(step).done) {
                if (IS_TO_ARRAY) {
                  target.length = counter2;
                  resolve2(target);
                } else resolve2(IS_SOME ? false : IS_EVERY || void 0);
              } else {
                var value = step.value;
                try {
                  if (MAPPING) {
                    var result = fn(value, counter2);
                    var handler = function($result) {
                      if (IS_FOR_EACH) {
                        loop();
                      } else if (IS_EVERY) {
                        $result ? loop() : closeAsyncIteration$4(iterator, resolve2, false, reject2);
                      } else if (IS_TO_ARRAY) {
                        try {
                          target[counter2++] = $result;
                          loop();
                        } catch (error4) {
                          ifAbruptCloseAsyncIterator(error4);
                        }
                      } else {
                        $result ? closeAsyncIteration$4(iterator, resolve2, IS_SOME || value, reject2) : loop();
                      }
                    };
                    if (isObject$e(result)) Promise2.resolve(result).then(handler, ifAbruptCloseAsyncIterator);
                    else handler(result);
                  } else {
                    target[counter2++] = value;
                    loop();
                  }
                } catch (error3) {
                  ifAbruptCloseAsyncIterator(error3);
                }
              }
            } catch (error22) {
              reject2(error22);
            }
          }, reject2);
        } catch (error3) {
          reject2(error3);
        }
      };
      loop();
    });
  };
};
var asyncIteratorIteration = {
  toArray: createMethod(0),
  forEach: createMethod(1),
  every: createMethod(2),
  some: createMethod(3),
  find: createMethod(4)
};
var bind$i = functionBindContext;
var uncurryThis$C = functionUncurryThis;
var toObject$9 = toObject$E;
var isConstructor$4 = isConstructor$a;
var getAsyncIterator = getAsyncIterator$1;
var getIterator$2 = getIterator$7;
var getIteratorDirect$8 = getIteratorDirect$o;
var getIteratorMethod$3 = getIteratorMethod$9;
var getMethod$7 = getMethod$l;
var getBuiltIn$t = getBuiltIn$Q;
var getBuiltInPrototypeMethod = getBuiltInPrototypeMethod$2;
var wellKnownSymbol$g = wellKnownSymbol$S;
var AsyncFromSyncIterator$2 = asyncFromSyncIterator;
var toArray$1 = asyncIteratorIteration.toArray;
var ASYNC_ITERATOR$1 = wellKnownSymbol$g("asyncIterator");
var arrayIterator = uncurryThis$C(getBuiltInPrototypeMethod("Array", "values"));
var arrayIteratorNext = uncurryThis$C(arrayIterator([]).next);
var safeArrayIterator = function() {
  return new SafeArrayIterator(this);
};
var SafeArrayIterator = function(O) {
  this.iterator = arrayIterator(O);
};
SafeArrayIterator.prototype.next = function() {
  return arrayIteratorNext(this.iterator);
};
var arrayFromAsync$1 = function fromAsync(asyncItems) {
  var C = this;
  var argumentsLength = arguments.length;
  var mapfn = argumentsLength > 1 ? arguments[1] : void 0;
  var thisArg = argumentsLength > 2 ? arguments[2] : void 0;
  return new (getBuiltIn$t("Promise"))(function(resolve2) {
    var O = toObject$9(asyncItems);
    if (mapfn !== void 0) mapfn = bind$i(mapfn, thisArg);
    var usingAsyncIterator = getMethod$7(O, ASYNC_ITERATOR$1);
    var usingSyncIterator = usingAsyncIterator ? void 0 : getIteratorMethod$3(O) || safeArrayIterator;
    var A = isConstructor$4(C) ? new C() : [];
    var iterator = usingAsyncIterator ? getAsyncIterator(O, usingAsyncIterator) : new AsyncFromSyncIterator$2(getIteratorDirect$8(getIterator$2(O, usingSyncIterator)));
    resolve2(toArray$1(iterator, mapfn, A));
  });
};
var $$2q = _export;
var fromAsync2 = arrayFromAsync$1;
var fails$a = fails$1z;
var nativeFromAsync = Array.fromAsync;
var INCORRECT_CONSTRUCTURING = !nativeFromAsync || fails$a(function() {
  var counter2 = 0;
  nativeFromAsync.call(function() {
    counter2++;
    return [];
  }, {
    length: 0
  });
  return counter2 !== 1;
});
$$2q({
  target: "Array",
  stat: true,
  forced: INCORRECT_CONSTRUCTURING
}, {
  fromAsync: fromAsync2
});
var $$2p = _export;
var $filterReject$3 = arrayIteration.filterReject;
var addToUnscopables$8 = addToUnscopables$n;
$$2p({
  target: "Array",
  proto: true,
  forced: true
}, {
  filterOut: function filterOut(callbackfn) {
    return $filterReject$3(this, callbackfn, arguments.length > 1 ? arguments[1] : void 0);
  }
});
addToUnscopables$8("filterOut");
var $$2o = _export;
var $filterReject$2 = arrayIteration.filterReject;
var addToUnscopables$7 = addToUnscopables$n;
$$2o({
  target: "Array",
  proto: true,
  forced: true
}, {
  filterReject: function filterReject(callbackfn) {
    return $filterReject$2(this, callbackfn, arguments.length > 1 ? arguments[1] : void 0);
  }
});
addToUnscopables$7("filterReject");
var bind$h = functionBindContext;
var uncurryThis$B = functionUncurryThis;
var IndexedObject$1 = indexedObject;
var toObject$8 = toObject$E;
var toPropertyKey = toPropertyKey$9;
var lengthOfArrayLike$9 = lengthOfArrayLike$B;
var objectCreate = objectCreate$1;
var arrayFromConstructorAndList$3 = arrayFromConstructorAndList$8;
var $Array$2 = Array;
var push$e = uncurryThis$B([].push);
var arrayGroup = function($this, callbackfn, that, specificConstructor) {
  var O = toObject$8($this);
  var self2 = IndexedObject$1(O);
  var boundFunction = bind$h(callbackfn, that);
  var target = objectCreate(null);
  var length = lengthOfArrayLike$9(self2);
  var index = 0;
  var Constructor2, key, value;
  for (; length > index; index++) {
    value = self2[index];
    key = toPropertyKey(boundFunction(value, index, O));
    if (key in target) push$e(target[key], value);
    else target[key] = [value];
  }
  if (specificConstructor) {
    Constructor2 = specificConstructor(O);
    if (Constructor2 !== $Array$2) {
      for (key in target) target[key] = arrayFromConstructorAndList$3(Constructor2, target[key]);
    }
  }
  return target;
};
var $$2n = _export;
var $group$2 = arrayGroup;
var addToUnscopables$6 = addToUnscopables$n;
$$2n({
  target: "Array",
  proto: true
}, {
  group: function group(callbackfn) {
    var thisArg = arguments.length > 1 ? arguments[1] : void 0;
    return $group$2(this, callbackfn, thisArg);
  }
});
addToUnscopables$6("group");
var $$2m = _export;
var $group$1 = arrayGroup;
var arrayMethodIsStrict$1 = arrayMethodIsStrict$b;
var addToUnscopables$5 = addToUnscopables$n;
$$2m({
  target: "Array",
  proto: true,
  forced: !arrayMethodIsStrict$1("groupBy")
}, {
  groupBy: function groupBy3(callbackfn) {
    var thisArg = arguments.length > 1 ? arguments[1] : void 0;
    return $group$1(this, callbackfn, thisArg);
  }
});
addToUnscopables$5("groupBy");
var bind$g = functionBindContext;
var uncurryThis$A = functionUncurryThis;
var IndexedObject = indexedObject;
var toObject$7 = toObject$E;
var lengthOfArrayLike$8 = lengthOfArrayLike$B;
var MapHelpers$c = mapHelpers;
var Map$a = MapHelpers$c.Map;
var mapGet$1 = MapHelpers$c.get;
var mapHas$2 = MapHelpers$c.has;
var mapSet$2 = MapHelpers$c.set;
var push$d = uncurryThis$A([].push);
var arrayGroupToMap = function groupToMap(callbackfn) {
  var O = toObject$7(this);
  var self2 = IndexedObject(O);
  var boundFunction = bind$g(callbackfn, arguments.length > 1 ? arguments[1] : void 0);
  var map7 = new Map$a();
  var length = lengthOfArrayLike$8(self2);
  var index = 0;
  var key, value;
  for (; length > index; index++) {
    value = self2[index];
    key = boundFunction(value, index, O);
    if (mapHas$2(map7, key)) push$d(mapGet$1(map7, key), value);
    else mapSet$2(map7, key, [value]);
  }
  return map7;
};
var $$2l = _export;
var arrayMethodIsStrict = arrayMethodIsStrict$b;
var addToUnscopables$4 = addToUnscopables$n;
var $groupToMap$1 = arrayGroupToMap;
$$2l({
  target: "Array",
  proto: true,
  name: "groupToMap",
  forced: !arrayMethodIsStrict("groupByToMap")
}, {
  groupByToMap: $groupToMap$1
});
addToUnscopables$4("groupByToMap");
var $$2k = _export;
var addToUnscopables$3 = addToUnscopables$n;
var $groupToMap = arrayGroupToMap;
var IS_PURE$9 = isPure;
$$2k({
  target: "Array",
  proto: true,
  forced: IS_PURE$9
}, {
  groupToMap: $groupToMap
});
addToUnscopables$3("groupToMap");
var $$2j = _export;
var isArray$1 = isArray$b;
var isFrozen$1 = Object.isFrozen;
var isFrozenStringArray = function(array, allowUndefined) {
  if (!isFrozen$1 || !isArray$1(array) || !isFrozen$1(array)) return false;
  var index = 0;
  var length = array.length;
  var element;
  while (index < length) {
    element = array[index++];
    if (!(typeof element == "string" || allowUndefined && element === void 0)) {
      return false;
    }
  }
  return length !== 0;
};
$$2j({
  target: "Array",
  stat: true,
  sham: true,
  forced: true
}, {
  isTemplateObject: function isTemplateObject(value) {
    if (!isFrozenStringArray(value, true)) return false;
    var raw3 = value.raw;
    return raw3.length === value.length && isFrozenStringArray(raw3, false);
  }
});
var DESCRIPTORS$f = descriptors;
var addToUnscopables$2 = addToUnscopables$n;
var toObject$6 = toObject$E;
var lengthOfArrayLike$7 = lengthOfArrayLike$B;
var defineBuiltInAccessor$a = defineBuiltInAccessor$p;
if (DESCRIPTORS$f) {
  defineBuiltInAccessor$a(Array.prototype, "lastIndex", {
    configurable: true,
    get: function lastIndex() {
      var O = toObject$6(this);
      var len = lengthOfArrayLike$7(O);
      return len === 0 ? 0 : len - 1;
    }
  });
  addToUnscopables$2("lastIndex");
}
var DESCRIPTORS$e = descriptors;
var addToUnscopables$1 = addToUnscopables$n;
var toObject$5 = toObject$E;
var lengthOfArrayLike$6 = lengthOfArrayLike$B;
var defineBuiltInAccessor$9 = defineBuiltInAccessor$p;
if (DESCRIPTORS$e) {
  defineBuiltInAccessor$9(Array.prototype, "lastItem", {
    configurable: true,
    get: function lastItem() {
      var O = toObject$5(this);
      var len = lengthOfArrayLike$6(O);
      return len === 0 ? void 0 : O[len - 1];
    },
    set: function lastItem(value) {
      var O = toObject$5(this);
      var len = lengthOfArrayLike$6(O);
      return O[len === 0 ? 0 : len - 1] = value;
    }
  });
  addToUnscopables$1("lastItem");
}
var uncurryThis$z = functionUncurryThis;
var iterateSimple = iterateSimple$8;
var MapHelpers$b = mapHelpers;
var Map$9 = MapHelpers$b.Map;
var MapPrototype = MapHelpers$b.proto;
var forEach$3 = uncurryThis$z(MapPrototype.forEach);
var entries3 = uncurryThis$z(MapPrototype.entries);
var next4 = entries3(new Map$9()).next;
var mapIterate = function(map7, fn, interruptible) {
  return interruptible ? iterateSimple({
    iterator: entries3(map7),
    next: next4
  }, function(entry) {
    return fn(entry[1], entry[0]);
  }) : forEach$3(map7, fn);
};
var uncurryThis$y = functionUncurryThis;
var aCallable$i = aCallable$Q;
var isNullOrUndefined$5 = isNullOrUndefined$j;
var lengthOfArrayLike$5 = lengthOfArrayLike$B;
var toObject$4 = toObject$E;
var MapHelpers$a = mapHelpers;
var iterate$n = mapIterate;
var Map$8 = MapHelpers$a.Map;
var mapHas$1 = MapHelpers$a.has;
var mapSet$1 = MapHelpers$a.set;
var push$c = uncurryThis$y([].push);
var arrayUniqueBy$2 = function uniqueBy(resolver) {
  var that = toObject$4(this);
  var length = lengthOfArrayLike$5(that);
  var result = [];
  var map7 = new Map$8();
  var resolverFunction = !isNullOrUndefined$5(resolver) ? aCallable$i(resolver) : function(value) {
    return value;
  };
  var index, item, key;
  for (index = 0; index < length; index++) {
    item = that[index];
    key = resolverFunction(item);
    if (!mapHas$1(map7, key)) mapSet$1(map7, key, item);
  }
  iterate$n(map7, function(value) {
    push$c(result, value);
  });
  return result;
};
var $$2i = _export;
var addToUnscopables = addToUnscopables$n;
var uniqueBy2 = arrayUniqueBy$2;
$$2i({
  target: "Array",
  proto: true,
  forced: true
}, {
  uniqueBy: uniqueBy2
});
addToUnscopables("uniqueBy");
var getBuiltIn$s = getBuiltIn$Q;
var call$v = functionCall;
var uncurryThis$x = functionUncurryThis;
var bind$f = functionBindContext;
var anObject$t = anObject$1i;
var aCallable$h = aCallable$Q;
var isNullOrUndefined$4 = isNullOrUndefined$j;
var getMethod$6 = getMethod$l;
var wellKnownSymbol$f = wellKnownSymbol$S;
var ASYNC_DISPOSE$2 = wellKnownSymbol$f("asyncDispose");
var DISPOSE$2 = wellKnownSymbol$f("dispose");
var push$b = uncurryThis$x([].push);
var getDisposeMethod = function(V, hint) {
  if (hint === "async-dispose") {
    var method = getMethod$6(V, ASYNC_DISPOSE$2);
    if (method !== void 0) return method;
    method = getMethod$6(V, DISPOSE$2);
    if (method === void 0) return method;
    return function() {
      var O = this;
      var Promise2 = getBuiltIn$s("Promise");
      return new Promise2(function(resolve2) {
        call$v(method, O);
        resolve2(void 0);
      });
    };
  }
  return getMethod$6(V, DISPOSE$2);
};
var createDisposableResource = function(V, hint, method) {
  if (arguments.length < 3 && !isNullOrUndefined$4(V)) {
    method = aCallable$h(getDisposeMethod(anObject$t(V), hint));
  }
  return method === void 0 ? function() {
    return void 0;
  } : bind$f(method, V);
};
var addDisposableResource$2 = function(disposable, V, hint, method) {
  var resource;
  if (arguments.length < 4) {
    if (isNullOrUndefined$4(V) && hint === "sync-dispose") return;
    resource = createDisposableResource(V, hint);
  } else {
    resource = createDisposableResource(void 0, hint, method);
  }
  push$b(disposable.stack, resource);
};
var $$2h = _export;
var DESCRIPTORS$d = descriptors;
var getBuiltIn$r = getBuiltIn$Q;
var aCallable$g = aCallable$Q;
var anInstance$7 = anInstance$f;
var defineBuiltIn$9 = defineBuiltIn$u;
var defineBuiltIns$4 = defineBuiltIns$b;
var defineBuiltInAccessor$8 = defineBuiltInAccessor$p;
var wellKnownSymbol$e = wellKnownSymbol$S;
var InternalStateModule$a = internalState;
var addDisposableResource$1 = addDisposableResource$2;
var V8_VERSION = environmentV8Version;
var Promise$4 = getBuiltIn$r("Promise");
var SuppressedError$1 = getBuiltIn$r("SuppressedError");
var $ReferenceError$1 = ReferenceError;
var ASYNC_DISPOSE$1 = wellKnownSymbol$e("asyncDispose");
var TO_STRING_TAG$3 = wellKnownSymbol$e("toStringTag");
var ASYNC_DISPOSABLE_STACK = "AsyncDisposableStack";
var setInternalState$b = InternalStateModule$a.set;
var getAsyncDisposableStackInternalState = InternalStateModule$a.getterFor(ASYNC_DISPOSABLE_STACK);
var HINT$1 = "async-dispose";
var DISPOSED$1 = "disposed";
var PENDING$1 = "pending";
var getPendingAsyncDisposableStackInternalState = function(stack) {
  var internalState2 = getAsyncDisposableStackInternalState(stack);
  if (internalState2.state === DISPOSED$1) throw new $ReferenceError$1(ASYNC_DISPOSABLE_STACK + " already disposed");
  return internalState2;
};
var $AsyncDisposableStack = function AsyncDisposableStack() {
  setInternalState$b(anInstance$7(this, AsyncDisposableStackPrototype), {
    type: ASYNC_DISPOSABLE_STACK,
    state: PENDING$1,
    stack: []
  });
  if (!DESCRIPTORS$d) this.disposed = false;
};
var AsyncDisposableStackPrototype = $AsyncDisposableStack.prototype;
defineBuiltIns$4(AsyncDisposableStackPrototype, {
  disposeAsync: function disposeAsync() {
    var asyncDisposableStack = this;
    return new Promise$4(function(resolve2, reject2) {
      var internalState2 = getAsyncDisposableStackInternalState(asyncDisposableStack);
      if (internalState2.state === DISPOSED$1) return resolve2(void 0);
      internalState2.state = DISPOSED$1;
      if (!DESCRIPTORS$d) asyncDisposableStack.disposed = true;
      var stack = internalState2.stack;
      var i = stack.length;
      var thrown = false;
      var suppressed;
      var handleError = function(result) {
        if (thrown) {
          suppressed = new SuppressedError$1(result, suppressed);
        } else {
          thrown = true;
          suppressed = result;
        }
        loop();
      };
      var loop = function() {
        if (i) {
          var disposeMethod = stack[--i];
          stack[i] = null;
          try {
            Promise$4.resolve(disposeMethod()).then(loop, handleError);
          } catch (error3) {
            handleError(error3);
          }
        } else {
          internalState2.stack = null;
          thrown ? reject2(suppressed) : resolve2(void 0);
        }
      };
      loop();
    });
  },
  use: function use(value) {
    addDisposableResource$1(getPendingAsyncDisposableStackInternalState(this), value, HINT$1);
    return value;
  },
  adopt: function adopt(value, onDispose) {
    var internalState2 = getPendingAsyncDisposableStackInternalState(this);
    aCallable$g(onDispose);
    addDisposableResource$1(internalState2, void 0, HINT$1, function() {
      return onDispose(value);
    });
    return value;
  },
  defer: function defer2(onDispose) {
    var internalState2 = getPendingAsyncDisposableStackInternalState(this);
    aCallable$g(onDispose);
    addDisposableResource$1(internalState2, void 0, HINT$1, onDispose);
  },
  move: function move() {
    var internalState2 = getPendingAsyncDisposableStackInternalState(this);
    var newAsyncDisposableStack = new $AsyncDisposableStack();
    getAsyncDisposableStackInternalState(newAsyncDisposableStack).stack = internalState2.stack;
    internalState2.stack = [];
    internalState2.state = DISPOSED$1;
    if (!DESCRIPTORS$d) this.disposed = true;
    return newAsyncDisposableStack;
  }
});
if (DESCRIPTORS$d) defineBuiltInAccessor$8(AsyncDisposableStackPrototype, "disposed", {
  configurable: true,
  get: function disposed() {
    return getAsyncDisposableStackInternalState(this).state === DISPOSED$1;
  }
});
defineBuiltIn$9(AsyncDisposableStackPrototype, ASYNC_DISPOSE$1, AsyncDisposableStackPrototype.disposeAsync, {
  name: "disposeAsync"
});
defineBuiltIn$9(AsyncDisposableStackPrototype, TO_STRING_TAG$3, ASYNC_DISPOSABLE_STACK, {
  nonWritable: true
});
var SYNC_DISPOSE_RETURNING_PROMISE_RESOLUTION_BUG = V8_VERSION && V8_VERSION < 136;
$$2h({
  global: true,
  constructor: true,
  forced: SYNC_DISPOSE_RETURNING_PROMISE_RESOLUTION_BUG
}, {
  AsyncDisposableStack: $AsyncDisposableStack
});
var $$2g = _export;
var anInstance$6 = anInstance$f;
var getPrototypeOf$3 = objectGetPrototypeOf$2;
var createNonEnumerableProperty$4 = createNonEnumerableProperty$j;
var hasOwn$d = hasOwnProperty_1;
var wellKnownSymbol$d = wellKnownSymbol$S;
var AsyncIteratorPrototype$3 = asyncIteratorPrototype;
var IS_PURE$8 = isPure;
var TO_STRING_TAG$2 = wellKnownSymbol$d("toStringTag");
var $TypeError$i = TypeError;
var AsyncIteratorConstructor = function AsyncIterator3() {
  anInstance$6(this, AsyncIteratorPrototype$3);
  if (getPrototypeOf$3(this) === AsyncIteratorPrototype$3) throw new $TypeError$i("Abstract class AsyncIterator not directly constructable");
};
AsyncIteratorConstructor.prototype = AsyncIteratorPrototype$3;
if (!hasOwn$d(AsyncIteratorPrototype$3, TO_STRING_TAG$2)) {
  createNonEnumerableProperty$4(AsyncIteratorPrototype$3, TO_STRING_TAG$2, "AsyncIterator");
}
if (!hasOwn$d(AsyncIteratorPrototype$3, "constructor") || AsyncIteratorPrototype$3.constructor === Object) {
  createNonEnumerableProperty$4(AsyncIteratorPrototype$3, "constructor", AsyncIteratorConstructor);
}
$$2g({
  global: true,
  constructor: true,
  forced: IS_PURE$8
}, {
  AsyncIterator: AsyncIteratorConstructor
});
var call$u = functionCall;
var perform = perform$7;
var anObject$s = anObject$1i;
var create$5 = objectCreate$1;
var createNonEnumerableProperty$3 = createNonEnumerableProperty$j;
var defineBuiltIns$3 = defineBuiltIns$b;
var wellKnownSymbol$c = wellKnownSymbol$S;
var InternalStateModule$9 = internalState;
var getBuiltIn$q = getBuiltIn$Q;
var getMethod$5 = getMethod$l;
var AsyncIteratorPrototype$2 = asyncIteratorPrototype;
var createIterResultObject$b = createIterResultObject$i;
var iteratorClose = iteratorClose$8;
var Promise$3 = getBuiltIn$q("Promise");
var TO_STRING_TAG$1 = wellKnownSymbol$c("toStringTag");
var ASYNC_ITERATOR_HELPER = "AsyncIteratorHelper";
var WRAP_FOR_VALID_ASYNC_ITERATOR = "WrapForValidAsyncIterator";
var setInternalState$a = InternalStateModule$9.set;
var createAsyncIteratorProxyPrototype = function(IS_ITERATOR) {
  var IS_GENERATOR = !IS_ITERATOR;
  var getInternalState2 = InternalStateModule$9.getterFor(IS_ITERATOR ? WRAP_FOR_VALID_ASYNC_ITERATOR : ASYNC_ITERATOR_HELPER);
  var getStateOrEarlyExit = function(that) {
    var stateCompletion = perform(function() {
      return getInternalState2(that);
    });
    var stateError = stateCompletion.error;
    var state = stateCompletion.value;
    if (stateError || IS_GENERATOR && state.done) {
      return {
        exit: true,
        value: stateError ? Promise$3.reject(state) : Promise$3.resolve(createIterResultObject$b(void 0, true))
      };
    }
    return {
      exit: false,
      value: state
    };
  };
  return defineBuiltIns$3(create$5(AsyncIteratorPrototype$2), {
    next: function next11() {
      var stateCompletion = getStateOrEarlyExit(this);
      var state = stateCompletion.value;
      if (stateCompletion.exit) return state;
      var handlerCompletion = perform(function() {
        return anObject$s(state.nextHandler(Promise$3));
      });
      var handlerError = handlerCompletion.error;
      var value = handlerCompletion.value;
      if (handlerError) state.done = true;
      return handlerError ? Promise$3.reject(value) : Promise$3.resolve(value);
    },
    "return": function() {
      var stateCompletion = getStateOrEarlyExit(this);
      var state = stateCompletion.value;
      if (stateCompletion.exit) return state;
      state.done = true;
      var iterator = state.iterator;
      var returnMethod, result;
      var completion = perform(function() {
        if (state.inner) try {
          iteratorClose(state.inner.iterator, "normal");
        } catch (error3) {
          return iteratorClose(iterator, "throw", error3);
        }
        return getMethod$5(iterator, "return");
      });
      returnMethod = result = completion.value;
      if (completion.error) return Promise$3.reject(result);
      if (returnMethod === void 0) return Promise$3.resolve(createIterResultObject$b(void 0, true));
      completion = perform(function() {
        return call$u(returnMethod, iterator);
      });
      result = completion.value;
      if (completion.error) return Promise$3.reject(result);
      return IS_ITERATOR ? Promise$3.resolve(result) : Promise$3.resolve(result).then(function(resolved) {
        anObject$s(resolved);
        return createIterResultObject$b(void 0, true);
      });
    }
  });
};
var WrapForValidAsyncIteratorPrototype = createAsyncIteratorProxyPrototype(true);
var AsyncIteratorHelperPrototype = createAsyncIteratorProxyPrototype(false);
createNonEnumerableProperty$3(AsyncIteratorHelperPrototype, TO_STRING_TAG$1, "Async Iterator Helper");
var asyncIteratorCreateProxy = function(nextHandler, IS_ITERATOR) {
  var AsyncIteratorProxy2 = function AsyncIterator4(record, state) {
    if (state) {
      state.iterator = record.iterator;
      state.next = record.next;
    } else state = record;
    state.type = IS_ITERATOR ? WRAP_FOR_VALID_ASYNC_ITERATOR : ASYNC_ITERATOR_HELPER;
    state.nextHandler = nextHandler;
    state.counter = 0;
    state.done = false;
    setInternalState$a(this, state);
  };
  AsyncIteratorProxy2.prototype = IS_ITERATOR ? WrapForValidAsyncIteratorPrototype : AsyncIteratorHelperPrototype;
  return AsyncIteratorProxy2;
};
var call$t = functionCall;
var aCallable$f = aCallable$Q;
var anObject$r = anObject$1i;
var isObject$d = isObject$O;
var getIteratorDirect$7 = getIteratorDirect$o;
var createAsyncIteratorProxy$5 = asyncIteratorCreateProxy;
var createIterResultObject$a = createIterResultObject$i;
var closeAsyncIteration$3 = asyncIteratorClose;
var AsyncIteratorProxy$4 = createAsyncIteratorProxy$5(function(Promise2) {
  var state = this;
  var iterator = state.iterator;
  var mapper = state.mapper;
  return new Promise2(function(resolve2, reject2) {
    var doneAndReject = function(error3) {
      state.done = true;
      reject2(error3);
    };
    var ifAbruptCloseAsyncIterator = function(error3) {
      closeAsyncIteration$3(iterator, doneAndReject, error3, doneAndReject);
    };
    Promise2.resolve(anObject$r(call$t(state.next, iterator))).then(function(step) {
      try {
        if (anObject$r(step).done) {
          state.done = true;
          resolve2(createIterResultObject$a(void 0, true));
        } else {
          var value = step.value;
          try {
            var result = mapper(value, state.counter++);
            var handler = function(mapped) {
              resolve2(createIterResultObject$a(mapped, false));
            };
            if (isObject$d(result)) Promise2.resolve(result).then(handler, ifAbruptCloseAsyncIterator);
            else handler(result);
          } catch (error22) {
            ifAbruptCloseAsyncIterator(error22);
          }
        }
      } catch (error3) {
        doneAndReject(error3);
      }
    }, doneAndReject);
  });
});
var asyncIteratorMap = function map4(mapper) {
  anObject$r(this);
  aCallable$f(mapper);
  return new AsyncIteratorProxy$4(getIteratorDirect$7(this), {
    mapper
  });
};
var call$s = functionCall;
var map$2 = asyncIteratorMap;
var callback$1 = function(value, counter2) {
  return [counter2, value];
};
var asyncIteratorIndexed = function indexed() {
  return call$s(map$2, this, callback$1);
};
var $$2f = _export;
var indexed$3 = asyncIteratorIndexed;
$$2f({
  target: "AsyncIterator",
  name: "indexed",
  proto: true,
  real: true,
  forced: true
}, {
  asIndexedPairs: indexed$3
});
var call$r = functionCall;
var defineBuiltIn$8 = defineBuiltIn$u;
var getBuiltIn$p = getBuiltIn$Q;
var getMethod$4 = getMethod$l;
var hasOwn$c = hasOwnProperty_1;
var wellKnownSymbol$b = wellKnownSymbol$S;
var AsyncIteratorPrototype$1 = asyncIteratorPrototype;
var ASYNC_DISPOSE = wellKnownSymbol$b("asyncDispose");
var Promise$2 = getBuiltIn$p("Promise");
if (!hasOwn$c(AsyncIteratorPrototype$1, ASYNC_DISPOSE)) {
  defineBuiltIn$8(AsyncIteratorPrototype$1, ASYNC_DISPOSE, function() {
    var O = this;
    return new Promise$2(function(resolve2, reject2) {
      var $return = getMethod$4(O, "return");
      if ($return) {
        Promise$2.resolve(call$r($return, O)).then(function() {
          resolve2(void 0);
        }, reject2);
      } else resolve2(void 0);
    });
  });
}
var $$2e = _export;
var call$q = functionCall;
var anObject$q = anObject$1i;
var getIteratorDirect$6 = getIteratorDirect$o;
var notANaN$2 = notANan;
var toPositiveInteger$1 = toPositiveInteger$5;
var createAsyncIteratorProxy$4 = asyncIteratorCreateProxy;
var createIterResultObject$9 = createIterResultObject$i;
var IS_PURE$7 = isPure;
var AsyncIteratorProxy$3 = createAsyncIteratorProxy$4(function(Promise2) {
  var state = this;
  return new Promise2(function(resolve2, reject2) {
    var doneAndReject = function(error3) {
      state.done = true;
      reject2(error3);
    };
    var loop = function() {
      try {
        Promise2.resolve(anObject$q(call$q(state.next, state.iterator))).then(function(step) {
          try {
            if (anObject$q(step).done) {
              state.done = true;
              resolve2(createIterResultObject$9(void 0, true));
            } else if (state.remaining) {
              state.remaining--;
              loop();
            } else resolve2(createIterResultObject$9(step.value, false));
          } catch (err) {
            doneAndReject(err);
          }
        }, doneAndReject);
      } catch (error3) {
        doneAndReject(error3);
      }
    };
    loop();
  });
});
$$2e({
  target: "AsyncIterator",
  proto: true,
  real: true,
  forced: IS_PURE$7
}, {
  drop: function drop2(limit) {
    anObject$q(this);
    var remaining = toPositiveInteger$1(notANaN$2(+limit));
    return new AsyncIteratorProxy$3(getIteratorDirect$6(this), {
      remaining
    });
  }
});
var $$2d = _export;
var $every = asyncIteratorIteration.every;
$$2d({
  target: "AsyncIterator",
  proto: true,
  real: true
}, {
  every: function every4(predicate) {
    return $every(this, predicate);
  }
});
var $$2c = _export;
var call$p = functionCall;
var aCallable$e = aCallable$Q;
var anObject$p = anObject$1i;
var isObject$c = isObject$O;
var getIteratorDirect$5 = getIteratorDirect$o;
var createAsyncIteratorProxy$3 = asyncIteratorCreateProxy;
var createIterResultObject$8 = createIterResultObject$i;
var closeAsyncIteration$2 = asyncIteratorClose;
var IS_PURE$6 = isPure;
var AsyncIteratorProxy$2 = createAsyncIteratorProxy$3(function(Promise2) {
  var state = this;
  var iterator = state.iterator;
  var predicate = state.predicate;
  return new Promise2(function(resolve2, reject2) {
    var doneAndReject = function(error3) {
      state.done = true;
      reject2(error3);
    };
    var ifAbruptCloseAsyncIterator = function(error3) {
      closeAsyncIteration$2(iterator, doneAndReject, error3, doneAndReject);
    };
    var loop = function() {
      try {
        Promise2.resolve(anObject$p(call$p(state.next, iterator))).then(function(step) {
          try {
            if (anObject$p(step).done) {
              state.done = true;
              resolve2(createIterResultObject$8(void 0, true));
            } else {
              var value = step.value;
              try {
                var result = predicate(value, state.counter++);
                var handler = function(selected) {
                  selected ? resolve2(createIterResultObject$8(value, false)) : loop();
                };
                if (isObject$c(result)) Promise2.resolve(result).then(handler, ifAbruptCloseAsyncIterator);
                else handler(result);
              } catch (error3) {
                ifAbruptCloseAsyncIterator(error3);
              }
            }
          } catch (error22) {
            doneAndReject(error22);
          }
        }, doneAndReject);
      } catch (error3) {
        doneAndReject(error3);
      }
    };
    loop();
  });
});
$$2c({
  target: "AsyncIterator",
  proto: true,
  real: true,
  forced: IS_PURE$6
}, {
  filter: function filter4(predicate) {
    anObject$p(this);
    aCallable$e(predicate);
    return new AsyncIteratorProxy$2(getIteratorDirect$5(this), {
      predicate
    });
  }
});
var $$2b = _export;
var $find = asyncIteratorIteration.find;
$$2b({
  target: "AsyncIterator",
  proto: true,
  real: true
}, {
  find: function find4(predicate) {
    return $find(this, predicate);
  }
});
var call$o = functionCall;
var isCallable$a = isCallable$I;
var anObject$o = anObject$1i;
var getIteratorDirect$4 = getIteratorDirect$o;
var getIteratorMethod$2 = getIteratorMethod$9;
var getMethod$3 = getMethod$l;
var wellKnownSymbol$a = wellKnownSymbol$S;
var AsyncFromSyncIterator$1 = asyncFromSyncIterator;
var ASYNC_ITERATOR = wellKnownSymbol$a("asyncIterator");
var getAsyncIteratorFlattenable$2 = function(obj) {
  var object = anObject$o(obj);
  var alreadyAsync = true;
  var method = getMethod$3(object, ASYNC_ITERATOR);
  var iterator;
  if (!isCallable$a(method)) {
    method = getIteratorMethod$2(object);
    alreadyAsync = false;
  }
  if (method !== void 0) {
    iterator = call$o(method, object);
  } else {
    iterator = object;
    alreadyAsync = true;
  }
  anObject$o(iterator);
  return getIteratorDirect$4(alreadyAsync ? iterator : new AsyncFromSyncIterator$1(getIteratorDirect$4(iterator)));
};
var $$2a = _export;
var call$n = functionCall;
var aCallable$d = aCallable$Q;
var anObject$n = anObject$1i;
var isObject$b = isObject$O;
var getIteratorDirect$3 = getIteratorDirect$o;
var createAsyncIteratorProxy$2 = asyncIteratorCreateProxy;
var createIterResultObject$7 = createIterResultObject$i;
var getAsyncIteratorFlattenable$1 = getAsyncIteratorFlattenable$2;
var closeAsyncIteration$1 = asyncIteratorClose;
var IS_PURE$5 = isPure;
var AsyncIteratorProxy$1 = createAsyncIteratorProxy$2(function(Promise2) {
  var state = this;
  var iterator = state.iterator;
  var mapper = state.mapper;
  return new Promise2(function(resolve2, reject2) {
    var doneAndReject = function(error3) {
      state.done = true;
      reject2(error3);
    };
    var ifAbruptCloseAsyncIterator = function(error3) {
      closeAsyncIteration$1(iterator, doneAndReject, error3, doneAndReject);
    };
    var outerLoop = function() {
      try {
        Promise2.resolve(anObject$n(call$n(state.next, iterator))).then(function(step) {
          try {
            if (anObject$n(step).done) {
              state.done = true;
              resolve2(createIterResultObject$7(void 0, true));
            } else {
              var value = step.value;
              try {
                var result = mapper(value, state.counter++);
                var handler = function(mapped) {
                  try {
                    state.inner = getAsyncIteratorFlattenable$1(mapped);
                    innerLoop();
                  } catch (error4) {
                    ifAbruptCloseAsyncIterator(error4);
                  }
                };
                if (isObject$b(result)) Promise2.resolve(result).then(handler, ifAbruptCloseAsyncIterator);
                else handler(result);
              } catch (error3) {
                ifAbruptCloseAsyncIterator(error3);
              }
            }
          } catch (error22) {
            doneAndReject(error22);
          }
        }, doneAndReject);
      } catch (error3) {
        doneAndReject(error3);
      }
    };
    var innerLoop = function() {
      var inner = state.inner;
      if (inner) {
        try {
          Promise2.resolve(anObject$n(call$n(inner.next, inner.iterator))).then(function(result) {
            try {
              if (anObject$n(result).done) {
                state.inner = null;
                outerLoop();
              } else resolve2(createIterResultObject$7(result.value, false));
            } catch (error1) {
              ifAbruptCloseAsyncIterator(error1);
            }
          }, ifAbruptCloseAsyncIterator);
        } catch (error3) {
          ifAbruptCloseAsyncIterator(error3);
        }
      } else outerLoop();
    };
    innerLoop();
  });
});
$$2a({
  target: "AsyncIterator",
  proto: true,
  real: true,
  forced: IS_PURE$5
}, {
  flatMap: function flatMap3(mapper) {
    anObject$n(this);
    aCallable$d(mapper);
    return new AsyncIteratorProxy$1(getIteratorDirect$3(this), {
      mapper,
      inner: null
    });
  }
});
var $$29 = _export;
var $forEach = asyncIteratorIteration.forEach;
$$29({
  target: "AsyncIterator",
  proto: true,
  real: true
}, {
  forEach: function forEach4(fn) {
    return $forEach(this, fn);
  }
});
var call$m = functionCall;
var createAsyncIteratorProxy$1 = asyncIteratorCreateProxy;
var asyncIteratorWrap = createAsyncIteratorProxy$1(function() {
  return call$m(this.next, this.iterator);
}, true);
var $$28 = _export;
var toObject$3 = toObject$E;
var isPrototypeOf = objectIsPrototypeOf;
var getAsyncIteratorFlattenable = getAsyncIteratorFlattenable$2;
var AsyncIteratorPrototype = asyncIteratorPrototype;
var WrapAsyncIterator$1 = asyncIteratorWrap;
var IS_PURE$4 = isPure;
$$28({
  target: "AsyncIterator",
  stat: true,
  forced: IS_PURE$4
}, {
  from: function from5(O) {
    var iteratorRecord = getAsyncIteratorFlattenable(typeof O == "string" ? toObject$3(O) : O);
    return isPrototypeOf(AsyncIteratorPrototype, iteratorRecord.iterator) ? iteratorRecord.iterator : new WrapAsyncIterator$1(iteratorRecord);
  }
});
var $$27 = _export;
var indexed$2 = asyncIteratorIndexed;
$$27({
  target: "AsyncIterator",
  proto: true,
  real: true,
  forced: true
}, {
  indexed: indexed$2
});
var $$26 = _export;
var map$1 = asyncIteratorMap;
var IS_PURE$3 = isPure;
$$26({
  target: "AsyncIterator",
  proto: true,
  real: true,
  forced: IS_PURE$3
}, {
  map: map$1
});
var $$25 = _export;
var call$l = functionCall;
var aCallable$c = aCallable$Q;
var anObject$m = anObject$1i;
var isObject$a = isObject$O;
var getBuiltIn$o = getBuiltIn$Q;
var getIteratorDirect$2 = getIteratorDirect$o;
var closeAsyncIteration = asyncIteratorClose;
var Promise$1 = getBuiltIn$o("Promise");
var $TypeError$h = TypeError;
$$25({
  target: "AsyncIterator",
  proto: true,
  real: true
}, {
  reduce: function reduce4(reducer) {
    anObject$m(this);
    aCallable$c(reducer);
    var record = getIteratorDirect$2(this);
    var iterator = record.iterator;
    var next11 = record.next;
    var noInitial = arguments.length < 2;
    var accumulator = noInitial ? void 0 : arguments[1];
    var counter2 = 0;
    return new Promise$1(function(resolve2, reject2) {
      var ifAbruptCloseAsyncIterator = function(error3) {
        closeAsyncIteration(iterator, reject2, error3, reject2);
      };
      var loop = function() {
        try {
          Promise$1.resolve(anObject$m(call$l(next11, iterator))).then(function(step) {
            try {
              if (anObject$m(step).done) {
                noInitial ? reject2(new $TypeError$h("Reduce of empty iterator with no initial value")) : resolve2(accumulator);
              } else {
                var value = step.value;
                if (noInitial) {
                  noInitial = false;
                  accumulator = value;
                  loop();
                } else try {
                  var result = reducer(accumulator, value, counter2);
                  var handler = function($result) {
                    accumulator = $result;
                    loop();
                  };
                  if (isObject$a(result)) Promise$1.resolve(result).then(handler, ifAbruptCloseAsyncIterator);
                  else handler(result);
                } catch (error3) {
                  ifAbruptCloseAsyncIterator(error3);
                }
              }
              counter2++;
            } catch (error22) {
              reject2(error22);
            }
          }, reject2);
        } catch (error3) {
          reject2(error3);
        }
      };
      loop();
    });
  }
});
var $$24 = _export;
var $some = asyncIteratorIteration.some;
$$24({
  target: "AsyncIterator",
  proto: true,
  real: true
}, {
  some: function some4(predicate) {
    return $some(this, predicate);
  }
});
var $$23 = _export;
var call$k = functionCall;
var anObject$l = anObject$1i;
var getIteratorDirect$1 = getIteratorDirect$o;
var notANaN$1 = notANan;
var toPositiveInteger = toPositiveInteger$5;
var createAsyncIteratorProxy = asyncIteratorCreateProxy;
var createIterResultObject$6 = createIterResultObject$i;
var IS_PURE$2 = isPure;
var AsyncIteratorProxy = createAsyncIteratorProxy(function(Promise2) {
  var state = this;
  var iterator = state.iterator;
  var returnMethod;
  if (!state.remaining--) {
    var resultDone = createIterResultObject$6(void 0, true);
    state.done = true;
    returnMethod = iterator["return"];
    if (returnMethod !== void 0) {
      return Promise2.resolve(call$k(returnMethod, iterator, void 0)).then(function() {
        return resultDone;
      });
    }
    return resultDone;
  }
  return Promise2.resolve(call$k(state.next, iterator)).then(function(step) {
    if (anObject$l(step).done) {
      state.done = true;
      return createIterResultObject$6(void 0, true);
    }
    return createIterResultObject$6(step.value, false);
  }).then(null, function(error3) {
    state.done = true;
    throw error3;
  });
});
$$23({
  target: "AsyncIterator",
  proto: true,
  real: true,
  forced: IS_PURE$2
}, {
  take: function take2(limit) {
    anObject$l(this);
    var remaining = toPositiveInteger(notANaN$1(+limit));
    return new AsyncIteratorProxy(getIteratorDirect$1(this), {
      remaining
    });
  }
});
var $$22 = _export;
var $toArray = asyncIteratorIteration.toArray;
$$22({
  target: "AsyncIterator",
  proto: true,
  real: true
}, {
  toArray: function toArray2() {
    return $toArray(this, void 0, []);
  }
});
var InternalStateModule$8 = internalState;
var createIteratorConstructor$4 = iteratorCreateConstructor;
var createIterResultObject$5 = createIterResultObject$i;
var isNullOrUndefined$3 = isNullOrUndefined$j;
var isObject$9 = isObject$O;
var defineBuiltInAccessor$7 = defineBuiltInAccessor$p;
var DESCRIPTORS$c = descriptors;
var INCORRECT_RANGE = "Incorrect Iterator.range arguments";
var NUMERIC_RANGE_ITERATOR = "NumericRangeIterator";
var setInternalState$9 = InternalStateModule$8.set;
var getInternalState$5 = InternalStateModule$8.getterFor(NUMERIC_RANGE_ITERATOR);
var $RangeError$4 = RangeError;
var $TypeError$g = TypeError;
var $RangeIterator = createIteratorConstructor$4(function NumericRangeIterator(start2, end, option, type, zero, one) {
  if (typeof start2 != type || end !== Infinity && end !== -Infinity && typeof end != type) {
    throw new $TypeError$g(INCORRECT_RANGE);
  }
  if (start2 === Infinity || start2 === -Infinity) {
    throw new $RangeError$4(INCORRECT_RANGE);
  }
  var ifIncrease = end > start2;
  var inclusiveEnd = false;
  var step;
  if (option === void 0) {
    step = void 0;
  } else if (isObject$9(option)) {
    step = option.step;
    inclusiveEnd = !!option.inclusive;
  } else if (typeof option == type) {
    step = option;
  } else {
    throw new $TypeError$g(INCORRECT_RANGE);
  }
  if (isNullOrUndefined$3(step)) {
    step = ifIncrease ? one : -one;
  }
  if (typeof step != type) {
    throw new $TypeError$g(INCORRECT_RANGE);
  }
  if (step === Infinity || step === -Infinity || step === zero && start2 !== end) {
    throw new $RangeError$4(INCORRECT_RANGE);
  }
  var hitsEnd = start2 !== start2 || end !== end || step !== step || end > start2 !== step > zero;
  setInternalState$9(this, {
    type: NUMERIC_RANGE_ITERATOR,
    start: start2,
    end,
    step,
    inclusive: inclusiveEnd,
    hitsEnd,
    currentCount: zero,
    zero
  });
  if (!DESCRIPTORS$c) {
    this.start = start2;
    this.end = end;
    this.step = step;
    this.inclusive = inclusiveEnd;
  }
}, NUMERIC_RANGE_ITERATOR, function next5() {
  var state = getInternalState$5(this);
  if (state.hitsEnd) return createIterResultObject$5(void 0, true);
  var start2 = state.start;
  var end = state.end;
  var step = state.step;
  var currentYieldingValue = start2 + step * state.currentCount++;
  if (currentYieldingValue === end) state.hitsEnd = true;
  var inclusiveEnd = state.inclusive;
  var endCondition;
  if (end > start2) {
    endCondition = inclusiveEnd ? currentYieldingValue > end : currentYieldingValue >= end;
  } else {
    endCondition = inclusiveEnd ? end > currentYieldingValue : end >= currentYieldingValue;
  }
  if (endCondition) {
    state.hitsEnd = true;
    return createIterResultObject$5(void 0, true);
  }
  return createIterResultObject$5(currentYieldingValue, false);
});
var addGetter = function(key) {
  defineBuiltInAccessor$7($RangeIterator.prototype, key, {
    get: function() {
      return getInternalState$5(this)[key];
    },
    set: function() {
    },
    configurable: true,
    enumerable: false
  });
};
if (DESCRIPTORS$c) {
  addGetter("start");
  addGetter("end");
  addGetter("inclusive");
  addGetter("step");
}
var numericRangeIterator = $RangeIterator;
var $$21 = _export;
var NumericRangeIterator$2 = numericRangeIterator;
if (typeof BigInt == "function") {
  $$21({
    target: "BigInt",
    stat: true,
    forced: true
  }, {
    range: function range3(start2, end, option) {
      return new NumericRangeIterator$2(start2, end, option, "bigint", BigInt(0), BigInt(1));
    }
  });
}
var getBuiltIn$n = getBuiltIn$Q;
var create$4 = objectCreate$1;
var isObject$8 = isObject$O;
var $Object$2 = Object;
var $TypeError$f = TypeError;
var Map$7 = getBuiltIn$n("Map");
var WeakMap$2 = getBuiltIn$n("WeakMap");
var Node$1 = function() {
  this.object = null;
  this.symbol = null;
  this.primitives = null;
  this.objectsByIndex = create$4(null);
};
Node$1.prototype.get = function(key, initializer2) {
  return this[key] || (this[key] = initializer2());
};
Node$1.prototype.next = function(i, it, IS_OBJECT) {
  var store2 = IS_OBJECT ? this.objectsByIndex[i] || (this.objectsByIndex[i] = new WeakMap$2()) : this.primitives || (this.primitives = new Map$7());
  var entry = store2.get(it);
  if (!entry) store2.set(it, entry = new Node$1());
  return entry;
};
var root = new Node$1();
var compositeKey = function() {
  var active = root;
  var length = arguments.length;
  var i, it;
  for (i = 0; i < length; i++) {
    if (isObject$8(it = arguments[i])) active = active.next(i, it, true);
  }
  if (this === $Object$2 && active === root) throw new $TypeError$f("Composite keys must contain a non-primitive component");
  for (i = 0; i < length; i++) {
    if (!isObject$8(it = arguments[i])) active = active.next(i, it, false);
  }
  return active;
};
var $$20 = _export;
var apply$3 = functionApply$1;
var getCompositeKeyNode$1 = compositeKey;
var getBuiltIn$m = getBuiltIn$Q;
var create$3 = objectCreate$1;
var $Object$1 = Object;
var initializer = function() {
  var freeze3 = getBuiltIn$m("Object", "freeze");
  return freeze3 ? freeze3(create$3(null)) : create$3(null);
};
$$20({
  global: true,
  forced: true
}, {
  compositeKey: function compositeKey2() {
    return apply$3(getCompositeKeyNode$1, $Object$1, arguments).get("object", initializer);
  }
});
var $$1$ = _export;
var getCompositeKeyNode = compositeKey;
var getBuiltIn$l = getBuiltIn$Q;
var apply$2 = functionApply$1;
$$1$({
  global: true,
  forced: true
}, {
  compositeSymbol: function compositeSymbol() {
    if (arguments.length === 1 && typeof arguments[0] == "string") return getBuiltIn$l("Symbol")["for"](arguments[0]);
    return apply$2(getCompositeKeyNode, null, arguments).get("symbol", getBuiltIn$l("Symbol"));
  }
});
var $$1_ = _export;
var uncurryThis$w = functionUncurryThis;
var getUint8 = uncurryThis$w(DataView.prototype.getUint8);
$$1_({
  target: "DataView",
  proto: true,
  forced: true
}, {
  getUint8Clamped: function getUint8Clamped(byteOffset) {
    return getUint8(this, byteOffset);
  }
});
var $$1Z = _export;
var uncurryThis$v = functionUncurryThis;
var aDataView = aDataView$2;
var toIndex = toIndex$5;
var toUint8Clamped = toUint8Clamped$2;
var setUint8 = uncurryThis$v(DataView.prototype.setUint8);
$$1Z({
  target: "DataView",
  proto: true,
  forced: true
}, {
  setUint8Clamped: function setUint8Clamped(byteOffset, value) {
    aDataView(this);
    var offset = toIndex(byteOffset);
    return setUint8(this, offset, toUint8Clamped(value));
  }
});
var $$1Y = _export;
var DESCRIPTORS$b = descriptors;
var getBuiltIn$k = getBuiltIn$Q;
var aCallable$b = aCallable$Q;
var anInstance$5 = anInstance$f;
var defineBuiltIn$7 = defineBuiltIn$u;
var defineBuiltIns$2 = defineBuiltIns$b;
var defineBuiltInAccessor$6 = defineBuiltInAccessor$p;
var wellKnownSymbol$9 = wellKnownSymbol$S;
var InternalStateModule$7 = internalState;
var addDisposableResource = addDisposableResource$2;
var SuppressedError2 = getBuiltIn$k("SuppressedError");
var $ReferenceError = ReferenceError;
var DISPOSE$1 = wellKnownSymbol$9("dispose");
var TO_STRING_TAG = wellKnownSymbol$9("toStringTag");
var DISPOSABLE_STACK = "DisposableStack";
var setInternalState$8 = InternalStateModule$7.set;
var getDisposableStackInternalState = InternalStateModule$7.getterFor(DISPOSABLE_STACK);
var HINT = "sync-dispose";
var DISPOSED = "disposed";
var PENDING = "pending";
var getPendingDisposableStackInternalState = function(stack) {
  var internalState2 = getDisposableStackInternalState(stack);
  if (internalState2.state === DISPOSED) throw new $ReferenceError(DISPOSABLE_STACK + " already disposed");
  return internalState2;
};
var $DisposableStack = function DisposableStack() {
  setInternalState$8(anInstance$5(this, DisposableStackPrototype), {
    type: DISPOSABLE_STACK,
    state: PENDING,
    stack: []
  });
  if (!DESCRIPTORS$b) this.disposed = false;
};
var DisposableStackPrototype = $DisposableStack.prototype;
defineBuiltIns$2(DisposableStackPrototype, {
  dispose: function dispose() {
    var internalState2 = getDisposableStackInternalState(this);
    if (internalState2.state === DISPOSED) return;
    internalState2.state = DISPOSED;
    if (!DESCRIPTORS$b) this.disposed = true;
    var stack = internalState2.stack;
    var i = stack.length;
    var thrown = false;
    var suppressed;
    while (i) {
      var disposeMethod = stack[--i];
      stack[i] = null;
      try {
        disposeMethod();
      } catch (errorResult) {
        if (thrown) {
          suppressed = new SuppressedError2(errorResult, suppressed);
        } else {
          thrown = true;
          suppressed = errorResult;
        }
      }
    }
    internalState2.stack = null;
    if (thrown) throw suppressed;
  },
  use: function use2(value) {
    addDisposableResource(getPendingDisposableStackInternalState(this), value, HINT);
    return value;
  },
  adopt: function adopt2(value, onDispose) {
    var internalState2 = getPendingDisposableStackInternalState(this);
    aCallable$b(onDispose);
    addDisposableResource(internalState2, void 0, HINT, function() {
      onDispose(value);
    });
    return value;
  },
  defer: function defer3(onDispose) {
    var internalState2 = getPendingDisposableStackInternalState(this);
    aCallable$b(onDispose);
    addDisposableResource(internalState2, void 0, HINT, onDispose);
  },
  move: function move2() {
    var internalState2 = getPendingDisposableStackInternalState(this);
    var newDisposableStack = new $DisposableStack();
    getDisposableStackInternalState(newDisposableStack).stack = internalState2.stack;
    internalState2.stack = [];
    internalState2.state = DISPOSED;
    if (!DESCRIPTORS$b) this.disposed = true;
    return newDisposableStack;
  }
});
if (DESCRIPTORS$b) defineBuiltInAccessor$6(DisposableStackPrototype, "disposed", {
  configurable: true,
  get: function disposed2() {
    return getDisposableStackInternalState(this).state === DISPOSED;
  }
});
defineBuiltIn$7(DisposableStackPrototype, DISPOSE$1, DisposableStackPrototype.dispose, {
  name: "dispose"
});
defineBuiltIn$7(DisposableStackPrototype, TO_STRING_TAG, DISPOSABLE_STACK, {
  nonWritable: true
});
$$1Y({
  global: true,
  constructor: true
}, {
  DisposableStack: $DisposableStack
});
var $$1X = _export;
var getBuiltIn$j = getBuiltIn$Q;
var isObject$7 = isObject$O;
var classof$4 = classof$q;
var fails$9 = fails$1z;
var ERROR = "Error";
var DOM_EXCEPTION$3 = "DOMException";
var PROTOTYPE_SETTING_AVAILABLE = Object.setPrototypeOf || {}.__proto__;
var DOMException$1 = getBuiltIn$j(DOM_EXCEPTION$3);
var $Error = Error;
var $isError = $Error.isError;
var FORCED$1 = !$isError || !PROTOTYPE_SETTING_AVAILABLE || fails$9(function() {
  return DOMException$1 && !$isError(new DOMException$1(DOM_EXCEPTION$3)) || // structuredClone-based implementations
  // eslint-disable-next-line es/no-error-cause -- detection
  !$isError(new $Error(ERROR, {
    cause: function() {
    }
  })) || // instanceof-based and FF Error#stack-based implementations
  $isError(getBuiltIn$j("Object", "create")($Error.prototype));
});
$$1X({
  target: "Error",
  stat: true,
  sham: true,
  forced: FORCED$1
}, {
  isError: function isError(arg) {
    if (!isObject$7(arg)) return false;
    var tag = classof$4(arg);
    return tag === ERROR || tag === DOM_EXCEPTION$3;
  }
});
var uncurryThis$u = functionUncurryThis;
var aCallable$a = aCallable$Q;
var functionDemethodize = function demethodize() {
  return uncurryThis$u(aCallable$a(this));
};
var $$1W = _export;
var demethodize$1 = functionDemethodize;
$$1W({
  target: "Function",
  proto: true,
  forced: true
}, {
  demethodize: demethodize$1
});
var $$1V = _export;
var uncurryThis$t = functionUncurryThis;
var $isCallable = isCallable$I;
var inspectSource = inspectSource$4;
var hasOwn$b = hasOwnProperty_1;
var DESCRIPTORS$a = descriptors;
var getOwnPropertyDescriptor$3 = Object.getOwnPropertyDescriptor;
var classRegExp = /^\s*class\b/;
var exec$9 = uncurryThis$t(classRegExp.exec);
var isClassConstructor = function(argument) {
  try {
    if (!DESCRIPTORS$a || !exec$9(classRegExp, inspectSource(argument))) return false;
  } catch (error3) {
  }
  var prototype2 = getOwnPropertyDescriptor$3(argument, "prototype");
  return !!prototype2 && hasOwn$b(prototype2, "writable") && !prototype2.writable;
};
$$1V({
  target: "Function",
  stat: true,
  sham: true,
  forced: true
}, {
  isCallable: function isCallable(argument) {
    return $isCallable(argument) && !isClassConstructor(argument);
  }
});
var $$1U = _export;
var isConstructor$3 = isConstructor$a;
$$1U({
  target: "Function",
  stat: true,
  forced: true
}, {
  isConstructor: isConstructor$3
});
var wellKnownSymbol$8 = wellKnownSymbol$S;
var defineProperty$6 = objectDefineProperty.f;
var METADATA = wellKnownSymbol$8("metadata");
var FunctionPrototype = Function.prototype;
if (FunctionPrototype[METADATA] === void 0) {
  defineProperty$6(FunctionPrototype, METADATA, {
    value: null
  });
}
var $$1T = _export;
var demethodize2 = functionDemethodize;
$$1T({
  target: "Function",
  proto: true,
  forced: true,
  name: "demethodize"
}, {
  unThis: demethodize2
});
var call$j = functionCall;
var map5 = iteratorMap;
var callback = function(value, counter2) {
  return [counter2, value];
};
var iteratorIndexed = function indexed2() {
  return call$j(map5, this, callback);
};
var $$1S = _export;
var indexed$1 = iteratorIndexed;
$$1S({
  target: "Iterator",
  name: "indexed",
  proto: true,
  real: true,
  forced: true
}, {
  asIndexedPairs: indexed$1
});
var $$1R = _export;
var call$i = functionCall;
var aCallable$9 = aCallable$Q;
var anObject$k = anObject$1i;
var getIteratorMethod$1 = getIteratorMethod$9;
var createIteratorProxy = iteratorCreateProxy;
var createIterResultObject$4 = createIterResultObject$i;
var $Array$1 = Array;
var IteratorProxy = createIteratorProxy(function() {
  while (true) {
    var iterator = this.iterator;
    if (!iterator) {
      var iterableIndex = this.nextIterableIndex++;
      var iterables = this.iterables;
      if (iterableIndex >= iterables.length) {
        this.done = true;
        return createIterResultObject$4(void 0, true);
      }
      var entry = iterables[iterableIndex];
      this.iterables[iterableIndex] = null;
      iterator = this.iterator = call$i(entry.method, entry.iterable);
      this.next = iterator.next;
    }
    var result = anObject$k(call$i(this.next, iterator));
    if (result.done) {
      this.iterator = null;
      this.next = null;
      continue;
    }
    return result;
  }
}, false, true);
$$1R({
  target: "Iterator",
  stat: true,
  forced: true
}, {
  concat: function concat2() {
    var length = arguments.length;
    var iterables = $Array$1(length);
    for (var index = 0; index < length; index++) {
      var item = anObject$k(arguments[index]);
      iterables[index] = {
        iterable: item,
        method: aCallable$9(getIteratorMethod$1(item))
      };
    }
    return new IteratorProxy({
      iterables,
      nextIterableIndex: 0,
      iterator: null,
      next: null
    });
  }
});
var call$h = functionCall;
var defineBuiltIn$6 = defineBuiltIn$u;
var getMethod$2 = getMethod$l;
var hasOwn$a = hasOwnProperty_1;
var wellKnownSymbol$7 = wellKnownSymbol$S;
var IteratorPrototype = iteratorsCore.IteratorPrototype;
var DISPOSE = wellKnownSymbol$7("dispose");
if (!hasOwn$a(IteratorPrototype, DISPOSE)) {
  defineBuiltIn$6(IteratorPrototype, DISPOSE, function() {
    var $return = getMethod$2(this, "return");
    if ($return) call$h($return, this);
  });
}
var $$1Q = _export;
var indexed3 = iteratorIndexed;
$$1Q({
  target: "Iterator",
  proto: true,
  real: true,
  forced: true
}, {
  indexed: indexed3
});
var $$1P = _export;
var NumericRangeIterator$1 = numericRangeIterator;
var $TypeError$e = TypeError;
$$1P({
  target: "Iterator",
  stat: true,
  forced: true
}, {
  range: function range(start2, end, option) {
    if (typeof start2 == "number") return new NumericRangeIterator$1(start2, end, option, "number", 0, 1);
    if (typeof start2 == "bigint") return new NumericRangeIterator$1(start2, end, option, "bigint", BigInt(0), BigInt(1));
    throw new $TypeError$e("Incorrect Iterator.range arguments");
  }
});
var $$1O = _export;
var anObject$j = anObject$1i;
var AsyncFromSyncIterator = asyncFromSyncIterator;
var WrapAsyncIterator = asyncIteratorWrap;
var getIteratorDirect = getIteratorDirect$o;
var IS_PURE$1 = isPure;
$$1O({
  target: "Iterator",
  proto: true,
  real: true,
  forced: IS_PURE$1
}, {
  toAsync: function toAsync() {
    return new WrapAsyncIterator(getIteratorDirect(new AsyncFromSyncIterator(getIteratorDirect(anObject$j(this)))));
  }
});
var fails$8 = fails$1z;
var nativeRawJson = !fails$8(function() {
  var unsafeInt = "9007199254740993";
  var raw3 = JSON.rawJSON(unsafeInt);
  return !JSON.isRawJSON(raw3) || JSON.stringify(raw3) !== unsafeInt;
});
var isObject$6 = isObject$O;
var getInternalState$4 = internalState.get;
var isRawJson = function isRawJSON(O) {
  if (!isObject$6(O)) return false;
  var state = getInternalState$4(O);
  return !!state && state.type === "RawJSON";
};
var $$1N = _export;
var NATIVE_RAW_JSON$1 = nativeRawJson;
var isRawJSON$1 = isRawJson;
$$1N({
  target: "JSON",
  stat: true,
  forced: !NATIVE_RAW_JSON$1
}, {
  isRawJSON: isRawJSON$1
});
var uncurryThis$s = functionUncurryThis;
var hasOwn$9 = hasOwnProperty_1;
var $SyntaxError$2 = SyntaxError;
var $parseInt$2 = parseInt;
var fromCharCode$4 = String.fromCharCode;
var at$3 = uncurryThis$s("".charAt);
var slice$2 = uncurryThis$s("".slice);
var exec$8 = uncurryThis$s(/./.exec);
var codePoints = {
  '\\"': '"',
  "\\\\": "\\",
  "\\/": "/",
  "\\b": "\b",
  "\\f": "\f",
  "\\n": "\n",
  "\\r": "\r",
  "\\t": "	"
};
var IS_4_HEX_DIGITS = /^[\da-f]{4}$/i;
var IS_C0_CONTROL_CODE = /^[\u0000-\u001F]$/;
var parseJsonString = function(source, i) {
  var unterminated = true;
  var value = "";
  while (i < source.length) {
    var chr = at$3(source, i);
    if (chr === "\\") {
      var twoChars = slice$2(source, i, i + 2);
      if (hasOwn$9(codePoints, twoChars)) {
        value += codePoints[twoChars];
        i += 2;
      } else if (twoChars === "\\u") {
        i += 2;
        var fourHexDigits = slice$2(source, i, i + 4);
        if (!exec$8(IS_4_HEX_DIGITS, fourHexDigits)) throw new $SyntaxError$2("Bad Unicode escape at: " + i);
        value += fromCharCode$4($parseInt$2(fourHexDigits, 16));
        i += 4;
      } else throw new $SyntaxError$2('Unknown escape sequence: "' + twoChars + '"');
    } else if (chr === '"') {
      unterminated = false;
      i++;
      break;
    } else {
      if (exec$8(IS_C0_CONTROL_CODE, chr)) throw new $SyntaxError$2("Bad control character in string literal at: " + i);
      value += chr;
      i++;
    }
  }
  if (unterminated) throw new $SyntaxError$2("Unterminated string at: " + i);
  return {
    value,
    end: i
  };
};
var $$1M = _export;
var DESCRIPTORS$9 = descriptors;
var globalThis$q = globalThis_1;
var getBuiltIn$i = getBuiltIn$Q;
var uncurryThis$r = functionUncurryThis;
var call$g = functionCall;
var isCallable$9 = isCallable$I;
var isObject$5 = isObject$O;
var isArray2 = isArray$b;
var hasOwn$8 = hasOwnProperty_1;
var toString$b = toString$J;
var lengthOfArrayLike$4 = lengthOfArrayLike$B;
var createProperty$2 = createProperty$b;
var fails$7 = fails$1z;
var parseJSONString$1 = parseJsonString;
var NATIVE_SYMBOL = symbolConstructorDetection;
var JSON$1 = globalThis$q.JSON;
var Number$1 = globalThis$q.Number;
var SyntaxError$3 = globalThis$q.SyntaxError;
var nativeParse = JSON$1 && JSON$1.parse;
var enumerableOwnProperties = getBuiltIn$i("Object", "keys");
var getOwnPropertyDescriptor$2 = Object.getOwnPropertyDescriptor;
var at$2 = uncurryThis$r("".charAt);
var slice$1 = uncurryThis$r("".slice);
var exec$7 = uncurryThis$r(/./.exec);
var push$a = uncurryThis$r([].push);
var IS_DIGIT = /^\d$/;
var IS_NON_ZERO_DIGIT = /^[1-9]$/;
var IS_NUMBER_START = /^[\d-]$/;
var IS_WHITESPACE = /^[\t\n\r ]$/;
var PRIMITIVE = 0;
var OBJECT = 1;
var $parse = function(source, reviver) {
  source = toString$b(source);
  var context = new Context(source, 0);
  var root2 = context.parse();
  var value = root2.value;
  var endIndex = context.skip(IS_WHITESPACE, root2.end);
  if (endIndex < source.length) {
    throw new SyntaxError$3('Unexpected extra character: "' + at$2(source, endIndex) + '" after the parsed data at: ' + endIndex);
  }
  return isCallable$9(reviver) ? internalize({
    "": value
  }, "", reviver, root2) : value;
};
var internalize = function(holder, name, reviver, node2) {
  var val = holder[name];
  var unmodified = node2 && val === node2.value;
  var context = unmodified && typeof node2.source == "string" ? {
    source: node2.source
  } : {};
  var elementRecordsLen, keys6, len, i, P;
  if (isObject$5(val)) {
    var nodeIsArray = isArray2(val);
    var nodes = unmodified ? node2.nodes : nodeIsArray ? [] : {};
    if (nodeIsArray) {
      elementRecordsLen = nodes.length;
      len = lengthOfArrayLike$4(val);
      for (i = 0; i < len; i++) {
        internalizeProperty(val, i, internalize(val, "" + i, reviver, i < elementRecordsLen ? nodes[i] : void 0));
      }
    } else {
      keys6 = enumerableOwnProperties(val);
      len = lengthOfArrayLike$4(keys6);
      for (i = 0; i < len; i++) {
        P = keys6[i];
        internalizeProperty(val, P, internalize(val, P, reviver, hasOwn$8(nodes, P) ? nodes[P] : void 0));
      }
    }
  }
  return call$g(reviver, holder, name, val, context);
};
var internalizeProperty = function(object, key, value) {
  if (DESCRIPTORS$9) {
    var descriptor = getOwnPropertyDescriptor$2(object, key);
    if (descriptor && !descriptor.configurable) return;
  }
  if (value === void 0) delete object[key];
  else createProperty$2(object, key, value);
};
var Node = function(value, end, source, nodes) {
  this.value = value;
  this.end = end;
  this.source = source;
  this.nodes = nodes;
};
var Context = function(source, index) {
  this.source = source;
  this.index = index;
};
Context.prototype = {
  fork: function(nextIndex) {
    return new Context(this.source, nextIndex);
  },
  parse: function() {
    var source = this.source;
    var i = this.skip(IS_WHITESPACE, this.index);
    var fork = this.fork(i);
    var chr = at$2(source, i);
    if (exec$7(IS_NUMBER_START, chr)) return fork.number();
    switch (chr) {
      case "{":
        return fork.object();
      case "[":
        return fork.array();
      case '"':
        return fork.string();
      case "t":
        return fork.keyword(true);
      case "f":
        return fork.keyword(false);
      case "n":
        return fork.keyword(null);
    }
    throw new SyntaxError$3('Unexpected character: "' + chr + '" at: ' + i);
  },
  node: function(type, value, start2, end, nodes) {
    return new Node(value, end, type ? null : slice$1(this.source, start2, end), nodes);
  },
  object: function() {
    var source = this.source;
    var i = this.index + 1;
    var expectKeypair = false;
    var object = {};
    var nodes = {};
    while (i < source.length) {
      i = this.until(['"', "}"], i);
      if (at$2(source, i) === "}" && !expectKeypair) {
        i++;
        break;
      }
      var result = this.fork(i).string();
      var key = result.value;
      i = result.end;
      i = this.until([":"], i) + 1;
      i = this.skip(IS_WHITESPACE, i);
      result = this.fork(i).parse();
      createProperty$2(nodes, key, result);
      createProperty$2(object, key, result.value);
      i = this.until([",", "}"], result.end);
      var chr = at$2(source, i);
      if (chr === ",") {
        expectKeypair = true;
        i++;
      } else if (chr === "}") {
        i++;
        break;
      }
    }
    return this.node(OBJECT, object, this.index, i, nodes);
  },
  array: function() {
    var source = this.source;
    var i = this.index + 1;
    var expectElement = false;
    var array = [];
    var nodes = [];
    while (i < source.length) {
      i = this.skip(IS_WHITESPACE, i);
      if (at$2(source, i) === "]" && !expectElement) {
        i++;
        break;
      }
      var result = this.fork(i).parse();
      push$a(nodes, result);
      push$a(array, result.value);
      i = this.until([",", "]"], result.end);
      if (at$2(source, i) === ",") {
        expectElement = true;
        i++;
      } else if (at$2(source, i) === "]") {
        i++;
        break;
      }
    }
    return this.node(OBJECT, array, this.index, i, nodes);
  },
  string: function() {
    var index = this.index;
    var parsed = parseJSONString$1(this.source, this.index + 1);
    return this.node(PRIMITIVE, parsed.value, index, parsed.end);
  },
  number: function() {
    var source = this.source;
    var startIndex = this.index;
    var i = startIndex;
    if (at$2(source, i) === "-") i++;
    if (at$2(source, i) === "0") i++;
    else if (exec$7(IS_NON_ZERO_DIGIT, at$2(source, i))) i = this.skip(IS_DIGIT, i + 1);
    else throw new SyntaxError$3("Failed to parse number at: " + i);
    if (at$2(source, i) === ".") i = this.skip(IS_DIGIT, i + 1);
    if (at$2(source, i) === "e" || at$2(source, i) === "E") {
      i++;
      if (at$2(source, i) === "+" || at$2(source, i) === "-") i++;
      var exponentStartIndex = i;
      i = this.skip(IS_DIGIT, i);
      if (exponentStartIndex === i) throw new SyntaxError$3("Failed to parse number's exponent value at: " + i);
    }
    return this.node(PRIMITIVE, Number$1(slice$1(source, startIndex, i)), startIndex, i);
  },
  keyword: function(value) {
    var keyword = "" + value;
    var index = this.index;
    var endIndex = index + keyword.length;
    if (slice$1(this.source, index, endIndex) !== keyword) throw new SyntaxError$3("Failed to parse value at: " + index);
    return this.node(PRIMITIVE, value, index, endIndex);
  },
  skip: function(regex, i) {
    var source = this.source;
    for (; i < source.length; i++) if (!exec$7(regex, at$2(source, i))) break;
    return i;
  },
  until: function(array, i) {
    i = this.skip(IS_WHITESPACE, i);
    var chr = at$2(this.source, i);
    for (var j = 0; j < array.length; j++) if (array[j] === chr) return i;
    throw new SyntaxError$3('Unexpected character: "' + chr + '" at: ' + i);
  }
};
var NO_SOURCE_SUPPORT = fails$7(function() {
  var unsafeInt = "9007199254740993";
  var source;
  nativeParse(unsafeInt, function(key, value, context) {
    source = context.source;
  });
  return source !== unsafeInt;
});
var PROPER_BASE_PARSE = NATIVE_SYMBOL && !fails$7(function() {
  return 1 / nativeParse("-0 	") !== -Infinity;
});
$$1M({
  target: "JSON",
  stat: true,
  forced: NO_SOURCE_SUPPORT
}, {
  parse: function parse(text, reviver) {
    return PROPER_BASE_PARSE && !isCallable$9(reviver) ? nativeParse(text) : $parse(text, reviver);
  }
});
var $$1L = _export;
var FREEZING$1 = freezing;
var NATIVE_RAW_JSON = nativeRawJson;
var getBuiltIn$h = getBuiltIn$Q;
var call$f = functionCall;
var uncurryThis$q = functionUncurryThis;
var isCallable$8 = isCallable$I;
var isRawJSON2 = isRawJson;
var toString$a = toString$J;
var createProperty$1 = createProperty$b;
var parseJSONString = parseJsonString;
var getReplacerFunction = getJsonReplacerFunction;
var uid$1 = uid$7;
var setInternalState$7 = internalState.set;
var $String$1 = String;
var $SyntaxError$1 = SyntaxError;
var parse$1 = getBuiltIn$h("JSON", "parse");
var $stringify = getBuiltIn$h("JSON", "stringify");
var create$2 = getBuiltIn$h("Object", "create");
var freeze$1 = getBuiltIn$h("Object", "freeze");
var at$1 = uncurryThis$q("".charAt);
var slice4 = uncurryThis$q("".slice);
var push$9 = uncurryThis$q([].push);
var MARK = uid$1();
var MARK_LENGTH = MARK.length;
var ERROR_MESSAGE = "Unacceptable as raw JSON";
var isWhitespace = function(it) {
  return it === " " || it === "	" || it === "\n" || it === "\r";
};
$$1L({
  target: "JSON",
  stat: true,
  forced: !NATIVE_RAW_JSON
}, {
  rawJSON: function rawJSON(text) {
    var jsonString = toString$a(text);
    if (jsonString === "" || isWhitespace(at$1(jsonString, 0)) || isWhitespace(at$1(jsonString, jsonString.length - 1))) {
      throw new $SyntaxError$1(ERROR_MESSAGE);
    }
    var parsed = parse$1(jsonString);
    if (typeof parsed == "object" && parsed !== null) throw new $SyntaxError$1(ERROR_MESSAGE);
    var obj = create$2(null);
    setInternalState$7(obj, {
      type: "RawJSON"
    });
    createProperty$1(obj, "rawJSON", jsonString);
    return FREEZING$1 ? freeze$1(obj) : obj;
  }
});
if ($stringify) $$1L({
  target: "JSON",
  stat: true,
  arity: 3,
  forced: !NATIVE_RAW_JSON
}, {
  stringify: function stringify(text, replacer2, space) {
    var replacerFunction = getReplacerFunction(replacer2);
    var rawStrings = [];
    var json = $stringify(text, function(key, value) {
      var v = isCallable$8(replacerFunction) ? call$f(replacerFunction, this, $String$1(key), value) : value;
      return isRawJSON2(v) ? MARK + (push$9(rawStrings, v.rawJSON) - 1) : v;
    }, space);
    if (typeof json != "string") return json;
    var result = "";
    var length = json.length;
    for (var i = 0; i < length; i++) {
      var chr = at$1(json, i);
      if (chr === '"') {
        var end = parseJSONString(json, ++i).end - 1;
        var string = slice4(json, i, end);
        result += slice4(string, 0, MARK_LENGTH) === MARK ? rawStrings[slice4(string, MARK_LENGTH)] : '"' + string + '"';
        i = end;
      } else result += chr;
    }
    return result;
  }
});
var has$a = mapHelpers.has;
var aMap$g = function(it) {
  has$a(it);
  return it;
};
var $$1K = _export;
var aMap$f = aMap$g;
var remove$3 = mapHelpers.remove;
$$1K({
  target: "Map",
  proto: true,
  real: true,
  forced: true
}, {
  deleteAll: function deleteAll() {
    var collection2 = aMap$f(this);
    var allDeleted = true;
    var wasDeleted;
    for (var k = 0, len = arguments.length; k < len; k++) {
      wasDeleted = remove$3(collection2, arguments[k]);
      allDeleted = allDeleted && wasDeleted;
    }
    return !!allDeleted;
  }
});
var $$1J = _export;
var aMap$e = aMap$g;
var MapHelpers$9 = mapHelpers;
var get$6 = MapHelpers$9.get;
var has$9 = MapHelpers$9.has;
var set$a = MapHelpers$9.set;
$$1J({
  target: "Map",
  proto: true,
  real: true,
  forced: true
}, {
  emplace: function emplace(key, handler) {
    var map7 = aMap$e(this);
    var value, inserted;
    if (has$9(map7, key)) {
      value = get$6(map7, key);
      if ("update" in handler) {
        value = handler.update(value, key, map7);
        set$a(map7, key, value);
      }
      return value;
    }
    inserted = handler.insert(key, map7);
    set$a(map7, key, inserted);
    return inserted;
  }
});
var $$1I = _export;
var bind$e = functionBindContext;
var aMap$d = aMap$g;
var iterate$m = mapIterate;
$$1I({
  target: "Map",
  proto: true,
  real: true,
  forced: true
}, {
  every: function every5(callbackfn) {
    var map7 = aMap$d(this);
    var boundFunction = bind$e(callbackfn, arguments.length > 1 ? arguments[1] : void 0);
    return iterate$m(map7, function(value, key) {
      if (!boundFunction(value, key, map7)) return false;
    }, true) !== false;
  }
});
var $$1H = _export;
var bind$d = functionBindContext;
var aMap$c = aMap$g;
var MapHelpers$8 = mapHelpers;
var iterate$l = mapIterate;
var Map$6 = MapHelpers$8.Map;
var set$9 = MapHelpers$8.set;
$$1H({
  target: "Map",
  proto: true,
  real: true,
  forced: true
}, {
  filter: function filter5(callbackfn) {
    var map7 = aMap$c(this);
    var boundFunction = bind$d(callbackfn, arguments.length > 1 ? arguments[1] : void 0);
    var newMap = new Map$6();
    iterate$l(map7, function(value, key) {
      if (boundFunction(value, key, map7)) set$9(newMap, key, value);
    });
    return newMap;
  }
});
var $$1G = _export;
var bind$c = functionBindContext;
var aMap$b = aMap$g;
var iterate$k = mapIterate;
$$1G({
  target: "Map",
  proto: true,
  real: true,
  forced: true
}, {
  find: function find5(callbackfn) {
    var map7 = aMap$b(this);
    var boundFunction = bind$c(callbackfn, arguments.length > 1 ? arguments[1] : void 0);
    var result = iterate$k(map7, function(value, key) {
      if (boundFunction(value, key, map7)) return {
        value
      };
    }, true);
    return result && result.value;
  }
});
var $$1F = _export;
var bind$b = functionBindContext;
var aMap$a = aMap$g;
var iterate$j = mapIterate;
$$1F({
  target: "Map",
  proto: true,
  real: true,
  forced: true
}, {
  findKey: function findKey(callbackfn) {
    var map7 = aMap$a(this);
    var boundFunction = bind$b(callbackfn, arguments.length > 1 ? arguments[1] : void 0);
    var result = iterate$j(map7, function(value, key) {
      if (boundFunction(value, key, map7)) return {
        key
      };
    }, true);
    return result && result.key;
  }
});
var bind$a = functionBindContext;
var anObject$i = anObject$1i;
var toObject$2 = toObject$E;
var iterate$i = iterate$H;
var collectionFrom = function(C, adder, ENTRY) {
  return function from7(source) {
    var O = toObject$2(source);
    var length = arguments.length;
    var mapFn = length > 1 ? arguments[1] : void 0;
    var mapping = mapFn !== void 0;
    var boundFunction = mapping ? bind$a(mapFn, length > 2 ? arguments[2] : void 0) : void 0;
    var result = new C();
    var n = 0;
    iterate$i(O, function(nextItem) {
      var entry = mapping ? boundFunction(nextItem, n++) : nextItem;
      if (ENTRY) adder(result, anObject$i(entry)[0], entry[1]);
      else adder(result, entry);
    });
    return result;
  };
};
var $$1E = _export;
var MapHelpers$7 = mapHelpers;
var createCollectionFrom$3 = collectionFrom;
$$1E({
  target: "Map",
  stat: true,
  forced: true
}, {
  from: createCollectionFrom$3(MapHelpers$7.Map, MapHelpers$7.set, true)
});
var $$1D = _export;
var aMap$9 = aMap$g;
var MapHelpers$6 = mapHelpers;
var get$5 = MapHelpers$6.get;
var has$8 = MapHelpers$6.has;
var set$8 = MapHelpers$6.set;
$$1D({
  target: "Map",
  proto: true,
  real: true,
  forced: true
}, {
  getOrInsert: function getOrInsert(key, value) {
    if (has$8(aMap$9(this), key)) return get$5(this, key);
    set$8(this, key, value);
    return value;
  }
});
var $$1C = _export;
var aCallable$8 = aCallable$Q;
var aMap$8 = aMap$g;
var MapHelpers$5 = mapHelpers;
var get$4 = MapHelpers$5.get;
var has$7 = MapHelpers$5.has;
var set$7 = MapHelpers$5.set;
$$1C({
  target: "Map",
  proto: true,
  real: true,
  forced: true
}, {
  getOrInsertComputed: function getOrInsertComputed(key, callbackfn) {
    aMap$8(this);
    aCallable$8(callbackfn);
    if (has$7(this, key)) return get$4(this, key);
    if (key === 0 && 1 / key === -Infinity) key = 0;
    var value = callbackfn(key);
    set$7(this, key, value);
    return value;
  }
});
var sameValueZero$1 = function(x, y) {
  return x === y || x !== x && y !== y;
};
var $$1B = _export;
var sameValueZero = sameValueZero$1;
var aMap$7 = aMap$g;
var iterate$h = mapIterate;
$$1B({
  target: "Map",
  proto: true,
  real: true,
  forced: true
}, {
  includes: function includes4(searchElement) {
    return iterate$h(aMap$7(this), function(value) {
      if (sameValueZero(value, searchElement)) return true;
    }, true) === true;
  }
});
var $$1A = _export;
var call$e = functionCall;
var iterate$g = iterate$H;
var isCallable$7 = isCallable$I;
var aCallable$7 = aCallable$Q;
var Map$5 = mapHelpers.Map;
$$1A({
  target: "Map",
  stat: true,
  forced: true
}, {
  keyBy: function keyBy(iterable, keyDerivative) {
    var C = isCallable$7(this) ? this : Map$5;
    var newMap = new C();
    aCallable$7(keyDerivative);
    var setter = aCallable$7(newMap.set);
    iterate$g(iterable, function(element) {
      call$e(setter, newMap, keyDerivative(element), element);
    });
    return newMap;
  }
});
var $$1z = _export;
var aMap$6 = aMap$g;
var iterate$f = mapIterate;
$$1z({
  target: "Map",
  proto: true,
  real: true,
  forced: true
}, {
  keyOf: function keyOf(searchElement) {
    var result = iterate$f(aMap$6(this), function(value, key) {
      if (value === searchElement) return {
        key
      };
    }, true);
    return result && result.key;
  }
});
var $$1y = _export;
var bind$9 = functionBindContext;
var aMap$5 = aMap$g;
var MapHelpers$4 = mapHelpers;
var iterate$e = mapIterate;
var Map$4 = MapHelpers$4.Map;
var set$6 = MapHelpers$4.set;
$$1y({
  target: "Map",
  proto: true,
  real: true,
  forced: true
}, {
  mapKeys: function mapKeys(callbackfn) {
    var map7 = aMap$5(this);
    var boundFunction = bind$9(callbackfn, arguments.length > 1 ? arguments[1] : void 0);
    var newMap = new Map$4();
    iterate$e(map7, function(value, key) {
      set$6(newMap, boundFunction(value, key, map7), value);
    });
    return newMap;
  }
});
var $$1x = _export;
var bind$8 = functionBindContext;
var aMap$4 = aMap$g;
var MapHelpers$3 = mapHelpers;
var iterate$d = mapIterate;
var Map$3 = MapHelpers$3.Map;
var set$5 = MapHelpers$3.set;
$$1x({
  target: "Map",
  proto: true,
  real: true,
  forced: true
}, {
  mapValues: function mapValues(callbackfn) {
    var map7 = aMap$4(this);
    var boundFunction = bind$8(callbackfn, arguments.length > 1 ? arguments[1] : void 0);
    var newMap = new Map$3();
    iterate$d(map7, function(value, key) {
      set$5(newMap, key, boundFunction(value, key, map7));
    });
    return newMap;
  }
});
var $$1w = _export;
var aMap$3 = aMap$g;
var iterate$c = iterate$H;
var set$4 = mapHelpers.set;
$$1w({
  target: "Map",
  proto: true,
  real: true,
  arity: 1,
  forced: true
}, {
  // eslint-disable-next-line no-unused-vars -- required for `.length`
  merge: function merge(iterable) {
    var map7 = aMap$3(this);
    var argumentsLength = arguments.length;
    var i = 0;
    while (i < argumentsLength) {
      iterate$c(arguments[i++], function(key, value) {
        set$4(map7, key, value);
      }, {
        AS_ENTRIES: true
      });
    }
    return map7;
  }
});
var anObject$h = anObject$1i;
var collectionOf = function(C, adder, ENTRY) {
  return function of4() {
    var result = new C();
    var length = arguments.length;
    for (var index = 0; index < length; index++) {
      var entry = arguments[index];
      if (ENTRY) adder(result, anObject$h(entry)[0], entry[1]);
      else adder(result, entry);
    }
    return result;
  };
};
var $$1v = _export;
var MapHelpers$2 = mapHelpers;
var createCollectionOf$3 = collectionOf;
$$1v({
  target: "Map",
  stat: true,
  forced: true
}, {
  of: createCollectionOf$3(MapHelpers$2.Map, MapHelpers$2.set, true)
});
var $$1u = _export;
var aCallable$6 = aCallable$Q;
var aMap$2 = aMap$g;
var iterate$b = mapIterate;
var $TypeError$d = TypeError;
$$1u({
  target: "Map",
  proto: true,
  real: true,
  forced: true
}, {
  reduce: function reduce5(callbackfn) {
    var map7 = aMap$2(this);
    var noInitial = arguments.length < 2;
    var accumulator = noInitial ? void 0 : arguments[1];
    aCallable$6(callbackfn);
    iterate$b(map7, function(value, key) {
      if (noInitial) {
        noInitial = false;
        accumulator = value;
      } else {
        accumulator = callbackfn(accumulator, value, key, map7);
      }
    });
    if (noInitial) throw new $TypeError$d("Reduce of empty map with no initial value");
    return accumulator;
  }
});
var $$1t = _export;
var bind$7 = functionBindContext;
var aMap$1 = aMap$g;
var iterate$a = mapIterate;
$$1t({
  target: "Map",
  proto: true,
  real: true,
  forced: true
}, {
  some: function some5(callbackfn) {
    var map7 = aMap$1(this);
    var boundFunction = bind$7(callbackfn, arguments.length > 1 ? arguments[1] : void 0);
    return iterate$a(map7, function(value, key) {
      if (boundFunction(value, key, map7)) return true;
    }, true) === true;
  }
});
var $$1s = _export;
var aCallable$5 = aCallable$Q;
var aMap = aMap$g;
var MapHelpers$1 = mapHelpers;
var $TypeError$c = TypeError;
var get$3 = MapHelpers$1.get;
var has$6 = MapHelpers$1.has;
var set$3 = MapHelpers$1.set;
$$1s({
  target: "Map",
  proto: true,
  real: true,
  forced: true
}, {
  update: function update(key, callback2) {
    var map7 = aMap(this);
    var length = arguments.length;
    aCallable$5(callback2);
    var isPresentInMap = has$6(map7, key);
    if (!isPresentInMap && length < 3) {
      throw new $TypeError$c("Updating absent value");
    }
    var value = isPresentInMap ? get$3(map7, key) : aCallable$5(length > 2 ? arguments[2] : void 0)(key, map7);
    set$3(map7, key, callback2(value, key, map7));
    return map7;
  }
});
var call$d = functionCall;
var aCallable$4 = aCallable$Q;
var isCallable$6 = isCallable$I;
var anObject$g = anObject$1i;
var $TypeError$b = TypeError;
var mapUpsert = function upsert(key, updateFn) {
  var map7 = anObject$g(this);
  var get3 = aCallable$4(map7.get);
  var has4 = aCallable$4(map7.has);
  var set4 = aCallable$4(map7.set);
  var insertFn = arguments.length > 2 ? arguments[2] : void 0;
  var value;
  if (!isCallable$6(updateFn) && !isCallable$6(insertFn)) {
    throw new $TypeError$b("At least one callback required");
  }
  if (call$d(has4, map7, key)) {
    value = call$d(get3, map7, key);
    if (isCallable$6(updateFn)) {
      value = updateFn(value);
      call$d(set4, map7, key, value);
    }
  } else if (isCallable$6(insertFn)) {
    value = insertFn();
    call$d(set4, map7, key, value);
  }
  return value;
};
var $$1r = _export;
var upsert$2 = mapUpsert;
$$1r({
  target: "Map",
  proto: true,
  real: true,
  name: "upsert",
  forced: true
}, {
  updateOrInsert: upsert$2
});
var $$1q = _export;
var upsert$1 = mapUpsert;
$$1q({
  target: "Map",
  proto: true,
  real: true,
  forced: true
}, {
  upsert: upsert$1
});
var $TypeError$a = TypeError;
var aNumber$1 = function(argument) {
  if (typeof argument == "number") return argument;
  throw new $TypeError$a("Argument is not a number");
};
var $$1p = _export;
var aNumber = aNumber$1;
var notANaN = notANan;
var sameValue = sameValue$2;
var $RangeError$3 = RangeError;
var $min = Math.min;
var $max = Math.max;
$$1p({
  target: "Math",
  stat: true,
  forced: true
}, {
  clamp: function clamp(value, min2, max2) {
    aNumber(value);
    notANaN(aNumber(min2));
    notANaN(aNumber(max2));
    if (sameValue(min2, 0) && sameValue(max2, -0) || min2 > max2) throw new $RangeError$3("`min` should be smaller than `max`");
    return $min(max2, $max(min2, value));
  }
});
var $$1o = _export;
$$1o({
  target: "Math",
  stat: true,
  nonConfigurable: true,
  nonWritable: true
}, {
  DEG_PER_RAD: Math.PI / 180
});
var $$1n = _export;
var RAD_PER_DEG = 180 / Math.PI;
$$1n({
  target: "Math",
  stat: true,
  forced: true
}, {
  degrees: function degrees(radians2) {
    return radians2 * RAD_PER_DEG;
  }
});
var mathScale = function scale(x, inLow, inHigh, outLow, outHigh) {
  var nx = +x;
  var nInLow = +inLow;
  var nInHigh = +inHigh;
  var nOutLow = +outLow;
  var nOutHigh = +outHigh;
  if (nx !== nx || nInLow !== nInLow || nInHigh !== nInHigh || nOutLow !== nOutLow || nOutHigh !== nOutHigh) return NaN;
  if (nx === Infinity || nx === -Infinity) return nx;
  return (nx - nInLow) * (nOutHigh - nOutLow) / (nInHigh - nInLow) + nOutLow;
};
var $$1m = _export;
var scale$1 = mathScale;
var fround2 = mathFround;
$$1m({
  target: "Math",
  stat: true,
  forced: true
}, {
  fscale: function fscale(x, inLow, inHigh, outLow, outHigh) {
    return fround2(scale$1(x, inLow, inHigh, outLow, outHigh));
  }
});
var $$1l = _export;
$$1l({
  target: "Math",
  stat: true,
  forced: true
}, {
  iaddh: function iaddh(x0, x1, y0, y1) {
    var $x0 = x0 >>> 0;
    var $x1 = x1 >>> 0;
    var $y0 = y0 >>> 0;
    return $x1 + (y1 >>> 0) + (($x0 & $y0 | ($x0 | $y0) & ~($x0 + $y0 >>> 0)) >>> 31) | 0;
  }
});
var $$1k = _export;
$$1k({
  target: "Math",
  stat: true,
  forced: true
}, {
  imulh: function imulh(u, v) {
    var UINT16 = 65535;
    var $u = +u;
    var $v = +v;
    var u0 = $u & UINT16;
    var v0 = $v & UINT16;
    var u1 = $u >> 16;
    var v1 = $v >> 16;
    var t = (u1 * v0 >>> 0) + (u0 * v0 >>> 16);
    return u1 * v1 + (t >> 16) + ((u0 * v1 >>> 0) + (t & UINT16) >> 16);
  }
});
var $$1j = _export;
$$1j({
  target: "Math",
  stat: true,
  forced: true
}, {
  isubh: function isubh(x0, x1, y0, y1) {
    var $x0 = x0 >>> 0;
    var $x1 = x1 >>> 0;
    var $y0 = y0 >>> 0;
    return $x1 - (y1 >>> 0) - ((~$x0 & $y0 | ~($x0 ^ $y0) & $x0 - $y0 >>> 0) >>> 31) | 0;
  }
});
var $$1i = _export;
$$1i({
  target: "Math",
  stat: true,
  nonConfigurable: true,
  nonWritable: true
}, {
  RAD_PER_DEG: 180 / Math.PI
});
var $$1h = _export;
var DEG_PER_RAD = Math.PI / 180;
$$1h({
  target: "Math",
  stat: true,
  forced: true
}, {
  radians: function radians(degrees2) {
    return degrees2 * DEG_PER_RAD;
  }
});
var $$1g = _export;
var scale2 = mathScale;
$$1g({
  target: "Math",
  stat: true,
  forced: true
}, {
  scale: scale2
});
var $$1f = _export;
var anObject$f = anObject$1i;
var numberIsFinite = numberIsFinite$2;
var createIteratorConstructor$3 = iteratorCreateConstructor;
var createIterResultObject$3 = createIterResultObject$i;
var InternalStateModule$6 = internalState;
var SEEDED_RANDOM = "Seeded Random";
var SEEDED_RANDOM_GENERATOR = SEEDED_RANDOM + " Generator";
var SEED_TYPE_ERROR = 'Math.seededPRNG() argument should have a "seed" field with a finite value.';
var setInternalState$6 = InternalStateModule$6.set;
var getInternalState$3 = InternalStateModule$6.getterFor(SEEDED_RANDOM_GENERATOR);
var $TypeError$9 = TypeError;
var $SeededRandomGenerator = createIteratorConstructor$3(function SeededRandomGenerator(seed) {
  setInternalState$6(this, {
    type: SEEDED_RANDOM_GENERATOR,
    seed: seed % 2147483647
  });
}, SEEDED_RANDOM, function next6() {
  var state = getInternalState$3(this);
  var seed = state.seed = (state.seed * 1103515245 + 12345) % 2147483647;
  return createIterResultObject$3((seed & 1073741823) / 1073741823, false);
});
$$1f({
  target: "Math",
  stat: true,
  forced: true
}, {
  seededPRNG: function seededPRNG(it) {
    var seed = anObject$f(it).seed;
    if (!numberIsFinite(seed)) throw new $TypeError$9(SEED_TYPE_ERROR);
    return new $SeededRandomGenerator(seed);
  }
});
var $$1e = _export;
$$1e({
  target: "Math",
  stat: true,
  forced: true
}, {
  signbit: function signbit(x) {
    var n = +x;
    return n === n && n === 0 ? 1 / n === -Infinity : n < 0;
  }
});
var $$1d = _export;
var uncurryThis$p = functionUncurryThis;
var iterate$9 = iterate$H;
var $RangeError$2 = RangeError;
var $TypeError$8 = TypeError;
var $Infinity = Infinity;
var $NaN = NaN;
var abs = Math.abs;
var pow$2 = Math.pow;
var push$8 = uncurryThis$p([].push);
var POW_2_1023 = pow$2(2, 1023);
var MAX_SAFE_INTEGER = pow$2(2, 53) - 1;
var MAX_DOUBLE = Number.MAX_VALUE;
var MAX_ULP = pow$2(2, 971);
var NOT_A_NUMBER = {};
var MINUS_INFINITY = {};
var PLUS_INFINITY = {};
var MINUS_ZERO = {};
var FINITE = {};
var twosum = function(x, y) {
  var hi2 = x + y;
  var lo = y - (hi2 - x);
  return {
    hi: hi2,
    lo
  };
};
$$1d({
  target: "Math",
  stat: true
}, {
  // eslint-disable-next-line max-statements -- ok
  sumPrecise: function sumPrecise(items) {
    var numbers = [];
    var count = 0;
    var state = MINUS_ZERO;
    iterate$9(items, function(n2) {
      if (++count >= MAX_SAFE_INTEGER) throw new $RangeError$2("Maximum allowed index exceeded");
      if (typeof n2 != "number") throw new $TypeError$8("Value is not a number");
      if (state !== NOT_A_NUMBER) {
        if (n2 !== n2) state = NOT_A_NUMBER;
        else if (n2 === $Infinity) state = state === MINUS_INFINITY ? NOT_A_NUMBER : PLUS_INFINITY;
        else if (n2 === -$Infinity) state = state === PLUS_INFINITY ? NOT_A_NUMBER : MINUS_INFINITY;
        else if ((n2 !== 0 || 1 / n2 === $Infinity) && (state === MINUS_ZERO || state === FINITE)) {
          state = FINITE;
          push$8(numbers, n2);
        }
      }
    });
    switch (state) {
      case NOT_A_NUMBER:
        return $NaN;
      case MINUS_INFINITY:
        return -$Infinity;
      case PLUS_INFINITY:
        return $Infinity;
      case MINUS_ZERO:
        return -0;
    }
    var partials = [];
    var overflow = 0;
    var x, y, sum, hi2, lo, tmp;
    for (var i = 0; i < numbers.length; i++) {
      x = numbers[i];
      var actuallyUsedPartials = 0;
      for (var j = 0; j < partials.length; j++) {
        y = partials[j];
        if (abs(x) < abs(y)) {
          tmp = x;
          x = y;
          y = tmp;
        }
        sum = twosum(x, y);
        hi2 = sum.hi;
        lo = sum.lo;
        if (abs(hi2) === $Infinity) {
          var sign3 = hi2 === $Infinity ? 1 : -1;
          overflow += sign3;
          x = x - sign3 * POW_2_1023 - sign3 * POW_2_1023;
          if (abs(x) < abs(y)) {
            tmp = x;
            x = y;
            y = tmp;
          }
          sum = twosum(x, y);
          hi2 = sum.hi;
          lo = sum.lo;
        }
        if (lo !== 0) partials[actuallyUsedPartials++] = lo;
        x = hi2;
      }
      partials.length = actuallyUsedPartials;
      if (x !== 0) push$8(partials, x);
    }
    var n = partials.length - 1;
    hi2 = 0;
    lo = 0;
    if (overflow !== 0) {
      var next11 = n >= 0 ? partials[n] : 0;
      n--;
      if (abs(overflow) > 1 || overflow > 0 && next11 > 0 || overflow < 0 && next11 < 0) {
        return overflow > 0 ? $Infinity : -$Infinity;
      }
      sum = twosum(overflow * POW_2_1023, next11 / 2);
      hi2 = sum.hi;
      lo = sum.lo;
      lo *= 2;
      if (abs(2 * hi2) === $Infinity) {
        if (hi2 > 0) {
          return hi2 === POW_2_1023 && lo === -(MAX_ULP / 2) && n >= 0 && partials[n] < 0 ? MAX_DOUBLE : $Infinity;
        }
        return hi2 === -POW_2_1023 && lo === MAX_ULP / 2 && n >= 0 && partials[n] > 0 ? -MAX_DOUBLE : -$Infinity;
      }
      if (lo !== 0) {
        partials[++n] = lo;
        lo = 0;
      }
      hi2 *= 2;
    }
    while (n >= 0) {
      sum = twosum(hi2, partials[n--]);
      hi2 = sum.hi;
      lo = sum.lo;
      if (lo !== 0) break;
    }
    if (n >= 0 && (lo < 0 && partials[n] < 0 || lo > 0 && partials[n] > 0)) {
      y = lo * 2;
      x = hi2 + y;
      if (y === x - hi2) hi2 = x;
    }
    return hi2;
  }
});
var $$1c = _export;
$$1c({
  target: "Math",
  stat: true,
  forced: true
}, {
  umulh: function umulh(u, v) {
    var UINT16 = 65535;
    var $u = +u;
    var $v = +v;
    var u0 = $u & UINT16;
    var v0 = $v & UINT16;
    var u1 = $u >>> 16;
    var v1 = $v >>> 16;
    var t = (u1 * v0 >>> 0) + (u0 * v0 >>> 16);
    return u1 * v1 + (t >>> 16) + ((u0 * v1 >>> 0) + (t & UINT16) >>> 16);
  }
});
var $$1b = _export;
var uncurryThis$o = functionUncurryThis;
var toIntegerOrInfinity$2 = toIntegerOrInfinity$p;
var INVALID_NUMBER_REPRESENTATION = "Invalid number representation";
var INVALID_RADIX = "Invalid radix";
var $RangeError$1 = RangeError;
var $SyntaxError = SyntaxError;
var $TypeError$7 = TypeError;
var $parseInt$1 = parseInt;
var pow$1 = Math.pow;
var valid = /^[\d.a-z]+$/;
var charAt$9 = uncurryThis$o("".charAt);
var exec$6 = uncurryThis$o(valid.exec);
var numberToString$2 = uncurryThis$o(1 .toString);
var stringSlice$5 = uncurryThis$o("".slice);
var split$4 = uncurryThis$o("".split);
$$1b({
  target: "Number",
  stat: true,
  forced: true
}, {
  fromString: function fromString(string, radix) {
    var sign3 = 1;
    if (typeof string != "string") throw new $TypeError$7(INVALID_NUMBER_REPRESENTATION);
    if (!string.length) throw new $SyntaxError(INVALID_NUMBER_REPRESENTATION);
    if (charAt$9(string, 0) === "-") {
      sign3 = -1;
      string = stringSlice$5(string, 1);
      if (!string.length) throw new $SyntaxError(INVALID_NUMBER_REPRESENTATION);
    }
    var R = radix === void 0 ? 10 : toIntegerOrInfinity$2(radix);
    if (R < 2 || R > 36) throw new $RangeError$1(INVALID_RADIX);
    if (!exec$6(valid, string)) throw new $SyntaxError(INVALID_NUMBER_REPRESENTATION);
    var parts = split$4(string, ".");
    var mathNum = $parseInt$1(parts[0], R);
    if (parts.length > 1) mathNum += $parseInt$1(parts[1], R) / pow$1(R, parts[1].length);
    if (R === 10 && numberToString$2(mathNum, R) !== string) throw new $SyntaxError(INVALID_NUMBER_REPRESENTATION);
    return sign3 * mathNum;
  }
});
var $$1a = _export;
var NumericRangeIterator2 = numericRangeIterator;
$$1a({
  target: "Number",
  stat: true,
  forced: true
}, {
  range: function range2(start2, end, option) {
    return new NumericRangeIterator2(start2, end, option, "number", 0, 1);
  }
});
var InternalStateModule$5 = internalState;
var createIteratorConstructor$2 = iteratorCreateConstructor;
var createIterResultObject$2 = createIterResultObject$i;
var hasOwn$7 = hasOwnProperty_1;
var objectKeys$1 = objectKeys$6;
var toObject$1 = toObject$E;
var OBJECT_ITERATOR = "Object Iterator";
var setInternalState$5 = InternalStateModule$5.set;
var getInternalState$2 = InternalStateModule$5.getterFor(OBJECT_ITERATOR);
var objectIterator = createIteratorConstructor$2(function ObjectIterator(source, mode) {
  var object = toObject$1(source);
  setInternalState$5(this, {
    type: OBJECT_ITERATOR,
    mode,
    object,
    keys: objectKeys$1(object),
    index: 0
  });
}, "Object", function next7() {
  var state = getInternalState$2(this);
  var keys6 = state.keys;
  while (true) {
    if (keys6 === null || state.index >= keys6.length) {
      state.object = state.keys = null;
      return createIterResultObject$2(void 0, true);
    }
    var key = keys6[state.index++];
    var object = state.object;
    if (!hasOwn$7(object, key)) continue;
    switch (state.mode) {
      case "keys":
        return createIterResultObject$2(key, false);
      case "values":
        return createIterResultObject$2(object[key], false);
    }
    return createIterResultObject$2([key, object[key]], false);
  }
});
var $$19 = _export;
var ObjectIterator$2 = objectIterator;
$$19({
  target: "Object",
  stat: true,
  forced: true
}, {
  iterateEntries: function iterateEntries(object) {
    return new ObjectIterator$2(object, "entries");
  }
});
var $$18 = _export;
var ObjectIterator$1 = objectIterator;
$$18({
  target: "Object",
  stat: true,
  forced: true
}, {
  iterateKeys: function iterateKeys(object) {
    return new ObjectIterator$1(object, "keys");
  }
});
var $$17 = _export;
var ObjectIterator2 = objectIterator;
$$17({
  target: "Object",
  stat: true,
  forced: true
}, {
  iterateValues: function iterateValues(object) {
    return new ObjectIterator2(object, "values");
  }
});
var $$16 = _export;
var call$c = functionCall;
var DESCRIPTORS$8 = descriptors;
var setSpecies = setSpecies$7;
var aCallable$3 = aCallable$Q;
var anObject$e = anObject$1i;
var anInstance$4 = anInstance$f;
var isCallable$5 = isCallable$I;
var isNullOrUndefined$2 = isNullOrUndefined$j;
var isObject$4 = isObject$O;
var getMethod$1 = getMethod$l;
var defineBuiltIn$5 = defineBuiltIn$u;
var defineBuiltIns$1 = defineBuiltIns$b;
var defineBuiltInAccessor$5 = defineBuiltInAccessor$p;
var hostReportErrors = hostReportErrors$2;
var wellKnownSymbol$6 = wellKnownSymbol$S;
var InternalStateModule$4 = internalState;
var $$OBSERVABLE$1 = wellKnownSymbol$6("observable");
var OBSERVABLE = "Observable";
var SUBSCRIPTION = "Subscription";
var SUBSCRIPTION_OBSERVER = "SubscriptionObserver";
var getterFor$1 = InternalStateModule$4.getterFor;
var setInternalState$4 = InternalStateModule$4.set;
var getObservableInternalState = getterFor$1(OBSERVABLE);
var getSubscriptionInternalState = getterFor$1(SUBSCRIPTION);
var getSubscriptionObserverInternalState = getterFor$1(SUBSCRIPTION_OBSERVER);
var SubscriptionState = function(observer) {
  this.observer = anObject$e(observer);
  this.cleanup = null;
  this.subscriptionObserver = null;
};
SubscriptionState.prototype = {
  type: SUBSCRIPTION,
  clean: function() {
    var cleanup = this.cleanup;
    if (cleanup) {
      this.cleanup = null;
      try {
        cleanup();
      } catch (error22) {
        hostReportErrors(error22);
      }
    }
  },
  close: function() {
    if (!DESCRIPTORS$8) {
      var subscription = this.facade;
      var subscriptionObserver = this.subscriptionObserver;
      subscription.closed = true;
      if (subscriptionObserver) subscriptionObserver.closed = true;
    }
    this.observer = null;
  },
  isClosed: function() {
    return this.observer === null;
  }
};
var Subscription = function(observer, subscriber) {
  var subscriptionState = setInternalState$4(this, new SubscriptionState(observer));
  var start2;
  if (!DESCRIPTORS$8) this.closed = false;
  try {
    if (start2 = getMethod$1(observer, "start")) call$c(start2, observer, this);
  } catch (error22) {
    hostReportErrors(error22);
  }
  if (subscriptionState.isClosed()) return;
  var subscriptionObserver = subscriptionState.subscriptionObserver = new SubscriptionObserver(subscriptionState);
  try {
    var cleanup = subscriber(subscriptionObserver);
    var subscription = cleanup;
    if (!isNullOrUndefined$2(cleanup)) subscriptionState.cleanup = isCallable$5(cleanup.unsubscribe) ? function() {
      subscription.unsubscribe();
    } : aCallable$3(cleanup);
  } catch (error22) {
    subscriptionObserver.error(error22);
    return;
  }
  if (subscriptionState.isClosed()) subscriptionState.clean();
};
Subscription.prototype = defineBuiltIns$1({}, {
  unsubscribe: function unsubscribe() {
    var subscriptionState = getSubscriptionInternalState(this);
    if (!subscriptionState.isClosed()) {
      subscriptionState.close();
      subscriptionState.clean();
    }
  }
});
if (DESCRIPTORS$8) defineBuiltInAccessor$5(Subscription.prototype, "closed", {
  configurable: true,
  get: function closed() {
    return getSubscriptionInternalState(this).isClosed();
  }
});
var SubscriptionObserver = function(subscriptionState) {
  setInternalState$4(this, {
    type: SUBSCRIPTION_OBSERVER,
    subscriptionState
  });
  if (!DESCRIPTORS$8) this.closed = false;
};
SubscriptionObserver.prototype = defineBuiltIns$1({}, {
  next: function next8(value) {
    var subscriptionState = getSubscriptionObserverInternalState(this).subscriptionState;
    if (!subscriptionState.isClosed()) {
      var observer = subscriptionState.observer;
      try {
        var nextMethod = getMethod$1(observer, "next");
        if (nextMethod) call$c(nextMethod, observer, value);
      } catch (error22) {
        hostReportErrors(error22);
      }
    }
  },
  error: function error(value) {
    var subscriptionState = getSubscriptionObserverInternalState(this).subscriptionState;
    if (!subscriptionState.isClosed()) {
      var observer = subscriptionState.observer;
      subscriptionState.close();
      try {
        var errorMethod = getMethod$1(observer, "error");
        if (errorMethod) call$c(errorMethod, observer, value);
        else hostReportErrors(value);
      } catch (err) {
        hostReportErrors(err);
      }
      subscriptionState.clean();
    }
  },
  complete: function complete() {
    var subscriptionState = getSubscriptionObserverInternalState(this).subscriptionState;
    if (!subscriptionState.isClosed()) {
      var observer = subscriptionState.observer;
      subscriptionState.close();
      try {
        var completeMethod = getMethod$1(observer, "complete");
        if (completeMethod) call$c(completeMethod, observer);
      } catch (error22) {
        hostReportErrors(error22);
      }
      subscriptionState.clean();
    }
  }
});
if (DESCRIPTORS$8) defineBuiltInAccessor$5(SubscriptionObserver.prototype, "closed", {
  configurable: true,
  get: function closed2() {
    return getSubscriptionObserverInternalState(this).subscriptionState.isClosed();
  }
});
var $Observable = function Observable(subscriber) {
  anInstance$4(this, ObservablePrototype);
  setInternalState$4(this, {
    type: OBSERVABLE,
    subscriber: aCallable$3(subscriber)
  });
};
var ObservablePrototype = $Observable.prototype;
defineBuiltIns$1(ObservablePrototype, {
  subscribe: function subscribe(observer) {
    var length = arguments.length;
    return new Subscription(isCallable$5(observer) ? {
      next: observer,
      error: length > 1 ? arguments[1] : void 0,
      complete: length > 2 ? arguments[2] : void 0
    } : isObject$4(observer) ? observer : {}, getObservableInternalState(this).subscriber);
  }
});
defineBuiltIn$5(ObservablePrototype, $$OBSERVABLE$1, function() {
  return this;
});
$$16({
  global: true,
  constructor: true,
  forced: true
}, {
  Observable: $Observable
});
setSpecies(OBSERVABLE);
var $$15 = _export;
var getBuiltIn$g = getBuiltIn$Q;
var call$b = functionCall;
var anObject$d = anObject$1i;
var isConstructor$2 = isConstructor$a;
var getIterator$1 = getIterator$7;
var getMethod = getMethod$l;
var iterate$8 = iterate$H;
var wellKnownSymbol$5 = wellKnownSymbol$S;
var $$OBSERVABLE = wellKnownSymbol$5("observable");
$$15({
  target: "Observable",
  stat: true,
  forced: true
}, {
  from: function from6(x) {
    var C = isConstructor$2(this) ? this : getBuiltIn$g("Observable");
    var observableMethod = getMethod(anObject$d(x), $$OBSERVABLE);
    if (observableMethod) {
      var observable = anObject$d(call$b(observableMethod, x));
      return observable.constructor === C ? observable : new C(function(observer) {
        return observable.subscribe(observer);
      });
    }
    var iterator = getIterator$1(x);
    return new C(function(observer) {
      iterate$8(iterator, function(it, stop) {
        observer.next(it);
        if (observer.closed) return stop();
      }, {
        IS_ITERATOR: true,
        INTERRUPTED: true
      });
      observer.complete();
    });
  }
});
var $$14 = _export;
var getBuiltIn$f = getBuiltIn$Q;
var isConstructor$1 = isConstructor$a;
var Array$2 = getBuiltIn$f("Array");
$$14({
  target: "Observable",
  stat: true,
  forced: true
}, {
  of: function of3() {
    var C = isConstructor$1(this) ? this : getBuiltIn$f("Observable");
    var length = arguments.length;
    var items = Array$2(length);
    var index = 0;
    while (index < length) items[index] = arguments[index++];
    return new C(function(observer) {
      for (var i = 0; i < length; i++) {
        observer.next(items[i]);
        if (observer.closed) return;
      }
      observer.complete();
    });
  }
});
var getBuiltIn$e = getBuiltIn$Q;
var uncurryThis$n = functionUncurryThis;
var shared$1 = shared$a;
var Map$2 = getBuiltIn$e("Map");
var WeakMap$1 = getBuiltIn$e("WeakMap");
var push$7 = uncurryThis$n([].push);
var metadata$1 = shared$1("metadata");
var store$1 = metadata$1.store || (metadata$1.store = new WeakMap$1());
var getOrCreateMetadataMap$1 = function(target, targetKey, create4) {
  var targetMetadata = store$1.get(target);
  if (!targetMetadata) {
    if (!create4) return;
    store$1.set(target, targetMetadata = new Map$2());
  }
  var keyMetadata = targetMetadata.get(targetKey);
  if (!keyMetadata) {
    if (!create4) return;
    targetMetadata.set(targetKey, keyMetadata = new Map$2());
  }
  return keyMetadata;
};
var ordinaryHasOwnMetadata$3 = function(MetadataKey, O, P) {
  var metadataMap = getOrCreateMetadataMap$1(O, P, false);
  return metadataMap === void 0 ? false : metadataMap.has(MetadataKey);
};
var ordinaryGetOwnMetadata$2 = function(MetadataKey, O, P) {
  var metadataMap = getOrCreateMetadataMap$1(O, P, false);
  return metadataMap === void 0 ? void 0 : metadataMap.get(MetadataKey);
};
var ordinaryDefineOwnMetadata$2 = function(MetadataKey, MetadataValue, O, P) {
  getOrCreateMetadataMap$1(O, P, true).set(MetadataKey, MetadataValue);
};
var ordinaryOwnMetadataKeys$2 = function(target, targetKey) {
  var metadataMap = getOrCreateMetadataMap$1(target, targetKey, false);
  var keys6 = [];
  if (metadataMap) metadataMap.forEach(function(_, key) {
    push$7(keys6, key);
  });
  return keys6;
};
var toMetadataKey$9 = function(it) {
  return it === void 0 || typeof it == "symbol" ? it : String(it);
};
var reflectMetadata = {
  store: store$1,
  getMap: getOrCreateMetadataMap$1,
  has: ordinaryHasOwnMetadata$3,
  get: ordinaryGetOwnMetadata$2,
  set: ordinaryDefineOwnMetadata$2,
  keys: ordinaryOwnMetadataKeys$2,
  toKey: toMetadataKey$9
};
var $$13 = _export;
var ReflectMetadataModule$8 = reflectMetadata;
var anObject$c = anObject$1i;
var toMetadataKey$8 = ReflectMetadataModule$8.toKey;
var ordinaryDefineOwnMetadata$1 = ReflectMetadataModule$8.set;
$$13({
  target: "Reflect",
  stat: true
}, {
  defineMetadata: function defineMetadata(metadataKey, metadataValue, target) {
    var targetKey = arguments.length < 4 ? void 0 : toMetadataKey$8(arguments[3]);
    ordinaryDefineOwnMetadata$1(metadataKey, metadataValue, anObject$c(target), targetKey);
  }
});
var $$12 = _export;
var ReflectMetadataModule$7 = reflectMetadata;
var anObject$b = anObject$1i;
var toMetadataKey$7 = ReflectMetadataModule$7.toKey;
var getOrCreateMetadataMap = ReflectMetadataModule$7.getMap;
var store = ReflectMetadataModule$7.store;
$$12({
  target: "Reflect",
  stat: true
}, {
  deleteMetadata: function deleteMetadata(metadataKey, target) {
    var targetKey = arguments.length < 3 ? void 0 : toMetadataKey$7(arguments[2]);
    var metadataMap = getOrCreateMetadataMap(anObject$b(target), targetKey, false);
    if (metadataMap === void 0 || !metadataMap["delete"](metadataKey)) return false;
    if (metadataMap.size) return true;
    var targetMetadata = store.get(target);
    targetMetadata["delete"](targetKey);
    return !!targetMetadata.size || store["delete"](target);
  }
});
var $$11 = _export;
var ReflectMetadataModule$6 = reflectMetadata;
var anObject$a = anObject$1i;
var getPrototypeOf$2 = objectGetPrototypeOf$2;
var ordinaryHasOwnMetadata$2 = ReflectMetadataModule$6.has;
var ordinaryGetOwnMetadata$1 = ReflectMetadataModule$6.get;
var toMetadataKey$6 = ReflectMetadataModule$6.toKey;
var ordinaryGetMetadata = function(MetadataKey, O, P) {
  var hasOwn3 = ordinaryHasOwnMetadata$2(MetadataKey, O, P);
  if (hasOwn3) return ordinaryGetOwnMetadata$1(MetadataKey, O, P);
  var parent = getPrototypeOf$2(O);
  return parent !== null ? ordinaryGetMetadata(MetadataKey, parent, P) : void 0;
};
$$11({
  target: "Reflect",
  stat: true
}, {
  getMetadata: function getMetadata(metadataKey, target) {
    var targetKey = arguments.length < 3 ? void 0 : toMetadataKey$6(arguments[2]);
    return ordinaryGetMetadata(metadataKey, anObject$a(target), targetKey);
  }
});
var $$10 = _export;
var uncurryThis$m = functionUncurryThis;
var ReflectMetadataModule$5 = reflectMetadata;
var anObject$9 = anObject$1i;
var getPrototypeOf$1 = objectGetPrototypeOf$2;
var $arrayUniqueBy$1 = arrayUniqueBy$2;
var arrayUniqueBy$1 = uncurryThis$m($arrayUniqueBy$1);
var concat3 = uncurryThis$m([].concat);
var ordinaryOwnMetadataKeys$1 = ReflectMetadataModule$5.keys;
var toMetadataKey$5 = ReflectMetadataModule$5.toKey;
var ordinaryMetadataKeys = function(O, P) {
  var oKeys = ordinaryOwnMetadataKeys$1(O, P);
  var parent = getPrototypeOf$1(O);
  if (parent === null) return oKeys;
  var pKeys = ordinaryMetadataKeys(parent, P);
  return pKeys.length ? oKeys.length ? arrayUniqueBy$1(concat3(oKeys, pKeys)) : pKeys : oKeys;
};
$$10({
  target: "Reflect",
  stat: true
}, {
  getMetadataKeys: function getMetadataKeys(target) {
    var targetKey = arguments.length < 2 ? void 0 : toMetadataKey$5(arguments[1]);
    return ordinaryMetadataKeys(anObject$9(target), targetKey);
  }
});
var $$$ = _export;
var ReflectMetadataModule$4 = reflectMetadata;
var anObject$8 = anObject$1i;
var ordinaryGetOwnMetadata = ReflectMetadataModule$4.get;
var toMetadataKey$4 = ReflectMetadataModule$4.toKey;
$$$({
  target: "Reflect",
  stat: true
}, {
  getOwnMetadata: function getOwnMetadata(metadataKey, target) {
    var targetKey = arguments.length < 3 ? void 0 : toMetadataKey$4(arguments[2]);
    return ordinaryGetOwnMetadata(metadataKey, anObject$8(target), targetKey);
  }
});
var $$_ = _export;
var ReflectMetadataModule$3 = reflectMetadata;
var anObject$7 = anObject$1i;
var ordinaryOwnMetadataKeys = ReflectMetadataModule$3.keys;
var toMetadataKey$3 = ReflectMetadataModule$3.toKey;
$$_({
  target: "Reflect",
  stat: true
}, {
  getOwnMetadataKeys: function getOwnMetadataKeys(target) {
    var targetKey = arguments.length < 2 ? void 0 : toMetadataKey$3(arguments[1]);
    return ordinaryOwnMetadataKeys(anObject$7(target), targetKey);
  }
});
var $$Z = _export;
var ReflectMetadataModule$2 = reflectMetadata;
var anObject$6 = anObject$1i;
var getPrototypeOf3 = objectGetPrototypeOf$2;
var ordinaryHasOwnMetadata$1 = ReflectMetadataModule$2.has;
var toMetadataKey$2 = ReflectMetadataModule$2.toKey;
var ordinaryHasMetadata = function(MetadataKey, O, P) {
  var hasOwn3 = ordinaryHasOwnMetadata$1(MetadataKey, O, P);
  if (hasOwn3) return true;
  var parent = getPrototypeOf3(O);
  return parent !== null ? ordinaryHasMetadata(MetadataKey, parent, P) : false;
};
$$Z({
  target: "Reflect",
  stat: true
}, {
  hasMetadata: function hasMetadata(metadataKey, target) {
    var targetKey = arguments.length < 3 ? void 0 : toMetadataKey$2(arguments[2]);
    return ordinaryHasMetadata(metadataKey, anObject$6(target), targetKey);
  }
});
var $$Y = _export;
var ReflectMetadataModule$1 = reflectMetadata;
var anObject$5 = anObject$1i;
var ordinaryHasOwnMetadata = ReflectMetadataModule$1.has;
var toMetadataKey$1 = ReflectMetadataModule$1.toKey;
$$Y({
  target: "Reflect",
  stat: true
}, {
  hasOwnMetadata: function hasOwnMetadata(metadataKey, target) {
    var targetKey = arguments.length < 3 ? void 0 : toMetadataKey$1(arguments[2]);
    return ordinaryHasOwnMetadata(metadataKey, anObject$5(target), targetKey);
  }
});
var $$X = _export;
var ReflectMetadataModule = reflectMetadata;
var anObject$4 = anObject$1i;
var toMetadataKey = ReflectMetadataModule.toKey;
var ordinaryDefineOwnMetadata = ReflectMetadataModule.set;
$$X({
  target: "Reflect",
  stat: true
}, {
  metadata: function metadata(metadataKey, metadataValue) {
    return function decorator(target, key) {
      ordinaryDefineOwnMetadata(metadataKey, metadataValue, anObject$4(target), toMetadataKey(key));
    };
  }
});
var $$W = _export;
var aSet$8 = aSet$g;
var add$3 = setHelpers.add;
$$W({
  target: "Set",
  proto: true,
  real: true,
  forced: true
}, {
  addAll: function addAll() {
    var set4 = aSet$8(this);
    for (var k = 0, len = arguments.length; k < len; k++) {
      add$3(set4, arguments[k]);
    }
    return set4;
  }
});
var $$V = _export;
var aSet$7 = aSet$g;
var remove$2 = setHelpers.remove;
$$V({
  target: "Set",
  proto: true,
  real: true,
  forced: true
}, {
  deleteAll: function deleteAll2() {
    var collection2 = aSet$7(this);
    var allDeleted = true;
    var wasDeleted;
    for (var k = 0, len = arguments.length; k < len; k++) {
      wasDeleted = remove$2(collection2, arguments[k]);
      allDeleted = allDeleted && wasDeleted;
    }
    return !!allDeleted;
  }
});
var classof$3 = classof$q;
var hasOwn$6 = hasOwnProperty_1;
var isNullOrUndefined$1 = isNullOrUndefined$j;
var wellKnownSymbol$4 = wellKnownSymbol$S;
var Iterators = iterators;
var ITERATOR$3 = wellKnownSymbol$4("iterator");
var $Object = Object;
var isIterable$1 = function(it) {
  if (isNullOrUndefined$1(it)) return false;
  var O = $Object(it);
  return O[ITERATOR$3] !== void 0 || "@@iterator" in O || hasOwn$6(Iterators, classof$3(O));
};
var getBuiltIn$d = getBuiltIn$Q;
var isCallable$4 = isCallable$I;
var isIterable = isIterable$1;
var isObject$3 = isObject$O;
var Set$4 = getBuiltIn$d("Set");
var isSetLike = function(it) {
  return isObject$3(it) && typeof it.size == "number" && isCallable$4(it.has) && isCallable$4(it.keys);
};
var toSetLike$7 = function(it) {
  if (isSetLike(it)) return it;
  return isIterable(it) ? new Set$4(it) : it;
};
var $$U = _export;
var call$a = functionCall;
var toSetLike$6 = toSetLike$7;
var $difference = setDifference;
$$U({
  target: "Set",
  proto: true,
  real: true,
  forced: true
}, {
  difference: function difference3(other) {
    return call$a($difference, this, toSetLike$6(other));
  }
});
var $$T = _export;
var bind$6 = functionBindContext;
var aSet$6 = aSet$g;
var iterate$7 = setIterate$1;
$$T({
  target: "Set",
  proto: true,
  real: true,
  forced: true
}, {
  every: function every6(callbackfn) {
    var set4 = aSet$6(this);
    var boundFunction = bind$6(callbackfn, arguments.length > 1 ? arguments[1] : void 0);
    return iterate$7(set4, function(value) {
      if (!boundFunction(value, value, set4)) return false;
    }, true) !== false;
  }
});
var $$S = _export;
var bind$5 = functionBindContext;
var aSet$5 = aSet$g;
var SetHelpers$4 = setHelpers;
var iterate$6 = setIterate$1;
var Set$3 = SetHelpers$4.Set;
var add$2 = SetHelpers$4.add;
$$S({
  target: "Set",
  proto: true,
  real: true,
  forced: true
}, {
  filter: function filter6(callbackfn) {
    var set4 = aSet$5(this);
    var boundFunction = bind$5(callbackfn, arguments.length > 1 ? arguments[1] : void 0);
    var newSet = new Set$3();
    iterate$6(set4, function(value) {
      if (boundFunction(value, value, set4)) add$2(newSet, value);
    });
    return newSet;
  }
});
var $$R = _export;
var bind$4 = functionBindContext;
var aSet$4 = aSet$g;
var iterate$5 = setIterate$1;
$$R({
  target: "Set",
  proto: true,
  real: true,
  forced: true
}, {
  find: function find6(callbackfn) {
    var set4 = aSet$4(this);
    var boundFunction = bind$4(callbackfn, arguments.length > 1 ? arguments[1] : void 0);
    var result = iterate$5(set4, function(value) {
      if (boundFunction(value, value, set4)) return {
        value
      };
    }, true);
    return result && result.value;
  }
});
var $$Q = _export;
var SetHelpers$3 = setHelpers;
var createCollectionFrom$2 = collectionFrom;
$$Q({
  target: "Set",
  stat: true,
  forced: true
}, {
  from: createCollectionFrom$2(SetHelpers$3.Set, SetHelpers$3.add, false)
});
var $$P = _export;
var call$9 = functionCall;
var toSetLike$5 = toSetLike$7;
var $intersection = setIntersection;
$$P({
  target: "Set",
  proto: true,
  real: true,
  forced: true
}, {
  intersection: function intersection3(other) {
    return call$9($intersection, this, toSetLike$5(other));
  }
});
var $$O = _export;
var call$8 = functionCall;
var toSetLike$4 = toSetLike$7;
var $isDisjointFrom = setIsDisjointFrom;
$$O({
  target: "Set",
  proto: true,
  real: true,
  forced: true
}, {
  isDisjointFrom: function isDisjointFrom3(other) {
    return call$8($isDisjointFrom, this, toSetLike$4(other));
  }
});
var $$N = _export;
var call$7 = functionCall;
var toSetLike$3 = toSetLike$7;
var $isSubsetOf = setIsSubsetOf;
$$N({
  target: "Set",
  proto: true,
  real: true,
  forced: true
}, {
  isSubsetOf: function isSubsetOf3(other) {
    return call$7($isSubsetOf, this, toSetLike$3(other));
  }
});
var $$M = _export;
var call$6 = functionCall;
var toSetLike$2 = toSetLike$7;
var $isSupersetOf = setIsSupersetOf;
$$M({
  target: "Set",
  proto: true,
  real: true,
  forced: true
}, {
  isSupersetOf: function isSupersetOf3(other) {
    return call$6($isSupersetOf, this, toSetLike$2(other));
  }
});
var $$L = _export;
var uncurryThis$l = functionUncurryThis;
var aSet$3 = aSet$g;
var iterate$4 = setIterate$1;
var toString$9 = toString$J;
var arrayJoin = uncurryThis$l([].join);
var push$6 = uncurryThis$l([].push);
$$L({
  target: "Set",
  proto: true,
  real: true,
  forced: true
}, {
  join: function join3(separator) {
    var set4 = aSet$3(this);
    var sep = separator === void 0 ? "," : toString$9(separator);
    var array = [];
    iterate$4(set4, function(value) {
      push$6(array, value);
    });
    return arrayJoin(array, sep);
  }
});
var $$K = _export;
var bind$3 = functionBindContext;
var aSet$2 = aSet$g;
var SetHelpers$2 = setHelpers;
var iterate$3 = setIterate$1;
var Set$2 = SetHelpers$2.Set;
var add$1 = SetHelpers$2.add;
$$K({
  target: "Set",
  proto: true,
  real: true,
  forced: true
}, {
  map: function map6(callbackfn) {
    var set4 = aSet$2(this);
    var boundFunction = bind$3(callbackfn, arguments.length > 1 ? arguments[1] : void 0);
    var newSet = new Set$2();
    iterate$3(set4, function(value) {
      add$1(newSet, boundFunction(value, value, set4));
    });
    return newSet;
  }
});
var $$J = _export;
var SetHelpers$1 = setHelpers;
var createCollectionOf$2 = collectionOf;
$$J({
  target: "Set",
  stat: true,
  forced: true
}, {
  of: createCollectionOf$2(SetHelpers$1.Set, SetHelpers$1.add, false)
});
var $$I = _export;
var aCallable$2 = aCallable$Q;
var aSet$1 = aSet$g;
var iterate$2 = setIterate$1;
var $TypeError$6 = TypeError;
$$I({
  target: "Set",
  proto: true,
  real: true,
  forced: true
}, {
  reduce: function reduce6(callbackfn) {
    var set4 = aSet$1(this);
    var noInitial = arguments.length < 2;
    var accumulator = noInitial ? void 0 : arguments[1];
    aCallable$2(callbackfn);
    iterate$2(set4, function(value) {
      if (noInitial) {
        noInitial = false;
        accumulator = value;
      } else {
        accumulator = callbackfn(accumulator, value, value, set4);
      }
    });
    if (noInitial) throw new $TypeError$6("Reduce of empty set with no initial value");
    return accumulator;
  }
});
var $$H = _export;
var bind$2 = functionBindContext;
var aSet = aSet$g;
var iterate$1 = setIterate$1;
$$H({
  target: "Set",
  proto: true,
  real: true,
  forced: true
}, {
  some: function some6(callbackfn) {
    var set4 = aSet(this);
    var boundFunction = bind$2(callbackfn, arguments.length > 1 ? arguments[1] : void 0);
    return iterate$1(set4, function(value) {
      if (boundFunction(value, value, set4)) return true;
    }, true) === true;
  }
});
var $$G = _export;
var call$5 = functionCall;
var toSetLike$1 = toSetLike$7;
var $symmetricDifference = setSymmetricDifference;
$$G({
  target: "Set",
  proto: true,
  real: true,
  forced: true
}, {
  symmetricDifference: function symmetricDifference3(other) {
    return call$5($symmetricDifference, this, toSetLike$1(other));
  }
});
var $$F = _export;
var call$4 = functionCall;
var toSetLike = toSetLike$7;
var $union = setUnion;
$$F({
  target: "Set",
  proto: true,
  real: true,
  forced: true
}, {
  union: function union3(other) {
    return call$4($union, this, toSetLike(other));
  }
});
var $$E = _export;
var charAt$8 = stringMultibyte.charAt;
var requireObjectCoercible$1 = requireObjectCoercible$q;
var toIntegerOrInfinity$1 = toIntegerOrInfinity$p;
var toString$8 = toString$J;
$$E({
  target: "String",
  proto: true,
  forced: true
}, {
  at: function at4(index) {
    var S = toString$8(requireObjectCoercible$1(this));
    var len = S.length;
    var relativeIndex = toIntegerOrInfinity$1(index);
    var k = relativeIndex >= 0 ? relativeIndex : len + relativeIndex;
    return k < 0 || k >= len ? void 0 : charAt$8(S, k);
  }
});
var uncurryThis$k = functionUncurryThis;
var toIndexedObject = toIndexedObject$k;
var toString$7 = toString$J;
var lengthOfArrayLike$3 = lengthOfArrayLike$B;
var $TypeError$5 = TypeError;
var push$5 = uncurryThis$k([].push);
var join$3 = uncurryThis$k([].join);
var stringCooked = function cooked(template) {
  var cookedTemplate = toIndexedObject(template);
  var literalSegments = lengthOfArrayLike$3(cookedTemplate);
  if (!literalSegments) return "";
  var argumentsLength = arguments.length;
  var elements = [];
  var i = 0;
  while (true) {
    var nextVal = cookedTemplate[i++];
    if (nextVal === void 0) throw new $TypeError$5("Incorrect template");
    push$5(elements, toString$7(nextVal));
    if (i === literalSegments) return join$3(elements, "");
    if (i < argumentsLength) push$5(elements, toString$7(arguments[i]));
  }
};
var $$D = _export;
var cooked$1 = stringCooked;
$$D({
  target: "String",
  stat: true,
  forced: true
}, {
  cooked: cooked$1
});
var $$C = _export;
var createIteratorConstructor$1 = iteratorCreateConstructor;
var createIterResultObject$1 = createIterResultObject$i;
var requireObjectCoercible = requireObjectCoercible$q;
var toString$6 = toString$J;
var InternalStateModule$3 = internalState;
var StringMultibyteModule = stringMultibyte;
var codeAt$1 = StringMultibyteModule.codeAt;
var charAt$7 = StringMultibyteModule.charAt;
var STRING_ITERATOR = "String Iterator";
var setInternalState$3 = InternalStateModule$3.set;
var getInternalState$1 = InternalStateModule$3.getterFor(STRING_ITERATOR);
var $StringIterator = createIteratorConstructor$1(function StringIterator(string) {
  setInternalState$3(this, {
    type: STRING_ITERATOR,
    string,
    index: 0
  });
}, "String", function next9() {
  var state = getInternalState$1(this);
  var string = state.string;
  var index = state.index;
  var point;
  if (index >= string.length) return createIterResultObject$1(void 0, true);
  point = charAt$7(string, index);
  state.index += point.length;
  return createIterResultObject$1({
    codePoint: codeAt$1(point, 0),
    position: index
  }, false);
});
$$C({
  target: "String",
  proto: true,
  forced: true
}, {
  codePoints: function codePoints2() {
    return new $StringIterator(toString$6(requireObjectCoercible(this)));
  }
});
var uncurryThis$j = functionUncurryThis;
var WeakMapPrototype = WeakMap.prototype;
var weakMapHelpers = {
  // eslint-disable-next-line es/no-weak-map -- safe
  WeakMap,
  set: uncurryThis$j(WeakMapPrototype.set),
  get: uncurryThis$j(WeakMapPrototype.get),
  has: uncurryThis$j(WeakMapPrototype.has),
  remove: uncurryThis$j(WeakMapPrototype["delete"])
};
var getBuiltIn$c = getBuiltIn$Q;
var uncurryThis$i = functionUncurryThis;
var fromCharCode$3 = String.fromCharCode;
var fromCodePoint$1 = getBuiltIn$c("String", "fromCodePoint");
var charAt$6 = uncurryThis$i("".charAt);
var charCodeAt$2 = uncurryThis$i("".charCodeAt);
var stringIndexOf = uncurryThis$i("".indexOf);
var stringSlice$4 = uncurryThis$i("".slice);
var ZERO_CODE = 48;
var NINE_CODE = 57;
var LOWER_A_CODE = 97;
var LOWER_F_CODE = 102;
var UPPER_A_CODE = 65;
var UPPER_F_CODE = 70;
var isDigit = function(str, index) {
  var c = charCodeAt$2(str, index);
  return c >= ZERO_CODE && c <= NINE_CODE;
};
var parseHex = function(str, index, end) {
  if (end >= str.length) return -1;
  var n = 0;
  for (; index < end; index++) {
    var c = hexToInt(charCodeAt$2(str, index));
    if (c === -1) return -1;
    n = n * 16 + c;
  }
  return n;
};
var hexToInt = function(c) {
  if (c >= ZERO_CODE && c <= NINE_CODE) return c - ZERO_CODE;
  if (c >= LOWER_A_CODE && c <= LOWER_F_CODE) return c - LOWER_A_CODE + 10;
  if (c >= UPPER_A_CODE && c <= UPPER_F_CODE) return c - UPPER_A_CODE + 10;
  return -1;
};
var stringParse = function(raw3) {
  var out = "";
  var start2 = 0;
  var i = 0;
  var n;
  while ((i = stringIndexOf(raw3, "\\", i)) > -1) {
    out += stringSlice$4(raw3, start2, i);
    if (++i === raw3.length) return;
    var next11 = charAt$6(raw3, i++);
    switch (next11) {
      case "b":
        out += "\b";
        break;
      case "t":
        out += "	";
        break;
      case "n":
        out += "\n";
        break;
      case "v":
        out += "\v";
        break;
      case "f":
        out += "\f";
        break;
      case "r":
        out += "\r";
        break;
      case "\r":
        if (i < raw3.length && charAt$6(raw3, i) === "\n") ++i;
      case "\n":
      case "\u2028":
      case "\u2029":
        break;
      case "0":
        if (isDigit(raw3, i)) return;
        out += "\0";
        break;
      case "x":
        n = parseHex(raw3, i, i + 2);
        if (n === -1) return;
        i += 2;
        out += fromCharCode$3(n);
        break;
      case "u":
        if (i < raw3.length && charAt$6(raw3, i) === "{") {
          var end = stringIndexOf(raw3, "}", ++i);
          if (end === -1) return;
          n = parseHex(raw3, i, end);
          i = end + 1;
        } else {
          n = parseHex(raw3, i, i + 4);
          i += 4;
        }
        if (n === -1 || n > 1114111) return;
        out += fromCodePoint$1(n);
        break;
      default:
        if (isDigit(next11, 0)) return;
        out += next11;
    }
    start2 = i;
  }
  return out + stringSlice$4(raw3, start2);
};
var FREEZING = freezing;
var $$B = _export;
var makeBuiltIn = makeBuiltInExports;
var uncurryThis$h = functionUncurryThis;
var apply$1 = functionApply$1;
var anObject$3 = anObject$1i;
var toObject = toObject$E;
var isCallable$3 = isCallable$I;
var lengthOfArrayLike$2 = lengthOfArrayLike$B;
var defineProperty$5 = objectDefineProperty.f;
var createArrayFromList = arraySlice$a;
var WeakMapHelpers$5 = weakMapHelpers;
var cooked2 = stringCooked;
var parse2 = stringParse;
var whitespaces$1 = whitespaces$6;
var DedentMap = new WeakMapHelpers$5.WeakMap();
var weakMapGet = WeakMapHelpers$5.get;
var weakMapHas = WeakMapHelpers$5.has;
var weakMapSet = WeakMapHelpers$5.set;
var $Array = Array;
var $TypeError$4 = TypeError;
var freeze2 = Object.freeze || Object;
var isFrozen2 = Object.isFrozen;
var min$2 = Math.min;
var charAt$5 = uncurryThis$h("".charAt);
var stringSlice$3 = uncurryThis$h("".slice);
var split$3 = uncurryThis$h("".split);
var exec$5 = uncurryThis$h(/./.exec);
var NEW_LINE = /([\n\u2028\u2029]|\r\n?)/g;
var LEADING_WHITESPACE = RegExp("^[" + whitespaces$1 + "]*");
var NON_WHITESPACE = RegExp("[^" + whitespaces$1 + "]");
var INVALID_TAG = "Invalid tag";
var INVALID_OPENING_LINE = "Invalid opening line";
var INVALID_CLOSING_LINE = "Invalid closing line";
var dedentTemplateStringsArray = function(template) {
  var rawInput = template.raw;
  if (FREEZING && !isFrozen2(rawInput)) throw new $TypeError$4("Raw template should be frozen");
  if (weakMapHas(DedentMap, rawInput)) return weakMapGet(DedentMap, rawInput);
  var raw3 = dedentStringsArray(rawInput);
  var cookedArr = cookStrings(raw3);
  defineProperty$5(cookedArr, "raw", {
    value: freeze2(raw3)
  });
  freeze2(cookedArr);
  weakMapSet(DedentMap, rawInput, cookedArr);
  return cookedArr;
};
var dedentStringsArray = function(template) {
  var t = toObject(template);
  var length = lengthOfArrayLike$2(t);
  var blocks = $Array(length);
  var dedented = $Array(length);
  var i = 0;
  var lines, common, quasi, k;
  if (!length) throw new $TypeError$4(INVALID_TAG);
  for (; i < length; i++) {
    var element = t[i];
    if (typeof element == "string") blocks[i] = split$3(element, NEW_LINE);
    else throw new $TypeError$4(INVALID_TAG);
  }
  for (i = 0; i < length; i++) {
    var lastSplit = i + 1 === length;
    lines = blocks[i];
    if (i === 0) {
      if (lines.length === 1 || lines[0].length > 0) {
        throw new $TypeError$4(INVALID_OPENING_LINE);
      }
      lines[1] = "";
    }
    if (lastSplit) {
      if (lines.length === 1 || exec$5(NON_WHITESPACE, lines[lines.length - 1])) {
        throw new $TypeError$4(INVALID_CLOSING_LINE);
      }
      lines[lines.length - 2] = "";
      lines[lines.length - 1] = "";
    }
    for (var j = 2; j < lines.length; j += 2) {
      var text = lines[j];
      var lineContainsTemplateExpression = j + 1 === lines.length && !lastSplit;
      var leading = exec$5(LEADING_WHITESPACE, text)[0];
      if (!lineContainsTemplateExpression && leading.length === text.length) {
        lines[j] = "";
        continue;
      }
      common = commonLeadingIndentation(leading, common);
    }
  }
  var count = common ? common.length : 0;
  for (i = 0; i < length; i++) {
    lines = blocks[i];
    quasi = lines[0];
    k = 1;
    for (; k < lines.length; k += 2) {
      quasi += lines[k] + stringSlice$3(lines[k + 1], count);
    }
    dedented[i] = quasi;
  }
  return dedented;
};
var commonLeadingIndentation = function(a, b) {
  if (b === void 0 || a === b) return a;
  var i = 0;
  for (var len = min$2(a.length, b.length); i < len; i++) {
    if (charAt$5(a, i) !== charAt$5(b, i)) break;
  }
  return stringSlice$3(a, 0, i);
};
var cookStrings = function(raw3) {
  var i = 0;
  var length = raw3.length;
  var result = $Array(length);
  for (; i < length; i++) {
    result[i] = parse2(raw3[i]);
  }
  return result;
};
var makeDedentTag = function(tag) {
  return makeBuiltIn(function(template) {
    var args = createArrayFromList(arguments);
    args[0] = dedentTemplateStringsArray(anObject$3(template));
    return apply$1(tag, this, args);
  }, "");
};
var cookedDedentTag = makeDedentTag(cooked2);
$$B({
  target: "String",
  stat: true,
  forced: true
}, {
  dedent: function dedent(templateOrFn) {
    anObject$3(templateOrFn);
    if (isCallable$3(templateOrFn)) return makeDedentTag(templateOrFn);
    return apply$1(cookedDedentTag, this, arguments);
  }
});
var globalThis$p = globalThis_1;
var defineWellKnownSymbol$8 = wellKnownSymbolDefine;
var defineProperty$4 = objectDefineProperty.f;
var getOwnPropertyDescriptor$1 = objectGetOwnPropertyDescriptor.f;
var Symbol$4 = globalThis$p.Symbol;
defineWellKnownSymbol$8("asyncDispose");
if (Symbol$4) {
  var descriptor$4 = getOwnPropertyDescriptor$1(Symbol$4, "asyncDispose");
  if (descriptor$4.enumerable && descriptor$4.configurable && descriptor$4.writable) {
    defineProperty$4(Symbol$4, "asyncDispose", {
      value: descriptor$4.value,
      enumerable: false,
      configurable: false,
      writable: false
    });
  }
}
var defineWellKnownSymbol$7 = wellKnownSymbolDefine;
defineWellKnownSymbol$7("customMatcher");
var globalThis$o = globalThis_1;
var defineWellKnownSymbol$6 = wellKnownSymbolDefine;
var defineProperty$3 = objectDefineProperty.f;
var getOwnPropertyDescriptor6 = objectGetOwnPropertyDescriptor.f;
var Symbol$3 = globalThis$o.Symbol;
defineWellKnownSymbol$6("dispose");
if (Symbol$3) {
  var descriptor$3 = getOwnPropertyDescriptor6(Symbol$3, "dispose");
  if (descriptor$3.enumerable && descriptor$3.configurable && descriptor$3.writable) {
    defineProperty$3(Symbol$3, "dispose", {
      value: descriptor$3.value,
      enumerable: false,
      configurable: false,
      writable: false
    });
  }
}
var getBuiltIn$b = getBuiltIn$Q;
var uncurryThis$g = functionUncurryThis;
var Symbol$2 = getBuiltIn$b("Symbol");
var keyFor2 = Symbol$2.keyFor;
var thisSymbolValue$1 = uncurryThis$g(Symbol$2.prototype.valueOf);
var symbolIsRegistered = Symbol$2.isRegisteredSymbol || function isRegisteredSymbol(value) {
  try {
    return keyFor2(thisSymbolValue$1(value)) !== void 0;
  } catch (error3) {
    return false;
  }
};
var $$A = _export;
var isRegisteredSymbol$1 = symbolIsRegistered;
$$A({
  target: "Symbol",
  stat: true
}, {
  isRegisteredSymbol: isRegisteredSymbol$1
});
var $$z = _export;
var isRegisteredSymbol2 = symbolIsRegistered;
$$z({
  target: "Symbol",
  stat: true,
  name: "isRegisteredSymbol"
}, {
  isRegistered: isRegisteredSymbol2
});
var shared = shared$a;
var getBuiltIn$a = getBuiltIn$Q;
var uncurryThis$f = functionUncurryThis;
var isSymbol$1 = isSymbol$8;
var wellKnownSymbol$3 = wellKnownSymbol$S;
var Symbol$1 = getBuiltIn$a("Symbol");
var $isWellKnownSymbol = Symbol$1.isWellKnownSymbol;
var getOwnPropertyNames4 = getBuiltIn$a("Object", "getOwnPropertyNames");
var thisSymbolValue = uncurryThis$f(Symbol$1.prototype.valueOf);
var WellKnownSymbolsStore = shared("wks");
for (var i = 0, symbolKeys = getOwnPropertyNames4(Symbol$1), symbolKeysLength = symbolKeys.length; i < symbolKeysLength; i++) {
  try {
    var symbolKey = symbolKeys[i];
    if (isSymbol$1(Symbol$1[symbolKey])) wellKnownSymbol$3(symbolKey);
  } catch (error3) {
  }
}
var symbolIsWellKnown = function isWellKnownSymbol(value) {
  if ($isWellKnownSymbol && $isWellKnownSymbol(value)) return true;
  try {
    var symbol = thisSymbolValue(value);
    for (var j = 0, keys6 = getOwnPropertyNames4(WellKnownSymbolsStore), keysLength = keys6.length; j < keysLength; j++) {
      if (WellKnownSymbolsStore[keys6[j]] == symbol) return true;
    }
  } catch (error3) {
  }
  return false;
};
var $$y = _export;
var isWellKnownSymbol$1 = symbolIsWellKnown;
$$y({
  target: "Symbol",
  stat: true,
  forced: true
}, {
  isWellKnownSymbol: isWellKnownSymbol$1
});
var $$x = _export;
var isWellKnownSymbol2 = symbolIsWellKnown;
$$x({
  target: "Symbol",
  stat: true,
  name: "isWellKnownSymbol",
  forced: true
}, {
  isWellKnown: isWellKnownSymbol2
});
var defineWellKnownSymbol$5 = wellKnownSymbolDefine;
defineWellKnownSymbol$5("matcher");
var defineWellKnownSymbol$4 = wellKnownSymbolDefine;
defineWellKnownSymbol$4("metadata");
var defineWellKnownSymbol$3 = wellKnownSymbolDefine;
defineWellKnownSymbol$3("metadataKey");
var defineWellKnownSymbol$2 = wellKnownSymbolDefine;
defineWellKnownSymbol$2("observable");
var defineWellKnownSymbol$1 = wellKnownSymbolDefine;
defineWellKnownSymbol$1("patternMatch");
var defineWellKnownSymbol = wellKnownSymbolDefine;
defineWellKnownSymbol("replaceAll");
var getBuiltIn$9 = getBuiltIn$Q;
var aConstructor = aConstructor$4;
var arrayFromAsync = arrayFromAsync$1;
var ArrayBufferViewCore$5 = arrayBufferViewCore;
var arrayFromConstructorAndList$2 = arrayFromConstructorAndList$8;
var aTypedArrayConstructor = ArrayBufferViewCore$5.aTypedArrayConstructor;
var exportTypedArrayStaticMethod = ArrayBufferViewCore$5.exportTypedArrayStaticMethod;
exportTypedArrayStaticMethod("fromAsync", function fromAsync3(asyncItems) {
  var C = this;
  var argumentsLength = arguments.length;
  var mapfn = argumentsLength > 1 ? arguments[1] : void 0;
  var thisArg = argumentsLength > 2 ? arguments[2] : void 0;
  return new (getBuiltIn$9("Promise"))(function(resolve2) {
    aConstructor(C);
    resolve2(arrayFromAsync(asyncItems, mapfn, thisArg));
  }).then(function(list) {
    return arrayFromConstructorAndList$2(aTypedArrayConstructor(C), list);
  });
}, true);
var ArrayBufferViewCore$4 = arrayBufferViewCore;
var $filterReject$1 = arrayIteration.filterReject;
var fromSameTypeAndList$1 = typedArrayFromSameTypeAndList;
var aTypedArray$4 = ArrayBufferViewCore$4.aTypedArray;
var exportTypedArrayMethod$4 = ArrayBufferViewCore$4.exportTypedArrayMethod;
exportTypedArrayMethod$4("filterOut", function filterOut2(callbackfn) {
  var list = $filterReject$1(aTypedArray$4(this), callbackfn, arguments.length > 1 ? arguments[1] : void 0);
  return fromSameTypeAndList$1(this, list);
}, true);
var ArrayBufferViewCore$3 = arrayBufferViewCore;
var $filterReject = arrayIteration.filterReject;
var fromSameTypeAndList = typedArrayFromSameTypeAndList;
var aTypedArray$3 = ArrayBufferViewCore$3.aTypedArray;
var exportTypedArrayMethod$3 = ArrayBufferViewCore$3.exportTypedArrayMethod;
exportTypedArrayMethod$3("filterReject", function filterReject2(callbackfn) {
  var list = $filterReject(aTypedArray$3(this), callbackfn, arguments.length > 1 ? arguments[1] : void 0);
  return fromSameTypeAndList(this, list);
}, true);
var ArrayBufferViewCore$2 = arrayBufferViewCore;
var $group = arrayGroup;
var aTypedArray$2 = ArrayBufferViewCore$2.aTypedArray;
var getTypedArrayConstructor$2 = ArrayBufferViewCore$2.getTypedArrayConstructor;
var exportTypedArrayMethod$2 = ArrayBufferViewCore$2.exportTypedArrayMethod;
exportTypedArrayMethod$2("groupBy", function groupBy4(callbackfn) {
  var thisArg = arguments.length > 1 ? arguments[1] : void 0;
  return $group(aTypedArray$2(this), callbackfn, thisArg, getTypedArrayConstructor$2);
}, true);
var ArrayBufferViewCore$1 = arrayBufferViewCore;
var lengthOfArrayLike$1 = lengthOfArrayLike$B;
var isBigIntArray = isBigIntArray$3;
var toAbsoluteIndex = toAbsoluteIndex$a;
var toBigInt = toBigInt$4;
var toIntegerOrInfinity = toIntegerOrInfinity$p;
var aTypedArray$1 = ArrayBufferViewCore$1.aTypedArray;
var getTypedArrayConstructor$1 = ArrayBufferViewCore$1.getTypedArrayConstructor;
var exportTypedArrayMethod$1 = ArrayBufferViewCore$1.exportTypedArrayMethod;
var max = Math.max;
var min$1 = Math.min;
exportTypedArrayMethod$1("toSpliced", function toSpliced2(start2, deleteCount) {
  var O = aTypedArray$1(this);
  var C = getTypedArrayConstructor$1(O);
  var len = lengthOfArrayLike$1(O);
  var actualStart = toAbsoluteIndex(start2, len);
  var argumentsLength = arguments.length;
  var k = 0;
  var insertCount, actualDeleteCount, thisIsBigIntArray, convertedItems, value, newLen, A;
  if (argumentsLength === 0) {
    insertCount = actualDeleteCount = 0;
  } else if (argumentsLength === 1) {
    insertCount = 0;
    actualDeleteCount = len - actualStart;
  } else {
    actualDeleteCount = min$1(max(toIntegerOrInfinity(deleteCount), 0), len - actualStart);
    insertCount = argumentsLength - 2;
    if (insertCount) {
      convertedItems = new C(insertCount);
      thisIsBigIntArray = isBigIntArray(convertedItems);
      for (var i = 2; i < argumentsLength; i++) {
        value = arguments[i];
        convertedItems[i - 2] = thisIsBigIntArray ? toBigInt(value) : +value;
      }
    }
  }
  newLen = len + insertCount - actualDeleteCount;
  A = new C(newLen);
  for (; k < actualStart; k++) A[k] = O[k];
  for (; k < actualStart + insertCount; k++) A[k] = convertedItems[k - actualStart];
  for (; k < newLen; k++) A[k] = O[k + actualDeleteCount - insertCount];
  return A;
}, true);
var uncurryThis$e = functionUncurryThis;
var ArrayBufferViewCore = arrayBufferViewCore;
var arrayFromConstructorAndList$1 = arrayFromConstructorAndList$8;
var $arrayUniqueBy = arrayUniqueBy$2;
var aTypedArray = ArrayBufferViewCore.aTypedArray;
var getTypedArrayConstructor = ArrayBufferViewCore.getTypedArrayConstructor;
var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
var arrayUniqueBy = uncurryThis$e($arrayUniqueBy);
exportTypedArrayMethod("uniqueBy", function uniqueBy3(resolver) {
  aTypedArray(this);
  return arrayFromConstructorAndList$1(getTypedArrayConstructor(this), arrayUniqueBy(this, resolver));
}, true);
var isObject$2 = isObject$O;
var $String = String;
var $TypeError$3 = TypeError;
var anObjectOrUndefined$2 = function(argument) {
  if (argument === void 0 || isObject$2(argument)) return argument;
  throw new $TypeError$3($String(argument) + " is not an object or undefined");
};
var commonAlphabet = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
var base64Alphabet$2 = commonAlphabet + "+/";
var base64UrlAlphabet$2 = commonAlphabet + "-_";
var inverse = function(characters) {
  var result = {};
  var index = 0;
  for (; index < 64; index++) result[characters.charAt(index)] = index;
  return result;
};
var base64Map$2 = {
  i2c: base64Alphabet$2,
  c2i: inverse(base64Alphabet$2),
  i2cUrl: base64UrlAlphabet$2,
  c2iUrl: inverse(base64UrlAlphabet$2)
};
var $TypeError$2 = TypeError;
var getAlphabetOption$2 = function(options) {
  var alphabet = options && options.alphabet;
  if (alphabet === void 0 || alphabet === "base64" || alphabet === "base64url") return alphabet || "base64";
  throw new $TypeError$2("Incorrect `alphabet` option");
};
var globalThis$n = globalThis_1;
var uncurryThis$d = functionUncurryThis;
var anObjectOrUndefined$1 = anObjectOrUndefined$2;
var aString$2 = aString$4;
var hasOwn$5 = hasOwnProperty_1;
var base64Map$1 = base64Map$2;
var getAlphabetOption$1 = getAlphabetOption$2;
var notDetached$3 = arrayBufferNotDetached;
var base64Alphabet$1 = base64Map$1.c2i;
var base64UrlAlphabet$1 = base64Map$1.c2iUrl;
var SyntaxError$2 = globalThis$n.SyntaxError;
var TypeError$4 = globalThis$n.TypeError;
var at5 = uncurryThis$d("".charAt);
var skipAsciiWhitespace = function(string, index) {
  var length = string.length;
  for (; index < length; index++) {
    var chr = at5(string, index);
    if (chr !== " " && chr !== "	" && chr !== "\n" && chr !== "\f" && chr !== "\r") break;
  }
  return index;
};
var decodeBase64Chunk = function(chunk, alphabet, throwOnExtraBits) {
  var chunkLength = chunk.length;
  if (chunkLength < 4) {
    chunk += chunkLength === 2 ? "AA" : "A";
  }
  var triplet = (alphabet[at5(chunk, 0)] << 18) + (alphabet[at5(chunk, 1)] << 12) + (alphabet[at5(chunk, 2)] << 6) + alphabet[at5(chunk, 3)];
  var chunkBytes = [triplet >> 16 & 255, triplet >> 8 & 255, triplet & 255];
  if (chunkLength === 2) {
    if (throwOnExtraBits && chunkBytes[1] !== 0) {
      throw new SyntaxError$2("Extra bits");
    }
    return [chunkBytes[0]];
  }
  if (chunkLength === 3) {
    if (throwOnExtraBits && chunkBytes[2] !== 0) {
      throw new SyntaxError$2("Extra bits");
    }
    return [chunkBytes[0], chunkBytes[1]];
  }
  return chunkBytes;
};
var writeBytes = function(bytes, elements, written) {
  var elementsLength = elements.length;
  for (var index = 0; index < elementsLength; index++) {
    bytes[written + index] = elements[index];
  }
  return written + elementsLength;
};
var uint8FromBase64 = function(string, options, into, maxLength) {
  aString$2(string);
  anObjectOrUndefined$1(options);
  var alphabet = getAlphabetOption$1(options) === "base64" ? base64Alphabet$1 : base64UrlAlphabet$1;
  var lastChunkHandling = options ? options.lastChunkHandling : void 0;
  if (lastChunkHandling === void 0) lastChunkHandling = "loose";
  if (lastChunkHandling !== "loose" && lastChunkHandling !== "strict" && lastChunkHandling !== "stop-before-partial") {
    throw new TypeError$4("Incorrect `lastChunkHandling` option");
  }
  if (into) notDetached$3(into.buffer);
  var bytes = into || [];
  var written = 0;
  var read = 0;
  var chunk = "";
  var index = 0;
  if (maxLength) while (true) {
    index = skipAsciiWhitespace(string, index);
    if (index === string.length) {
      if (chunk.length > 0) {
        if (lastChunkHandling === "stop-before-partial") {
          break;
        }
        if (lastChunkHandling === "loose") {
          if (chunk.length === 1) {
            throw new SyntaxError$2("Malformed padding: exactly one additional character");
          }
          written = writeBytes(bytes, decodeBase64Chunk(chunk, alphabet, false), written);
        } else {
          throw new SyntaxError$2("Missing padding");
        }
      }
      read = string.length;
      break;
    }
    var chr = at5(string, index);
    ++index;
    if (chr === "=") {
      if (chunk.length < 2) {
        throw new SyntaxError$2("Padding is too early");
      }
      index = skipAsciiWhitespace(string, index);
      if (chunk.length === 2) {
        if (index === string.length) {
          if (lastChunkHandling === "stop-before-partial") {
            break;
          }
          throw new SyntaxError$2("Malformed padding: only one =");
        }
        if (at5(string, index) === "=") {
          ++index;
          index = skipAsciiWhitespace(string, index);
        }
      }
      if (index < string.length) {
        throw new SyntaxError$2("Unexpected character after padding");
      }
      written = writeBytes(bytes, decodeBase64Chunk(chunk, alphabet, lastChunkHandling === "strict"), written);
      read = string.length;
      break;
    }
    if (!hasOwn$5(alphabet, chr)) {
      throw new SyntaxError$2("Unexpected character");
    }
    var remainingBytes = maxLength - written;
    if (remainingBytes === 1 && chunk.length === 2 || remainingBytes === 2 && chunk.length === 3) {
      break;
    }
    chunk += chr;
    if (chunk.length === 4) {
      written = writeBytes(bytes, decodeBase64Chunk(chunk, alphabet, false), written);
      chunk = "";
      read = index;
      if (written === maxLength) {
        break;
      }
    }
  }
  return {
    bytes,
    read,
    written
  };
};
var $$w = _export;
var globalThis$m = globalThis_1;
var arrayFromConstructorAndList = arrayFromConstructorAndList$8;
var $fromBase64$1 = uint8FromBase64;
var Uint8Array$3 = globalThis$m.Uint8Array;
if (Uint8Array$3) $$w({
  target: "Uint8Array",
  stat: true
}, {
  fromBase64: function fromBase64(string) {
    var result = $fromBase64$1(string, arguments.length > 1 ? arguments[1] : void 0, null, 9007199254740991);
    return arrayFromConstructorAndList(Uint8Array$3, result.bytes);
  }
});
var globalThis$l = globalThis_1;
var uncurryThis$c = functionUncurryThis;
var Uint8Array$2 = globalThis$l.Uint8Array;
var SyntaxError$1 = globalThis$l.SyntaxError;
var parseInt$2 = globalThis$l.parseInt;
var min = Math.min;
var NOT_HEX = /[^\da-f]/i;
var exec$4 = uncurryThis$c(NOT_HEX.exec);
var stringSlice$2 = uncurryThis$c("".slice);
var uint8FromHex = function(string, into) {
  var stringLength = string.length;
  if (stringLength % 2 !== 0) throw new SyntaxError$1("String should be an even number of characters");
  var maxLength = into ? min(into.length, stringLength / 2) : stringLength / 2;
  var bytes = into || new Uint8Array$2(maxLength);
  var read = 0;
  var written = 0;
  while (written < maxLength) {
    var hexits = stringSlice$2(string, read, read += 2);
    if (exec$4(NOT_HEX, hexits)) throw new SyntaxError$1("String should only contain hex characters");
    bytes[written++] = parseInt$2(hexits, 16);
  }
  return {
    bytes,
    read
  };
};
var $$v = _export;
var globalThis$k = globalThis_1;
var aString$1 = aString$4;
var $fromHex$1 = uint8FromHex;
if (globalThis$k.Uint8Array) $$v({
  target: "Uint8Array",
  stat: true
}, {
  fromHex: function fromHex(string) {
    return $fromHex$1(aString$1(string)).bytes;
  }
});
var classof$2 = classof$q;
var $TypeError$1 = TypeError;
var anUint8Array$4 = function(argument) {
  if (classof$2(argument) === "Uint8Array") return argument;
  throw new $TypeError$1("Argument is not an Uint8Array");
};
var $$u = _export;
var globalThis$j = globalThis_1;
var $fromBase64 = uint8FromBase64;
var anUint8Array$3 = anUint8Array$4;
var Uint8Array$1 = globalThis$j.Uint8Array;
if (Uint8Array$1) $$u({
  target: "Uint8Array",
  proto: true
}, {
  setFromBase64: function setFromBase64(string) {
    anUint8Array$3(this);
    var result = $fromBase64(string, arguments.length > 1 ? arguments[1] : void 0, this, this.length);
    return {
      read: result.read,
      written: result.written
    };
  }
});
var $$t = _export;
var globalThis$i = globalThis_1;
var aString = aString$4;
var anUint8Array$2 = anUint8Array$4;
var notDetached$2 = arrayBufferNotDetached;
var $fromHex = uint8FromHex;
if (globalThis$i.Uint8Array) $$t({
  target: "Uint8Array",
  proto: true
}, {
  setFromHex: function setFromHex(string) {
    anUint8Array$2(this);
    aString(string);
    notDetached$2(this.buffer);
    var read = $fromHex(string, this).read;
    return {
      read,
      written: read / 2
    };
  }
});
var $$s = _export;
var globalThis$h = globalThis_1;
var uncurryThis$b = functionUncurryThis;
var anObjectOrUndefined = anObjectOrUndefined$2;
var anUint8Array$1 = anUint8Array$4;
var notDetached$1 = arrayBufferNotDetached;
var base64Map = base64Map$2;
var getAlphabetOption = getAlphabetOption$2;
var base64Alphabet = base64Map.i2c;
var base64UrlAlphabet = base64Map.i2cUrl;
var charAt$4 = uncurryThis$b("".charAt);
if (globalThis$h.Uint8Array) $$s({
  target: "Uint8Array",
  proto: true
}, {
  toBase64: function toBase64() {
    var array = anUint8Array$1(this);
    var options = arguments.length ? anObjectOrUndefined(arguments[0]) : void 0;
    var alphabet = getAlphabetOption(options) === "base64" ? base64Alphabet : base64UrlAlphabet;
    var omitPadding = !!options && !!options.omitPadding;
    notDetached$1(this.buffer);
    var result = "";
    var i = 0;
    var length = array.length;
    var triplet;
    var at6 = function(shift2) {
      return charAt$4(alphabet, triplet >> 6 * shift2 & 63);
    };
    for (; i + 2 < length; i += 3) {
      triplet = (array[i] << 16) + (array[i + 1] << 8) + array[i + 2];
      result += at6(3) + at6(2) + at6(1) + at6(0);
    }
    if (i + 2 === length) {
      triplet = (array[i] << 16) + (array[i + 1] << 8);
      result += at6(3) + at6(2) + at6(1) + (omitPadding ? "" : "=");
    } else if (i + 1 === length) {
      triplet = array[i] << 16;
      result += at6(3) + at6(2) + (omitPadding ? "" : "==");
    }
    return result;
  }
});
var $$r = _export;
var globalThis$g = globalThis_1;
var uncurryThis$a = functionUncurryThis;
var anUint8Array = anUint8Array$4;
var notDetached = arrayBufferNotDetached;
var numberToString$1 = uncurryThis$a(1 .toString);
if (globalThis$g.Uint8Array) $$r({
  target: "Uint8Array",
  proto: true
}, {
  toHex: function toHex() {
    anUint8Array(this);
    notDetached(this.buffer);
    var result = "";
    for (var i = 0, length = this.length; i < length; i++) {
      var hex3 = numberToString$1(this[i], 16);
      result += hex3.length === 1 ? "0" + hex3 : hex3;
    }
    return result;
  }
});
var has$5 = weakMapHelpers.has;
var aWeakMap$4 = function(it) {
  has$5(it);
  return it;
};
var $$q = _export;
var aWeakMap$3 = aWeakMap$4;
var remove$1 = weakMapHelpers.remove;
$$q({
  target: "WeakMap",
  proto: true,
  real: true,
  forced: true
}, {
  deleteAll: function deleteAll3() {
    var collection2 = aWeakMap$3(this);
    var allDeleted = true;
    var wasDeleted;
    for (var k = 0, len = arguments.length; k < len; k++) {
      wasDeleted = remove$1(collection2, arguments[k]);
      allDeleted = allDeleted && wasDeleted;
    }
    return !!allDeleted;
  }
});
var $$p = _export;
var WeakMapHelpers$4 = weakMapHelpers;
var createCollectionFrom$1 = collectionFrom;
$$p({
  target: "WeakMap",
  stat: true,
  forced: true
}, {
  from: createCollectionFrom$1(WeakMapHelpers$4.WeakMap, WeakMapHelpers$4.set, true)
});
var $$o = _export;
var WeakMapHelpers$3 = weakMapHelpers;
var createCollectionOf$1 = collectionOf;
$$o({
  target: "WeakMap",
  stat: true,
  forced: true
}, {
  of: createCollectionOf$1(WeakMapHelpers$3.WeakMap, WeakMapHelpers$3.set, true)
});
var $$n = _export;
var aWeakMap$2 = aWeakMap$4;
var WeakMapHelpers$2 = weakMapHelpers;
var get$2 = WeakMapHelpers$2.get;
var has$4 = WeakMapHelpers$2.has;
var set$2 = WeakMapHelpers$2.set;
$$n({
  target: "WeakMap",
  proto: true,
  real: true,
  forced: true
}, {
  emplace: function emplace2(key, handler) {
    var map7 = aWeakMap$2(this);
    var value, inserted;
    if (has$4(map7, key)) {
      value = get$2(map7, key);
      if ("update" in handler) {
        value = handler.update(value, key, map7);
        set$2(map7, key, value);
      }
      return value;
    }
    inserted = handler.insert(key, map7);
    set$2(map7, key, inserted);
    return inserted;
  }
});
var $$m = _export;
var aWeakMap$1 = aWeakMap$4;
var WeakMapHelpers$1 = weakMapHelpers;
var get$1 = WeakMapHelpers$1.get;
var has$3 = WeakMapHelpers$1.has;
var set$1 = WeakMapHelpers$1.set;
$$m({
  target: "WeakMap",
  proto: true,
  real: true,
  forced: true
}, {
  getOrInsert: function getOrInsert2(key, value) {
    if (has$3(aWeakMap$1(this), key)) return get$1(this, key);
    set$1(this, key, value);
    return value;
  }
});
var $$l = _export;
var aCallable$1 = aCallable$Q;
var aWeakMap = aWeakMap$4;
var WeakMapHelpers = weakMapHelpers;
var get = WeakMapHelpers.get;
var has$2 = WeakMapHelpers.has;
var set2 = WeakMapHelpers.set;
$$l({
  target: "WeakMap",
  proto: true,
  real: true,
  forced: true
}, {
  getOrInsertComputed: function getOrInsertComputed2(key, callbackfn) {
    aWeakMap(this);
    aCallable$1(callbackfn);
    if (has$2(this, key)) return get(this, key);
    set2(this, key);
    var value = callbackfn(key);
    set2(this, key, value);
    return value;
  }
});
var $$k = _export;
var upsert2 = mapUpsert;
$$k({
  target: "WeakMap",
  proto: true,
  real: true,
  forced: true
}, {
  upsert: upsert2
});
var uncurryThis$9 = functionUncurryThis;
var WeakSetPrototype = WeakSet.prototype;
var weakSetHelpers = {
  // eslint-disable-next-line es/no-weak-set -- safe
  WeakSet,
  add: uncurryThis$9(WeakSetPrototype.add),
  has: uncurryThis$9(WeakSetPrototype.has),
  remove: uncurryThis$9(WeakSetPrototype["delete"])
};
var has$1 = weakSetHelpers.has;
var aWeakSet$2 = function(it) {
  has$1(it);
  return it;
};
var $$j = _export;
var aWeakSet$1 = aWeakSet$2;
var add = weakSetHelpers.add;
$$j({
  target: "WeakSet",
  proto: true,
  real: true,
  forced: true
}, {
  addAll: function addAll2() {
    var set4 = aWeakSet$1(this);
    for (var k = 0, len = arguments.length; k < len; k++) {
      add(set4, arguments[k]);
    }
    return set4;
  }
});
var $$i = _export;
var aWeakSet = aWeakSet$2;
var remove = weakSetHelpers.remove;
$$i({
  target: "WeakSet",
  proto: true,
  real: true,
  forced: true
}, {
  deleteAll: function deleteAll4() {
    var collection2 = aWeakSet(this);
    var allDeleted = true;
    var wasDeleted;
    for (var k = 0, len = arguments.length; k < len; k++) {
      wasDeleted = remove(collection2, arguments[k]);
      allDeleted = allDeleted && wasDeleted;
    }
    return !!allDeleted;
  }
});
var $$h = _export;
var WeakSetHelpers$1 = weakSetHelpers;
var createCollectionFrom = collectionFrom;
$$h({
  target: "WeakSet",
  stat: true,
  forced: true
}, {
  from: createCollectionFrom(WeakSetHelpers$1.WeakSet, WeakSetHelpers$1.add, false)
});
var $$g = _export;
var WeakSetHelpers = weakSetHelpers;
var createCollectionOf = collectionOf;
$$g({
  target: "WeakSet",
  stat: true,
  forced: true
}, {
  of: createCollectionOf(WeakSetHelpers.WeakSet, WeakSetHelpers.add, false)
});
var $$f = _export;
var globalThis$f = globalThis_1;
var getBuiltIn$8 = getBuiltIn$Q;
var uncurryThis$8 = functionUncurryThis;
var call$3 = functionCall;
var fails$6 = fails$1z;
var toString$5 = toString$J;
var validateArgumentsLength$a = validateArgumentsLength$c;
var c2i = base64Map$2.c2i;
var disallowed = /[^\d+/a-z]/i;
var whitespaces = /[\t\n\f\r ]+/g;
var finalEq = /[=]{1,2}$/;
var $atob = getBuiltIn$8("atob");
var fromCharCode$2 = String.fromCharCode;
var charAt$3 = uncurryThis$8("".charAt);
var replace$3 = uncurryThis$8("".replace);
var exec$3 = uncurryThis$8(disallowed.exec);
var BASIC$1 = !!$atob && !fails$6(function() {
  return $atob("aGk=") !== "hi";
});
var NO_SPACES_IGNORE = BASIC$1 && fails$6(function() {
  return $atob(" ") !== "";
});
var NO_ENCODING_CHECK = BASIC$1 && !fails$6(function() {
  $atob("a");
});
var NO_ARG_RECEIVING_CHECK$1 = BASIC$1 && !fails$6(function() {
  $atob();
});
var WRONG_ARITY$3 = BASIC$1 && $atob.length !== 1;
var FORCED = !BASIC$1 || NO_SPACES_IGNORE || NO_ENCODING_CHECK || NO_ARG_RECEIVING_CHECK$1 || WRONG_ARITY$3;
$$f({
  global: true,
  bind: true,
  enumerable: true,
  forced: FORCED
}, {
  atob: function atob(data2) {
    validateArgumentsLength$a(arguments.length, 1);
    if (BASIC$1 && !NO_SPACES_IGNORE && !NO_ENCODING_CHECK) return call$3($atob, globalThis$f, data2);
    var string = replace$3(toString$5(data2), whitespaces, "");
    var output = "";
    var position = 0;
    var bc = 0;
    var length, chr, bs;
    if (string.length % 4 === 0) {
      string = replace$3(string, finalEq, "");
    }
    length = string.length;
    if (length % 4 === 1 || exec$3(disallowed, string)) {
      throw new (getBuiltIn$8("DOMException"))("The string is not correctly encoded", "InvalidCharacterError");
    }
    while (position < length) {
      chr = charAt$3(string, position++);
      bs = bc % 4 ? bs * 64 + c2i[chr] : c2i[chr];
      if (bc++ % 4) output += fromCharCode$2(255 & bs >> (-2 * bc & 6));
    }
    return output;
  }
});
var $$e = _export;
var globalThis$e = globalThis_1;
var getBuiltIn$7 = getBuiltIn$Q;
var uncurryThis$7 = functionUncurryThis;
var call$2 = functionCall;
var fails$5 = fails$1z;
var toString$4 = toString$J;
var validateArgumentsLength$9 = validateArgumentsLength$c;
var i2c = base64Map$2.i2c;
var $btoa = getBuiltIn$7("btoa");
var charAt$2 = uncurryThis$7("".charAt);
var charCodeAt$1 = uncurryThis$7("".charCodeAt);
var BASIC = !!$btoa && !fails$5(function() {
  return $btoa("hi") !== "aGk=";
});
var NO_ARG_RECEIVING_CHECK = BASIC && !fails$5(function() {
  $btoa();
});
var WRONG_ARG_CONVERSION = BASIC && fails$5(function() {
  return $btoa(null) !== "bnVsbA==";
});
var WRONG_ARITY$2 = BASIC && $btoa.length !== 1;
$$e({
  global: true,
  bind: true,
  enumerable: true,
  forced: !BASIC || NO_ARG_RECEIVING_CHECK || WRONG_ARG_CONVERSION || WRONG_ARITY$2
}, {
  btoa: function btoa(data2) {
    validateArgumentsLength$9(arguments.length, 1);
    if (BASIC) return call$2($btoa, globalThis$e, toString$4(data2));
    var string = toString$4(data2);
    var output = "";
    var position = 0;
    var map7 = i2c;
    var block, charCode;
    while (charAt$2(string, position) || (map7 = "=", position % 1)) {
      charCode = charCodeAt$1(string, position += 3 / 4);
      if (charCode > 255) {
        throw new (getBuiltIn$7("DOMException"))("The string contains characters outside of the Latin1 range", "InvalidCharacterError");
      }
      block = block << 8 | charCode;
      output += charAt$2(map7, 63 & block >> 8 - position % 1 * 8);
    }
    return output;
  }
});
var domIterables = {
  CSSRuleList: 0,
  CSSStyleDeclaration: 0,
  CSSValueList: 0,
  ClientRectList: 0,
  DOMRectList: 0,
  DOMStringList: 0,
  DOMTokenList: 1,
  DataTransferItemList: 0,
  FileList: 0,
  HTMLAllCollection: 0,
  HTMLCollection: 0,
  HTMLFormElement: 0,
  HTMLSelectElement: 0,
  MediaList: 0,
  MimeTypeArray: 0,
  NamedNodeMap: 0,
  NodeList: 1,
  PaintRequestList: 0,
  Plugin: 0,
  PluginArray: 0,
  SVGLengthList: 0,
  SVGNumberList: 0,
  SVGPathSegList: 0,
  SVGPointList: 0,
  SVGStringList: 0,
  SVGTransformList: 0,
  SourceBufferList: 0,
  StyleSheetList: 0,
  TextTrackCueList: 0,
  TextTrackList: 0,
  TouchList: 0
};
var documentCreateElement = documentCreateElement$2;
var classList = documentCreateElement("span").classList;
var DOMTokenListPrototype$2 = classList && classList.constructor && classList.constructor.prototype;
var domTokenListPrototype = DOMTokenListPrototype$2 === Object.prototype ? void 0 : DOMTokenListPrototype$2;
var globalThis$d = globalThis_1;
var DOMIterables$1 = domIterables;
var DOMTokenListPrototype$1 = domTokenListPrototype;
var forEach$2 = arrayForEach;
var createNonEnumerableProperty$2 = createNonEnumerableProperty$j;
var handlePrototype$1 = function(CollectionPrototype) {
  if (CollectionPrototype && CollectionPrototype.forEach !== forEach$2) try {
    createNonEnumerableProperty$2(CollectionPrototype, "forEach", forEach$2);
  } catch (error3) {
    CollectionPrototype.forEach = forEach$2;
  }
};
for (var COLLECTION_NAME$1 in DOMIterables$1) {
  if (DOMIterables$1[COLLECTION_NAME$1]) {
    handlePrototype$1(globalThis$d[COLLECTION_NAME$1] && globalThis$d[COLLECTION_NAME$1].prototype);
  }
}
handlePrototype$1(DOMTokenListPrototype$1);
var globalThis$c = globalThis_1;
var DOMIterables = domIterables;
var DOMTokenListPrototype = domTokenListPrototype;
var ArrayIteratorMethods = es_array_iterator;
var createNonEnumerableProperty$1 = createNonEnumerableProperty$j;
var setToStringTag$3 = setToStringTag$e;
var wellKnownSymbol$2 = wellKnownSymbol$S;
var ITERATOR$2 = wellKnownSymbol$2("iterator");
var ArrayValues = ArrayIteratorMethods.values;
var handlePrototype = function(CollectionPrototype, COLLECTION_NAME2) {
  if (CollectionPrototype) {
    if (CollectionPrototype[ITERATOR$2] !== ArrayValues) try {
      createNonEnumerableProperty$1(CollectionPrototype, ITERATOR$2, ArrayValues);
    } catch (error3) {
      CollectionPrototype[ITERATOR$2] = ArrayValues;
    }
    setToStringTag$3(CollectionPrototype, COLLECTION_NAME2, true);
    if (DOMIterables[COLLECTION_NAME2]) for (var METHOD_NAME in ArrayIteratorMethods) {
      if (CollectionPrototype[METHOD_NAME] !== ArrayIteratorMethods[METHOD_NAME]) try {
        createNonEnumerableProperty$1(CollectionPrototype, METHOD_NAME, ArrayIteratorMethods[METHOD_NAME]);
      } catch (error3) {
        CollectionPrototype[METHOD_NAME] = ArrayIteratorMethods[METHOD_NAME];
      }
    }
  }
};
for (var COLLECTION_NAME in DOMIterables) {
  handlePrototype(globalThis$c[COLLECTION_NAME] && globalThis$c[COLLECTION_NAME].prototype, COLLECTION_NAME);
}
handlePrototype(DOMTokenListPrototype, "DOMTokenList");
var domExceptionConstants = {
  IndexSizeError: {
    s: "INDEX_SIZE_ERR",
    c: 1,
    m: 1
  },
  DOMStringSizeError: {
    s: "DOMSTRING_SIZE_ERR",
    c: 2,
    m: 0
  },
  HierarchyRequestError: {
    s: "HIERARCHY_REQUEST_ERR",
    c: 3,
    m: 1
  },
  WrongDocumentError: {
    s: "WRONG_DOCUMENT_ERR",
    c: 4,
    m: 1
  },
  InvalidCharacterError: {
    s: "INVALID_CHARACTER_ERR",
    c: 5,
    m: 1
  },
  NoDataAllowedError: {
    s: "NO_DATA_ALLOWED_ERR",
    c: 6,
    m: 0
  },
  NoModificationAllowedError: {
    s: "NO_MODIFICATION_ALLOWED_ERR",
    c: 7,
    m: 1
  },
  NotFoundError: {
    s: "NOT_FOUND_ERR",
    c: 8,
    m: 1
  },
  NotSupportedError: {
    s: "NOT_SUPPORTED_ERR",
    c: 9,
    m: 1
  },
  InUseAttributeError: {
    s: "INUSE_ATTRIBUTE_ERR",
    c: 10,
    m: 1
  },
  InvalidStateError: {
    s: "INVALID_STATE_ERR",
    c: 11,
    m: 1
  },
  SyntaxError: {
    s: "SYNTAX_ERR",
    c: 12,
    m: 1
  },
  InvalidModificationError: {
    s: "INVALID_MODIFICATION_ERR",
    c: 13,
    m: 1
  },
  NamespaceError: {
    s: "NAMESPACE_ERR",
    c: 14,
    m: 1
  },
  InvalidAccessError: {
    s: "INVALID_ACCESS_ERR",
    c: 15,
    m: 1
  },
  ValidationError: {
    s: "VALIDATION_ERR",
    c: 16,
    m: 0
  },
  TypeMismatchError: {
    s: "TYPE_MISMATCH_ERR",
    c: 17,
    m: 1
  },
  SecurityError: {
    s: "SECURITY_ERR",
    c: 18,
    m: 1
  },
  NetworkError: {
    s: "NETWORK_ERR",
    c: 19,
    m: 1
  },
  AbortError: {
    s: "ABORT_ERR",
    c: 20,
    m: 1
  },
  URLMismatchError: {
    s: "URL_MISMATCH_ERR",
    c: 21,
    m: 1
  },
  QuotaExceededError: {
    s: "QUOTA_EXCEEDED_ERR",
    c: 22,
    m: 1
  },
  TimeoutError: {
    s: "TIMEOUT_ERR",
    c: 23,
    m: 1
  },
  InvalidNodeTypeError: {
    s: "INVALID_NODE_TYPE_ERR",
    c: 24,
    m: 1
  },
  DataCloneError: {
    s: "DATA_CLONE_ERR",
    c: 25,
    m: 1
  }
};
var $$d = _export;
var getBuiltIn$6 = getBuiltIn$Q;
var getBuiltInNodeModule = getBuiltInNodeModule$2;
var fails$4 = fails$1z;
var create$1 = objectCreate$1;
var createPropertyDescriptor$2 = createPropertyDescriptor$d;
var defineProperty$2 = objectDefineProperty.f;
var defineBuiltIn$4 = defineBuiltIn$u;
var defineBuiltInAccessor$4 = defineBuiltInAccessor$p;
var hasOwn$4 = hasOwnProperty_1;
var anInstance$3 = anInstance$f;
var anObject$2 = anObject$1i;
var errorToString = errorToString$2;
var normalizeStringArgument$1 = normalizeStringArgument$6;
var DOMExceptionConstants$1 = domExceptionConstants;
var clearErrorStack$1 = errorStackClear;
var InternalStateModule$2 = internalState;
var DESCRIPTORS$7 = descriptors;
var DOM_EXCEPTION$2 = "DOMException";
var DATA_CLONE_ERR = "DATA_CLONE_ERR";
var Error$3 = getBuiltIn$6("Error");
var NativeDOMException$1 = getBuiltIn$6(DOM_EXCEPTION$2) || function() {
  try {
    var MessageChannel2 = getBuiltIn$6("MessageChannel") || getBuiltInNodeModule("worker_threads").MessageChannel;
    new MessageChannel2().port1.postMessage(/* @__PURE__ */ new WeakMap());
  } catch (error3) {
    if (error3.name === DATA_CLONE_ERR && error3.code === 25) return error3.constructor;
  }
}();
var NativeDOMExceptionPrototype = NativeDOMException$1 && NativeDOMException$1.prototype;
var ErrorPrototype = Error$3.prototype;
var setInternalState$2 = InternalStateModule$2.set;
var getInternalState = InternalStateModule$2.getterFor(DOM_EXCEPTION$2);
var HAS_STACK = "stack" in new Error$3(DOM_EXCEPTION$2);
var codeFor = function(name) {
  return hasOwn$4(DOMExceptionConstants$1, name) && DOMExceptionConstants$1[name].m ? DOMExceptionConstants$1[name].c : 0;
};
var $DOMException$1 = function DOMException() {
  anInstance$3(this, DOMExceptionPrototype$1);
  var argumentsLength = arguments.length;
  var message = normalizeStringArgument$1(argumentsLength < 1 ? void 0 : arguments[0]);
  var name = normalizeStringArgument$1(argumentsLength < 2 ? void 0 : arguments[1], "Error");
  var code2 = codeFor(name);
  setInternalState$2(this, {
    type: DOM_EXCEPTION$2,
    name,
    message,
    code: code2
  });
  if (!DESCRIPTORS$7) {
    this.name = name;
    this.message = message;
    this.code = code2;
  }
  if (HAS_STACK) {
    var error3 = new Error$3(message);
    error3.name = DOM_EXCEPTION$2;
    defineProperty$2(this, "stack", createPropertyDescriptor$2(1, clearErrorStack$1(error3.stack, 1)));
  }
};
var DOMExceptionPrototype$1 = $DOMException$1.prototype = create$1(ErrorPrototype);
var createGetterDescriptor = function(get3) {
  return {
    enumerable: true,
    configurable: true,
    get: get3
  };
};
var getterFor = function(key2) {
  return createGetterDescriptor(function() {
    return getInternalState(this)[key2];
  });
};
if (DESCRIPTORS$7) {
  defineBuiltInAccessor$4(DOMExceptionPrototype$1, "code", getterFor("code"));
  defineBuiltInAccessor$4(DOMExceptionPrototype$1, "message", getterFor("message"));
  defineBuiltInAccessor$4(DOMExceptionPrototype$1, "name", getterFor("name"));
}
defineProperty$2(DOMExceptionPrototype$1, "constructor", createPropertyDescriptor$2(1, $DOMException$1));
var INCORRECT_CONSTRUCTOR = fails$4(function() {
  return !(new NativeDOMException$1() instanceof Error$3);
});
var INCORRECT_TO_STRING = INCORRECT_CONSTRUCTOR || fails$4(function() {
  return ErrorPrototype.toString !== errorToString || String(new NativeDOMException$1(1, 2)) !== "2: 1";
});
var INCORRECT_CODE = INCORRECT_CONSTRUCTOR || fails$4(function() {
  return new NativeDOMException$1(1, "DataCloneError").code !== 25;
});
INCORRECT_CONSTRUCTOR || NativeDOMException$1[DATA_CLONE_ERR] !== 25 || NativeDOMExceptionPrototype[DATA_CLONE_ERR] !== 25;
var FORCED_CONSTRUCTOR$1 = INCORRECT_CONSTRUCTOR;
$$d({
  global: true,
  constructor: true,
  forced: FORCED_CONSTRUCTOR$1
}, {
  DOMException: FORCED_CONSTRUCTOR$1 ? $DOMException$1 : NativeDOMException$1
});
var PolyfilledDOMException$1 = getBuiltIn$6(DOM_EXCEPTION$2);
var PolyfilledDOMExceptionPrototype$1 = PolyfilledDOMException$1.prototype;
if (INCORRECT_TO_STRING && NativeDOMException$1 === PolyfilledDOMException$1) {
  defineBuiltIn$4(PolyfilledDOMExceptionPrototype$1, "toString", errorToString);
}
if (INCORRECT_CODE && DESCRIPTORS$7 && NativeDOMException$1 === PolyfilledDOMException$1) {
  defineBuiltInAccessor$4(PolyfilledDOMExceptionPrototype$1, "code", createGetterDescriptor(function() {
    return codeFor(anObject$2(this).name);
  }));
}
for (var key$1 in DOMExceptionConstants$1) if (hasOwn$4(DOMExceptionConstants$1, key$1)) {
  var constant$1 = DOMExceptionConstants$1[key$1];
  var constantName$1 = constant$1.s;
  var descriptor$2 = createPropertyDescriptor$2(6, constant$1.c);
  if (!hasOwn$4(PolyfilledDOMException$1, constantName$1)) {
    defineProperty$2(PolyfilledDOMException$1, constantName$1, descriptor$2);
  }
  if (!hasOwn$4(PolyfilledDOMExceptionPrototype$1, constantName$1)) {
    defineProperty$2(PolyfilledDOMExceptionPrototype$1, constantName$1, descriptor$2);
  }
}
var $$c = _export;
var globalThis$b = globalThis_1;
var getBuiltIn$5 = getBuiltIn$Q;
var createPropertyDescriptor$1 = createPropertyDescriptor$d;
var defineProperty$1 = objectDefineProperty.f;
var hasOwn$3 = hasOwnProperty_1;
var anInstance$2 = anInstance$f;
var inheritIfRequired = inheritIfRequired$7;
var normalizeStringArgument = normalizeStringArgument$6;
var DOMExceptionConstants = domExceptionConstants;
var clearErrorStack = errorStackClear;
var DESCRIPTORS$6 = descriptors;
var DOM_EXCEPTION$1 = "DOMException";
var Error$2 = getBuiltIn$5("Error");
var NativeDOMException = getBuiltIn$5(DOM_EXCEPTION$1);
var $DOMException = function DOMException2() {
  anInstance$2(this, DOMExceptionPrototype);
  var argumentsLength = arguments.length;
  var message = normalizeStringArgument(argumentsLength < 1 ? void 0 : arguments[0]);
  var name = normalizeStringArgument(argumentsLength < 2 ? void 0 : arguments[1], "Error");
  var that = new NativeDOMException(message, name);
  var error3 = new Error$2(message);
  error3.name = DOM_EXCEPTION$1;
  defineProperty$1(that, "stack", createPropertyDescriptor$1(1, clearErrorStack(error3.stack, 1)));
  inheritIfRequired(that, this, $DOMException);
  return that;
};
var DOMExceptionPrototype = $DOMException.prototype = NativeDOMException.prototype;
var ERROR_HAS_STACK = "stack" in new Error$2(DOM_EXCEPTION$1);
var DOM_EXCEPTION_HAS_STACK = "stack" in new NativeDOMException(1, 2);
var descriptor$1 = NativeDOMException && DESCRIPTORS$6 && Object.getOwnPropertyDescriptor(globalThis$b, DOM_EXCEPTION$1);
var BUGGY_DESCRIPTOR = !!descriptor$1 && !(descriptor$1.writable && descriptor$1.configurable);
var FORCED_CONSTRUCTOR = ERROR_HAS_STACK && !BUGGY_DESCRIPTOR && !DOM_EXCEPTION_HAS_STACK;
$$c({
  global: true,
  constructor: true,
  forced: FORCED_CONSTRUCTOR
}, {
  // TODO: fix export logic
  DOMException: FORCED_CONSTRUCTOR ? $DOMException : NativeDOMException
});
var PolyfilledDOMException = getBuiltIn$5(DOM_EXCEPTION$1);
var PolyfilledDOMExceptionPrototype = PolyfilledDOMException.prototype;
if (PolyfilledDOMExceptionPrototype.constructor !== PolyfilledDOMException) {
  {
    defineProperty$1(PolyfilledDOMExceptionPrototype, "constructor", createPropertyDescriptor$1(1, PolyfilledDOMException));
  }
  for (var key in DOMExceptionConstants) if (hasOwn$3(DOMExceptionConstants, key)) {
    var constant = DOMExceptionConstants[key];
    var constantName = constant.s;
    if (!hasOwn$3(PolyfilledDOMException, constantName)) {
      defineProperty$1(PolyfilledDOMException, constantName, createPropertyDescriptor$1(6, constant.c));
    }
  }
}
var getBuiltIn$4 = getBuiltIn$Q;
var setToStringTag$2 = setToStringTag$e;
var DOM_EXCEPTION = "DOMException";
setToStringTag$2(getBuiltIn$4(DOM_EXCEPTION), DOM_EXCEPTION);
var $$b = _export;
var globalThis$a = globalThis_1;
var clearImmediate = task$1.clear;
$$b({
  global: true,
  bind: true,
  enumerable: true,
  forced: globalThis$a.clearImmediate !== clearImmediate
}, {
  clearImmediate
});
var globalThis$9 = globalThis_1;
var apply2 = functionApply$1;
var isCallable$2 = isCallable$I;
var ENVIRONMENT = environment;
var USER_AGENT = environmentUserAgent;
var arraySlice$1 = arraySlice$a;
var validateArgumentsLength$8 = validateArgumentsLength$c;
var Function$1 = globalThis$9.Function;
var WRAP = /MSIE .\./.test(USER_AGENT) || ENVIRONMENT === "BUN" && function() {
  var version2 = globalThis$9.Bun.version.split(".");
  return version2.length < 3 || version2[0] === "0" && (version2[1] < 3 || version2[1] === "3" && version2[2] === "0");
}();
var schedulersFix$3 = function(scheduler2, hasTimeArg) {
  var firstParamIndex = hasTimeArg ? 2 : 1;
  return WRAP ? function(handler, timeout) {
    var boundArgs = validateArgumentsLength$8(arguments.length, 1) > firstParamIndex;
    var fn = isCallable$2(handler) ? handler : Function$1(handler);
    var params2 = boundArgs ? arraySlice$1(arguments, firstParamIndex) : [];
    var callback2 = boundArgs ? function() {
      apply2(fn, this, params2);
    } : fn;
    return hasTimeArg ? scheduler2(callback2, timeout) : scheduler2(callback2);
  } : scheduler2;
};
var $$a = _export;
var globalThis$8 = globalThis_1;
var setTask = task$1.set;
var schedulersFix$2 = schedulersFix$3;
var setImmediate = globalThis$8.setImmediate ? schedulersFix$2(setTask, false) : setTask;
$$a({
  global: true,
  bind: true,
  enumerable: true,
  forced: globalThis$8.setImmediate !== setImmediate
}, {
  setImmediate
});
var $$9 = _export;
var globalThis$7 = globalThis_1;
var microtask = microtask_1;
var aCallable = aCallable$Q;
var validateArgumentsLength$7 = validateArgumentsLength$c;
var fails$3 = fails$1z;
var DESCRIPTORS$5 = descriptors;
var WRONG_ARITY$1 = fails$3(function() {
  return DESCRIPTORS$5 && Object.getOwnPropertyDescriptor(globalThis$7, "queueMicrotask").value.length !== 1;
});
$$9({
  global: true,
  enumerable: true,
  dontCallGetSet: true,
  forced: WRONG_ARITY$1
}, {
  queueMicrotask: function queueMicrotask2(fn) {
    validateArgumentsLength$7(arguments.length, 1);
    microtask(aCallable(fn));
  }
});
var $$8 = _export;
var globalThis$6 = globalThis_1;
var defineBuiltInAccessor$3 = defineBuiltInAccessor$p;
var DESCRIPTORS$4 = descriptors;
var $TypeError = TypeError;
var defineProperty6 = Object.defineProperty;
var INCORRECT_VALUE = globalThis$6.self !== globalThis$6;
try {
  if (DESCRIPTORS$4) {
    var descriptor = Object.getOwnPropertyDescriptor(globalThis$6, "self");
    if (INCORRECT_VALUE || !descriptor || !descriptor.get || !descriptor.enumerable) {
      defineBuiltInAccessor$3(globalThis$6, "self", {
        get: function self2() {
          return globalThis$6;
        },
        set: function self2(value) {
          if (this !== globalThis$6) throw new $TypeError("Illegal invocation");
          defineProperty6(globalThis$6, "self", {
            value,
            writable: true,
            configurable: true,
            enumerable: true
          });
        },
        configurable: true,
        enumerable: true
      });
    }
  } else $$8({
    global: true,
    simple: true,
    forced: INCORRECT_VALUE
  }, {
    self: globalThis$6
  });
} catch (error3) {
}
var $$7 = _export;
var globalThis$5 = globalThis_1;
var getBuiltIn$3 = getBuiltIn$Q;
var uncurryThis$6 = functionUncurryThis;
var fails$2 = fails$1z;
var uid = uid$7;
var isCallable$1 = isCallable$I;
var isConstructor3 = isConstructor$a;
var isNullOrUndefined = isNullOrUndefined$j;
var isObject$1 = isObject$O;
var isSymbol = isSymbol$8;
var iterate = iterate$H;
var anObject$1 = anObject$1i;
var classof$1 = classof$q;
var hasOwn$2 = hasOwnProperty_1;
var createProperty = createProperty$b;
var createNonEnumerableProperty = createNonEnumerableProperty$j;
var lengthOfArrayLike = lengthOfArrayLike$B;
var validateArgumentsLength$6 = validateArgumentsLength$c;
var getRegExpFlags = regexpGetFlags;
var MapHelpers = mapHelpers;
var SetHelpers = setHelpers;
var setIterate = setIterate$1;
var detachTransferable = detachTransferable$2;
var ERROR_STACK_INSTALLABLE = errorStackInstallable;
var PROPER_STRUCTURED_CLONE_TRANSFER = structuredCloneProperTransfer;
var Object$1 = globalThis$5.Object;
var Array$1 = globalThis$5.Array;
var Date$1 = globalThis$5.Date;
var Error$1 = globalThis$5.Error;
var TypeError$3 = globalThis$5.TypeError;
var PerformanceMark = globalThis$5.PerformanceMark;
var DOMException3 = getBuiltIn$3("DOMException");
var Map$1 = MapHelpers.Map;
var mapHas = MapHelpers.has;
var mapGet = MapHelpers.get;
var mapSet = MapHelpers.set;
var Set$1 = SetHelpers.Set;
var setAdd = SetHelpers.add;
var setHas = SetHelpers.has;
var objectKeys = getBuiltIn$3("Object", "keys");
var push$4 = uncurryThis$6([].push);
var thisBooleanValue = uncurryThis$6(true.valueOf);
var thisNumberValue = uncurryThis$6(1 .valueOf);
var thisStringValue = uncurryThis$6("".valueOf);
var thisTimeValue = uncurryThis$6(Date$1.prototype.getTime);
var PERFORMANCE_MARK = uid("structuredClone");
var DATA_CLONE_ERROR = "DataCloneError";
var TRANSFERRING = "Transferring";
var checkBasicSemantic = function(structuredCloneImplementation) {
  return !fails$2(function() {
    var set1 = new globalThis$5.Set([7]);
    var set22 = structuredCloneImplementation(set1);
    var number = structuredCloneImplementation(Object$1(7));
    return set22 === set1 || !set22.has(7) || !isObject$1(number) || +number !== 7;
  }) && structuredCloneImplementation;
};
var checkErrorsCloning = function(structuredCloneImplementation, $Error2) {
  return !fails$2(function() {
    var error3 = new $Error2();
    var test2 = structuredCloneImplementation({
      a: error3,
      b: error3
    });
    return !(test2 && test2.a === test2.b && test2.a instanceof $Error2 && test2.a.stack === error3.stack);
  });
};
var checkNewErrorsCloningSemantic = function(structuredCloneImplementation) {
  return !fails$2(function() {
    var test2 = structuredCloneImplementation(new globalThis$5.AggregateError([1], PERFORMANCE_MARK, {
      cause: 3
    }));
    return test2.name !== "AggregateError" || test2.errors[0] !== 1 || test2.message !== PERFORMANCE_MARK || test2.cause !== 3;
  });
};
var nativeStructuredClone = globalThis$5.structuredClone;
var FORCED_REPLACEMENT = !checkErrorsCloning(nativeStructuredClone, Error$1) || !checkErrorsCloning(nativeStructuredClone, DOMException3) || !checkNewErrorsCloningSemantic(nativeStructuredClone);
var structuredCloneFromMark = !nativeStructuredClone && checkBasicSemantic(function(value) {
  return new PerformanceMark(PERFORMANCE_MARK, {
    detail: value
  }).detail;
});
var nativeRestrictedStructuredClone = checkBasicSemantic(nativeStructuredClone) || structuredCloneFromMark;
var throwUncloneable = function(type) {
  throw new DOMException3("Uncloneable type: " + type, DATA_CLONE_ERROR);
};
var throwUnpolyfillable = function(type, action) {
  throw new DOMException3((action || "Cloning") + " of " + type + " cannot be properly polyfilled in this engine", DATA_CLONE_ERROR);
};
var tryNativeRestrictedStructuredClone = function(value, type) {
  if (!nativeRestrictedStructuredClone) throwUnpolyfillable(type);
  return nativeRestrictedStructuredClone(value);
};
var createDataTransfer = function() {
  var dataTransfer;
  try {
    dataTransfer = new globalThis$5.DataTransfer();
  } catch (error3) {
    try {
      dataTransfer = new globalThis$5.ClipboardEvent("").clipboardData;
    } catch (error22) {
    }
  }
  return dataTransfer && dataTransfer.items && dataTransfer.files ? dataTransfer : null;
};
var cloneBuffer = function(value, map7, $type) {
  if (mapHas(map7, value)) return mapGet(map7, value);
  var type = $type || classof$1(value);
  var clone2, length, options, source, target, i;
  if (type === "SharedArrayBuffer") {
    if (nativeRestrictedStructuredClone) clone2 = nativeRestrictedStructuredClone(value);
    else clone2 = value;
  } else {
    var DataView2 = globalThis$5.DataView;
    if (!DataView2 && !isCallable$1(value.slice)) throwUnpolyfillable("ArrayBuffer");
    try {
      if (isCallable$1(value.slice) && !value.resizable) {
        clone2 = value.slice(0);
      } else {
        length = value.byteLength;
        options = "maxByteLength" in value ? {
          maxByteLength: value.maxByteLength
        } : void 0;
        clone2 = new ArrayBuffer(length, options);
        source = new DataView2(value);
        target = new DataView2(clone2);
        for (i = 0; i < length; i++) {
          target.setUint8(i, source.getUint8(i));
        }
      }
    } catch (error3) {
      throw new DOMException3("ArrayBuffer is detached", DATA_CLONE_ERROR);
    }
  }
  mapSet(map7, value, clone2);
  return clone2;
};
var cloneView = function(value, type, offset, length, map7) {
  var C = globalThis$5[type];
  if (!isObject$1(C)) throwUnpolyfillable(type);
  return new C(cloneBuffer(value.buffer, map7), offset, length);
};
var structuredCloneInternal = function(value, map7) {
  if (isSymbol(value)) throwUncloneable("Symbol");
  if (!isObject$1(value)) return value;
  if (map7) {
    if (mapHas(map7, value)) return mapGet(map7, value);
  } else map7 = new Map$1();
  var type = classof$1(value);
  var C, name, cloned, dataTransfer, i, length, keys6, key;
  switch (type) {
    case "Array":
      cloned = Array$1(lengthOfArrayLike(value));
      break;
    case "Object":
      cloned = {};
      break;
    case "Map":
      cloned = new Map$1();
      break;
    case "Set":
      cloned = new Set$1();
      break;
    case "RegExp":
      cloned = new RegExp(value.source, getRegExpFlags(value));
      break;
    case "Error":
      name = value.name;
      switch (name) {
        case "AggregateError":
          cloned = new (getBuiltIn$3(name))([]);
          break;
        case "EvalError":
        case "RangeError":
        case "ReferenceError":
        case "SuppressedError":
        case "SyntaxError":
        case "TypeError":
        case "URIError":
          cloned = new (getBuiltIn$3(name))();
          break;
        case "CompileError":
        case "LinkError":
        case "RuntimeError":
          cloned = new (getBuiltIn$3("WebAssembly", name))();
          break;
        default:
          cloned = new Error$1();
      }
      break;
    case "DOMException":
      cloned = new DOMException3(value.message, value.name);
      break;
    case "ArrayBuffer":
    case "SharedArrayBuffer":
      cloned = cloneBuffer(value, map7, type);
      break;
    case "DataView":
    case "Int8Array":
    case "Uint8Array":
    case "Uint8ClampedArray":
    case "Int16Array":
    case "Uint16Array":
    case "Int32Array":
    case "Uint32Array":
    case "Float16Array":
    case "Float32Array":
    case "Float64Array":
    case "BigInt64Array":
    case "BigUint64Array":
      length = type === "DataView" ? value.byteLength : value.length;
      cloned = cloneView(value, type, value.byteOffset, length, map7);
      break;
    case "DOMQuad":
      try {
        cloned = new DOMQuad(structuredCloneInternal(value.p1, map7), structuredCloneInternal(value.p2, map7), structuredCloneInternal(value.p3, map7), structuredCloneInternal(value.p4, map7));
      } catch (error3) {
        cloned = tryNativeRestrictedStructuredClone(value, type);
      }
      break;
    case "File":
      if (nativeRestrictedStructuredClone) try {
        cloned = nativeRestrictedStructuredClone(value);
        if (classof$1(cloned) !== type) cloned = void 0;
      } catch (error3) {
      }
      if (!cloned) try {
        cloned = new File([value], value.name, value);
      } catch (error3) {
      }
      if (!cloned) throwUnpolyfillable(type);
      break;
    case "FileList":
      dataTransfer = createDataTransfer();
      if (dataTransfer) {
        for (i = 0, length = lengthOfArrayLike(value); i < length; i++) {
          dataTransfer.items.add(structuredCloneInternal(value[i], map7));
        }
        cloned = dataTransfer.files;
      } else cloned = tryNativeRestrictedStructuredClone(value, type);
      break;
    case "ImageData":
      try {
        cloned = new ImageData(structuredCloneInternal(value.data, map7), value.width, value.height, {
          colorSpace: value.colorSpace
        });
      } catch (error3) {
        cloned = tryNativeRestrictedStructuredClone(value, type);
      }
      break;
    default:
      if (nativeRestrictedStructuredClone) {
        cloned = nativeRestrictedStructuredClone(value);
      } else switch (type) {
        case "BigInt":
          cloned = Object$1(value.valueOf());
          break;
        case "Boolean":
          cloned = Object$1(thisBooleanValue(value));
          break;
        case "Number":
          cloned = Object$1(thisNumberValue(value));
          break;
        case "String":
          cloned = Object$1(thisStringValue(value));
          break;
        case "Date":
          cloned = new Date$1(thisTimeValue(value));
          break;
        case "Blob":
          try {
            cloned = value.slice(0, value.size, value.type);
          } catch (error3) {
            throwUnpolyfillable(type);
          }
          break;
        case "DOMPoint":
        case "DOMPointReadOnly":
          C = globalThis$5[type];
          try {
            cloned = C.fromPoint ? C.fromPoint(value) : new C(value.x, value.y, value.z, value.w);
          } catch (error3) {
            throwUnpolyfillable(type);
          }
          break;
        case "DOMRect":
        case "DOMRectReadOnly":
          C = globalThis$5[type];
          try {
            cloned = C.fromRect ? C.fromRect(value) : new C(value.x, value.y, value.width, value.height);
          } catch (error3) {
            throwUnpolyfillable(type);
          }
          break;
        case "DOMMatrix":
        case "DOMMatrixReadOnly":
          C = globalThis$5[type];
          try {
            cloned = C.fromMatrix ? C.fromMatrix(value) : new C(value);
          } catch (error3) {
            throwUnpolyfillable(type);
          }
          break;
        case "AudioData":
        case "VideoFrame":
          if (!isCallable$1(value.clone)) throwUnpolyfillable(type);
          try {
            cloned = value.clone();
          } catch (error3) {
            throwUncloneable(type);
          }
          break;
        case "CropTarget":
        case "CryptoKey":
        case "FileSystemDirectoryHandle":
        case "FileSystemFileHandle":
        case "FileSystemHandle":
        case "GPUCompilationInfo":
        case "GPUCompilationMessage":
        case "ImageBitmap":
        case "RTCCertificate":
        case "WebAssembly.Module":
          throwUnpolyfillable(type);
        default:
          throwUncloneable(type);
      }
  }
  mapSet(map7, value, cloned);
  switch (type) {
    case "Array":
    case "Object":
      keys6 = objectKeys(value);
      for (i = 0, length = lengthOfArrayLike(keys6); i < length; i++) {
        key = keys6[i];
        createProperty(cloned, key, structuredCloneInternal(value[key], map7));
      }
      break;
    case "Map":
      value.forEach(function(v, k) {
        mapSet(cloned, structuredCloneInternal(k, map7), structuredCloneInternal(v, map7));
      });
      break;
    case "Set":
      value.forEach(function(v) {
        setAdd(cloned, structuredCloneInternal(v, map7));
      });
      break;
    case "Error":
      createNonEnumerableProperty(cloned, "message", structuredCloneInternal(value.message, map7));
      if (hasOwn$2(value, "cause")) {
        createNonEnumerableProperty(cloned, "cause", structuredCloneInternal(value.cause, map7));
      }
      if (name === "AggregateError") {
        cloned.errors = structuredCloneInternal(value.errors, map7);
      } else if (name === "SuppressedError") {
        cloned.error = structuredCloneInternal(value.error, map7);
        cloned.suppressed = structuredCloneInternal(value.suppressed, map7);
      }
    case "DOMException":
      if (ERROR_STACK_INSTALLABLE) {
        createNonEnumerableProperty(cloned, "stack", structuredCloneInternal(value.stack, map7));
      }
  }
  return cloned;
};
var tryToTransfer = function(rawTransfer, map7) {
  if (!isObject$1(rawTransfer)) throw new TypeError$3("Transfer option cannot be converted to a sequence");
  var transfer2 = [];
  iterate(rawTransfer, function(value2) {
    push$4(transfer2, anObject$1(value2));
  });
  var i = 0;
  var length = lengthOfArrayLike(transfer2);
  var buffers = new Set$1();
  var value, type, C, transferred, canvas, context;
  while (i < length) {
    value = transfer2[i++];
    type = classof$1(value);
    if (type === "ArrayBuffer" ? setHas(buffers, value) : mapHas(map7, value)) {
      throw new DOMException3("Duplicate transferable", DATA_CLONE_ERROR);
    }
    if (type === "ArrayBuffer") {
      setAdd(buffers, value);
      continue;
    }
    if (PROPER_STRUCTURED_CLONE_TRANSFER) {
      transferred = nativeStructuredClone(value, {
        transfer: [value]
      });
    } else switch (type) {
      case "ImageBitmap":
        C = globalThis$5.OffscreenCanvas;
        if (!isConstructor3(C)) throwUnpolyfillable(type, TRANSFERRING);
        try {
          canvas = new C(value.width, value.height);
          context = canvas.getContext("bitmaprenderer");
          context.transferFromImageBitmap(value);
          transferred = canvas.transferToImageBitmap();
        } catch (error3) {
        }
        break;
      case "AudioData":
      case "VideoFrame":
        if (!isCallable$1(value.clone) || !isCallable$1(value.close)) throwUnpolyfillable(type, TRANSFERRING);
        try {
          transferred = value.clone();
          value.close();
        } catch (error3) {
        }
        break;
      case "MediaSourceHandle":
      case "MessagePort":
      case "MIDIAccess":
      case "OffscreenCanvas":
      case "ReadableStream":
      case "RTCDataChannel":
      case "TransformStream":
      case "WebTransportReceiveStream":
      case "WebTransportSendStream":
      case "WritableStream":
        throwUnpolyfillable(type, TRANSFERRING);
    }
    if (transferred === void 0) throw new DOMException3("This object cannot be transferred: " + type, DATA_CLONE_ERROR);
    mapSet(map7, value, transferred);
  }
  return buffers;
};
var detachBuffers = function(buffers) {
  setIterate(buffers, function(buffer2) {
    if (PROPER_STRUCTURED_CLONE_TRANSFER) {
      nativeRestrictedStructuredClone(buffer2, {
        transfer: [buffer2]
      });
    } else if (isCallable$1(buffer2.transfer)) {
      buffer2.transfer();
    } else if (detachTransferable) {
      detachTransferable(buffer2);
    } else {
      throwUnpolyfillable("ArrayBuffer", TRANSFERRING);
    }
  });
};
$$7({
  global: true,
  enumerable: true,
  sham: !PROPER_STRUCTURED_CLONE_TRANSFER,
  forced: FORCED_REPLACEMENT
}, {
  structuredClone: function structuredClone2(value) {
    var options = validateArgumentsLength$6(arguments.length, 1) > 1 && !isNullOrUndefined(arguments[1]) ? anObject$1(arguments[1]) : void 0;
    var transfer2 = options ? options.transfer : void 0;
    var map7, buffers;
    if (transfer2 !== void 0) {
      map7 = new Map$1();
      buffers = tryToTransfer(transfer2, map7);
    }
    var clone2 = structuredCloneInternal(value, map7);
    if (buffers) detachBuffers(buffers);
    return clone2;
  }
});
var $$6 = _export;
var globalThis$4 = globalThis_1;
var schedulersFix$1 = schedulersFix$3;
var setInterval$1 = schedulersFix$1(globalThis$4.setInterval, true);
$$6({
  global: true,
  bind: true,
  forced: globalThis$4.setInterval !== setInterval$1
}, {
  setInterval: setInterval$1
});
var $$5 = _export;
var globalThis$3 = globalThis_1;
var schedulersFix = schedulersFix$3;
var setTimeout$1 = schedulersFix(globalThis$3.setTimeout, true);
$$5({
  global: true,
  bind: true,
  forced: globalThis$3.setTimeout !== setTimeout$1
}, {
  setTimeout: setTimeout$1
});
var fails$1 = fails$1z;
var wellKnownSymbol$1 = wellKnownSymbol$S;
var DESCRIPTORS$3 = descriptors;
var IS_PURE = isPure;
var ITERATOR$1 = wellKnownSymbol$1("iterator");
var urlConstructorDetection = !fails$1(function() {
  var url = new URL("b?a=1&b=2&c=3", "https://a");
  var params2 = url.searchParams;
  var params22 = new URLSearchParams("a=1&a=2&b=3");
  var result = "";
  url.pathname = "c%20d";
  params2.forEach(function(value, key) {
    params2["delete"]("b");
    result += key + value;
  });
  params22["delete"]("a", 2);
  params22["delete"]("b", void 0);
  return IS_PURE && (!url.toJSON || !params22.has("a", 1) || params22.has("a", 2) || !params22.has("a", void 0) || params22.has("b")) || !params2.size && (IS_PURE || !DESCRIPTORS$3) || !params2.sort || url.href !== "https://a/c%20d?a=1&c=3" || params2.get("c") !== "3" || String(new URLSearchParams("?a=1")) !== "a=1" || !params2[ITERATOR$1] || new URL("https://a@b").username !== "a" || new URLSearchParams(new URLSearchParams("a=b")).get("a") !== "b" || new URL("https://").host !== "xn--e1aybc" || new URL("https://a#").hash !== "#%D0%B1" || result !== "a1c3" || new URL("https://x", void 0).host !== "x";
});
var uncurryThis$5 = functionUncurryThis;
var maxInt = 2147483647;
var base = 36;
var tMin = 1;
var tMax = 26;
var skew = 38;
var damp = 700;
var initialBias = 72;
var initialN = 128;
var delimiter = "-";
var regexNonASCII = /[^\0-\u007E]/;
var regexSeparators = /[.\u3002\uFF0E\uFF61]/g;
var OVERFLOW_ERROR = "Overflow: input needs wider integers to process";
var baseMinusTMin = base - tMin;
var $RangeError = RangeError;
var exec$2 = uncurryThis$5(regexSeparators.exec);
var floor$1 = Math.floor;
var fromCharCode$1 = String.fromCharCode;
var charCodeAt = uncurryThis$5("".charCodeAt);
var join$2 = uncurryThis$5([].join);
var push$3 = uncurryThis$5([].push);
var replace$2 = uncurryThis$5("".replace);
var split$2 = uncurryThis$5("".split);
var toLowerCase$1 = uncurryThis$5("".toLowerCase);
var ucs2decode = function(string) {
  var output = [];
  var counter2 = 0;
  var length = string.length;
  while (counter2 < length) {
    var value = charCodeAt(string, counter2++);
    if (value >= 55296 && value <= 56319 && counter2 < length) {
      var extra = charCodeAt(string, counter2++);
      if ((extra & 64512) === 56320) {
        push$3(output, ((value & 1023) << 10) + (extra & 1023) + 65536);
      } else {
        push$3(output, value);
        counter2--;
      }
    } else {
      push$3(output, value);
    }
  }
  return output;
};
var digitToBasic = function(digit) {
  return digit + 22 + 75 * (digit < 26);
};
var adapt = function(delta, numPoints, firstTime) {
  var k = 0;
  delta = firstTime ? floor$1(delta / damp) : delta >> 1;
  delta += floor$1(delta / numPoints);
  while (delta > baseMinusTMin * tMax >> 1) {
    delta = floor$1(delta / baseMinusTMin);
    k += base;
  }
  return floor$1(k + (baseMinusTMin + 1) * delta / (delta + skew));
};
var encode = function(input) {
  var output = [];
  input = ucs2decode(input);
  var inputLength = input.length;
  var n = initialN;
  var delta = 0;
  var bias = initialBias;
  var i, currentValue;
  for (i = 0; i < input.length; i++) {
    currentValue = input[i];
    if (currentValue < 128) {
      push$3(output, fromCharCode$1(currentValue));
    }
  }
  var basicLength = output.length;
  var handledCPCount = basicLength;
  if (basicLength) {
    push$3(output, delimiter);
  }
  while (handledCPCount < inputLength) {
    var m = maxInt;
    for (i = 0; i < input.length; i++) {
      currentValue = input[i];
      if (currentValue >= n && currentValue < m) {
        m = currentValue;
      }
    }
    var handledCPCountPlusOne = handledCPCount + 1;
    if (m - n > floor$1((maxInt - delta) / handledCPCountPlusOne)) {
      throw new $RangeError(OVERFLOW_ERROR);
    }
    delta += (m - n) * handledCPCountPlusOne;
    n = m;
    for (i = 0; i < input.length; i++) {
      currentValue = input[i];
      if (currentValue < n && ++delta > maxInt) {
        throw new $RangeError(OVERFLOW_ERROR);
      }
      if (currentValue === n) {
        var q = delta;
        var k = base;
        while (true) {
          var t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
          if (q < t) break;
          var qMinusT = q - t;
          var baseMinusT = base - t;
          push$3(output, fromCharCode$1(digitToBasic(t + qMinusT % baseMinusT)));
          q = floor$1(qMinusT / baseMinusT);
          k += base;
        }
        push$3(output, fromCharCode$1(digitToBasic(q)));
        bias = adapt(delta, handledCPCountPlusOne, handledCPCount === basicLength);
        delta = 0;
        handledCPCount++;
      }
    }
    delta++;
    n++;
  }
  return join$2(output, "");
};
var stringPunycodeToAscii = function(input) {
  var encoded = [];
  var labels = split$2(replace$2(toLowerCase$1(input), regexSeparators, "."), ".");
  var i, label;
  for (i = 0; i < labels.length; i++) {
    label = labels[i];
    push$3(encoded, exec$2(regexNonASCII, label) ? "xn--" + encode(label) : label);
  }
  return join$2(encoded, ".");
};
var $$4 = _export;
var globalThis$2 = globalThis_1;
var safeGetBuiltIn = safeGetBuiltIn$2;
var getBuiltIn$2 = getBuiltIn$Q;
var call$1 = functionCall;
var uncurryThis$4 = functionUncurryThis;
var DESCRIPTORS$2 = descriptors;
var USE_NATIVE_URL$3 = urlConstructorDetection;
var defineBuiltIn$3 = defineBuiltIn$u;
var defineBuiltInAccessor$2 = defineBuiltInAccessor$p;
var defineBuiltIns = defineBuiltIns$b;
var setToStringTag$1 = setToStringTag$e;
var createIteratorConstructor = iteratorCreateConstructor;
var InternalStateModule$1 = internalState;
var anInstance$1 = anInstance$f;
var isCallable2 = isCallable$I;
var hasOwn$1 = hasOwnProperty_1;
var bind$1 = functionBindContext;
var classof = classof$q;
var anObject = anObject$1i;
var isObject = isObject$O;
var $toString$1 = toString$J;
var create3 = objectCreate$1;
var createPropertyDescriptor = createPropertyDescriptor$d;
var getIterator = getIterator$7;
var getIteratorMethod = getIteratorMethod$9;
var createIterResultObject = createIterResultObject$i;
var validateArgumentsLength$5 = validateArgumentsLength$c;
var wellKnownSymbol = wellKnownSymbol$S;
var arraySort = arraySort$1;
var ITERATOR = wellKnownSymbol("iterator");
var URL_SEARCH_PARAMS = "URLSearchParams";
var URL_SEARCH_PARAMS_ITERATOR = URL_SEARCH_PARAMS + "Iterator";
var setInternalState$1 = InternalStateModule$1.set;
var getInternalParamsState = InternalStateModule$1.getterFor(URL_SEARCH_PARAMS);
var getInternalIteratorState = InternalStateModule$1.getterFor(URL_SEARCH_PARAMS_ITERATOR);
var nativeFetch = safeGetBuiltIn("fetch");
var NativeRequest = safeGetBuiltIn("Request");
var Headers$1 = safeGetBuiltIn("Headers");
var RequestPrototype = NativeRequest && NativeRequest.prototype;
var HeadersPrototype = Headers$1 && Headers$1.prototype;
var TypeError$2 = globalThis$2.TypeError;
var encodeURIComponent$1 = globalThis$2.encodeURIComponent;
var fromCharCode = String.fromCharCode;
var fromCodePoint2 = getBuiltIn$2("String", "fromCodePoint");
var $parseInt = parseInt;
var charAt$1 = uncurryThis$4("".charAt);
var join$1 = uncurryThis$4([].join);
var push$2 = uncurryThis$4([].push);
var replace$1 = uncurryThis$4("".replace);
var shift$1 = uncurryThis$4([].shift);
var splice$1 = uncurryThis$4([].splice);
var split$1 = uncurryThis$4("".split);
var stringSlice$1 = uncurryThis$4("".slice);
var exec$1 = uncurryThis$4(/./.exec);
var plus = /\+/g;
var FALLBACK_REPLACER = "";
var VALID_HEX = /^[0-9a-f]+$/i;
var parseHexOctet = function(string, start2) {
  var substr2 = stringSlice$1(string, start2, start2 + 2);
  if (!exec$1(VALID_HEX, substr2)) return NaN;
  return $parseInt(substr2, 16);
};
var getLeadingOnes = function(octet) {
  var count = 0;
  for (var mask = 128; mask > 0 && (octet & mask) !== 0; mask >>= 1) {
    count++;
  }
  return count;
};
var utf8Decode = function(octets) {
  var codePoint = null;
  switch (octets.length) {
    case 1:
      codePoint = octets[0];
      break;
    case 2:
      codePoint = (octets[0] & 31) << 6 | octets[1] & 63;
      break;
    case 3:
      codePoint = (octets[0] & 15) << 12 | (octets[1] & 63) << 6 | octets[2] & 63;
      break;
    case 4:
      codePoint = (octets[0] & 7) << 18 | (octets[1] & 63) << 12 | (octets[2] & 63) << 6 | octets[3] & 63;
      break;
  }
  return codePoint > 1114111 ? null : codePoint;
};
var decode = function(input) {
  input = replace$1(input, plus, " ");
  var length = input.length;
  var result = "";
  var i = 0;
  while (i < length) {
    var decodedChar = charAt$1(input, i);
    if (decodedChar === "%") {
      if (charAt$1(input, i + 1) === "%" || i + 3 > length) {
        result += "%";
        i++;
        continue;
      }
      var octet = parseHexOctet(input, i + 1);
      if (octet !== octet) {
        result += decodedChar;
        i++;
        continue;
      }
      i += 2;
      var byteSequenceLength = getLeadingOnes(octet);
      if (byteSequenceLength === 0) {
        decodedChar = fromCharCode(octet);
      } else {
        if (byteSequenceLength === 1 || byteSequenceLength > 4) {
          result += FALLBACK_REPLACER;
          i++;
          continue;
        }
        var octets = [octet];
        var sequenceIndex = 1;
        while (sequenceIndex < byteSequenceLength) {
          i++;
          if (i + 3 > length || charAt$1(input, i) !== "%") break;
          var nextByte = parseHexOctet(input, i + 1);
          if (nextByte !== nextByte) {
            i += 3;
            break;
          }
          if (nextByte > 191 || nextByte < 128) break;
          push$2(octets, nextByte);
          i += 2;
          sequenceIndex++;
        }
        if (octets.length !== byteSequenceLength) {
          result += FALLBACK_REPLACER;
          continue;
        }
        var codePoint = utf8Decode(octets);
        if (codePoint === null) {
          result += FALLBACK_REPLACER;
        } else {
          decodedChar = fromCodePoint2(codePoint);
        }
      }
    }
    result += decodedChar;
    i++;
  }
  return result;
};
var find7 = /[!'()~]|%20/g;
var replacements = {
  "!": "%21",
  "'": "%27",
  "(": "%28",
  ")": "%29",
  "~": "%7E",
  "%20": "+"
};
var replacer = function(match2) {
  return replacements[match2];
};
var serialize = function(it) {
  return replace$1(encodeURIComponent$1(it), find7, replacer);
};
var URLSearchParamsIterator = createIteratorConstructor(function Iterator2(params2, kind) {
  setInternalState$1(this, {
    type: URL_SEARCH_PARAMS_ITERATOR,
    target: getInternalParamsState(params2).entries,
    index: 0,
    kind
  });
}, URL_SEARCH_PARAMS, function next10() {
  var state = getInternalIteratorState(this);
  var target = state.target;
  var index = state.index++;
  if (!target || index >= target.length) {
    state.target = null;
    return createIterResultObject(void 0, true);
  }
  var entry = target[index];
  switch (state.kind) {
    case "keys":
      return createIterResultObject(entry.key, false);
    case "values":
      return createIterResultObject(entry.value, false);
  }
  return createIterResultObject([entry.key, entry.value], false);
}, true);
var URLSearchParamsState = function(init) {
  this.entries = [];
  this.url = null;
  if (init !== void 0) {
    if (isObject(init)) this.parseObject(init);
    else this.parseQuery(typeof init == "string" ? charAt$1(init, 0) === "?" ? stringSlice$1(init, 1) : init : $toString$1(init));
  }
};
URLSearchParamsState.prototype = {
  type: URL_SEARCH_PARAMS,
  bindURL: function(url) {
    this.url = url;
    this.update();
  },
  parseObject: function(object) {
    var entries22 = this.entries;
    var iteratorMethod = getIteratorMethod(object);
    var iterator, next22, step, entryIterator, entryNext, first, second;
    if (iteratorMethod) {
      iterator = getIterator(object, iteratorMethod);
      next22 = iterator.next;
      while (!(step = call$1(next22, iterator)).done) {
        entryIterator = getIterator(anObject(step.value));
        entryNext = entryIterator.next;
        if ((first = call$1(entryNext, entryIterator)).done || (second = call$1(entryNext, entryIterator)).done || !call$1(entryNext, entryIterator).done) throw new TypeError$2("Expected sequence with length 2");
        push$2(entries22, {
          key: $toString$1(first.value),
          value: $toString$1(second.value)
        });
      }
    } else for (var key in object) if (hasOwn$1(object, key)) {
      push$2(entries22, {
        key,
        value: $toString$1(object[key])
      });
    }
  },
  parseQuery: function(query) {
    if (query) {
      var entries22 = this.entries;
      var attributes = split$1(query, "&");
      var index = 0;
      var attribute, entry;
      while (index < attributes.length) {
        attribute = attributes[index++];
        if (attribute.length) {
          entry = split$1(attribute, "=");
          push$2(entries22, {
            key: decode(shift$1(entry)),
            value: decode(join$1(entry, "="))
          });
        }
      }
    }
  },
  serialize: function() {
    var entries22 = this.entries;
    var result = [];
    var index = 0;
    var entry;
    while (index < entries22.length) {
      entry = entries22[index++];
      push$2(result, serialize(entry.key) + "=" + serialize(entry.value));
    }
    return join$1(result, "&");
  },
  update: function() {
    this.entries.length = 0;
    this.parseQuery(this.url.query);
  },
  updateURL: function() {
    if (this.url) this.url.update();
  }
};
var URLSearchParamsConstructor = function URLSearchParams2() {
  anInstance$1(this, URLSearchParamsPrototype$3);
  var init = arguments.length > 0 ? arguments[0] : void 0;
  var state = setInternalState$1(this, new URLSearchParamsState(init));
  if (!DESCRIPTORS$2) this.size = state.entries.length;
};
var URLSearchParamsPrototype$3 = URLSearchParamsConstructor.prototype;
defineBuiltIns(URLSearchParamsPrototype$3, {
  // `URLSearchParams.prototype.append` method
  // https://url.spec.whatwg.org/#dom-urlsearchparams-append
  append: function append(name, value) {
    var state = getInternalParamsState(this);
    validateArgumentsLength$5(arguments.length, 2);
    push$2(state.entries, {
      key: $toString$1(name),
      value: $toString$1(value)
    });
    if (!DESCRIPTORS$2) this.length++;
    state.updateURL();
  },
  // `URLSearchParams.prototype.delete` method
  // https://url.spec.whatwg.org/#dom-urlsearchparams-delete
  "delete": function(name) {
    var state = getInternalParamsState(this);
    var length = validateArgumentsLength$5(arguments.length, 1);
    var entries22 = state.entries;
    var key = $toString$1(name);
    var $value = length < 2 ? void 0 : arguments[1];
    var value = $value === void 0 ? $value : $toString$1($value);
    var index = 0;
    while (index < entries22.length) {
      var entry = entries22[index];
      if (entry.key === key && (value === void 0 || entry.value === value)) {
        splice$1(entries22, index, 1);
        if (value !== void 0) break;
      } else index++;
    }
    if (!DESCRIPTORS$2) this.size = entries22.length;
    state.updateURL();
  },
  // `URLSearchParams.prototype.get` method
  // https://url.spec.whatwg.org/#dom-urlsearchparams-get
  get: function get2(name) {
    var entries22 = getInternalParamsState(this).entries;
    validateArgumentsLength$5(arguments.length, 1);
    var key = $toString$1(name);
    var index = 0;
    for (; index < entries22.length; index++) {
      if (entries22[index].key === key) return entries22[index].value;
    }
    return null;
  },
  // `URLSearchParams.prototype.getAll` method
  // https://url.spec.whatwg.org/#dom-urlsearchparams-getall
  getAll: function getAll(name) {
    var entries22 = getInternalParamsState(this).entries;
    validateArgumentsLength$5(arguments.length, 1);
    var key = $toString$1(name);
    var result = [];
    var index = 0;
    for (; index < entries22.length; index++) {
      if (entries22[index].key === key) push$2(result, entries22[index].value);
    }
    return result;
  },
  // `URLSearchParams.prototype.has` method
  // https://url.spec.whatwg.org/#dom-urlsearchparams-has
  has: function has2(name) {
    var entries22 = getInternalParamsState(this).entries;
    var length = validateArgumentsLength$5(arguments.length, 1);
    var key = $toString$1(name);
    var $value = length < 2 ? void 0 : arguments[1];
    var value = $value === void 0 ? $value : $toString$1($value);
    var index = 0;
    while (index < entries22.length) {
      var entry = entries22[index++];
      if (entry.key === key && (value === void 0 || entry.value === value)) return true;
    }
    return false;
  },
  // `URLSearchParams.prototype.set` method
  // https://url.spec.whatwg.org/#dom-urlsearchparams-set
  set: function set3(name, value) {
    var state = getInternalParamsState(this);
    validateArgumentsLength$5(arguments.length, 1);
    var entries22 = state.entries;
    var found = false;
    var key = $toString$1(name);
    var val = $toString$1(value);
    var index = 0;
    var entry;
    for (; index < entries22.length; index++) {
      entry = entries22[index];
      if (entry.key === key) {
        if (found) splice$1(entries22, index--, 1);
        else {
          found = true;
          entry.value = val;
        }
      }
    }
    if (!found) push$2(entries22, {
      key,
      value: val
    });
    if (!DESCRIPTORS$2) this.size = entries22.length;
    state.updateURL();
  },
  // `URLSearchParams.prototype.sort` method
  // https://url.spec.whatwg.org/#dom-urlsearchparams-sort
  sort: function sort4() {
    var state = getInternalParamsState(this);
    arraySort(state.entries, function(a, b) {
      return a.key > b.key ? 1 : -1;
    });
    state.updateURL();
  },
  // `URLSearchParams.prototype.forEach` method
  forEach: function forEach5(callback2) {
    var entries22 = getInternalParamsState(this).entries;
    var boundFunction = bind$1(callback2, arguments.length > 1 ? arguments[1] : void 0);
    var index = 0;
    var entry;
    while (index < entries22.length) {
      entry = entries22[index++];
      boundFunction(entry.value, entry.key, this);
    }
  },
  // `URLSearchParams.prototype.keys` method
  keys: function keys5() {
    return new URLSearchParamsIterator(this, "keys");
  },
  // `URLSearchParams.prototype.values` method
  values: function values3() {
    return new URLSearchParamsIterator(this, "values");
  },
  // `URLSearchParams.prototype.entries` method
  entries: function entries4() {
    return new URLSearchParamsIterator(this, "entries");
  }
}, {
  enumerable: true
});
defineBuiltIn$3(URLSearchParamsPrototype$3, ITERATOR, URLSearchParamsPrototype$3.entries, {
  name: "entries"
});
defineBuiltIn$3(URLSearchParamsPrototype$3, "toString", function toString4() {
  return getInternalParamsState(this).serialize();
}, {
  enumerable: true
});
if (DESCRIPTORS$2) defineBuiltInAccessor$2(URLSearchParamsPrototype$3, "size", {
  get: function size2() {
    return getInternalParamsState(this).entries.length;
  },
  configurable: true,
  enumerable: true
});
setToStringTag$1(URLSearchParamsConstructor, URL_SEARCH_PARAMS);
$$4({
  global: true,
  constructor: true,
  forced: !USE_NATIVE_URL$3
}, {
  URLSearchParams: URLSearchParamsConstructor
});
if (!USE_NATIVE_URL$3 && isCallable2(Headers$1)) {
  var headersHas = uncurryThis$4(HeadersPrototype.has);
  var headersSet = uncurryThis$4(HeadersPrototype.set);
  var wrapRequestOptions = function(init) {
    if (isObject(init)) {
      var body2 = init.body;
      var headers;
      if (classof(body2) === URL_SEARCH_PARAMS) {
        headers = init.headers ? new Headers$1(init.headers) : new Headers$1();
        if (!headersHas(headers, "content-type")) {
          headersSet(headers, "content-type", "application/x-www-form-urlencoded;charset=UTF-8");
        }
        return create3(init, {
          body: createPropertyDescriptor(0, $toString$1(body2)),
          headers: createPropertyDescriptor(0, headers)
        });
      }
    }
    return init;
  };
  if (isCallable2(nativeFetch)) {
    $$4({
      global: true,
      enumerable: true,
      dontCallGetSet: true,
      forced: true
    }, {
      fetch: function fetch2(input) {
        return nativeFetch(input, arguments.length > 1 ? wrapRequestOptions(arguments[1]) : {});
      }
    });
  }
  if (isCallable2(NativeRequest)) {
    var RequestConstructor = function Request(input) {
      anInstance$1(this, RequestPrototype);
      return new NativeRequest(input, arguments.length > 1 ? wrapRequestOptions(arguments[1]) : {});
    };
    RequestPrototype.constructor = RequestConstructor;
    RequestConstructor.prototype = RequestPrototype;
    $$4({
      global: true,
      constructor: true,
      dontCallGetSet: true,
      forced: true
    }, {
      Request: RequestConstructor
    });
  }
}
var web_urlSearchParams_constructor = {
  URLSearchParams: URLSearchParamsConstructor,
  getState: getInternalParamsState
};
var $$3 = _export;
var DESCRIPTORS$1 = descriptors;
var USE_NATIVE_URL$2 = urlConstructorDetection;
var globalThis$1 = globalThis_1;
var bind2 = functionBindContext;
var uncurryThis$3 = functionUncurryThis;
var defineBuiltIn$2 = defineBuiltIn$u;
var defineBuiltInAccessor$1 = defineBuiltInAccessor$p;
var anInstance = anInstance$f;
var hasOwn2 = hasOwnProperty_1;
var assign2 = objectAssign;
var arrayFrom = arrayFrom$1;
var arraySlice = arraySlice$a;
var codeAt = stringMultibyte.codeAt;
var toASCII = stringPunycodeToAscii;
var $toString = toString$J;
var setToStringTag = setToStringTag$e;
var validateArgumentsLength$4 = validateArgumentsLength$c;
var URLSearchParamsModule = web_urlSearchParams_constructor;
var InternalStateModule = internalState;
var setInternalState = InternalStateModule.set;
var getInternalURLState = InternalStateModule.getterFor("URL");
var URLSearchParams$1 = URLSearchParamsModule.URLSearchParams;
var getInternalSearchParamsState = URLSearchParamsModule.getState;
var NativeURL = globalThis$1.URL;
var TypeError$1 = globalThis$1.TypeError;
var parseInt$1 = globalThis$1.parseInt;
var floor = Math.floor;
var pow = Math.pow;
var charAt = uncurryThis$3("".charAt);
var exec = uncurryThis$3(/./.exec);
var join4 = uncurryThis$3([].join);
var numberToString = uncurryThis$3(1 .toString);
var pop = uncurryThis$3([].pop);
var push$1 = uncurryThis$3([].push);
var replace = uncurryThis$3("".replace);
var shift = uncurryThis$3([].shift);
var split = uncurryThis$3("".split);
var stringSlice = uncurryThis$3("".slice);
var toLowerCase = uncurryThis$3("".toLowerCase);
var unshift2 = uncurryThis$3([].unshift);
var INVALID_AUTHORITY = "Invalid authority";
var INVALID_SCHEME = "Invalid scheme";
var INVALID_HOST = "Invalid host";
var INVALID_PORT = "Invalid port";
var ALPHA = /[a-z]/i;
var ALPHANUMERIC = /[\d+-.a-z]/i;
var DIGIT = /\d/;
var HEX_START = /^0x/i;
var OCT = /^[0-7]+$/;
var DEC = /^\d+$/;
var HEX = /^[\da-f]+$/i;
var FORBIDDEN_HOST_CODE_POINT = /[\0\t\n\r #%/:<>?@[\\\]^|]/;
var FORBIDDEN_HOST_CODE_POINT_EXCLUDING_PERCENT = /[\0\t\n\r #/:<>?@[\\\]^|]/;
var LEADING_C0_CONTROL_OR_SPACE = /^[\u0000-\u0020]+/;
var TRAILING_C0_CONTROL_OR_SPACE = /(^|[^\u0000-\u0020])[\u0000-\u0020]+$/;
var TAB_AND_NEW_LINE = /[\t\n\r]/g;
var EOF;
var parseIPv4 = function(input) {
  var parts = split(input, ".");
  var partsLength, numbers, index, part, radix, number, ipv4;
  if (parts.length && parts[parts.length - 1] === "") {
    parts.length--;
  }
  partsLength = parts.length;
  if (partsLength > 4) return input;
  numbers = [];
  for (index = 0; index < partsLength; index++) {
    part = parts[index];
    if (part === "") return input;
    radix = 10;
    if (part.length > 1 && charAt(part, 0) === "0") {
      radix = exec(HEX_START, part) ? 16 : 8;
      part = stringSlice(part, radix === 8 ? 1 : 2);
    }
    if (part === "") {
      number = 0;
    } else {
      if (!exec(radix === 10 ? DEC : radix === 8 ? OCT : HEX, part)) return input;
      number = parseInt$1(part, radix);
    }
    push$1(numbers, number);
  }
  for (index = 0; index < partsLength; index++) {
    number = numbers[index];
    if (index === partsLength - 1) {
      if (number >= pow(256, 5 - partsLength)) return null;
    } else if (number > 255) return null;
  }
  ipv4 = pop(numbers);
  for (index = 0; index < numbers.length; index++) {
    ipv4 += numbers[index] * pow(256, 3 - index);
  }
  return ipv4;
};
var parseIPv6 = function(input) {
  var address = [0, 0, 0, 0, 0, 0, 0, 0];
  var pieceIndex = 0;
  var compress = null;
  var pointer = 0;
  var value, length, numbersSeen, ipv4Piece, number, swaps, swap;
  var chr = function() {
    return charAt(input, pointer);
  };
  if (chr() === ":") {
    if (charAt(input, 1) !== ":") return;
    pointer += 2;
    pieceIndex++;
    compress = pieceIndex;
  }
  while (chr()) {
    if (pieceIndex === 8) return;
    if (chr() === ":") {
      if (compress !== null) return;
      pointer++;
      pieceIndex++;
      compress = pieceIndex;
      continue;
    }
    value = length = 0;
    while (length < 4 && exec(HEX, chr())) {
      value = value * 16 + parseInt$1(chr(), 16);
      pointer++;
      length++;
    }
    if (chr() === ".") {
      if (length === 0) return;
      pointer -= length;
      if (pieceIndex > 6) return;
      numbersSeen = 0;
      while (chr()) {
        ipv4Piece = null;
        if (numbersSeen > 0) {
          if (chr() === "." && numbersSeen < 4) pointer++;
          else return;
        }
        if (!exec(DIGIT, chr())) return;
        while (exec(DIGIT, chr())) {
          number = parseInt$1(chr(), 10);
          if (ipv4Piece === null) ipv4Piece = number;
          else if (ipv4Piece === 0) return;
          else ipv4Piece = ipv4Piece * 10 + number;
          if (ipv4Piece > 255) return;
          pointer++;
        }
        address[pieceIndex] = address[pieceIndex] * 256 + ipv4Piece;
        numbersSeen++;
        if (numbersSeen === 2 || numbersSeen === 4) pieceIndex++;
      }
      if (numbersSeen !== 4) return;
      break;
    } else if (chr() === ":") {
      pointer++;
      if (!chr()) return;
    } else if (chr()) return;
    address[pieceIndex++] = value;
  }
  if (compress !== null) {
    swaps = pieceIndex - compress;
    pieceIndex = 7;
    while (pieceIndex !== 0 && swaps > 0) {
      swap = address[pieceIndex];
      address[pieceIndex--] = address[compress + swaps - 1];
      address[compress + --swaps] = swap;
    }
  } else if (pieceIndex !== 8) return;
  return address;
};
var findLongestZeroSequence = function(ipv6) {
  var maxIndex = null;
  var maxLength = 1;
  var currStart = null;
  var currLength = 0;
  var index = 0;
  for (; index < 8; index++) {
    if (ipv6[index] !== 0) {
      if (currLength > maxLength) {
        maxIndex = currStart;
        maxLength = currLength;
      }
      currStart = null;
      currLength = 0;
    } else {
      if (currStart === null) currStart = index;
      ++currLength;
    }
  }
  return currLength > maxLength ? currStart : maxIndex;
};
var serializeHost = function(host) {
  var result, index, compress, ignore0;
  if (typeof host == "number") {
    result = [];
    for (index = 0; index < 4; index++) {
      unshift2(result, host % 256);
      host = floor(host / 256);
    }
    return join4(result, ".");
  }
  if (typeof host == "object") {
    result = "";
    compress = findLongestZeroSequence(host);
    for (index = 0; index < 8; index++) {
      if (ignore0 && host[index] === 0) continue;
      if (ignore0) ignore0 = false;
      if (compress === index) {
        result += index ? ":" : "::";
        ignore0 = true;
      } else {
        result += numberToString(host[index], 16);
        if (index < 7) result += ":";
      }
    }
    return "[" + result + "]";
  }
  return host;
};
var C0ControlPercentEncodeSet = {};
var fragmentPercentEncodeSet = assign2({}, C0ControlPercentEncodeSet, {
  " ": 1,
  '"': 1,
  "<": 1,
  ">": 1,
  "`": 1
});
var pathPercentEncodeSet = assign2({}, fragmentPercentEncodeSet, {
  "#": 1,
  "?": 1,
  "{": 1,
  "}": 1
});
var userinfoPercentEncodeSet = assign2({}, pathPercentEncodeSet, {
  "/": 1,
  ":": 1,
  ";": 1,
  "=": 1,
  "@": 1,
  "[": 1,
  "\\": 1,
  "]": 1,
  "^": 1,
  "|": 1
});
var percentEncode = function(chr, set4) {
  var code2 = codeAt(chr, 0);
  return code2 > 32 && code2 < 127 && !hasOwn2(set4, chr) ? chr : encodeURIComponent(chr);
};
var specialSchemes = {
  ftp: 21,
  file: null,
  http: 80,
  https: 443,
  ws: 80,
  wss: 443
};
var isWindowsDriveLetter = function(string, normalized) {
  var second;
  return string.length === 2 && exec(ALPHA, charAt(string, 0)) && ((second = charAt(string, 1)) === ":" || !normalized && second === "|");
};
var startsWithWindowsDriveLetter = function(string) {
  var third;
  return string.length > 1 && isWindowsDriveLetter(stringSlice(string, 0, 2)) && (string.length === 2 || (third = charAt(string, 2)) === "/" || third === "\\" || third === "?" || third === "#");
};
var isSingleDot = function(segment) {
  return segment === "." || toLowerCase(segment) === "%2e";
};
var isDoubleDot = function(segment) {
  segment = toLowerCase(segment);
  return segment === ".." || segment === "%2e." || segment === ".%2e" || segment === "%2e%2e";
};
var SCHEME_START = {};
var SCHEME = {};
var NO_SCHEME = {};
var SPECIAL_RELATIVE_OR_AUTHORITY = {};
var PATH_OR_AUTHORITY = {};
var RELATIVE = {};
var RELATIVE_SLASH = {};
var SPECIAL_AUTHORITY_SLASHES = {};
var SPECIAL_AUTHORITY_IGNORE_SLASHES = {};
var AUTHORITY = {};
var HOST = {};
var HOSTNAME = {};
var PORT = {};
var FILE = {};
var FILE_SLASH = {};
var FILE_HOST = {};
var PATH_START = {};
var PATH = {};
var CANNOT_BE_A_BASE_URL_PATH = {};
var QUERY = {};
var FRAGMENT = {};
var URLState = function(url, isBase, base2) {
  var urlString = $toString(url);
  var baseState, failure, searchParams;
  if (isBase) {
    failure = this.parse(urlString);
    if (failure) throw new TypeError$1(failure);
    this.searchParams = null;
  } else {
    if (base2 !== void 0) baseState = new URLState(base2, true);
    failure = this.parse(urlString, null, baseState);
    if (failure) throw new TypeError$1(failure);
    searchParams = getInternalSearchParamsState(new URLSearchParams$1());
    searchParams.bindURL(this);
    this.searchParams = searchParams;
  }
};
URLState.prototype = {
  type: "URL",
  // https://url.spec.whatwg.org/#url-parsing
  // eslint-disable-next-line max-statements -- TODO
  parse: function(input, stateOverride, base2) {
    var url = this;
    var state = stateOverride || SCHEME_START;
    var pointer = 0;
    var buffer2 = "";
    var seenAt = false;
    var seenBracket = false;
    var seenPasswordToken = false;
    var codePoints3, chr, bufferCodePoints, failure;
    input = $toString(input);
    if (!stateOverride) {
      url.scheme = "";
      url.username = "";
      url.password = "";
      url.host = null;
      url.port = null;
      url.path = [];
      url.query = null;
      url.fragment = null;
      url.cannotBeABaseURL = false;
      input = replace(input, LEADING_C0_CONTROL_OR_SPACE, "");
      input = replace(input, TRAILING_C0_CONTROL_OR_SPACE, "$1");
    }
    input = replace(input, TAB_AND_NEW_LINE, "");
    codePoints3 = arrayFrom(input);
    while (pointer <= codePoints3.length) {
      chr = codePoints3[pointer];
      switch (state) {
        case SCHEME_START:
          if (chr && exec(ALPHA, chr)) {
            buffer2 += toLowerCase(chr);
            state = SCHEME;
          } else if (!stateOverride) {
            state = NO_SCHEME;
            continue;
          } else return INVALID_SCHEME;
          break;
        case SCHEME:
          if (chr && (exec(ALPHANUMERIC, chr) || chr === "+" || chr === "-" || chr === ".")) {
            buffer2 += toLowerCase(chr);
          } else if (chr === ":") {
            if (stateOverride && (url.isSpecial() !== hasOwn2(specialSchemes, buffer2) || buffer2 === "file" && (url.includesCredentials() || url.port !== null) || url.scheme === "file" && !url.host)) return;
            url.scheme = buffer2;
            if (stateOverride) {
              if (url.isSpecial() && specialSchemes[url.scheme] === url.port) url.port = null;
              return;
            }
            buffer2 = "";
            if (url.scheme === "file") {
              state = FILE;
            } else if (url.isSpecial() && base2 && base2.scheme === url.scheme) {
              state = SPECIAL_RELATIVE_OR_AUTHORITY;
            } else if (url.isSpecial()) {
              state = SPECIAL_AUTHORITY_SLASHES;
            } else if (codePoints3[pointer + 1] === "/") {
              state = PATH_OR_AUTHORITY;
              pointer++;
            } else {
              url.cannotBeABaseURL = true;
              push$1(url.path, "");
              state = CANNOT_BE_A_BASE_URL_PATH;
            }
          } else if (!stateOverride) {
            buffer2 = "";
            state = NO_SCHEME;
            pointer = 0;
            continue;
          } else return INVALID_SCHEME;
          break;
        case NO_SCHEME:
          if (!base2 || base2.cannotBeABaseURL && chr !== "#") return INVALID_SCHEME;
          if (base2.cannotBeABaseURL && chr === "#") {
            url.scheme = base2.scheme;
            url.path = arraySlice(base2.path);
            url.query = base2.query;
            url.fragment = "";
            url.cannotBeABaseURL = true;
            state = FRAGMENT;
            break;
          }
          state = base2.scheme === "file" ? FILE : RELATIVE;
          continue;
        case SPECIAL_RELATIVE_OR_AUTHORITY:
          if (chr === "/" && codePoints3[pointer + 1] === "/") {
            state = SPECIAL_AUTHORITY_IGNORE_SLASHES;
            pointer++;
          } else {
            state = RELATIVE;
            continue;
          }
          break;
        case PATH_OR_AUTHORITY:
          if (chr === "/") {
            state = AUTHORITY;
            break;
          } else {
            state = PATH;
            continue;
          }
        case RELATIVE:
          url.scheme = base2.scheme;
          if (chr === EOF) {
            url.username = base2.username;
            url.password = base2.password;
            url.host = base2.host;
            url.port = base2.port;
            url.path = arraySlice(base2.path);
            url.query = base2.query;
          } else if (chr === "/" || chr === "\\" && url.isSpecial()) {
            state = RELATIVE_SLASH;
          } else if (chr === "?") {
            url.username = base2.username;
            url.password = base2.password;
            url.host = base2.host;
            url.port = base2.port;
            url.path = arraySlice(base2.path);
            url.query = "";
            state = QUERY;
          } else if (chr === "#") {
            url.username = base2.username;
            url.password = base2.password;
            url.host = base2.host;
            url.port = base2.port;
            url.path = arraySlice(base2.path);
            url.query = base2.query;
            url.fragment = "";
            state = FRAGMENT;
          } else {
            url.username = base2.username;
            url.password = base2.password;
            url.host = base2.host;
            url.port = base2.port;
            url.path = arraySlice(base2.path);
            url.path.length--;
            state = PATH;
            continue;
          }
          break;
        case RELATIVE_SLASH:
          if (url.isSpecial() && (chr === "/" || chr === "\\")) {
            state = SPECIAL_AUTHORITY_IGNORE_SLASHES;
          } else if (chr === "/") {
            state = AUTHORITY;
          } else {
            url.username = base2.username;
            url.password = base2.password;
            url.host = base2.host;
            url.port = base2.port;
            state = PATH;
            continue;
          }
          break;
        case SPECIAL_AUTHORITY_SLASHES:
          state = SPECIAL_AUTHORITY_IGNORE_SLASHES;
          if (chr !== "/" || charAt(buffer2, pointer + 1) !== "/") continue;
          pointer++;
          break;
        case SPECIAL_AUTHORITY_IGNORE_SLASHES:
          if (chr !== "/" && chr !== "\\") {
            state = AUTHORITY;
            continue;
          }
          break;
        case AUTHORITY:
          if (chr === "@") {
            if (seenAt) buffer2 = "%40" + buffer2;
            seenAt = true;
            bufferCodePoints = arrayFrom(buffer2);
            for (var i = 0; i < bufferCodePoints.length; i++) {
              var codePoint = bufferCodePoints[i];
              if (codePoint === ":" && !seenPasswordToken) {
                seenPasswordToken = true;
                continue;
              }
              var encodedCodePoints = percentEncode(codePoint, userinfoPercentEncodeSet);
              if (seenPasswordToken) url.password += encodedCodePoints;
              else url.username += encodedCodePoints;
            }
            buffer2 = "";
          } else if (chr === EOF || chr === "/" || chr === "?" || chr === "#" || chr === "\\" && url.isSpecial()) {
            if (seenAt && buffer2 === "") return INVALID_AUTHORITY;
            pointer -= arrayFrom(buffer2).length + 1;
            buffer2 = "";
            state = HOST;
          } else buffer2 += chr;
          break;
        case HOST:
        case HOSTNAME:
          if (stateOverride && url.scheme === "file") {
            state = FILE_HOST;
            continue;
          } else if (chr === ":" && !seenBracket) {
            if (buffer2 === "") return INVALID_HOST;
            failure = url.parseHost(buffer2);
            if (failure) return failure;
            buffer2 = "";
            state = PORT;
            if (stateOverride === HOSTNAME) return;
          } else if (chr === EOF || chr === "/" || chr === "?" || chr === "#" || chr === "\\" && url.isSpecial()) {
            if (url.isSpecial() && buffer2 === "") return INVALID_HOST;
            if (stateOverride && buffer2 === "" && (url.includesCredentials() || url.port !== null)) return;
            failure = url.parseHost(buffer2);
            if (failure) return failure;
            buffer2 = "";
            state = PATH_START;
            if (stateOverride) return;
            continue;
          } else {
            if (chr === "[") seenBracket = true;
            else if (chr === "]") seenBracket = false;
            buffer2 += chr;
          }
          break;
        case PORT:
          if (exec(DIGIT, chr)) {
            buffer2 += chr;
          } else if (chr === EOF || chr === "/" || chr === "?" || chr === "#" || chr === "\\" && url.isSpecial() || stateOverride) {
            if (buffer2 !== "") {
              var port2 = parseInt$1(buffer2, 10);
              if (port2 > 65535) return INVALID_PORT;
              url.port = url.isSpecial() && port2 === specialSchemes[url.scheme] ? null : port2;
              buffer2 = "";
            }
            if (stateOverride) return;
            state = PATH_START;
            continue;
          } else return INVALID_PORT;
          break;
        case FILE:
          url.scheme = "file";
          if (chr === "/" || chr === "\\") state = FILE_SLASH;
          else if (base2 && base2.scheme === "file") {
            switch (chr) {
              case EOF:
                url.host = base2.host;
                url.path = arraySlice(base2.path);
                url.query = base2.query;
                break;
              case "?":
                url.host = base2.host;
                url.path = arraySlice(base2.path);
                url.query = "";
                state = QUERY;
                break;
              case "#":
                url.host = base2.host;
                url.path = arraySlice(base2.path);
                url.query = base2.query;
                url.fragment = "";
                state = FRAGMENT;
                break;
              default:
                if (!startsWithWindowsDriveLetter(join4(arraySlice(codePoints3, pointer), ""))) {
                  url.host = base2.host;
                  url.path = arraySlice(base2.path);
                  url.shortenPath();
                }
                state = PATH;
                continue;
            }
          } else {
            state = PATH;
            continue;
          }
          break;
        case FILE_SLASH:
          if (chr === "/" || chr === "\\") {
            state = FILE_HOST;
            break;
          }
          if (base2 && base2.scheme === "file" && !startsWithWindowsDriveLetter(join4(arraySlice(codePoints3, pointer), ""))) {
            if (isWindowsDriveLetter(base2.path[0], true)) push$1(url.path, base2.path[0]);
            else url.host = base2.host;
          }
          state = PATH;
          continue;
        case FILE_HOST:
          if (chr === EOF || chr === "/" || chr === "\\" || chr === "?" || chr === "#") {
            if (!stateOverride && isWindowsDriveLetter(buffer2)) {
              state = PATH;
            } else if (buffer2 === "") {
              url.host = "";
              if (stateOverride) return;
              state = PATH_START;
            } else {
              failure = url.parseHost(buffer2);
              if (failure) return failure;
              if (url.host === "localhost") url.host = "";
              if (stateOverride) return;
              buffer2 = "";
              state = PATH_START;
            }
            continue;
          } else buffer2 += chr;
          break;
        case PATH_START:
          if (url.isSpecial()) {
            state = PATH;
            if (chr !== "/" && chr !== "\\") continue;
          } else if (!stateOverride && chr === "?") {
            url.query = "";
            state = QUERY;
          } else if (!stateOverride && chr === "#") {
            url.fragment = "";
            state = FRAGMENT;
          } else if (chr !== EOF) {
            state = PATH;
            if (chr !== "/") continue;
          }
          break;
        case PATH:
          if (chr === EOF || chr === "/" || chr === "\\" && url.isSpecial() || !stateOverride && (chr === "?" || chr === "#")) {
            if (isDoubleDot(buffer2)) {
              url.shortenPath();
              if (chr !== "/" && !(chr === "\\" && url.isSpecial())) {
                push$1(url.path, "");
              }
            } else if (isSingleDot(buffer2)) {
              if (chr !== "/" && !(chr === "\\" && url.isSpecial())) {
                push$1(url.path, "");
              }
            } else {
              if (url.scheme === "file" && !url.path.length && isWindowsDriveLetter(buffer2)) {
                if (url.host) url.host = "";
                buffer2 = charAt(buffer2, 0) + ":";
              }
              push$1(url.path, buffer2);
            }
            buffer2 = "";
            if (url.scheme === "file" && (chr === EOF || chr === "?" || chr === "#")) {
              while (url.path.length > 1 && url.path[0] === "") {
                shift(url.path);
              }
            }
            if (chr === "?") {
              url.query = "";
              state = QUERY;
            } else if (chr === "#") {
              url.fragment = "";
              state = FRAGMENT;
            }
          } else {
            buffer2 += percentEncode(chr, pathPercentEncodeSet);
          }
          break;
        case CANNOT_BE_A_BASE_URL_PATH:
          if (chr === "?") {
            url.query = "";
            state = QUERY;
          } else if (chr === "#") {
            url.fragment = "";
            state = FRAGMENT;
          } else if (chr !== EOF) {
            url.path[0] += percentEncode(chr, C0ControlPercentEncodeSet);
          }
          break;
        case QUERY:
          if (!stateOverride && chr === "#") {
            url.fragment = "";
            state = FRAGMENT;
          } else if (chr !== EOF) {
            if (chr === "'" && url.isSpecial()) url.query += "%27";
            else if (chr === "#") url.query += "%23";
            else url.query += percentEncode(chr, C0ControlPercentEncodeSet);
          }
          break;
        case FRAGMENT:
          if (chr !== EOF) url.fragment += percentEncode(chr, fragmentPercentEncodeSet);
          break;
      }
      pointer++;
    }
  },
  // https://url.spec.whatwg.org/#host-parsing
  parseHost: function(input) {
    var result, codePoints3, index;
    if (charAt(input, 0) === "[") {
      if (charAt(input, input.length - 1) !== "]") return INVALID_HOST;
      result = parseIPv6(stringSlice(input, 1, -1));
      if (!result) return INVALID_HOST;
      this.host = result;
    } else if (!this.isSpecial()) {
      if (exec(FORBIDDEN_HOST_CODE_POINT_EXCLUDING_PERCENT, input)) return INVALID_HOST;
      result = "";
      codePoints3 = arrayFrom(input);
      for (index = 0; index < codePoints3.length; index++) {
        result += percentEncode(codePoints3[index], C0ControlPercentEncodeSet);
      }
      this.host = result;
    } else {
      input = toASCII(input);
      if (exec(FORBIDDEN_HOST_CODE_POINT, input)) return INVALID_HOST;
      result = parseIPv4(input);
      if (result === null) return INVALID_HOST;
      this.host = result;
    }
  },
  // https://url.spec.whatwg.org/#cannot-have-a-username-password-port
  cannotHaveUsernamePasswordPort: function() {
    return !this.host || this.cannotBeABaseURL || this.scheme === "file";
  },
  // https://url.spec.whatwg.org/#include-credentials
  includesCredentials: function() {
    return this.username !== "" || this.password !== "";
  },
  // https://url.spec.whatwg.org/#is-special
  isSpecial: function() {
    return hasOwn2(specialSchemes, this.scheme);
  },
  // https://url.spec.whatwg.org/#shorten-a-urls-path
  shortenPath: function() {
    var path2 = this.path;
    var pathSize = path2.length;
    if (pathSize && (this.scheme !== "file" || pathSize !== 1 || !isWindowsDriveLetter(path2[0], true))) {
      path2.length--;
    }
  },
  // https://url.spec.whatwg.org/#concept-url-serializer
  serialize: function() {
    var url = this;
    var scheme = url.scheme;
    var username = url.username;
    var password = url.password;
    var host = url.host;
    var port2 = url.port;
    var path2 = url.path;
    var query = url.query;
    var fragment = url.fragment;
    var output = scheme + ":";
    if (host !== null) {
      output += "//";
      if (url.includesCredentials()) {
        output += username + (password ? ":" + password : "") + "@";
      }
      output += serializeHost(host);
      if (port2 !== null) output += ":" + port2;
    } else if (scheme === "file") output += "//";
    output += url.cannotBeABaseURL ? path2[0] : path2.length ? "/" + join4(path2, "/") : "";
    if (query !== null) output += "?" + query;
    if (fragment !== null) output += "#" + fragment;
    return output;
  },
  // https://url.spec.whatwg.org/#dom-url-href
  setHref: function(href2) {
    var failure = this.parse(href2);
    if (failure) throw new TypeError$1(failure);
    this.searchParams.update();
  },
  // https://url.spec.whatwg.org/#dom-url-origin
  getOrigin: function() {
    var scheme = this.scheme;
    var port2 = this.port;
    if (scheme === "blob") try {
      return new URLConstructor(scheme.path[0]).origin;
    } catch (error3) {
      return "null";
    }
    if (scheme === "file" || !this.isSpecial()) return "null";
    return scheme + "://" + serializeHost(this.host) + (port2 !== null ? ":" + port2 : "");
  },
  // https://url.spec.whatwg.org/#dom-url-protocol
  getProtocol: function() {
    return this.scheme + ":";
  },
  setProtocol: function(protocol2) {
    this.parse($toString(protocol2) + ":", SCHEME_START);
  },
  // https://url.spec.whatwg.org/#dom-url-username
  getUsername: function() {
    return this.username;
  },
  setUsername: function(username) {
    var codePoints3 = arrayFrom($toString(username));
    if (this.cannotHaveUsernamePasswordPort()) return;
    this.username = "";
    for (var i = 0; i < codePoints3.length; i++) {
      this.username += percentEncode(codePoints3[i], userinfoPercentEncodeSet);
    }
  },
  // https://url.spec.whatwg.org/#dom-url-password
  getPassword: function() {
    return this.password;
  },
  setPassword: function(password) {
    var codePoints3 = arrayFrom($toString(password));
    if (this.cannotHaveUsernamePasswordPort()) return;
    this.password = "";
    for (var i = 0; i < codePoints3.length; i++) {
      this.password += percentEncode(codePoints3[i], userinfoPercentEncodeSet);
    }
  },
  // https://url.spec.whatwg.org/#dom-url-host
  getHost: function() {
    var host = this.host;
    var port2 = this.port;
    return host === null ? "" : port2 === null ? serializeHost(host) : serializeHost(host) + ":" + port2;
  },
  setHost: function(host) {
    if (this.cannotBeABaseURL) return;
    this.parse(host, HOST);
  },
  // https://url.spec.whatwg.org/#dom-url-hostname
  getHostname: function() {
    var host = this.host;
    return host === null ? "" : serializeHost(host);
  },
  setHostname: function(hostname) {
    if (this.cannotBeABaseURL) return;
    this.parse(hostname, HOSTNAME);
  },
  // https://url.spec.whatwg.org/#dom-url-port
  getPort: function() {
    var port2 = this.port;
    return port2 === null ? "" : $toString(port2);
  },
  setPort: function(port2) {
    if (this.cannotHaveUsernamePasswordPort()) return;
    port2 = $toString(port2);
    if (port2 === "") this.port = null;
    else this.parse(port2, PORT);
  },
  // https://url.spec.whatwg.org/#dom-url-pathname
  getPathname: function() {
    var path2 = this.path;
    return this.cannotBeABaseURL ? path2[0] : path2.length ? "/" + join4(path2, "/") : "";
  },
  setPathname: function(pathname2) {
    if (this.cannotBeABaseURL) return;
    this.path = [];
    this.parse(pathname2, PATH_START);
  },
  // https://url.spec.whatwg.org/#dom-url-search
  getSearch: function() {
    var query = this.query;
    return query ? "?" + query : "";
  },
  setSearch: function(search) {
    search = $toString(search);
    if (search === "") {
      this.query = null;
    } else {
      if (charAt(search, 0) === "?") search = stringSlice(search, 1);
      this.query = "";
      this.parse(search, QUERY);
    }
    this.searchParams.update();
  },
  // https://url.spec.whatwg.org/#dom-url-searchparams
  getSearchParams: function() {
    return this.searchParams.facade;
  },
  // https://url.spec.whatwg.org/#dom-url-hash
  getHash: function() {
    var fragment = this.fragment;
    return fragment ? "#" + fragment : "";
  },
  setHash: function(hash) {
    hash = $toString(hash);
    if (hash === "") {
      this.fragment = null;
      return;
    }
    if (charAt(hash, 0) === "#") hash = stringSlice(hash, 1);
    this.fragment = "";
    this.parse(hash, FRAGMENT);
  },
  update: function() {
    this.query = this.searchParams.serialize() || null;
  }
};
var URLConstructor = function URL2(url) {
  var that = anInstance(this, URLPrototype);
  var base2 = validateArgumentsLength$4(arguments.length, 1) > 1 ? arguments[1] : void 0;
  var state = setInternalState(that, new URLState(url, false, base2));
  if (!DESCRIPTORS$1) {
    that.href = state.serialize();
    that.origin = state.getOrigin();
    that.protocol = state.getProtocol();
    that.username = state.getUsername();
    that.password = state.getPassword();
    that.host = state.getHost();
    that.hostname = state.getHostname();
    that.port = state.getPort();
    that.pathname = state.getPathname();
    that.search = state.getSearch();
    that.searchParams = state.getSearchParams();
    that.hash = state.getHash();
  }
};
var URLPrototype = URLConstructor.prototype;
var accessorDescriptor = function(getter, setter) {
  return {
    get: function() {
      return getInternalURLState(this)[getter]();
    },
    set: setter && function(value) {
      return getInternalURLState(this)[setter](value);
    },
    configurable: true,
    enumerable: true
  };
};
if (DESCRIPTORS$1) {
  defineBuiltInAccessor$1(URLPrototype, "href", accessorDescriptor("serialize", "setHref"));
  defineBuiltInAccessor$1(URLPrototype, "origin", accessorDescriptor("getOrigin"));
  defineBuiltInAccessor$1(URLPrototype, "protocol", accessorDescriptor("getProtocol", "setProtocol"));
  defineBuiltInAccessor$1(URLPrototype, "username", accessorDescriptor("getUsername", "setUsername"));
  defineBuiltInAccessor$1(URLPrototype, "password", accessorDescriptor("getPassword", "setPassword"));
  defineBuiltInAccessor$1(URLPrototype, "host", accessorDescriptor("getHost", "setHost"));
  defineBuiltInAccessor$1(URLPrototype, "hostname", accessorDescriptor("getHostname", "setHostname"));
  defineBuiltInAccessor$1(URLPrototype, "port", accessorDescriptor("getPort", "setPort"));
  defineBuiltInAccessor$1(URLPrototype, "pathname", accessorDescriptor("getPathname", "setPathname"));
  defineBuiltInAccessor$1(URLPrototype, "search", accessorDescriptor("getSearch", "setSearch"));
  defineBuiltInAccessor$1(URLPrototype, "searchParams", accessorDescriptor("getSearchParams"));
  defineBuiltInAccessor$1(URLPrototype, "hash", accessorDescriptor("getHash", "setHash"));
}
defineBuiltIn$2(URLPrototype, "toJSON", function toJSON2() {
  return getInternalURLState(this).serialize();
}, {
  enumerable: true
});
defineBuiltIn$2(URLPrototype, "toString", function toString5() {
  return getInternalURLState(this).serialize();
}, {
  enumerable: true
});
if (NativeURL) {
  var nativeCreateObjectURL = NativeURL.createObjectURL;
  var nativeRevokeObjectURL = NativeURL.revokeObjectURL;
  if (nativeCreateObjectURL) defineBuiltIn$2(URLConstructor, "createObjectURL", bind2(nativeCreateObjectURL, NativeURL));
  if (nativeRevokeObjectURL) defineBuiltIn$2(URLConstructor, "revokeObjectURL", bind2(nativeRevokeObjectURL, NativeURL));
}
setToStringTag(URLConstructor, "URL");
$$3({
  global: true,
  constructor: true,
  forced: !USE_NATIVE_URL$2,
  sham: !DESCRIPTORS$1
}, {
  URL: URLConstructor
});
var $$2 = _export;
var getBuiltIn$1 = getBuiltIn$Q;
var fails = fails$1z;
var validateArgumentsLength$3 = validateArgumentsLength$c;
var toString$3 = toString$J;
var USE_NATIVE_URL$1 = urlConstructorDetection;
var URL$2 = getBuiltIn$1("URL");
var THROWS_WITHOUT_ARGUMENTS = USE_NATIVE_URL$1 && fails(function() {
  URL$2.canParse();
});
var WRONG_ARITY = fails(function() {
  return URL$2.canParse.length !== 1;
});
$$2({
  target: "URL",
  stat: true,
  forced: !THROWS_WITHOUT_ARGUMENTS || WRONG_ARITY
}, {
  canParse: function canParse(url) {
    var length = validateArgumentsLength$3(arguments.length, 1);
    var urlString = toString$3(url);
    var base2 = length < 2 || arguments[1] === void 0 ? void 0 : toString$3(arguments[1]);
    try {
      return !!new URL$2(urlString, base2);
    } catch (error3) {
      return false;
    }
  }
});
var $$1 = _export;
var getBuiltIn = getBuiltIn$Q;
var validateArgumentsLength$2 = validateArgumentsLength$c;
var toString$2 = toString$J;
var USE_NATIVE_URL = urlConstructorDetection;
var URL$1 = getBuiltIn("URL");
$$1({
  target: "URL",
  stat: true,
  forced: !USE_NATIVE_URL
}, {
  parse: function parse3(url) {
    var length = validateArgumentsLength$2(arguments.length, 1);
    var urlString = toString$2(url);
    var base2 = length < 2 || arguments[1] === void 0 ? void 0 : toString$2(arguments[1]);
    try {
      return new URL$1(urlString, base2);
    } catch (error3) {
      return null;
    }
  }
});
var $ = _export;
var call = functionCall;
$({
  target: "URL",
  proto: true,
  enumerable: true
}, {
  toJSON: function toJSON3() {
    return call(URL.prototype.toString, this);
  }
});
var defineBuiltIn$1 = defineBuiltIn$u;
var uncurryThis$2 = functionUncurryThis;
var toString$1 = toString$J;
var validateArgumentsLength$1 = validateArgumentsLength$c;
var $URLSearchParams$1 = URLSearchParams;
var URLSearchParamsPrototype$2 = $URLSearchParams$1.prototype;
var append2 = uncurryThis$2(URLSearchParamsPrototype$2.append);
var $delete = uncurryThis$2(URLSearchParamsPrototype$2["delete"]);
var forEach$1 = uncurryThis$2(URLSearchParamsPrototype$2.forEach);
var push2 = uncurryThis$2([].push);
var params$1 = new $URLSearchParams$1("a=1&a=2&b=3");
params$1["delete"]("a", 1);
params$1["delete"]("b", void 0);
if (params$1 + "" !== "a=2") {
  defineBuiltIn$1(URLSearchParamsPrototype$2, "delete", function(name) {
    var length = arguments.length;
    var $value = length < 2 ? void 0 : arguments[1];
    if (length && $value === void 0) return $delete(this, name);
    var entries5 = [];
    forEach$1(this, function(v, k) {
      push2(entries5, {
        key: k,
        value: v
      });
    });
    validateArgumentsLength$1(length, 1);
    var key = toString$1(name);
    var value = toString$1($value);
    var index = 0;
    var dindex = 0;
    var found = false;
    var entriesLength = entries5.length;
    var entry;
    while (index < entriesLength) {
      entry = entries5[index++];
      if (found || entry.key === key) {
        found = true;
        $delete(this, entry.key);
      } else dindex++;
    }
    while (dindex < entriesLength) {
      entry = entries5[dindex++];
      if (!(entry.key === key && entry.value === value)) append2(this, entry.key, entry.value);
    }
  }, {
    enumerable: true,
    unsafe: true
  });
}
var defineBuiltIn = defineBuiltIn$u;
var uncurryThis$1 = functionUncurryThis;
var toString6 = toString$J;
var validateArgumentsLength = validateArgumentsLength$c;
var $URLSearchParams = URLSearchParams;
var URLSearchParamsPrototype$1 = $URLSearchParams.prototype;
var getAll2 = uncurryThis$1(URLSearchParamsPrototype$1.getAll);
var $has = uncurryThis$1(URLSearchParamsPrototype$1.has);
var params = new $URLSearchParams("a=1");
if (params.has("a", 2) || !params.has("a", void 0)) {
  defineBuiltIn(URLSearchParamsPrototype$1, "has", function has4(name) {
    var length = arguments.length;
    var $value = length < 2 ? void 0 : arguments[1];
    if (length && $value === void 0) return $has(this, name);
    var values5 = getAll2(this, name);
    validateArgumentsLength(length, 1);
    var value = toString6($value);
    var index = 0;
    while (index < values5.length) {
      if (values5[index++] === value) return true;
    }
    return false;
  }, {
    enumerable: true,
    unsafe: true
  });
}
var DESCRIPTORS = descriptors;
var uncurryThis = functionUncurryThis;
var defineBuiltInAccessor = defineBuiltInAccessor$p;
var URLSearchParamsPrototype = URLSearchParams.prototype;
var forEach6 = uncurryThis(URLSearchParamsPrototype.forEach);
if (DESCRIPTORS && !("size" in URLSearchParamsPrototype)) {
  defineBuiltInAccessor(URLSearchParamsPrototype, "size", {
    get: function size3() {
      var count = 0;
      forEach6(this, function() {
        count++;
      });
      return count;
    },
    configurable: true,
    enumerable: true
  });
}
var scrollToAnchor_1 = scrollToAnchor$1;
function scrollToAnchor$1(anchor2, options) {
  if (anchor2) {
    try {
      var el = document.querySelector(anchor2);
      if (el) el.scrollIntoView(options);
    } catch (e) {
    }
  }
}
var documentReady$1 = ready;
function ready(callback2) {
  if (typeof document === "undefined") {
    throw new Error("document-ready only runs in the browser");
  }
  var state = document.readyState;
  if (state === "complete" || state === "interactive") {
    return setTimeout(callback2, 0);
  }
  document.addEventListener("DOMContentLoaded", function onLoad() {
    callback2();
  });
}
assert$c.notEqual = notEqual;
assert$c.notOk = notOk;
assert$c.equal = equal;
assert$c.ok = assert$c;
var nanoassert = assert$c;
function equal(a, b, m) {
  assert$c(a == b, m);
}
function notEqual(a, b, m) {
  assert$c(a != b, m);
}
function notOk(t, m) {
  assert$c(!t, m);
}
function assert$c(t, m) {
  if (!t) throw new Error(m || "AssertionError");
}
var assert$b = nanoassert;
var hasWindow = typeof window !== "undefined";
function createScheduler() {
  var scheduler2;
  if (hasWindow) {
    if (!window._nanoScheduler) window._nanoScheduler = new NanoScheduler(true);
    scheduler2 = window._nanoScheduler;
  } else {
    scheduler2 = new NanoScheduler();
  }
  return scheduler2;
}
function NanoScheduler(hasWindow2) {
  this.hasWindow = hasWindow2;
  this.hasIdle = this.hasWindow && window.requestIdleCallback;
  this.method = this.hasIdle ? window.requestIdleCallback.bind(window) : this.setTimeout;
  this.scheduled = false;
  this.queue = [];
}
NanoScheduler.prototype.push = function(cb) {
  assert$b.equal(typeof cb, "function", "nanoscheduler.push: cb should be type function");
  this.queue.push(cb);
  this.schedule();
};
NanoScheduler.prototype.schedule = function() {
  if (this.scheduled) return;
  this.scheduled = true;
  var self2 = this;
  this.method(function(idleDeadline) {
    var cb;
    while (self2.queue.length && idleDeadline.timeRemaining() > 0) {
      cb = self2.queue.shift();
      cb(idleDeadline);
    }
    self2.scheduled = false;
    if (self2.queue.length) self2.schedule();
  });
};
NanoScheduler.prototype.setTimeout = function(cb) {
  setTimeout(cb, 0, {
    timeRemaining: function() {
      return 1;
    }
  });
};
var nanoscheduler = createScheduler;
var scheduler = nanoscheduler();
var assert$a = nanoassert;
var perf;
nanotiming$2.disabled = true;
try {
  perf = window.performance;
  nanotiming$2.disabled = window.localStorage.DISABLE_NANOTIMING === "true" || !perf.mark;
} catch (e) {
}
var browser$2 = nanotiming$2;
function nanotiming$2(name) {
  assert$a.equal(typeof name, "string", "nanotiming: name should be type string");
  if (nanotiming$2.disabled) return noop;
  var uuid = (perf.now() * 1e4).toFixed() % Number.MAX_SAFE_INTEGER;
  var startName = "start-" + uuid + "-" + name;
  perf.mark(startName);
  function end(cb) {
    var endName = "end-" + uuid + "-" + name;
    perf.mark(endName);
    scheduler.push(function() {
      var err = null;
      try {
        var measureName = name + " [" + uuid + "]";
        perf.measure(measureName, startName, endName);
        perf.clearMarks(startName);
        perf.clearMarks(endName);
      } catch (e) {
        err = e;
      }
      if (cb) cb(err, name);
    });
  }
  end.uuid = uuid;
  return end;
}
function noop(cb) {
  if (cb) {
    scheduler.push(function() {
      cb(new Error("nanotiming: performance API unavailable"));
    });
  }
}
var assert$9 = nanoassert;
var trie$1 = Trie;
function Trie() {
  if (!(this instanceof Trie)) return new Trie();
  this.trie = {
    nodes: {}
  };
}
Trie.prototype.create = function(route) {
  assert$9.equal(typeof route, "string", "route should be a string");
  var routes2 = route.replace(/^\//, "").split("/");
  function createNode(index, trie2) {
    var thisRoute = has3(routes2, index) && routes2[index];
    if (thisRoute === false) return trie2;
    var node2 = null;
    if (/^:|^\*/.test(thisRoute)) {
      if (!has3(trie2.nodes, "$$")) {
        node2 = {
          nodes: {}
        };
        trie2.nodes.$$ = node2;
      } else {
        node2 = trie2.nodes.$$;
      }
      if (thisRoute[0] === "*") {
        trie2.wildcard = true;
      }
      trie2.name = thisRoute.replace(/^:|^\*/, "");
    } else if (!has3(trie2.nodes, thisRoute)) {
      node2 = {
        nodes: {}
      };
      trie2.nodes[thisRoute] = node2;
    } else {
      node2 = trie2.nodes[thisRoute];
    }
    return createNode(index + 1, node2);
  }
  return createNode(0, this.trie);
};
Trie.prototype.match = function(route) {
  assert$9.equal(typeof route, "string", "route should be a string");
  var routes2 = route.replace(/^\//, "").split("/");
  var params2 = {};
  function search(index, trie2) {
    if (trie2 === void 0) return void 0;
    var thisRoute = routes2[index];
    if (thisRoute === void 0) return trie2;
    if (has3(trie2.nodes, thisRoute)) {
      return search(index + 1, trie2.nodes[thisRoute]);
    } else if (trie2.name) {
      try {
        params2[trie2.name] = decodeURIComponent(thisRoute);
      } catch (e) {
        return search(index, void 0);
      }
      return search(index + 1, trie2.nodes.$$);
    } else if (trie2.wildcard) {
      try {
        params2.wildcard = decodeURIComponent(routes2.slice(index).join("/"));
      } catch (e) {
        return search(index, void 0);
      }
      return trie2.nodes.$$;
    } else {
      return search(index + 1);
    }
  }
  var node2 = search(0, this.trie);
  if (!node2) return void 0;
  node2 = Object.assign({}, node2);
  node2.params = params2;
  return node2;
};
Trie.prototype.mount = function(route, trie2) {
  assert$9.equal(typeof route, "string", "route should be a string");
  assert$9.equal(typeof trie2, "object", "trie should be a object");
  var split2 = route.replace(/^\//, "").split("/");
  var node2 = null;
  var key = null;
  if (split2.length === 1) {
    key = split2[0];
    node2 = this.create(key);
  } else {
    var head = split2.join("/");
    key = split2[0];
    node2 = this.create(head);
  }
  Object.assign(node2.nodes, trie2.nodes);
  if (trie2.name) node2.name = trie2.name;
  if (node2.nodes[""]) {
    Object.keys(node2.nodes[""]).forEach(function(key2) {
      if (key2 === "nodes") return;
      node2[key2] = node2.nodes[""][key2];
    });
    Object.assign(node2.nodes, node2.nodes[""].nodes);
    delete node2.nodes[""].nodes;
  }
};
function has3(object, property) {
  return Object.prototype.hasOwnProperty.call(object, property);
}
var assert$8 = nanoassert;
var trie = trie$1;
var wayfarer$1 = Wayfarer;
function Wayfarer(dft) {
  if (!(this instanceof Wayfarer)) return new Wayfarer(dft);
  var _default = (dft || "").replace(/^\//, "");
  var _trie = trie();
  emit._trie = _trie;
  emit.on = on;
  emit.emit = emit;
  emit.match = match2;
  emit._wayfarer = true;
  return emit;
  function on(route, cb) {
    assert$8.equal(typeof route, "string");
    assert$8.equal(typeof cb, "function");
    route = route || "/";
    if (cb._wayfarer && cb._trie) {
      _trie.mount(route, cb._trie.trie);
    } else {
      var node2 = _trie.create(route);
      node2.cb = cb;
      node2.route = route;
    }
    return emit;
  }
  function emit(route) {
    var matched = match2(route);
    var args = new Array(arguments.length);
    args[0] = matched.params;
    for (var i = 1; i < args.length; i++) {
      args[i] = arguments[i];
    }
    return matched.cb.apply(matched.cb, args);
  }
  function match2(route) {
    assert$8.notEqual(route, void 0, "'route' must be defined");
    var matched = _trie.match(route);
    if (matched && matched.cb) return new Route(matched);
    var dft2 = _trie.match(_default);
    if (dft2 && dft2.cb) return new Route(dft2);
    throw new Error("route '" + route + "' did not match");
  }
  function Route(matched) {
    this.cb = matched.cb;
    this.route = matched.route;
    this.params = matched.params;
  }
}
var assert$7 = nanoassert;
var wayfarer = wayfarer$1;
var isLocalFile = /file:\/\//.test(typeof window === "object" && window.location && window.location.origin);
var electron = "^(file://|/)(.*.html?/?)?";
var protocol = "^(http(s)?(://))?(www.)?";
var domain = "[a-zA-Z0-9-_.]+(:[0-9]{1,5})?(/{1})?";
var qs$1 = "[?].*$";
var stripElectron = new RegExp(electron);
var prefix = new RegExp(protocol + domain);
var normalize = new RegExp("#");
var suffix = new RegExp(qs$1);
var nanorouter$1 = Nanorouter;
function Nanorouter(opts) {
  if (!(this instanceof Nanorouter)) return new Nanorouter(opts);
  opts = opts || {};
  this.router = wayfarer(opts.default || "/404");
}
Nanorouter.prototype.on = function(routename, listener) {
  assert$7.equal(typeof routename, "string");
  routename = routename.replace(/^[#/]/, "");
  this.router.on(routename, listener);
};
Nanorouter.prototype.emit = function(routename) {
  assert$7.equal(typeof routename, "string");
  routename = pathname(routename, isLocalFile);
  return this.router.emit(routename);
};
Nanorouter.prototype.match = function(routename) {
  assert$7.equal(typeof routename, "string");
  routename = pathname(routename, isLocalFile);
  return this.router.match(routename);
};
function pathname(routename, isElectron) {
  if (isElectron) routename = routename.replace(stripElectron, "");
  else routename = routename.replace(prefix, "");
  return decodeURI(routename.replace(suffix, "").replace(normalize, "/"));
}
var events$1 = [
  // attribute events (can be set with attributes)
  "onclick",
  "ondblclick",
  "onmousedown",
  "onmouseup",
  "onmouseover",
  "onmousemove",
  "onmouseout",
  "onmouseenter",
  "onmouseleave",
  "ontouchcancel",
  "ontouchend",
  "ontouchmove",
  "ontouchstart",
  "ondragstart",
  "ondrag",
  "ondragenter",
  "ondragleave",
  "ondragover",
  "ondrop",
  "ondragend",
  "onkeydown",
  "onkeypress",
  "onkeyup",
  "onunload",
  "onabort",
  "onerror",
  "onresize",
  "onscroll",
  "onselect",
  "onchange",
  "onsubmit",
  "onreset",
  "onfocus",
  "onblur",
  "oninput",
  "onanimationend",
  "onanimationiteration",
  "onanimationstart",
  // other common events
  "oncontextmenu",
  "onfocusin",
  "onfocusout"
];
var events = events$1;
var eventsLength = events.length;
var ELEMENT_NODE = 1;
var TEXT_NODE$1 = 3;
var COMMENT_NODE = 8;
var morph_1 = morph$1;
function morph$1(newNode, oldNode) {
  var nodeType = newNode.nodeType;
  var nodeName = newNode.nodeName;
  if (nodeType === ELEMENT_NODE) {
    copyAttrs(newNode, oldNode);
  }
  if (nodeType === TEXT_NODE$1 || nodeType === COMMENT_NODE) {
    if (oldNode.nodeValue !== newNode.nodeValue) {
      oldNode.nodeValue = newNode.nodeValue;
    }
  }
  if (nodeName === "INPUT") updateInput(newNode, oldNode);
  else if (nodeName === "OPTION") updateOption(newNode, oldNode);
  else if (nodeName === "TEXTAREA") updateTextarea(newNode, oldNode);
  copyEvents(newNode, oldNode);
}
function copyAttrs(newNode, oldNode) {
  var oldAttrs = oldNode.attributes;
  var newAttrs = newNode.attributes;
  var attrNamespaceURI = null;
  var attrValue = null;
  var fromValue = null;
  var attrName = null;
  var attr = null;
  for (var i = newAttrs.length - 1; i >= 0; --i) {
    attr = newAttrs[i];
    attrName = attr.name;
    attrNamespaceURI = attr.namespaceURI;
    attrValue = attr.value;
    if (attrNamespaceURI) {
      attrName = attr.localName || attrName;
      fromValue = oldNode.getAttributeNS(attrNamespaceURI, attrName);
      if (fromValue !== attrValue) {
        oldNode.setAttributeNS(attrNamespaceURI, attrName, attrValue);
      }
    } else {
      if (!oldNode.hasAttribute(attrName)) {
        oldNode.setAttribute(attrName, attrValue);
      } else {
        fromValue = oldNode.getAttribute(attrName);
        if (fromValue !== attrValue) {
          if (attrValue === "null" || attrValue === "undefined") {
            oldNode.removeAttribute(attrName);
          } else {
            oldNode.setAttribute(attrName, attrValue);
          }
        }
      }
    }
  }
  for (var j = oldAttrs.length - 1; j >= 0; --j) {
    attr = oldAttrs[j];
    if (attr.specified !== false) {
      attrName = attr.name;
      attrNamespaceURI = attr.namespaceURI;
      if (attrNamespaceURI) {
        attrName = attr.localName || attrName;
        if (!newNode.hasAttributeNS(attrNamespaceURI, attrName)) {
          oldNode.removeAttributeNS(attrNamespaceURI, attrName);
        }
      } else {
        if (!newNode.hasAttributeNS(null, attrName)) {
          oldNode.removeAttribute(attrName);
        }
      }
    }
  }
}
function copyEvents(newNode, oldNode) {
  for (var i = 0; i < eventsLength; i++) {
    var ev = events[i];
    if (newNode[ev]) {
      oldNode[ev] = newNode[ev];
    } else if (oldNode[ev]) {
      oldNode[ev] = void 0;
    }
  }
}
function updateOption(newNode, oldNode) {
  updateAttribute(newNode, oldNode, "selected");
}
function updateInput(newNode, oldNode) {
  var newValue = newNode.value;
  var oldValue = oldNode.value;
  updateAttribute(newNode, oldNode, "checked");
  updateAttribute(newNode, oldNode, "disabled");
  if (newNode.indeterminate !== oldNode.indeterminate) {
    oldNode.indeterminate = newNode.indeterminate;
  }
  if (oldNode.type === "file") return;
  if (newValue !== oldValue) {
    oldNode.setAttribute("value", newValue);
    oldNode.value = newValue;
  }
  if (newValue === "null") {
    oldNode.value = "";
    oldNode.removeAttribute("value");
  }
  if (!newNode.hasAttributeNS(null, "value")) {
    oldNode.removeAttribute("value");
  } else if (oldNode.type === "range") {
    oldNode.value = newValue;
  }
}
function updateTextarea(newNode, oldNode) {
  var newValue = newNode.value;
  if (newValue !== oldNode.value) {
    oldNode.value = newValue;
  }
  if (oldNode.firstChild && oldNode.firstChild.nodeValue !== newValue) {
    if (newValue === "" && oldNode.firstChild.nodeValue === oldNode.placeholder) {
      return;
    }
    oldNode.firstChild.nodeValue = newValue;
  }
}
function updateAttribute(newNode, oldNode, name) {
  if (newNode[name] !== oldNode[name]) {
    oldNode[name] = newNode[name];
    if (newNode[name]) {
      oldNode.setAttribute(name, "");
    } else {
      oldNode.removeAttribute(name);
    }
  }
}
var assert$6 = nanoassert;
var morph = morph_1;
var TEXT_NODE = 3;
var nanomorph_1 = nanomorph$1;
function nanomorph$1(oldTree, newTree, options) {
  assert$6.equal(typeof oldTree, "object", "nanomorph: oldTree should be an object");
  assert$6.equal(typeof newTree, "object", "nanomorph: newTree should be an object");
  if (options && options.childrenOnly) {
    updateChildren(newTree, oldTree);
    return oldTree;
  }
  assert$6.notEqual(newTree.nodeType, 11, "nanomorph: newTree should have one root node (which is not a DocumentFragment)");
  return walk(newTree, oldTree);
}
function walk(newNode, oldNode) {
  if (!oldNode) {
    return newNode;
  } else if (!newNode) {
    return null;
  } else if (newNode.isSameNode && newNode.isSameNode(oldNode)) {
    return oldNode;
  } else if (newNode.tagName !== oldNode.tagName || getComponentId(newNode) !== getComponentId(oldNode)) {
    return newNode;
  } else {
    morph(newNode, oldNode);
    updateChildren(newNode, oldNode);
    return oldNode;
  }
}
function getComponentId(node2) {
  return node2.dataset ? node2.dataset.nanomorphComponentId : void 0;
}
function updateChildren(newNode, oldNode) {
  var oldChild, newChild, morphed, oldMatch;
  var offset = 0;
  for (var i = 0; ; i++) {
    oldChild = oldNode.childNodes[i];
    newChild = newNode.childNodes[i - offset];
    if (!oldChild && !newChild) {
      break;
    } else if (!newChild) {
      oldNode.removeChild(oldChild);
      i--;
    } else if (!oldChild) {
      oldNode.appendChild(newChild);
      offset++;
    } else if (same(newChild, oldChild)) {
      morphed = walk(newChild, oldChild);
      if (morphed !== oldChild) {
        oldNode.replaceChild(morphed, oldChild);
        offset++;
      }
    } else {
      oldMatch = null;
      for (var j = i; j < oldNode.childNodes.length; j++) {
        if (same(oldNode.childNodes[j], newChild)) {
          oldMatch = oldNode.childNodes[j];
          break;
        }
      }
      if (oldMatch) {
        morphed = walk(newChild, oldMatch);
        if (morphed !== oldMatch) offset++;
        oldNode.insertBefore(morphed, oldChild);
      } else if (!newChild.id && !oldChild.id) {
        morphed = walk(newChild, oldChild);
        if (morphed !== oldChild) {
          oldNode.replaceChild(morphed, oldChild);
          offset++;
        }
      } else {
        oldNode.insertBefore(newChild, oldChild);
        offset++;
      }
    }
  }
}
function same(a, b) {
  if (a.id) return a.id === b.id;
  if (a.isSameNode) return a.isSameNode(b);
  if (a.tagName !== b.tagName) return false;
  if (a.type === TEXT_NODE) return a.nodeValue === b.nodeValue;
  return false;
}
var reg = /([^?=&]+)(=([^&]*))?/g;
var assert$5 = nanoassert;
var browser$1 = qs;
function qs(url) {
  assert$5.equal(typeof url, "string", "nanoquery: url should be type string");
  var obj = {};
  url.replace(/^.*\?/, "").replace(reg, function(a0, a1, a2, a3) {
    var value = decodeURIComponent(a3);
    var key = decodeURIComponent(a1);
    if (obj.hasOwnProperty(key)) {
      if (Array.isArray(obj[key])) obj[key].push(value);
      else obj[key] = [obj[key], value];
    } else {
      obj[key] = value;
    }
  });
  return obj;
}
var assert$4 = nanoassert;
var safeExternalLink = /(noopener|noreferrer) (noopener|noreferrer)/;
var protocolLink = /^[\w-_]+:/;
var nanohref$1 = href;
function href(cb, root2) {
  assert$4.notEqual(typeof window, "undefined", "nanohref: expected window to exist");
  root2 = root2 || window.document;
  assert$4.equal(typeof cb, "function", "nanohref: cb should be type function");
  assert$4.equal(typeof root2, "object", "nanohref: root should be type object");
  window.addEventListener("click", function(e) {
    if (e.button && e.button !== 0 || e.ctrlKey || e.metaKey || e.altKey || e.shiftKey || e.defaultPrevented) return;
    var anchor2 = function traverse(node2) {
      if (!node2 || node2 === root2) return;
      if (node2.localName !== "a" || node2.href === void 0) {
        return traverse(node2.parentNode);
      }
      return node2;
    }(e.target);
    if (!anchor2) return;
    if (window.location.protocol !== anchor2.protocol || window.location.hostname !== anchor2.hostname || window.location.port !== anchor2.port || anchor2.hasAttribute("data-nanohref-ignore") || anchor2.hasAttribute("download") || anchor2.getAttribute("target") === "_blank" && safeExternalLink.test(anchor2.getAttribute("rel")) || protocolLink.test(anchor2.getAttribute("href"))) return;
    e.preventDefault();
    cb(anchor2);
  });
}
var assert$3 = nanoassert;
var nanoraf_1 = nanoraf$1;
function nanoraf$1(render, raf) {
  assert$3.equal(typeof render, "function", "nanoraf: render should be a function");
  assert$3.ok(typeof raf === "function" || typeof raf === "undefined", "nanoraf: raf should be a function or undefined");
  if (!raf) raf = window.requestAnimationFrame;
  var redrawScheduled = false;
  var args = null;
  return function frame() {
    if (args === null && !redrawScheduled) {
      redrawScheduled = true;
      raf(function redraw() {
        redrawScheduled = false;
        var length = args.length;
        var _args = new Array(length);
        for (var i = 0; i < length; i++) _args[i] = args[i];
        render.apply(render, _args);
        args = null;
      });
    }
    args = arguments;
  };
}
var removeArrayItems = function removeItems(arr, startIdx, removeCount) {
  var i, length = arr.length;
  if (startIdx >= length || removeCount === 0) {
    return;
  }
  removeCount = startIdx + removeCount > length ? length - startIdx : removeCount;
  var len = length - removeCount;
  for (i = startIdx; i < len; ++i) {
    arr[i] = arr[i + removeCount];
  }
  arr.length = len;
};
var splice2 = removeArrayItems;
var nanotiming$1 = browser$2;
var assert$2 = nanoassert;
var nanobus$1 = Nanobus;
function Nanobus(name) {
  if (!(this instanceof Nanobus)) return new Nanobus(name);
  this._name = name || "nanobus";
  this._starListeners = [];
  this._listeners = {};
}
Nanobus.prototype.emit = function(eventName) {
  assert$2.ok(typeof eventName === "string" || typeof eventName === "symbol", "nanobus.emit: eventName should be type string or symbol");
  var data2 = [];
  for (var i = 1, len = arguments.length; i < len; i++) {
    data2.push(arguments[i]);
  }
  var emitTiming = nanotiming$1(this._name + "('" + eventName.toString() + "')");
  var listeners = this._listeners[eventName];
  if (listeners && listeners.length > 0) {
    this._emit(this._listeners[eventName], data2);
  }
  if (this._starListeners.length > 0) {
    this._emit(this._starListeners, eventName, data2, emitTiming.uuid);
  }
  emitTiming();
  return this;
};
Nanobus.prototype.on = Nanobus.prototype.addListener = function(eventName, listener) {
  assert$2.ok(typeof eventName === "string" || typeof eventName === "symbol", "nanobus.on: eventName should be type string or symbol");
  assert$2.equal(typeof listener, "function", "nanobus.on: listener should be type function");
  if (eventName === "*") {
    this._starListeners.push(listener);
  } else {
    if (!this._listeners[eventName]) this._listeners[eventName] = [];
    this._listeners[eventName].push(listener);
  }
  return this;
};
Nanobus.prototype.prependListener = function(eventName, listener) {
  assert$2.ok(typeof eventName === "string" || typeof eventName === "symbol", "nanobus.prependListener: eventName should be type string or symbol");
  assert$2.equal(typeof listener, "function", "nanobus.prependListener: listener should be type function");
  if (eventName === "*") {
    this._starListeners.unshift(listener);
  } else {
    if (!this._listeners[eventName]) this._listeners[eventName] = [];
    this._listeners[eventName].unshift(listener);
  }
  return this;
};
Nanobus.prototype.once = function(eventName, listener) {
  assert$2.ok(typeof eventName === "string" || typeof eventName === "symbol", "nanobus.once: eventName should be type string or symbol");
  assert$2.equal(typeof listener, "function", "nanobus.once: listener should be type function");
  var self2 = this;
  this.on(eventName, once);
  function once() {
    listener.apply(self2, arguments);
    self2.removeListener(eventName, once);
  }
  return this;
};
Nanobus.prototype.prependOnceListener = function(eventName, listener) {
  assert$2.ok(typeof eventName === "string" || typeof eventName === "symbol", "nanobus.prependOnceListener: eventName should be type string or symbol");
  assert$2.equal(typeof listener, "function", "nanobus.prependOnceListener: listener should be type function");
  var self2 = this;
  this.prependListener(eventName, once);
  function once() {
    listener.apply(self2, arguments);
    self2.removeListener(eventName, once);
  }
  return this;
};
Nanobus.prototype.removeListener = function(eventName, listener) {
  assert$2.ok(typeof eventName === "string" || typeof eventName === "symbol", "nanobus.removeListener: eventName should be type string or symbol");
  assert$2.equal(typeof listener, "function", "nanobus.removeListener: listener should be type function");
  if (eventName === "*") {
    this._starListeners = this._starListeners.slice();
    return remove2(this._starListeners, listener);
  } else {
    if (typeof this._listeners[eventName] !== "undefined") {
      this._listeners[eventName] = this._listeners[eventName].slice();
    }
    return remove2(this._listeners[eventName], listener);
  }
  function remove2(arr, listener2) {
    if (!arr) return;
    var index = arr.indexOf(listener2);
    if (index !== -1) {
      splice2(arr, index, 1);
      return true;
    }
  }
};
Nanobus.prototype.removeAllListeners = function(eventName) {
  if (eventName) {
    if (eventName === "*") {
      this._starListeners = [];
    } else {
      this._listeners[eventName] = [];
    }
  } else {
    this._starListeners = [];
    this._listeners = {};
  }
  return this;
};
Nanobus.prototype.listeners = function(eventName) {
  var listeners = eventName !== "*" ? this._listeners[eventName] : this._starListeners;
  var ret = [];
  if (listeners) {
    var ilength = listeners.length;
    for (var i = 0; i < ilength; i++) ret.push(listeners[i]);
  }
  return ret;
};
Nanobus.prototype._emit = function(arr, eventName, data2, uuid) {
  if (typeof arr === "undefined") return;
  if (arr.length === 0) return;
  if (data2 === void 0) {
    data2 = eventName;
    eventName = null;
  }
  if (eventName) {
    if (uuid !== void 0) {
      data2 = [eventName].concat(data2, uuid);
    } else {
      data2 = [eventName].concat(data2);
    }
  }
  var length = arr.length;
  for (var i = 0; i < length; i++) {
    var listener = arr[i];
    listener.apply(listener, data2);
  }
};
const Nanobus$1 = /* @__PURE__ */ getDefaultExportFromCjs(nanobus$1);
var nanolru = LRU$1;
function LRU$1(opts) {
  if (!(this instanceof LRU$1)) return new LRU$1(opts);
  if (typeof opts === "number") opts = {
    max: opts
  };
  if (!opts) opts = {};
  this.cache = {};
  this.head = this.tail = null;
  this.length = 0;
  this.max = opts.max || 1e3;
  this.maxAge = opts.maxAge || 0;
}
Object.defineProperty(LRU$1.prototype, "keys", {
  get: function() {
    return Object.keys(this.cache);
  }
});
LRU$1.prototype.clear = function() {
  this.cache = {};
  this.head = this.tail = null;
  this.length = 0;
};
LRU$1.prototype.remove = function(key) {
  if (typeof key !== "string") key = "" + key;
  if (!this.cache.hasOwnProperty(key)) return;
  var element = this.cache[key];
  delete this.cache[key];
  this._unlink(key, element.prev, element.next);
  return element.value;
};
LRU$1.prototype._unlink = function(key, prev, next11) {
  this.length--;
  if (this.length === 0) {
    this.head = this.tail = null;
  } else {
    if (this.head === key) {
      this.head = prev;
      this.cache[this.head].next = null;
    } else if (this.tail === key) {
      this.tail = next11;
      this.cache[this.tail].prev = null;
    } else {
      this.cache[prev].next = next11;
      this.cache[next11].prev = prev;
    }
  }
};
LRU$1.prototype.peek = function(key) {
  if (!this.cache.hasOwnProperty(key)) return;
  var element = this.cache[key];
  if (!this._checkAge(key, element)) return;
  return element.value;
};
LRU$1.prototype.set = function(key, value) {
  if (typeof key !== "string") key = "" + key;
  var element;
  if (this.cache.hasOwnProperty(key)) {
    element = this.cache[key];
    element.value = value;
    if (this.maxAge) element.modified = Date.now();
    if (key === this.head) return value;
    this._unlink(key, element.prev, element.next);
  } else {
    element = {
      value,
      modified: 0,
      next: null,
      prev: null
    };
    if (this.maxAge) element.modified = Date.now();
    this.cache[key] = element;
    if (this.length === this.max) this.evict();
  }
  this.length++;
  element.next = null;
  element.prev = this.head;
  if (this.head) this.cache[this.head].next = key;
  this.head = key;
  if (!this.tail) this.tail = key;
  return value;
};
LRU$1.prototype._checkAge = function(key, element) {
  if (this.maxAge && Date.now() - element.modified > this.maxAge) {
    this.remove(key);
    return false;
  }
  return true;
};
LRU$1.prototype.get = function(key) {
  if (typeof key !== "string") key = "" + key;
  if (!this.cache.hasOwnProperty(key)) return;
  var element = this.cache[key];
  if (!this._checkAge(key, element)) return;
  if (this.head !== key) {
    if (key === this.tail) {
      this.tail = element.next;
      this.cache[this.tail].prev = null;
    } else {
      this.cache[element.prev].next = element.next;
    }
    this.cache[element.next].prev = element.prev;
    this.cache[this.head].next = key;
    element.prev = this.head;
    element.next = null;
    this.head = key;
  }
  return element.value;
};
LRU$1.prototype.evict = function() {
  if (!this.tail) return;
  this.remove(this.tail);
};
var assert$1 = nanoassert;
var LRU = nanolru;
var cache$1 = ChooComponentCache;
function ChooComponentCache(state, emit, lru) {
  assert$1.ok(this instanceof ChooComponentCache, "ChooComponentCache should be created with `new`");
  assert$1.equal(typeof state, "object", "ChooComponentCache: state should be type object");
  assert$1.equal(typeof emit, "function", "ChooComponentCache: emit should be type function");
  if (typeof lru === "number") this.cache = new LRU(lru);
  else this.cache = lru || new LRU(100);
  this.state = state;
  this.emit = emit;
}
ChooComponentCache.prototype.render = function(Component, id2) {
  assert$1.equal(typeof Component, "function", "ChooComponentCache.render: Component should be type function");
  assert$1.ok(typeof id2 === "string" || typeof id2 === "number", "ChooComponentCache.render: id should be type string or type number");
  var el = this.cache.get(id2);
  if (!el) {
    var args = [];
    for (var i = 2, len = arguments.length; i < len; i++) {
      args.push(arguments[i]);
    }
    args.unshift(Component, id2, this.state, this.emit);
    el = newCall.apply(newCall, args);
    this.cache.set(id2, el);
  }
  return el;
};
function newCall(Cls) {
  return new (Cls.bind.apply(Cls, arguments))();
}
var scrollToAnchor = scrollToAnchor_1;
var documentReady = documentReady$1;
var nanotiming = browser$2;
var nanorouter = nanorouter$1;
var nanomorph = nanomorph_1;
var nanoquery = browser$1;
var nanohref = nanohref$1;
var nanoraf = nanoraf_1;
var nanobus = nanobus$1;
var assert = nanoassert;
var Cache = cache$1;
var choo = Choo;
var HISTORY_OBJECT = {};
function Choo(opts) {
  var timing = nanotiming("choo.constructor");
  if (!(this instanceof Choo)) return new Choo(opts);
  opts = opts || {};
  assert.equal(typeof opts, "object", "choo: opts should be type object");
  var self2 = this;
  this._events = {
    DOMCONTENTLOADED: "DOMContentLoaded",
    DOMTITLECHANGE: "DOMTitleChange",
    REPLACESTATE: "replaceState",
    PUSHSTATE: "pushState",
    NAVIGATE: "navigate",
    POPSTATE: "popState",
    RENDER: "render"
  };
  this._historyEnabled = opts.history === void 0 ? true : opts.history;
  this._hrefEnabled = opts.href === void 0 ? true : opts.href;
  this._hashEnabled = opts.hash === void 0 ? false : opts.hash;
  this._hasWindow = typeof window !== "undefined";
  this._cache = opts.cache;
  this._loaded = false;
  this._stores = [ondomtitlechange];
  this._tree = null;
  var _state = {
    events: this._events,
    components: {}
  };
  if (this._hasWindow) {
    this.state = window.initialState ? Object.assign({}, window.initialState, _state) : _state;
    delete window.initialState;
  } else {
    this.state = _state;
  }
  this.router = nanorouter({
    curry: true
  });
  this.emitter = nanobus("choo.emit");
  this.emit = this.emitter.emit.bind(this.emitter);
  if (this._hasWindow) this.state.title = document.title;
  function ondomtitlechange(state) {
    self2.emitter.prependListener(self2._events.DOMTITLECHANGE, function(title) {
      assert.equal(typeof title, "string", "events.DOMTitleChange: title should be type string");
      state.title = title;
      if (self2._hasWindow) document.title = title;
    });
  }
  timing();
}
Choo.prototype.route = function(route, handler) {
  var routeTiming = nanotiming("choo.route('" + route + "')");
  assert.equal(typeof route, "string", "choo.route: route should be type string");
  assert.equal(typeof handler, "function", "choo.handler: route should be type function");
  this.router.on(route, handler);
  routeTiming();
};
Choo.prototype.use = function(cb) {
  assert.equal(typeof cb, "function", "choo.use: cb should be type function");
  var self2 = this;
  this._stores.push(function(state) {
    var msg = "choo.use";
    msg = cb.storeName ? msg + "(" + cb.storeName + ")" : msg;
    var endTiming = nanotiming(msg);
    cb(state, self2.emitter, self2);
    endTiming();
  });
};
Choo.prototype.start = function() {
  assert.equal(typeof window, "object", "choo.start: window was not found. .start() must be called in a browser, use .toString() if running in Node");
  var startTiming = nanotiming("choo.start");
  var self2 = this;
  if (this._historyEnabled) {
    this.emitter.prependListener(this._events.NAVIGATE, function() {
      self2._matchRoute(self2.state);
      if (self2._loaded) {
        self2.emitter.emit(self2._events.RENDER);
        setTimeout(scrollToAnchor.bind(null, window.location.hash), 0);
      }
    });
    this.emitter.prependListener(this._events.POPSTATE, function() {
      self2.emitter.emit(self2._events.NAVIGATE);
    });
    this.emitter.prependListener(this._events.PUSHSTATE, function(href2) {
      assert.equal(typeof href2, "string", "events.pushState: href should be type string");
      window.history.pushState(HISTORY_OBJECT, null, href2);
      self2.emitter.emit(self2._events.NAVIGATE);
    });
    this.emitter.prependListener(this._events.REPLACESTATE, function(href2) {
      assert.equal(typeof href2, "string", "events.replaceState: href should be type string");
      window.history.replaceState(HISTORY_OBJECT, null, href2);
      self2.emitter.emit(self2._events.NAVIGATE);
    });
    window.onpopstate = function() {
      self2.emitter.emit(self2._events.POPSTATE);
    };
    if (self2._hrefEnabled) {
      nanohref(function(location2) {
        var href2 = location2.href;
        var hash = location2.hash;
        if (href2 === window.location.href) {
          if (!self2._hashEnabled && hash) scrollToAnchor(hash);
          return;
        }
        self2.emitter.emit(self2._events.PUSHSTATE, href2);
      });
    }
  }
  this._setCache(this.state);
  this._matchRoute(this.state);
  this._stores.forEach(function(initStore) {
    initStore(self2.state);
  });
  this._tree = this._prerender(this.state);
  assert.ok(this._tree, "choo.start: no valid DOM node returned for location " + this.state.href);
  this.emitter.prependListener(self2._events.RENDER, nanoraf(function() {
    var renderTiming = nanotiming("choo.render");
    var newTree = self2._prerender(self2.state);
    assert.ok(newTree, "choo.render: no valid DOM node returned for location " + self2.state.href);
    assert.equal(self2._tree.nodeName, newTree.nodeName, "choo.render: The target node <" + self2._tree.nodeName.toLowerCase() + "> is not the same type as the new node <" + newTree.nodeName.toLowerCase() + ">.");
    var morphTiming = nanotiming("choo.morph");
    nanomorph(self2._tree, newTree);
    morphTiming();
    renderTiming();
  }));
  documentReady(function() {
    self2.emitter.emit(self2._events.DOMCONTENTLOADED);
    self2._loaded = true;
  });
  startTiming();
  return this._tree;
};
Choo.prototype.mount = function mount(selector) {
  var mountTiming = nanotiming("choo.mount('" + selector + "')");
  if (typeof window !== "object") {
    assert.ok(typeof selector === "string", "choo.mount: selector should be type String");
    this.selector = selector;
    mountTiming();
    return this;
  }
  assert.ok(typeof selector === "string" || typeof selector === "object", "choo.mount: selector should be type String or HTMLElement");
  var self2 = this;
  documentReady(function() {
    var renderTiming = nanotiming("choo.render");
    var newTree = self2.start();
    if (typeof selector === "string") {
      self2._tree = document.querySelector(selector);
    } else {
      self2._tree = selector;
    }
    assert.ok(self2._tree, "choo.mount: could not query selector: " + selector);
    assert.equal(self2._tree.nodeName, newTree.nodeName, "choo.mount: The target node <" + self2._tree.nodeName.toLowerCase() + "> is not the same type as the new node <" + newTree.nodeName.toLowerCase() + ">.");
    var morphTiming = nanotiming("choo.morph");
    nanomorph(self2._tree, newTree);
    morphTiming();
    renderTiming();
  });
  mountTiming();
};
Choo.prototype.toString = function(location2, state) {
  state = state || {};
  state.components = state.components || {};
  state.events = Object.assign({}, state.events, this._events);
  assert.notEqual(typeof window, "object", "choo.mount: window was found. .toString() must be called in Node, use .start() or .mount() if running in the browser");
  assert.equal(typeof location2, "string", "choo.toString: location should be type string");
  assert.equal(typeof state, "object", "choo.toString: state should be type object");
  this._setCache(state);
  this._matchRoute(state, location2);
  this.emitter.removeAllListeners();
  this._stores.forEach(function(initStore) {
    initStore(state);
  });
  var html2 = this._prerender(state);
  assert.ok(html2, "choo.toString: no valid value returned for the route " + location2);
  assert(!Array.isArray(html2), "choo.toString: return value was an array for the route " + location2);
  return typeof html2.outerHTML === "string" ? html2.outerHTML : html2.toString();
};
Choo.prototype._matchRoute = function(state, locationOverride) {
  var location2, queryString;
  if (locationOverride) {
    location2 = locationOverride.replace(/\?.+$/, "").replace(/\/$/, "");
    if (!this._hashEnabled) location2 = location2.replace(/#.+$/, "");
    queryString = locationOverride;
  } else {
    location2 = window.location.pathname.replace(/\/$/, "");
    if (this._hashEnabled) location2 += window.location.hash.replace(/^#/, "/");
    queryString = window.location.search;
  }
  var matched = this.router.match(location2);
  this._handler = matched.cb;
  state.href = location2;
  state.query = nanoquery(queryString);
  state.route = matched.route;
  state.params = matched.params;
};
Choo.prototype._prerender = function(state) {
  var routeTiming = nanotiming("choo.prerender('" + state.route + "')");
  var res = this._handler(state, this.emit);
  routeTiming();
  return res;
};
Choo.prototype._setCache = function(state) {
  var cache2 = new Cache(state, this.emitter.emit.bind(this.emitter), this._cache);
  state.cache = renderComponent;
  function renderComponent(Component, id2) {
    assert.equal(typeof Component, "function", "choo.state.cache: Component should be type function");
    var args = [];
    for (var i = 0, len = arguments.length; i < len; i++) {
      args.push(arguments[i]);
    }
    return cache2.render.apply(cache2, args);
  }
  renderComponent.toJSON = function() {
    return null;
  };
};
const choo$1 = /* @__PURE__ */ getDefaultExportFromCjs(choo);
var trailingNewlineRegex = /\n[\s]+$/;
var leadingNewlineRegex = /^\n[\s]+/;
var trailingSpaceRegex = /[\s]+$/;
var leadingSpaceRegex = /^[\s]+/;
var multiSpaceRegex = /[\n\s]+/g;
var TEXT_TAGS = ["a", "abbr", "b", "bdi", "bdo", "br", "cite", "data", "dfn", "em", "i", "kbd", "mark", "q", "rp", "rt", "rtc", "ruby", "s", "amp", "small", "span", "strong", "sub", "sup", "time", "u", "var", "wbr"];
var VERBATIM_TAGS = ["code", "pre", "textarea"];
var appendChild$1 = function appendChild(el, childs) {
  if (!Array.isArray(childs)) return;
  var nodeName = el.nodeName.toLowerCase();
  var hadText = false;
  var value, leader;
  for (var i = 0, len = childs.length; i < len; i++) {
    var node2 = childs[i];
    if (Array.isArray(node2)) {
      appendChild(el, node2);
      continue;
    }
    if (typeof node2 === "number" || typeof node2 === "boolean" || typeof node2 === "function" || node2 instanceof Date || node2 instanceof RegExp) {
      node2 = node2.toString();
    }
    var lastChild = el.childNodes[el.childNodes.length - 1];
    if (typeof node2 === "string") {
      hadText = true;
      if (lastChild && lastChild.nodeName === "#text") {
        lastChild.nodeValue += node2;
      } else {
        node2 = el.ownerDocument.createTextNode(node2);
        el.appendChild(node2);
        lastChild = node2;
      }
      if (i === len - 1) {
        hadText = false;
        if (TEXT_TAGS.indexOf(nodeName) === -1 && VERBATIM_TAGS.indexOf(nodeName) === -1) {
          value = lastChild.nodeValue.replace(leadingNewlineRegex, "").replace(trailingSpaceRegex, "").replace(trailingNewlineRegex, "").replace(multiSpaceRegex, " ");
          if (value === "") {
            el.removeChild(lastChild);
          } else {
            lastChild.nodeValue = value;
          }
        } else if (VERBATIM_TAGS.indexOf(nodeName) === -1) {
          leader = i === 0 ? "" : " ";
          value = lastChild.nodeValue.replace(leadingNewlineRegex, leader).replace(leadingSpaceRegex, " ").replace(trailingSpaceRegex, "").replace(trailingNewlineRegex, "").replace(multiSpaceRegex, " ");
          lastChild.nodeValue = value;
        }
      }
    } else if (node2 && node2.nodeType) {
      if (hadText) {
        hadText = false;
        if (TEXT_TAGS.indexOf(nodeName) === -1 && VERBATIM_TAGS.indexOf(nodeName) === -1) {
          value = lastChild.nodeValue.replace(leadingNewlineRegex, "").replace(trailingNewlineRegex, " ").replace(multiSpaceRegex, " ");
          if (value === "") {
            el.removeChild(lastChild);
          } else {
            lastChild.nodeValue = value;
          }
        } else if (VERBATIM_TAGS.indexOf(nodeName) === -1) {
          value = lastChild.nodeValue.replace(leadingSpaceRegex, " ").replace(leadingNewlineRegex, "").replace(trailingNewlineRegex, " ").replace(multiSpaceRegex, " ");
          lastChild.nodeValue = value;
        }
      }
      var _nodeName = node2.nodeName;
      if (_nodeName) nodeName = _nodeName.toLowerCase();
      el.appendChild(node2);
    }
  }
};
var archiveTile = { exports: {} };
var directProps = ["indeterminate"];
var DIRECT_PROPS$1 = directProps;
var setAttribute = function nanohtmlSetAttribute(el, attr, value) {
  if (typeof attr === "object") {
    for (var i in attr) {
      if (attr.hasOwnProperty(i)) {
        nanohtmlSetAttribute(el, i, attr[i]);
      }
    }
    return;
  }
  if (!attr) return;
  if (attr === "className") attr = "class";
  if (attr === "htmlFor") attr = "for";
  if (attr.slice(0, 2) === "on" || DIRECT_PROPS$1.indexOf(attr) !== -1) {
    el[attr] = value;
  } else {
    if (value === true) value = attr;
    if (value === false) return;
    el.setAttribute(attr, value);
  }
};
function nanohtmlRawBrowser(tag) {
  var el = document.createElement("div");
  el.innerHTML = tag;
  return toArray3(el.childNodes);
}
function toArray3(arr) {
  return Array.isArray(arr) ? arr : [].slice.call(arr);
}
var rawBrowser = nanohtmlRawBrowser;
var raw2 = rawBrowser;
var generate_asset_map;
var hasRequiredGenerate_asset_map;
function requireGenerate_asset_map() {
  if (hasRequiredGenerate_asset_map) return generate_asset_map;
  hasRequiredGenerate_asset_map = 1;
  generate_asset_map = {
    "add.svg": "/add.svg",
    "addfiles.svg": "/addfiles.svg",
    "android-chrome-192x192.png": "/android-chrome-192x192.png",
    "android-chrome-512x512.png": "/android-chrome-512x512.png",
    "apple-touch-icon.png": "/apple-touch-icon.png",
    "bg.svg": "/bg.svg",
    "blue_file.svg": "/blue_file.svg",
    "close-16.svg": "/close-16.svg",
    "completed.svg": "/completed.svg",
    "copy-16.svg": "/copy-16.svg",
    "dl.svg": "/dl.svg",
    "error.svg": "/error.svg",
    "eye-off.svg": "/eye-off.svg",
    "eye.svg": "/eye.svg",
    "favicon-16x16.png": "/favicon-16x16.png",
    "favicon-32x32.png": "/favicon-32x32.png",
    "feedback.svg": "/feedback.svg",
    "firefox_logo-only.svg": "/firefox_logo-only.svg",
    "icon-64x64.png": "/icon-64x64.png",
    "icon.svg": "/icon.svg",
    "lock.svg": "/lock.svg",
    "master-logo.svg": "/master-logo.svg",
    "notFound.svg": "/notFound.svg",
    "safari-pinned-tab.svg": "/safari-pinned-tab.svg",
    "select-arrow.svg": "/select-arrow.svg",
    "send-fb.jpg": "/send-fb.jpg",
    "send-twitter.jpg": "/send-twitter.jpg",
    "share-24.svg": "/share-24.svg",
    "user.svg": "/user.svg",
    "wordmark.svg": "/wordmark.svg"
  };
  return generate_asset_map;
}
const require$$1 = {
  "app.js": "app.js",
  "app.css": "app.css"
};
var assets_1;
var hasRequiredAssets;
function requireAssets() {
  if (hasRequiredAssets) return assets_1;
  hasRequiredAssets = 1;
  const genmap = requireGenerate_asset_map();
  const isServer = typeof genmap === "function";
  let prefix2 = "";
  let manifest = {};
  try {
    manifest = require$$1;
  } catch (e) {
  }
  const assets = isServer ? manifest : genmap;
  function getAsset(name) {
    return prefix2 + assets[name];
  }
  function setPrefix(name) {
    prefix2 = name;
  }
  function getMatches(match2) {
    return Object.keys(assets).filter((k) => match2.test(k)).map(getAsset);
  }
  const instance = {
    setPrefix,
    get: getAsset,
    match: getMatches,
    setMiddleware: function(middleware) {
      function getManifest() {
        return JSON.parse(middleware.fileSystem.readFileSync(middleware.getFilenameFromUrl("/manifest.json")));
      }
      if (middleware) {
        instance.get = function getAssetWithMiddleware(name) {
          const m = getManifest();
          return prefix2 + m[name];
        };
        instance.match = function matchAssetWithMiddleware(match2) {
          const m = getManifest();
          return Object.keys(m).filter((k) => match2.test(k)).map((k) => prefix2 + m[k]);
        };
      }
    }
  };
  assets_1 = instance;
  return assets_1;
}
var hyperscriptAttributeToProperty = attributeToProperty;
var transform = {
  "class": "className",
  "for": "htmlFor",
  "http-equiv": "httpEquiv"
};
function attributeToProperty(h) {
  return function(tagName, attrs, children) {
    for (var attr in attrs) {
      if (attr in transform) {
        attrs[transform[attr]] = attrs[attr];
        delete attrs[attr];
      }
    }
    return h(tagName, attrs, children);
  };
}
var attrToProp = hyperscriptAttributeToProperty;
var VAR = 0, TEXT = 1, OPEN = 2, CLOSE = 3, ATTR = 4;
var ATTR_KEY = 5, ATTR_KEY_W = 6;
var ATTR_VALUE_W = 7, ATTR_VALUE = 8;
var ATTR_VALUE_SQ = 9, ATTR_VALUE_DQ = 10;
var ATTR_EQ = 11, ATTR_BREAK = 12;
var COMMENT = 13;
var hyperx$1 = function(h, opts) {
  if (!opts) opts = {};
  var concat4 = opts.concat || function(a, b) {
    return String(a) + String(b);
  };
  if (opts.attrToProp !== false) {
    h = attrToProp(h);
  }
  return function(strings) {
    var state = TEXT, reg2 = "";
    var arglen = arguments.length;
    var parts = [];
    for (var i = 0; i < strings.length; i++) {
      if (i < arglen - 1) {
        var arg = arguments[i + 1];
        var p = parse4(strings[i]);
        var xstate = state;
        if (xstate === ATTR_VALUE_DQ) xstate = ATTR_VALUE;
        if (xstate === ATTR_VALUE_SQ) xstate = ATTR_VALUE;
        if (xstate === ATTR_VALUE_W) xstate = ATTR_VALUE;
        if (xstate === ATTR) xstate = ATTR_KEY;
        if (xstate === OPEN) {
          if (reg2 === "/") {
            p.push([OPEN, "/", arg]);
            reg2 = "";
          } else {
            p.push([OPEN, arg]);
          }
        } else if (xstate === COMMENT && opts.comments) {
          reg2 += String(arg);
        } else if (xstate !== COMMENT) {
          p.push([VAR, xstate, arg]);
        }
        parts.push.apply(parts, p);
      } else parts.push.apply(parts, parse4(strings[i]));
    }
    var tree = [null, {}, []];
    var stack = [[tree, -1]];
    for (var i = 0; i < parts.length; i++) {
      var cur = stack[stack.length - 1][0];
      var p = parts[i], s = p[0];
      if (s === OPEN && /^\//.test(p[1])) {
        var ix = stack[stack.length - 1][1];
        if (stack.length > 1) {
          stack.pop();
          stack[stack.length - 1][0][2][ix] = h(cur[0], cur[1], cur[2].length ? cur[2] : void 0);
        }
      } else if (s === OPEN) {
        var c = [p[1], {}, []];
        cur[2].push(c);
        stack.push([c, cur[2].length - 1]);
      } else if (s === ATTR_KEY || s === VAR && p[1] === ATTR_KEY) {
        var key = "";
        var copyKey;
        for (; i < parts.length; i++) {
          if (parts[i][0] === ATTR_KEY) {
            key = concat4(key, parts[i][1]);
          } else if (parts[i][0] === VAR && parts[i][1] === ATTR_KEY) {
            if (typeof parts[i][2] === "object" && !key) {
              for (copyKey in parts[i][2]) {
                if (parts[i][2].hasOwnProperty(copyKey) && !cur[1][copyKey]) {
                  cur[1][copyKey] = parts[i][2][copyKey];
                }
              }
            } else {
              key = concat4(key, parts[i][2]);
            }
          } else break;
        }
        if (parts[i][0] === ATTR_EQ) i++;
        var j = i;
        for (; i < parts.length; i++) {
          if (parts[i][0] === ATTR_VALUE || parts[i][0] === ATTR_KEY) {
            if (!cur[1][key]) cur[1][key] = strfn(parts[i][1]);
            else parts[i][1] === "" || (cur[1][key] = concat4(cur[1][key], parts[i][1]));
          } else if (parts[i][0] === VAR && (parts[i][1] === ATTR_VALUE || parts[i][1] === ATTR_KEY)) {
            if (!cur[1][key]) cur[1][key] = strfn(parts[i][2]);
            else parts[i][2] === "" || (cur[1][key] = concat4(cur[1][key], parts[i][2]));
          } else {
            if (key.length && !cur[1][key] && i === j && (parts[i][0] === CLOSE || parts[i][0] === ATTR_BREAK)) {
              cur[1][key] = key.toLowerCase();
            }
            if (parts[i][0] === CLOSE) {
              i--;
            }
            break;
          }
        }
      } else if (s === ATTR_KEY) {
        cur[1][p[1]] = true;
      } else if (s === VAR && p[1] === ATTR_KEY) {
        cur[1][p[2]] = true;
      } else if (s === CLOSE) {
        if (selfClosing(cur[0]) && stack.length) {
          var ix = stack[stack.length - 1][1];
          stack.pop();
          stack[stack.length - 1][0][2][ix] = h(cur[0], cur[1], cur[2].length ? cur[2] : void 0);
        }
      } else if (s === VAR && p[1] === TEXT) {
        if (p[2] === void 0 || p[2] === null) p[2] = "";
        else if (!p[2]) p[2] = concat4("", p[2]);
        if (Array.isArray(p[2][0])) {
          cur[2].push.apply(cur[2], p[2]);
        } else {
          cur[2].push(p[2]);
        }
      } else if (s === TEXT) {
        cur[2].push(p[1]);
      } else if (s === ATTR_EQ || s === ATTR_BREAK) ;
      else {
        throw new Error("unhandled: " + s);
      }
    }
    if (tree[2].length > 1 && /^\s*$/.test(tree[2][0])) {
      tree[2].shift();
    }
    if (tree[2].length > 2 || tree[2].length === 2 && /\S/.test(tree[2][1])) {
      if (opts.createFragment) return opts.createFragment(tree[2]);
      throw new Error("multiple root elements must be wrapped in an enclosing tag");
    }
    if (Array.isArray(tree[2][0]) && typeof tree[2][0][0] === "string" && Array.isArray(tree[2][0][2])) {
      tree[2][0] = h(tree[2][0][0], tree[2][0][1], tree[2][0][2]);
    }
    return tree[2][0];
    function parse4(str) {
      var res = [];
      if (state === ATTR_VALUE_W) state = ATTR;
      for (var i2 = 0; i2 < str.length; i2++) {
        var c2 = str.charAt(i2);
        if (state === TEXT && c2 === "<") {
          if (reg2.length) res.push([TEXT, reg2]);
          reg2 = "";
          state = OPEN;
        } else if (c2 === ">" && !quot(state) && state !== COMMENT) {
          if (state === OPEN && reg2.length) {
            res.push([OPEN, reg2]);
          } else if (state === ATTR_KEY) {
            res.push([ATTR_KEY, reg2]);
          } else if (state === ATTR_VALUE && reg2.length) {
            res.push([ATTR_VALUE, reg2]);
          }
          res.push([CLOSE]);
          reg2 = "";
          state = TEXT;
        } else if (state === COMMENT && /-$/.test(reg2) && c2 === "-") {
          if (opts.comments) {
            res.push([ATTR_VALUE, reg2.substr(0, reg2.length - 1)]);
          }
          reg2 = "";
          state = TEXT;
        } else if (state === OPEN && /^!--$/.test(reg2)) {
          if (opts.comments) {
            res.push([OPEN, reg2], [ATTR_KEY, "comment"], [ATTR_EQ]);
          }
          reg2 = c2;
          state = COMMENT;
        } else if (state === TEXT || state === COMMENT) {
          reg2 += c2;
        } else if (state === OPEN && c2 === "/" && reg2.length) ;
        else if (state === OPEN && /\s/.test(c2)) {
          if (reg2.length) {
            res.push([OPEN, reg2]);
          }
          reg2 = "";
          state = ATTR;
        } else if (state === OPEN) {
          reg2 += c2;
        } else if (state === ATTR && /[^\s"'=/]/.test(c2)) {
          state = ATTR_KEY;
          reg2 = c2;
        } else if (state === ATTR && /\s/.test(c2)) {
          if (reg2.length) res.push([ATTR_KEY, reg2]);
          res.push([ATTR_BREAK]);
        } else if (state === ATTR_KEY && /\s/.test(c2)) {
          res.push([ATTR_KEY, reg2]);
          reg2 = "";
          state = ATTR_KEY_W;
        } else if (state === ATTR_KEY && c2 === "=") {
          res.push([ATTR_KEY, reg2], [ATTR_EQ]);
          reg2 = "";
          state = ATTR_VALUE_W;
        } else if (state === ATTR_KEY) {
          reg2 += c2;
        } else if ((state === ATTR_KEY_W || state === ATTR) && c2 === "=") {
          res.push([ATTR_EQ]);
          state = ATTR_VALUE_W;
        } else if ((state === ATTR_KEY_W || state === ATTR) && !/\s/.test(c2)) {
          res.push([ATTR_BREAK]);
          if (/[\w-]/.test(c2)) {
            reg2 += c2;
            state = ATTR_KEY;
          } else state = ATTR;
        } else if (state === ATTR_VALUE_W && c2 === '"') {
          state = ATTR_VALUE_DQ;
        } else if (state === ATTR_VALUE_W && c2 === "'") {
          state = ATTR_VALUE_SQ;
        } else if (state === ATTR_VALUE_DQ && c2 === '"') {
          res.push([ATTR_VALUE, reg2], [ATTR_BREAK]);
          reg2 = "";
          state = ATTR;
        } else if (state === ATTR_VALUE_SQ && c2 === "'") {
          res.push([ATTR_VALUE, reg2], [ATTR_BREAK]);
          reg2 = "";
          state = ATTR;
        } else if (state === ATTR_VALUE_W && !/\s/.test(c2)) {
          state = ATTR_VALUE;
          i2--;
        } else if (state === ATTR_VALUE && /\s/.test(c2)) {
          res.push([ATTR_VALUE, reg2], [ATTR_BREAK]);
          reg2 = "";
          state = ATTR;
        } else if (state === ATTR_VALUE || state === ATTR_VALUE_SQ || state === ATTR_VALUE_DQ) {
          reg2 += c2;
        }
      }
      if (state === TEXT && reg2.length) {
        res.push([TEXT, reg2]);
        reg2 = "";
      } else if (state === ATTR_VALUE && reg2.length) {
        res.push([ATTR_VALUE, reg2]);
        reg2 = "";
      } else if (state === ATTR_VALUE_DQ && reg2.length) {
        res.push([ATTR_VALUE, reg2]);
        reg2 = "";
      } else if (state === ATTR_VALUE_SQ && reg2.length) {
        res.push([ATTR_VALUE, reg2]);
        reg2 = "";
      } else if (state === ATTR_KEY) {
        res.push([ATTR_KEY, reg2]);
        reg2 = "";
      }
      return res;
    }
  };
  function strfn(x) {
    if (typeof x === "function") return x;
    else if (typeof x === "string") return x;
    else if (x && typeof x === "object") return x;
    else if (x === null || x === void 0) return x;
    else return concat4("", x);
  }
};
function quot(state) {
  return state === ATTR_VALUE_SQ || state === ATTR_VALUE_DQ;
}
var closeRE = RegExp("^(" + [
  "area",
  "base",
  "basefont",
  "bgsound",
  "br",
  "col",
  "command",
  "embed",
  "frame",
  "hr",
  "img",
  "input",
  "isindex",
  "keygen",
  "link",
  "meta",
  "param",
  "source",
  "track",
  "wbr",
  "!--",
  // SVG TAGS
  "animate",
  "animateTransform",
  "circle",
  "cursor",
  "desc",
  "ellipse",
  "feBlend",
  "feColorMatrix",
  "feComposite",
  "feConvolveMatrix",
  "feDiffuseLighting",
  "feDisplacementMap",
  "feDistantLight",
  "feFlood",
  "feFuncA",
  "feFuncB",
  "feFuncG",
  "feFuncR",
  "feGaussianBlur",
  "feImage",
  "feMergeNode",
  "feMorphology",
  "feOffset",
  "fePointLight",
  "feSpecularLighting",
  "feSpotLight",
  "feTile",
  "feTurbulence",
  "font-face-format",
  "font-face-name",
  "font-face-uri",
  "glyph",
  "glyphRef",
  "hkern",
  "image",
  "line",
  "missing-glyph",
  "mpath",
  "path",
  "polygon",
  "polyline",
  "rect",
  "set",
  "stop",
  "tref",
  "use",
  "view",
  "vkern"
].join("|") + ")(?:[.#][a-zA-Z0-9-_:-]+)*$");
function selfClosing(tag) {
  return closeRE.test(tag);
}
var svgTags = ["svg", "altGlyph", "altGlyphDef", "altGlyphItem", "animate", "animateColor", "animateMotion", "animateTransform", "circle", "clipPath", "color-profile", "cursor", "defs", "desc", "ellipse", "feBlend", "feColorMatrix", "feComponentTransfer", "feComposite", "feConvolveMatrix", "feDiffuseLighting", "feDisplacementMap", "feDistantLight", "feFlood", "feFuncA", "feFuncB", "feFuncG", "feFuncR", "feGaussianBlur", "feImage", "feMerge", "feMergeNode", "feMorphology", "feOffset", "fePointLight", "feSpecularLighting", "feSpotLight", "feTile", "feTurbulence", "filter", "font", "font-face", "font-face-format", "font-face-name", "font-face-src", "font-face-uri", "foreignObject", "g", "glyph", "glyphRef", "hkern", "image", "line", "linearGradient", "marker", "mask", "metadata", "missing-glyph", "mpath", "path", "pattern", "polygon", "polyline", "radialGradient", "rect", "set", "stop", "switch", "symbol", "text", "textPath", "title", "tref", "tspan", "use", "view", "vkern"];
var boolProps = ["async", "autofocus", "autoplay", "checked", "controls", "default", "defaultchecked", "defer", "disabled", "formnovalidate", "hidden", "ismap", "loop", "multiple", "muted", "novalidate", "open", "playsinline", "readonly", "required", "reversed", "selected"];
var hyperx = hyperx$1;
var appendChild2 = appendChild$1;
var SVG_TAGS = svgTags;
var BOOL_PROPS = boolProps;
var DIRECT_PROPS = directProps;
var SVGNS = "http://www.w3.org/2000/svg";
var XLINKNS = "http://www.w3.org/1999/xlink";
var COMMENT_TAG = "!--";
var dom = function(document2) {
  function nanoHtmlCreateElement(tag, props, children) {
    var el;
    if (SVG_TAGS.indexOf(tag) !== -1) {
      props.namespace = SVGNS;
    }
    var ns = false;
    if (props.namespace) {
      ns = props.namespace;
      delete props.namespace;
    }
    var isCustomElement = false;
    if (props.is) {
      isCustomElement = props.is;
      delete props.is;
    }
    if (ns) {
      if (isCustomElement) {
        el = document2.createElementNS(ns, tag, {
          is: isCustomElement
        });
      } else {
        el = document2.createElementNS(ns, tag);
      }
    } else if (tag === COMMENT_TAG) {
      return document2.createComment(props.comment);
    } else if (isCustomElement) {
      el = document2.createElement(tag, {
        is: isCustomElement
      });
    } else {
      el = document2.createElement(tag);
    }
    for (var p in props) {
      if (props.hasOwnProperty(p)) {
        var key = p.toLowerCase();
        var val = props[p];
        if (key === "classname") {
          key = "class";
          p = "class";
        }
        if (p === "htmlFor") {
          p = "for";
        }
        if (BOOL_PROPS.indexOf(key) !== -1) {
          if (String(val) === "true") val = key;
          else if (String(val) === "false") continue;
        }
        if (key.slice(0, 2) === "on" || DIRECT_PROPS.indexOf(key) !== -1) {
          el[p] = val;
        } else {
          if (ns) {
            if (p === "xlink:href") {
              el.setAttributeNS(XLINKNS, p, val);
            } else if (/^xmlns($|:)/i.test(p)) ;
            else {
              el.setAttributeNS(null, p, val);
            }
          } else {
            el.setAttribute(p, val);
          }
        }
      }
    }
    appendChild2(el, children);
    return el;
  }
  function createFragment(nodes) {
    var fragment = document2.createDocumentFragment();
    for (var i = 0; i < nodes.length; i++) {
      if (nodes[i] == null) continue;
      if (Array.isArray(nodes[i])) {
        fragment.appendChild(createFragment(nodes[i]));
      } else {
        if (typeof nodes[i] === "string") nodes[i] = document2.createTextNode(nodes[i]);
        fragment.appendChild(nodes[i]);
      }
    }
    return fragment;
  }
  var exports = hyperx(nanoHtmlCreateElement, {
    comments: true,
    createFragment
  });
  exports.default = exports;
  exports.createComment = nanoHtmlCreateElement;
  return exports;
};
var browser = dom(document);
var html = browser;
var utils;
var hasRequiredUtils;
function requireUtils() {
  if (hasRequiredUtils) return utils;
  hasRequiredUtils = 1;
  let html$12;
  try {
    html$12 = html;
  } catch (e) {
  }
  const b64 = base64Js;
  function arrayToB64(array) {
    return b64.fromByteArray(array).replace(/\+/g, "-").replace(/\//g, "_").replace(/=/g, "");
  }
  function b64ToArray(str) {
    return b64.toByteArray(str + "===".slice((str.length + 3) % 4));
  }
  function locale() {
    return document.querySelector("html").lang;
  }
  function loadShim(polyfill) {
    return new Promise((resolve2, reject2) => {
      const shim = document.createElement("script");
      shim.src = polyfill;
      shim.addEventListener("load", () => resolve2(true));
      shim.addEventListener("error", () => resolve2(false));
      document.head.appendChild(shim);
    });
  }
  function isFile(id2) {
    return /^[0-9a-fA-F]{10,16}$/.test(id2);
  }
  function copyToClipboard(str) {
    const aux = document.createElement("input");
    aux.setAttribute("value", str);
    aux.contentEditable = true;
    aux.readOnly = true;
    document.body.appendChild(aux);
    if (navigator.userAgent.match(/iphone|ipad|ipod/i)) {
      const range3 = document.createRange();
      range3.selectNodeContents(aux);
      const sel = getSelection();
      sel.removeAllRanges();
      sel.addRange(range3);
      aux.setSelectionRange(0, str.length);
    } else {
      aux.select();
    }
    const result = document.execCommand("copy");
    document.body.removeChild(aux);
    return result;
  }
  const LOCALIZE_NUMBERS = !!(typeof Intl === "object" && Intl && typeof Intl.NumberFormat === "function" && typeof navigator === "object");
  const UNITS = ["bytes", "kb", "mb", "gb"];
  function bytes(num) {
    if (num < 1) {
      return "0B";
    }
    const exponent = Math.min(Math.floor(Math.log10(num) / 3), UNITS.length - 1);
    const n = Number(num / Math.pow(1024, exponent));
    const decimalDigits = Math.floor(n) === n ? 0 : 1;
    let nStr = n.toFixed(decimalDigits);
    if (LOCALIZE_NUMBERS) {
      try {
        nStr = n.toLocaleString(locale(), {
          minimumFractionDigits: decimalDigits,
          maximumFractionDigits: decimalDigits
        });
      } catch (e) {
      }
    }
    return translate("fileSize", {
      num: nStr,
      units: translate(UNITS[exponent])
    });
  }
  function percent(ratio) {
    if (LOCALIZE_NUMBERS) {
      try {
        return ratio.toLocaleString(locale(), {
          style: "percent"
        });
      } catch (e) {
      }
    }
    return `${Math.floor(ratio * 100)}%`;
  }
  function number(n) {
    if (LOCALIZE_NUMBERS) {
      return n.toLocaleString(locale());
    }
    return n.toString();
  }
  function allowedCopy() {
    const support = !!document.queryCommandSupported;
    return support ? document.queryCommandSupported("copy") : false;
  }
  function delay(delay2 = 100) {
    return new Promise((resolve2) => setTimeout(resolve2, delay2));
  }
  function fadeOut(selector) {
    const classes = document.querySelector(selector).classList;
    classes.remove("effect--fadeIn");
    classes.add("effect--fadeOut");
    return delay(300);
  }
  function openLinksInNewTab(links, should = true) {
    links = links || Array.from(document.querySelectorAll("a:not([target])"));
    if (should) {
      links.forEach((l) => {
        l.setAttribute("target", "_blank");
        l.setAttribute("rel", "noopener noreferrer");
      });
    } else {
      links.forEach((l) => {
        l.removeAttribute("target");
        l.removeAttribute("rel");
      });
    }
    return links;
  }
  function browserName() {
    try {
      if (/firefox/i.test(navigator.userAgent)) {
        return "firefox";
      }
      if (/edge/i.test(navigator.userAgent)) {
        return "edge";
      }
      if (/edg/i.test(navigator.userAgent)) {
        return "edgium";
      }
      if (/trident/i.test(navigator.userAgent)) {
        return "ie";
      }
      if (/chrome/i.test(navigator.userAgent)) {
        return "chrome";
      }
      if (/safari/i.test(navigator.userAgent)) {
        return "safari";
      }
      if (/send android/i.test(navigator.userAgent)) {
        return "android-app";
      }
      return "other";
    } catch (e) {
      return "unknown";
    }
  }
  async function streamToArrayBuffer(stream, size3) {
    const reader = stream.getReader();
    let state = await reader.read();
    if (size3) {
      const result2 = new Uint8Array(size3);
      let offset2 = 0;
      while (!state.done) {
        result2.set(state.value, offset2);
        offset2 += state.value.length;
        state = await reader.read();
      }
      return result2.buffer;
    }
    const parts = [];
    let len = 0;
    while (!state.done) {
      parts.push(state.value);
      len += state.value.length;
      state = await reader.read();
    }
    let offset = 0;
    const result = new Uint8Array(len);
    for (const part of parts) {
      result.set(part, offset);
      offset += part.length;
    }
    return result.buffer;
  }
  function list(items, ulStyle = "", liStyle = "") {
    const lis = items.map((i) => html$12` <li class="${liStyle}">${i}</li> `);
    return html$12`
    <ul class="${ulStyle}">
      ${lis}
    </ul>
  `;
  }
  function secondsToL10nId(seconds) {
    if (seconds < 3600) {
      return {
        id: "timespanMinutes",
        num: Math.floor(seconds / 60)
      };
    } else if (seconds < 86400) {
      return {
        id: "timespanHours",
        num: Math.floor(seconds / 3600)
      };
    } else {
      return {
        id: "timespanDays",
        num: Math.floor(seconds / 86400)
      };
    }
  }
  function timeLeft(milliseconds) {
    if (milliseconds < 1) {
      return {
        id: "linkExpiredAlt"
      };
    }
    const minutes = Math.floor(milliseconds / 1e3 / 60);
    const hours = Math.floor(minutes / 60);
    const days = Math.floor(hours / 24);
    if (days >= 1) {
      return {
        id: "expiresDaysHoursMinutes",
        days,
        hours: hours % 24,
        minutes: minutes % 60
      };
    }
    if (hours >= 1) {
      return {
        id: "expiresHoursMinutes",
        hours,
        minutes: minutes % 60
      };
    } else if (hours === 0) {
      if (minutes === 0) {
        return {
          id: "expiresMinutes",
          minutes: "< 1"
        };
      }
      return {
        id: "expiresMinutes",
        minutes
      };
    }
    return null;
  }
  function platform() {
    if (typeof Android === "object") {
      return "android";
    }
    return "web";
  }
  const ECE_RECORD_SIZE2 = 1024 * 64;
  const TAG_LENGTH2 = 16;
  function encryptedSize(size3, rs = ECE_RECORD_SIZE2, tagLength = TAG_LENGTH2) {
    const chunk_meta = tagLength + 1;
    return 21 + size3 + chunk_meta * Math.ceil(size3 / (rs - chunk_meta));
  }
  let translate = function() {
    throw new Error("uninitialized translate function. call setTranslate first");
  };
  function setTranslate(t) {
    translate = t;
  }
  utils = {
    locale,
    fadeOut,
    delay,
    allowedCopy,
    bytes,
    percent,
    number,
    copyToClipboard,
    arrayToB64,
    b64ToArray,
    loadShim,
    isFile,
    openLinksInNewTab,
    browserName,
    streamToArrayBuffer,
    list,
    secondsToL10nId,
    timeLeft,
    platform,
    encryptedSize,
    setTranslate
  };
  return utils;
}
var selectbox;
var hasRequiredSelectbox;
function requireSelectbox() {
  if (hasRequiredSelectbox) return selectbox;
  hasRequiredSelectbox = 1;
  var _appendChild = appendChild$1, _setAttribute = setAttribute;
  selectbox = function(selected, options, translate, changed, htmlId) {
    var _appearanceNone;
    function choose(event) {
      if (event.target.value != selected) {
        console.log("Selected new value from dropdown", htmlId, ":", selected, "->", event.target.value);
        changed(event.target.value);
      }
    }
    return _appearanceNone = document.createElement("select"), _appearanceNone.setAttribute("id", "" + String(htmlId)), _appearanceNone.setAttribute("data-selected", "" + String(selected)), _appearanceNone.onchange = choose, _appearanceNone.setAttribute("class", "appearance-none cursor-pointer border-default rounded-default bg-grey-10 hover:border-primary focus:border-primary pl-1 pr-8 py-1 my-1 h-8 dark:bg-grey-80"), _appendChild(_appearanceNone, ["\n      ", options.map((value) => {
      var _option;
      return _option = document.createElement("option"), _option.setAttribute("value", "" + String(value)), _setAttribute(_option, value == selected ? "selected" : "", value == selected ? "selected" : ""), _appendChild(_option, ["\n              ", translate(value), "\n            "]), _option;
    }), "\n    "]), _appearanceNone;
  };
  return selectbox;
}
var expiryOptions;
var hasRequiredExpiryOptions;
function requireExpiryOptions() {
  if (hasRequiredExpiryOptions) return expiryOptions;
  hasRequiredExpiryOptions = 1;
  var _appendChild = appendChild$1;
  const raw$12 = raw2;
  const {
    secondsToL10nId
  } = requireUtils();
  const selectbox2 = requireSelectbox();
  expiryOptions = function(state, emit) {
    var _px_;
    const el = (_px_ = document.createElement("div"), _px_.setAttribute("class", "px-1"), _appendChild(_px_, ["\n      ", raw$12(state.translate("archiveExpiryInfo", {
      downloadCount: '<span class="lg:inline-block md:block sm:inline-block block"></span><select id="dlCount"></select>',
      timespan: '<select id="timespan"></select>'
    })), "\n    "]), _px_);
    if (el.__encoded) {
      return el;
    }
    const counts = state.DEFAULTS.DOWNLOAD_COUNTS.filter((i) => i <= state.LIMITS.MAX_DOWNLOADS);
    const dlCountSelect = el.querySelector("#dlCount");
    el.replaceChild(selectbox2(state.archive.dlimit, counts, (num) => state.translate("downloadCount", {
      num
    }), (value) => {
      const selected = parseInt(value);
      state.archive.dlimit = selected;
      emit("render");
    }, "expire-after-dl-count-select"), dlCountSelect);
    const expires = state.DEFAULTS.EXPIRE_TIMES_SECONDS.filter((i) => i <= state.LIMITS.MAX_EXPIRE_SECONDS);
    const timeSelect = el.querySelector("#timespan");
    el.replaceChild(selectbox2(state.archive.timeLimit, expires, (num) => {
      const l10n = secondsToL10nId(num);
      return state.translate(l10n.id, l10n);
    }, (value) => {
      const selected = parseInt(value);
      state.archive.timeLimit = selected;
      emit("render");
    }, "expire-after-time-select"), timeSelect);
    return el;
  };
  return expiryOptions;
}
var hasRequiredArchiveTile;
function requireArchiveTile() {
  if (hasRequiredArchiveTile) return archiveTile.exports;
  hasRequiredArchiveTile = 1;
  var _appendChild = appendChild$1, _setAttribute = setAttribute, _svgNamespace = "http://www.w3.org/2000/svg", _xlinkNamespace = "http://www.w3.org/1999/xlink";
  const raw$12 = raw2;
  const assets = requireAssets();
  const {
    bytes,
    copyToClipboard,
    list,
    percent,
    platform,
    timeLeft
  } = requireUtils();
  const expiryOptions2 = requireExpiryOptions();
  function expiryInfo(translate, archive) {
    const l10n = timeLeft(archive.expiresAt - Date.now());
    return raw$12(translate("archiveExpiryInfo", {
      downloadCount: translate("downloadCount", {
        num: archive.dlimit - archive.dtotal
      }),
      timespan: translate(l10n.id, l10n)
    }));
  }
  function password(state) {
    var _autocompleteDecoy, _addPassword, _label, _checkbox, _passwordInput, _mAuto, _passwordPreviewButton, _relative, _passwordMsg, _mb_;
    const MAX_LENGTH = 4096;
    return _mb_ = document.createElement("div"), _mb_.setAttribute("class", "mb-2 px-1"), _appendChild(_mb_, ["\n      ", (_autocompleteDecoy = document.createElement("input"), _autocompleteDecoy.setAttribute("id", "autocomplete-decoy"), _autocompleteDecoy.setAttribute("type", "password"), _autocompleteDecoy.setAttribute("value", "lol"), _autocompleteDecoy.setAttribute("class", "hidden"), _autocompleteDecoy), "\n      ", (_checkbox = document.createElement("div"), _checkbox.setAttribute("class", "checkbox inline-block mr-3"), _appendChild(_checkbox, ["\n        ", (_addPassword = document.createElement("input"), _addPassword.setAttribute("id", "add-password"), _addPassword.setAttribute("type", "checkbox"), _setAttribute(_addPassword, state.archive.password ? "checked" : "", state.archive.password ? "checked" : ""), _addPassword.setAttribute("autocomplete", "off"), _addPassword.onchange = togglePasswordInput, _addPassword), "\n        ", (_label = document.createElement("label"), _label.setAttribute("for", "add-password"), _appendChild(_label, [" ", state.translate("addPassword"), " "]), _label), "\n      "]), _checkbox), "\n      ", (_relative = document.createElement("div"), _relative.setAttribute("class", "relative inline-block my-1"), _appendChild(_relative, ["\n        ", (_passwordInput = document.createElement("input"), _passwordInput.setAttribute("id", "password-input"), _passwordInput.setAttribute("autocomplete", "off"), _passwordInput.setAttribute("maxlength", "" + String(MAX_LENGTH)), _passwordInput.setAttribute("type", "password"), _passwordInput.oninput = inputChanged, _passwordInput.onfocus = focused, _passwordInput.setAttribute("placeholder", "" + String(state.translate("unlockInputPlaceholder"))), _passwordInput.setAttribute("value", "" + String(state.archive.password || "")), _passwordInput.setAttribute("class", "" + String(state.archive.password ? "" : "invisible") + " border-default rounded-default focus:border-primary leading-normal my-1 py-1 px-2 h-8 dark:bg-grey-80"), _passwordInput), "\n        ", (_passwordPreviewButton = document.createElement("button"), _passwordPreviewButton.setAttribute("id", "password-preview-button"), _passwordPreviewButton.setAttribute("type", "button"), _passwordPreviewButton.onclick = onPasswordPreviewButtonclicked, _passwordPreviewButton.setAttribute("class", "" + String(state.archive.password ? "" : "invisible") + " absolute top-0 right-0 w-8 h-8"), _appendChild(_passwordPreviewButton, ["\n          ", (_mAuto = document.createElement("img"), _mAuto.setAttribute("src", "" + String(assets.get("eye.svg"))), _mAuto.setAttribute("width", "22"), _mAuto.setAttribute("height", "22"), _mAuto.setAttribute("class", "m-auto mt-2"), _mAuto), "\n        "]), _passwordPreviewButton), "\n      "]), _relative), "\n      ", (_passwordMsg = document.createElement("label"), _passwordMsg.setAttribute("id", "password-msg"), _passwordMsg.setAttribute("for", "password-input"), _passwordMsg.setAttribute("class", "block text-xs text-grey-70"), _passwordMsg), "\n    "]), _mb_;
    function onPasswordPreviewButtonclicked(event) {
      event.preventDefault();
      const input = document.getElementById("password-input");
      const eyeIcon = event.currentTarget.querySelector("img");
      if (input.type === "password") {
        input.type = "text";
        eyeIcon.src = assets.get("eye-off.svg");
      } else {
        input.type = "password";
        eyeIcon.src = assets.get("eye.svg");
      }
      input.focus();
    }
    function togglePasswordInput(event) {
      event.stopPropagation();
      const checked = event.target.checked;
      const input = document.getElementById("password-input");
      const passwordPreviewButton = document.getElementById("password-preview-button");
      if (checked) {
        input.classList.remove("invisible");
        passwordPreviewButton.classList.remove("invisible");
        input.focus();
      } else {
        input.classList.add("invisible");
        passwordPreviewButton.classList.add("invisible");
        input.value = "";
        document.getElementById("password-msg").textContent = "";
        state.archive.password = null;
      }
    }
    function inputChanged() {
      const passwordInput = document.getElementById("password-input");
      const pwdmsg = document.getElementById("password-msg");
      const password2 = passwordInput.value;
      const length = password2.length;
      if (length === MAX_LENGTH) {
        pwdmsg.textContent = state.translate("maxPasswordLength", {
          length: MAX_LENGTH
        });
      } else {
        pwdmsg.textContent = "";
      }
      state.archive.password = password2;
    }
    function focused(event) {
      event.preventDefault();
      const el = document.getElementById("password-input");
      if (el.placeholder !== state.translate("unlockInputPlaceholder")) {
        el.placeholder = "";
      }
    }
  }
  function fileInfo2(file, action) {
    var _use, _h_, _textBase, _textSm, _ml_, _flex;
    return _flex = document.createElement("send-file"), _flex.setAttribute("class", "flex flex-row items-center p-3 w-full"), _appendChild(_flex, ["\n      ", (_h_ = document.createElementNS(_svgNamespace, "svg"), _h_.setAttribute("class", "h-8 w-8 text-primary"), _appendChild(_h_, ["\n        ", (_use = document.createElementNS(_svgNamespace, "use"), _use.setAttributeNS(_xlinkNamespace, "xlink:href", "" + String(assets.get("blue_file.svg")) + "#icon"), _use), "\n      "]), _h_), "\n      ", (_ml_ = document.createElement("p"), _ml_.setAttribute("class", "ml-4 w-full"), _appendChild(_ml_, ["\n        ", (_textBase = document.createElement("h1"), _textBase.setAttribute("class", "text-base font-medium word-break-all"), _appendChild(_textBase, [file.name]), _textBase), "\n        ", (_textSm = document.createElement("div"), _textSm.setAttribute("class", "text-sm font-normal opacity-75 pt-1"), _appendChild(_textSm, [bytes(file.size)]), _textSm), "\n      "]), _ml_), "\n      ", action, "\n    "]), _flex;
  }
  function archiveInfo(archive, action) {
    var _use2, _h_2, _textBase2, _textSm2, _flexGrow, _wFull;
    return _wFull = document.createElement("p"), _wFull.setAttribute("class", "w-full flex items-center"), _appendChild(_wFull, ["\n      ", (_h_2 = document.createElementNS(_svgNamespace, "svg"), _h_2.setAttribute("class", "h-8 w-6 mr-3 flex-shrink-0 text-primary"), _appendChild(_h_2, ["\n        ", (_use2 = document.createElementNS(_svgNamespace, "use"), _use2.setAttributeNS(_xlinkNamespace, "xlink:href", "" + String(assets.get("blue_file.svg")) + "#icon"), _use2), "\n      "]), _h_2), "\n      ", (_flexGrow = document.createElement("p"), _flexGrow.setAttribute("class", "flex-grow"), _appendChild(_flexGrow, ["\n        ", (_textBase2 = document.createElement("h1"), _textBase2.setAttribute("class", "text-base font-medium word-break-all"), _appendChild(_textBase2, [archive.name]), _textBase2), "\n        ", (_textSm2 = document.createElement("div"), _textSm2.setAttribute("class", "text-sm font-normal opacity-75 pt-1"), _appendChild(_textSm2, [bytes(archive.size)]), _textSm2), "\n      "]), _flexGrow), "\n      ", action, "\n    "]), _wFull;
  }
  function archiveDetails(translate, archive) {
    if (archive.manifest.files.length > 1) {
      var _path, _fillCurrent, _flex2, _wFull2;
      return _wFull2 = document.createElement("details"), _setAttribute(_wFull2, archive.open ? "open" : "", archive.open ? "open" : ""), _wFull2.ontoggle = toggled, _wFull2.setAttribute("class", "w-full pb-1"), _appendChild(_wFull2, ["\n        ", (_flex2 = document.createElement("summary"), _flex2.setAttribute("class", "flex items-center link-primary text-sm cursor-pointer outline-none"), _appendChild(_flex2, ["\n          ", (_fillCurrent = document.createElementNS(_svgNamespace, "svg"), _fillCurrent.setAttribute("xmlns", "http://www.w3.org/2000/svg"), _fillCurrent.setAttribute("viewBox", "0 0 20 20"), _fillCurrent.setAttribute("class", "fill-current w-4 h-4 mr-1"), _appendChild(_fillCurrent, ["\n            ", (_path = document.createElementNS(_svgNamespace, "path"), _path.setAttribute("d", "M12.95 10.707l.707-.707L8 4.343 6.586 5.757 10.828 10l-4.242 4.243L8 15.657l4.95-4.95z"), _path), "\n          "]), _fillCurrent), "\n          ", translate("fileCount", {
        num: archive.manifest.files.length
      }), "\n        "]), _flex2), "\n        ", list(archive.manifest.files.map((f) => fileInfo2(f))), "\n      "]), _wFull2;
    }
    function toggled(event) {
      event.stopPropagation();
      archive.open = event.target.open;
    }
  }
  archiveTile.exports = function(state, emit, archive) {
    var _use3, _h_3, _linkPrimary, _use4, _h_4, _linkPrimary2, _use5, _h_5, _flex3, _div, _textSm3, _wFull3, _flex4, _flex5, _selfStart;
    const copyOrShare = state.capabilities.share || platform() === "android" ? (_linkPrimary = document.createElement("button"), _linkPrimary.onclick = share, _linkPrimary.setAttribute("title", "Share link"), _linkPrimary.setAttribute("class", "link-primary self-end flex items-start"), _appendChild(_linkPrimary, ["\n            ", (_h_3 = document.createElementNS(_svgNamespace, "svg"), _h_3.setAttribute("class", "h-4 w-4 mr-2"), _appendChild(_h_3, ["\n              ", (_use3 = document.createElementNS(_svgNamespace, "use"), _use3.setAttributeNS(_xlinkNamespace, "xlink:href", "" + String(assets.get("share-24.svg")) + "#icon"), _use3), "\n            "]), _h_3), "\n            Share link\n          "]), _linkPrimary) : (_linkPrimary2 = document.createElement("button"), _linkPrimary2.onclick = copy, _linkPrimary2.setAttribute("title", "" + String(state.translate("copyLinkButton"))), _linkPrimary2.setAttribute("class", "link-primary focus:outline self-end flex items-center"), _appendChild(_linkPrimary2, ["\n            ", (_h_4 = document.createElementNS(_svgNamespace, "svg"), _h_4.setAttribute("class", "h-4 w-4 mr-2"), _appendChild(_h_4, ["\n              ", (_use4 = document.createElementNS(_svgNamespace, "use"), _use4.setAttributeNS(_xlinkNamespace, "xlink:href", "" + String(assets.get("copy-16.svg")) + "#icon"), _use4), "\n            "]), _h_4), "\n            ", state.translate("copyLinkButton"), "\n          "]), _linkPrimary2);
    const dl = platform() === "web" ? (_flex3 = document.createElement("a"), _flex3.setAttribute("href", "" + String(archive.url)), _flex3.setAttribute("title", "" + String(state.translate("downloadButtonLabel"))), _flex3.setAttribute("tabindex", "0"), _flex3.setAttribute("class", "flex items-baseline link-primary"), _appendChild(_flex3, ["\n            ", (_h_5 = document.createElementNS(_svgNamespace, "svg"), _h_5.setAttribute("class", "h-4 w-3 mr-2"), _appendChild(_h_5, ["\n              ", (_use5 = document.createElementNS(_svgNamespace, "use"), _use5.setAttributeNS(_xlinkNamespace, "xlink:href", "" + String(assets.get("dl.svg")) + "#icon"), _use5), "\n            "]), _h_5), "\n            ", state.translate("downloadButtonLabel"), "\n          "]), _flex3) : (_div = document.createElement("div"), _div);
    return _flex5 = document.createElement("send-archive"), _flex5.setAttribute("id", "archive-" + String(archive.id)), _flex5.setAttribute("class", "flex flex-col items-start rounded-default shadow-light bg-white p-4 w-full dark:bg-grey-90 dark:border-default dark:border-grey-70"), _appendChild(_flex5, ["\n      ", archiveInfo(archive, (_selfStart = document.createElement("input"), _selfStart.setAttribute("type", "image"), _selfStart.setAttribute("alt", "" + String(state.translate("deleteButtonHover"))), _selfStart.setAttribute("title", "" + String(state.translate("deleteButtonHover"))), _selfStart.setAttribute("src", "" + String(assets.get("close-16.svg"))), _selfStart.onclick = del2, _selfStart.setAttribute("class", "self-start flex-shrink-0 text-white hover:opacity-75 focus:outline"), _selfStart)), "\n      ", (_textSm3 = document.createElement("div"), _textSm3.setAttribute("class", "text-sm opacity-75 w-full mt-2 mb-2"), _appendChild(_textSm3, ["\n        ", expiryInfo(state.translate, archive), "\n      "]), _textSm3), "\n      ", archiveDetails(state.translate, archive), "\n      ", (_wFull3 = document.createElement("hr"), _wFull3.setAttribute("class", "w-full border-t my-4 dark:border-grey-70"), _wFull3), "\n      ", (_flex4 = document.createElement("div"), _flex4.setAttribute("class", "flex justify-between w-full"), _appendChild(_flex4, [dl, " ", copyOrShare]), _flex4), "\n    "]), _flex5;
    function copy(event) {
      event.stopPropagation();
      copyToClipboard(archive.url);
      const text = event.target.lastChild;
      text.textContent = state.translate("copiedUrl");
      setTimeout(() => text.textContent = state.translate("copyLinkButton"), 1e3);
    }
    function del2(event) {
      event.stopPropagation();
      emit("delete", archive);
    }
    async function share(event) {
      event.stopPropagation();
      if (platform() === "android") {
        Android.shareUrl(archive.url);
      } else {
        try {
          await navigator.share({
            title: state.translate("-send-brand"),
            text: `Download "${archive.name}" with Send: simple, safe file sharing`,
            //state.translate('shareMessage', { name }),
            url: archive.url
          });
        } catch (e) {
        }
      }
    }
  };
  archiveTile.exports.wip = function(state, emit) {
    var _fileUpload, _use6, _w_, _flex6, _fontNormal, _flex7, _flexShrink_, _uploadBtn, _wip;
    return _wip = document.createElement("send-upload-area"), _wip.setAttribute("id", "wip"), _wip.setAttribute("class", "flex flex-col bg-white h-full w-full dark:bg-grey-90"), _appendChild(_wip, ["\n      ", list(Array.from(state.archive.files).reverse().map((f) => fileInfo2(f, remove2(f, state.translate("deleteButtonHover")))), "flex-shrink bg-grey-10 rounded-t overflow-y-auto px-6 py-4 md:h-full md:max-h-half-screen dark:bg-black", "bg-white px-2 my-2 shadow-light rounded-default dark:bg-grey-90 dark:border-default dark:border-grey-80"), "\n      ", (_flexShrink_ = document.createElement("div"), _flexShrink_.setAttribute("class", "flex-shrink-0 flex-grow flex items-end p-4 bg-grey-10 rounded-b mb-1 font-medium dark:bg-grey-90"), _appendChild(_flexShrink_, ["\n        ", (_fileUpload = document.createElement("input"), _fileUpload.setAttribute("id", "file-upload"), _fileUpload.setAttribute("type", "file"), _fileUpload.setAttribute("multiple", "multiple"), _fileUpload.onfocus = focus, _fileUpload.onblur = blur, _fileUpload.onchange = add2, _fileUpload.setAttribute("class", "opacity-0 w-0 h-0 appearance-none absolute overflow-hidden"), _fileUpload), "\n        ", (_flex7 = document.createElement("div"), _flex7.setAttribute("for", "file-upload"), _flex7.setAttribute("class", "flex flex-row items-center justify-between w-full p-2"), _appendChild(_flex7, ["\n          ", (_flex6 = document.createElement("label"), _flex6.setAttribute("title", "" + String(state.translate("addFilesButton"))), _flex6.setAttribute("for", "file-upload"), _flex6.setAttribute("class", "flex items-center cursor-pointer"), _appendChild(_flex6, ["\n            ", (_w_ = document.createElementNS(_svgNamespace, "svg"), _w_.setAttribute("class", "w-6 h-6 mr-2 link-primary"), _appendChild(_w_, ["\n              ", (_use6 = document.createElementNS(_svgNamespace, "use"), _use6.setAttributeNS(_xlinkNamespace, "xlink:href", "" + String(assets.get("addfiles.svg")) + "#plus"), _use6), "\n            "]), _w_), "\n            ", state.translate("addFilesButton"), "\n          "]), _flex6), "\n          ", (_fontNormal = document.createElement("div"), _fontNormal.setAttribute("class", "font-normal text-sm text-grey-70 dark:text-grey-40"), _appendChild(_fontNormal, ["\n            ", state.translate("totalSize", {
      size: bytes(state.archive.size)
    }), "\n          "]), _fontNormal), "\n        "]), _flex7), "\n      "]), _flexShrink_), "\n      ", expiryOptions2(state, emit), " ", password(state), "\n      ", (_uploadBtn = document.createElement("button"), _uploadBtn.setAttribute("id", "upload-btn"), _uploadBtn.setAttribute("title", "" + String(state.translate("uploadButton"))), _uploadBtn.onclick = upload2, _uploadBtn.setAttribute("class", "btn rounded-lg flex-shrink-0 focus:outline"), _appendChild(_uploadBtn, ["\n        ", state.translate("uploadButton"), "\n      "]), _uploadBtn), "\n    "]), _wip;
    function focus(event) {
      event.target.nextElementSibling.firstElementChild.classList.add("outline");
    }
    function blur(event) {
      event.target.nextElementSibling.firstElementChild.classList.remove("outline");
    }
    function upload2(event) {
      window.scrollTo(0, 0);
      event.preventDefault();
      event.target.disabled = true;
      if (!state.uploading) {
        emit("upload");
      }
    }
    function add2(event) {
      event.preventDefault();
      const newFiles = Array.from(event.target.files);
      emit("addFiles", {
        files: newFiles
      });
      setTimeout(() => {
        document.querySelector("#wip > ul > li:first-child").scrollIntoView({
          block: "center"
        });
      });
    }
    function remove2(file, desc) {
      var _selfCenter;
      return _selfCenter = document.createElement("input"), _selfCenter.setAttribute("type", "image"), _selfCenter.setAttribute("alt", "" + String(desc)), _selfCenter.setAttribute("title", "" + String(desc)), _selfCenter.setAttribute("src", "" + String(assets.get("close-16.svg"))), _selfCenter.onclick = del2, _selfCenter.setAttribute("class", "self-center text-white ml-4 h-4 hover:opacity-75 focus:outline"), _selfCenter;
      function del2(event) {
        event.stopPropagation();
        emit("removeUpload", file);
      }
    }
  };
  archiveTile.exports.uploading = function(state, emit) {
    var _textXs, _linkPrimary3, _my_, _linkPrimary4, _flex8;
    const progress = state.transfer.progressRatio;
    const progressPercent = percent(progress);
    const archive = state.archive;
    return _flex8 = document.createElement("send-upload-area"), _flex8.setAttribute("id", "" + String(archive.id)), _flex8.setAttribute("class", "flex flex-col items-start rounded-default shadow-light bg-white p-4 w-full dark:bg-grey-90"), _appendChild(_flex8, ["\n      ", archiveInfo(archive), "\n      ", (_textXs = document.createElement("div"), _textXs.setAttribute("class", "text-xs opacity-75 w-full mt-2 mb-2"), _appendChild(_textXs, ["\n        ", expiryInfo(state.translate, {
      dlimit: state.archive.dlimit,
      dtotal: 0,
      expiresAt: Date.now() + 500 + state.archive.timeLimit * 1e3
    }), "\n      "]), _textXs), "\n      ", (_linkPrimary3 = document.createElement("div"), _linkPrimary3.setAttribute("class", "link-primary text-sm font-medium mt-2"), _appendChild(_linkPrimary3, ["\n        ", progressPercent, "\n      "]), _linkPrimary3), "\n      ", (_my_ = document.createElement("progress"), _my_.setAttribute("value", "" + String(progress)), _my_.setAttribute("class", "my-3"), _appendChild(_my_, [progressPercent]), _my_), "\n      ", (_linkPrimary4 = document.createElement("button"), _linkPrimary4.onclick = cancel, _linkPrimary4.setAttribute("title", "" + String(state.translate("deletePopupCancel"))), _linkPrimary4.setAttribute("class", "link-primary self-end font-medium"), _appendChild(_linkPrimary4, ["\n        ", state.translate("deletePopupCancel"), "\n      "]), _linkPrimary4), "\n    "]), _flex8;
    function cancel(event) {
      event.stopPropagation();
      event.target.disabled = true;
      emit("cancel");
    }
  };
  archiveTile.exports.empty = function(state, emit) {
    var _wFull4, _use7, _w_2, _pt_, _pb_, _fileUpload2, _btn, _flex9;
    const uploadNotice = state.WEB_UI.UPLOAD_AREA_NOTICE_HTML ? (_wFull4 = document.createElement("p"), _wFull4.setAttribute("class", "w-full mt-8 p-2 border-default dark:border-grey-70 rounded-default text-orange-60 bg-yellow-40 text-center leading-normal"), _appendChild(_wFull4, ["\n          ", raw$12(state.WEB_UI.UPLOAD_AREA_NOTICE_HTML), "\n        "]), _wFull4) : "";
    return _flex9 = document.createElement("send-upload-area"), _flex9.onclick = (e) => {
      if (e.target.tagName !== "LABEL") {
        document.getElementById("file-upload").click();
      }
    }, _flex9.setAttribute("class", "flex flex-col items-center justify-center border-2 border-dashed border-grey-transparent rounded-default px-6 py-16 h-full w-full dark:border-grey-60"), _appendChild(_flex9, ["\n      ", (_w_2 = document.createElementNS(_svgNamespace, "svg"), _w_2.setAttribute("class", "w-10 h-10 link-primary"), _appendChild(_w_2, ["\n        ", (_use7 = document.createElementNS(_svgNamespace, "use"), _use7.setAttributeNS(_xlinkNamespace, "xlink:href", "" + String(assets.get("addfiles.svg")) + "#plus"), _use7), "\n      "]), _w_2), "\n      ", (_pt_ = document.createElement("div"), _pt_.setAttribute("class", "pt-6 pb-2 text-center text-lg font-bold tracking-wide"), _appendChild(_pt_, ["\n        ", state.translate("dragAndDropFiles"), "\n      "]), _pt_), "\n      ", (_pb_ = document.createElement("div"), _pb_.setAttribute("class", "pb-6 text-center text-base"), _appendChild(_pb_, ["\n        ", state.translate("orClickWithSize", {
      size: bytes(state.LIMITS.MAX_FILE_SIZE)
    }), "\n      "]), _pb_), "\n      ", (_fileUpload2 = document.createElement("input"), _fileUpload2.setAttribute("id", "file-upload"), _fileUpload2.setAttribute("type", "file"), _fileUpload2.setAttribute("multiple", "multiple"), _fileUpload2.onfocus = focus, _fileUpload2.onblur = blur, _fileUpload2.onchange = add2, _fileUpload2.onclick = (e) => e.stopPropagation(), _fileUpload2.setAttribute("class", "opacity-0 w-0 h-0 appearance-none absolute overflow-hidden"), _fileUpload2), "\n      ", (_btn = document.createElement("label"), _btn.setAttribute("role", "button"), _btn.setAttribute("title", "" + String(state.translate("addFilesButton", {
      size: bytes(state.LIMITS.MAX_FILE_SIZE)
    }))), _btn.setAttribute("for", "file-upload"), _btn.setAttribute("class", "btn rounded-lg flex items-center mt-4"), _appendChild(_btn, ["\n        ", state.translate("addFilesButton"), "\n      "]), _btn), "\n      ", uploadNotice, "\n    "]), _flex9;
    function focus(event) {
      event.target.nextElementSibling.classList.add("bg-primary", "outline");
    }
    function blur(event) {
      event.target.nextElementSibling.classList.remove("bg-primary", "outline");
    }
    function add2(event) {
      event.preventDefault();
      const newFiles = Array.from(event.target.files);
      emit("addFiles", {
        files: newFiles
      });
    }
  };
  archiveTile.exports.preview = function(state, emit) {
    var _mt_, _wFull5, _borderDefault, _downloadBtn, _flex10;
    const archive = state.fileInfo;
    if (archive.open === void 0) {
      archive.open = true;
    }
    const single = archive.manifest.files.length === 1;
    const details = single ? "" : (_mt_ = document.createElement("div"), _mt_.setAttribute("class", "mt-4 h-full md:h-48 overflow-y-auto"), _appendChild(_mt_, ["\n          ", archiveDetails(state.translate, archive), "\n        "]), _mt_);
    const notice = state.WEB_UI.DOWNLOAD_NOTICE_HTML ? (_wFull5 = document.createElement("p"), _wFull5.setAttribute("class", "w-full mt-4 p-2 border-default dark:border-grey-70 rounded-default text-orange-60 bg-yellow-40 text-center leading-normal"), _appendChild(_wFull5, ["\n          ", raw$12(state.WEB_UI.DOWNLOAD_NOTICE_HTML), "\n        "]), _wFull5) : "";
    return _flex10 = document.createElement("send-archive"), _flex10.setAttribute("class", "flex flex-col max-h-full bg-white p-4 w-full md:w-128 dark:bg-grey-90"), _appendChild(_flex10, ["\n      ", (_borderDefault = document.createElement("div"), _borderDefault.setAttribute("class", "border-default rounded-default py-3 px-6 dark:border-grey-70"), _appendChild(_borderDefault, ["\n        ", archiveInfo(archive), " ", details, "\n      "]), _borderDefault), "\n      ", (_downloadBtn = document.createElement("button"), _downloadBtn.setAttribute("id", "download-btn"), _downloadBtn.setAttribute("title", "" + String(state.translate("downloadButtonLabel"))), _downloadBtn.onclick = download2, _downloadBtn.setAttribute("class", "btn rounded-lg mt-4 w-full flex-shrink-0 focus:outline"), _appendChild(_downloadBtn, ["\n        ", state.translate("downloadButtonLabel"), "\n      "]), _downloadBtn), "\n      ", notice, "\n    "]), _flex10;
    function download2(event) {
      event.preventDefault();
      event.target.disabled = true;
      emit("download");
    }
  };
  archiveTile.exports.downloading = function(state) {
    var _linkPrimary5, _my_2, _flex11;
    const archive = state.fileInfo;
    const progress = state.transfer.progressRatio;
    const progressPercent = percent(progress);
    return _flex11 = document.createElement("send-archive"), _flex11.setAttribute("class", "flex flex-col bg-white rounded-default shadow-light p-4 w-full max-w-sm md:w-128 dark:bg-grey-90"), _appendChild(_flex11, ["\n      ", archiveInfo(archive), "\n      ", (_linkPrimary5 = document.createElement("div"), _linkPrimary5.setAttribute("class", "link-primary text-sm font-medium mt-2"), _appendChild(_linkPrimary5, ["\n        ", progressPercent, "\n      "]), _linkPrimary5), "\n      ", (_my_2 = document.createElement("progress"), _my_2.setAttribute("value", "" + String(progress)), _my_2.setAttribute("class", "my-3"), _appendChild(_my_2, [progressPercent]), _my_2), "\n    "]), _flex11;
  };
  return archiveTile.exports;
}
var modal;
var hasRequiredModal;
function requireModal() {
  if (hasRequiredModal) return modal;
  hasRequiredModal = 1;
  var _appendChild = appendChild$1;
  modal = function(state, emit) {
    var _wFull, _hFull, _absolute;
    return _absolute = document.createElement("send-modal"), _absolute.setAttribute("class", "absolute inset-0 flex items-center justify-center overflow-hidden z-40 bg-white md:rounded-xl md:my-8 dark:bg-grey-90"), _appendChild(_absolute, ["\n      ", (_hFull = document.createElement("div"), _hFull.setAttribute("class", "h-full w-full max-h-screen absolute top-0 flex justify-center md:items-center"), _appendChild(_hFull, ["\n        ", (_wFull = document.createElement("div"), _wFull.setAttribute("class", "w-full"), _appendChild(_wFull, ["\n          ", state.modal(state, emit, close), "\n        "]), _wFull), "\n      "]), _hFull), "\n    "]), _absolute;
    function close(event) {
      if (event) {
        event.preventDefault();
        event.stopPropagation();
      }
      emit("closeModal");
    }
  };
  return modal;
}
var noStreams;
var hasRequiredNoStreams;
function requireNoStreams() {
  if (hasRequiredNoStreams) return noStreams;
  hasRequiredNoStreams = 1;
  var _appendChild = appendChild$1, _svgNamespace = "http://www.w3.org/2000/svg", _xlinkNamespace = "http://www.w3.org/1999/xlink";
  const {
    bytes
  } = requireUtils();
  const assets = requireAssets();
  noStreams = function(state, emit) {
    var _mb_, _wFull, _use, _h_, _textBase, _textSm, _flexGrow, _flex, _copy, _, _2, _firefox, _3, _my_, _download, _4, _mt_, _borderDefault, _btn, _textGrey_, _mdW_, _flex2;
    const archive = state.fileInfo;
    return _flex2 = document.createElement("div"), _flex2.setAttribute("class", "flex flex-col w-full max-w-md h-full mx-auto items-center justify-center"), _appendChild(_flex2, ["\n      ", (_mb_ = document.createElement("h1"), _mb_.setAttribute("class", "mb-4 text-3xl font-bold"), _appendChild(_mb_, [state.translate("downloadTitle")]), _mb_), "\n      ", (_wFull = document.createElement("p"), _wFull.setAttribute("class", "w-full p-2 border-default border-yellow-50 rounded-default md:w-4/5 text-orange-60 bg-yellow-40 text-center leading-normal"), _appendChild(_wFull, ["\n         ", state.translate("noStreamsWarning"), " \n      "]), _wFull), "\n      ", (_mdW_ = document.createElement("form"), _mdW_.onsubmit = submit, _mdW_.setAttribute("class", "md:w-128"), _appendChild(_mdW_, ["\n        ", (_borderDefault = document.createElement("fieldset"), _borderDefault.onchange = optionChanged, _borderDefault.setAttribute("class", "border-default rounded-default p-4 my-4"), _appendChild(_borderDefault, ["\n          ", (_flex = document.createElement("div"), _flex.setAttribute("class", "flex items-center mb-2"), _appendChild(_flex, ["\n            ", (_h_ = document.createElementNS(_svgNamespace, "svg"), _h_.setAttribute("class", "h-8 w-6 mr-3 flex-shrink-0 text-primary"), _appendChild(_h_, ["\n              ", (_use = document.createElementNS(_svgNamespace, "use"), _use.setAttributeNS(_xlinkNamespace, "xlink:href", "" + String(assets.get("blue_file.svg")) + "#icon"), _use), "\n            "]), _h_), "\n            ", (_flexGrow = document.createElement("p"), _flexGrow.setAttribute("class", "flex-grow"), _appendChild(_flexGrow, ["\n              ", (_textBase = document.createElement("h1"), _textBase.setAttribute("class", "text-base font-medium word-break-all"), _appendChild(_textBase, [archive.name]), _textBase), "\n              ", (_textSm = document.createElement("div"), _textSm.setAttribute("class", "text-sm font-normal opacity-75 pt-1"), _appendChild(_textSm, [bytes(archive.size)]), _textSm), "\n            "]), _flexGrow), "\n          "]), _flex), "\n          ", (_2 = document.createElement("div"), _2.setAttribute("class", " mt-6 mb-3"), _appendChild(_2, ["\n            ", (_copy = document.createElement("input"), _copy.setAttribute("type", "radio"), _copy.setAttribute("name", "gus"), _copy.setAttribute("id", "copy"), _copy.setAttribute("value", "copy"), _copy.setAttribute("checked", "checked"), _copy.setAttribute("class", "mx-2"), _copy), "\n            ", (_ = document.createElement("label"), _.setAttribute("class", ""), _.setAttribute("for", "copy"), _appendChild(_, [state.translate("noStreamsOptionCopy")]), _), "\n          "]), _2), "\n          ", (_my_ = document.createElement("div"), _my_.setAttribute("class", "my-3"), _appendChild(_my_, ["\n            ", (_firefox = document.createElement("input"), _firefox.setAttribute("type", "radio"), _firefox.setAttribute("name", "gus"), _firefox.setAttribute("id", "firefox"), _firefox.setAttribute("value", "firefox"), _firefox.setAttribute("class", "mx-2"), _firefox), "\n            ", (_3 = document.createElement("label"), _3.setAttribute("class", ""), _3.setAttribute("for", "firefox"), _appendChild(_3, [state.translate("noStreamsOptionFirefox")]), _3), "\n          "]), _my_), "\n          ", (_mt_ = document.createElement("div"), _mt_.setAttribute("class", "mt-3"), _appendChild(_mt_, ["\n            ", (_download = document.createElement("input"), _download.setAttribute("type", "radio"), _download.setAttribute("name", "gus"), _download.setAttribute("id", "download"), _download.setAttribute("value", "download"), _download.setAttribute("class", "mx-2"), _download), "\n            ", (_4 = document.createElement("label"), _4.setAttribute("class", ""), _4.setAttribute("for", "download"), _appendChild(_4, [state.translate("noStreamsOptionDownload")]), _4), "\n          "]), _mt_), "\n        "]), _borderDefault), "\n        ", (_btn = document.createElement("input"), _btn.setAttribute("value", "" + String(state.translate("copyLinkButton"))), _btn.setAttribute("title", "" + String(state.translate("copyLinkButton"))), _btn.setAttribute("type", "submit"), _btn.setAttribute("class", "btn rounded-lg w-full flex flex-shrink-0 items-center justify-center"), _btn), "\n            ", (_textGrey_ = document.createElement("p"), _textGrey_.setAttribute("class", "text-grey-80 leading-normal dark:text-grey-40 font-semibold text-center md:my-8 md:text-left"), _appendChild(_textGrey_, ["\n          ", state.translate("downloadConfirmDescription"), "\n        "]), _textGrey_), "\n      "]), _mdW_), "\n    "]), _flex2;
    function optionChanged(event) {
      event.stopPropagation();
      const choice = event.target.value;
      const button = event.currentTarget.nextElementSibling;
      let title = button.title;
      console.error(choice, title);
      switch (choice) {
        case "copy":
          title = state.translate("copyLinkButton");
          break;
        case "firefox":
          title = state.translate("downloadFirefox");
          break;
        case "download":
          title = state.translate("downloadButtonLabel");
          break;
      }
      button.title = title;
      button.value = title;
    }
    function submit(event) {
      const action = document.querySelector('input[type="radio"]:checked').value;
      switch (action) {
        case "copy":
          emit("copy", {
            url: window.location.href
          });
          document.querySelector('input[type="submit"]').value = state.translate("copiedUrl");
          break;
        case "firefox":
          window.open("https://www.mozilla.org/firefox/new/?utm_campaign=send-acquisition&utm_medium=referral&utm_source=send.firefox.com");
          break;
        case "download":
          emit("download");
          break;
      }
      return false;
    }
  };
  return noStreams;
}
var notFound;
var hasRequiredNotFound;
function requireNotFound() {
  if (hasRequiredNotFound) return notFound;
  hasRequiredNotFound = 1;
  var _appendChild = appendChild$1, _svgNamespace = "http://www.w3.org/2000/svg", _xlinkNamespace = "http://www.w3.org/1999/xlink";
  const assets = requireAssets();
  const modal2 = requireModal();
  notFound = function(state, emit) {
    var _textCenter, _use, _textPrimary, _maxWMd, _btn, _my_, _flex, _main;
    const btnText = "sendYourFilesLink";
    return _main = document.createElement("div"), _main.setAttribute("class", "main"), _appendChild(_main, ["\n      ", state.modal && modal2(state, emit), "\n      ", (_flex = document.createElement("section"), _flex.setAttribute("class", "flex flex-col items-center justify-center h-full w-full p-6 md:p-8 overflow-hidden md:rounded-xl md:shadow-big"), _appendChild(_flex, ["\n        ", (_textCenter = document.createElement("h1"), _textCenter.setAttribute("class", "text-center text-3xl font-bold my-2"), _appendChild(_textCenter, ["\n          ", state.translate("expiredTitle"), "\n        "]), _textCenter), "\n        ", (_textPrimary = document.createElementNS(_svgNamespace, "svg"), _textPrimary.setAttribute("class", "text-primary my-12"), _appendChild(_textPrimary, ["\n          ", (_use = document.createElementNS(_svgNamespace, "use"), _use.setAttributeNS(_xlinkNamespace, "xlink:href", "" + String(assets.get("notFound.svg")) + "#svg124"), _use), "\n        "]), _textPrimary), "\n        ", (_maxWMd = document.createElement("p"), _maxWMd.setAttribute("class", "max-w-md text-center text-grey-80 leading-normal dark:text-grey-40"), _appendChild(_maxWMd, ["\n          ", state.translate("trySendDescription"), "\n        "]), _maxWMd), "\n        ", (_my_ = document.createElement("p"), _my_.setAttribute("class", "my-5"), _appendChild(_my_, ["\n          ", (_btn = document.createElement("a"), _btn.setAttribute("href", "/"), _btn.setAttribute("role", "button"), _btn.setAttribute("class", "btn rounded-lg flex items-center"), _appendChild(_btn, [state.translate(btnText)]), _btn), "\n        "]), _my_), "\n      "]), _flex), "\n    "]), _main;
  };
  return notFound;
}
var downloadPassword;
var hasRequiredDownloadPassword;
function requireDownloadPassword() {
  if (hasRequiredDownloadPassword) return downloadPassword;
  hasRequiredDownloadPassword = 1;
  var _appendChild = appendChild$1;
  downloadPassword = function(state, emit) {
    var _text_3xl, _wFull, _autocompleteDecoy, _passwordInput, _passwordBtn, _flex, _passwordError, _hFull;
    const fileInfo2 = state.fileInfo;
    const invalid = fileInfo2.password === null;
    const div = (_hFull = document.createElement("div"), _hFull.setAttribute("class", "h-full w-full flex flex-col items-center justify-center bg-white py-8 max-w-md mx-auto dark:bg-grey-90"), _appendChild(_hFull, ["\n      ", (_text_3xl = document.createElement("h1"), _text_3xl.setAttribute("class", "text-3xl font-bold mb-4"), _appendChild(_text_3xl, ["\n        ", state.translate("downloadTitle"), "\n      "]), _text_3xl), "\n      ", (_wFull = document.createElement("p"), _wFull.setAttribute("class", "w-full mb-4 text-center text-grey-80 dark:text-grey-40 leading-normal"), _appendChild(_wFull, ["\n        ", state.translate("downloadDescription"), "\n      "]), _wFull), "\n      ", (_flex = document.createElement("form"), _flex.onsubmit = checkPassword, _flex.setAttribute("data-no-csrf", "data-no-csrf"), _flex.setAttribute("class", "flex flex-row flex-nowrap w-full md:w-4/5"), _appendChild(_flex, ["\n        ", (_autocompleteDecoy = document.createElement("input"), _autocompleteDecoy.setAttribute("id", "autocomplete-decoy"), _autocompleteDecoy.setAttribute("type", "password"), _autocompleteDecoy.setAttribute("value", "lol"), _autocompleteDecoy.setAttribute("class", "hidden"), _autocompleteDecoy), "\n        ", (_passwordInput = document.createElement("input"), _passwordInput.setAttribute("id", "password-input"), _passwordInput.setAttribute("maxlength", "4096"), _passwordInput.setAttribute("autocomplete", "off"), _passwordInput.setAttribute("placeholder", "" + String(state.translate("unlockInputPlaceholder"))), _passwordInput.oninput = inputChanged, _passwordInput.setAttribute("type", "password"), _passwordInput.setAttribute("class", "w-full border-l border-t border-b rounded-l-lg rounded-r-none " + String(invalid ? "border-red dark:border-red-40" : "border-grey") + " leading-loose px-2 py-1 dark:bg-grey-80"), _passwordInput), "\n        ", (_passwordBtn = document.createElement("input"), _passwordBtn.setAttribute("type", "submit"), _passwordBtn.setAttribute("id", "password-btn"), _passwordBtn.setAttribute("value", "" + String(state.translate("unlockButtonLabel"))), _passwordBtn.setAttribute("title", "" + String(state.translate("unlockButtonLabel"))), _passwordBtn.setAttribute("class", "btn rounded-r-lg rounded-l-none " + String(invalid ? "bg-red hover:bg-red focus:bg-red dark:bg-red-40" : "")), _passwordBtn), "\n      "]), _flex), "\n      ", (_passwordError = document.createElement("label"), _passwordError.setAttribute("id", "password-error"), _passwordError.setAttribute("class", "" + String(invalid ? "" : "invisible") + " text-red dark:text-red-40 my-4"), _passwordError.setAttribute("for", "password-input"), _appendChild(_passwordError, ["\n        ", state.translate("passwordTryAgain"), "\n      "]), _passwordError), "\n    "]), _hFull);
    if (!(div instanceof String)) {
      setTimeout(() => document.getElementById("password-input").focus());
    }
    function inputChanged(event) {
      event.stopPropagation();
      event.preventDefault();
      const label = document.getElementById("password-error");
      const input = document.getElementById("password-input");
      const btn = document.getElementById("password-btn");
      label.classList.add("invisible");
      input.classList.remove("border-red", "dark:border-red-40");
      btn.classList.remove("bg-red", "hover:bg-red", "focus:bg-red", "dark:bg-red-40");
    }
    function checkPassword(event) {
      event.stopPropagation();
      event.preventDefault();
      const el = document.getElementById("password-input");
      const password = el.value;
      if (password.length > 0) {
        document.getElementById("password-btn").disabled = true;
        const fileInfoUrl = window.location.href.replace(/\?.+#/, "#");
        state.fileInfo.url = fileInfoUrl;
        state.fileInfo.password = password;
        emit("getMetadata");
      }
      return false;
    }
    return div;
  };
  return downloadPassword;
}
var downloadCompleted;
var hasRequiredDownloadCompleted;
function requireDownloadCompleted() {
  if (hasRequiredDownloadCompleted) return downloadCompleted;
  hasRequiredDownloadCompleted = 1;
  var _appendChild = appendChild$1, _svgNamespace = "http://www.w3.org/2000/svg", _xlinkNamespace = "http://www.w3.org/1999/xlink";
  const assets = requireAssets();
  downloadCompleted = function(state) {
    var _textCenter, _use, _my_, _textGrey_, _btn, _my_2, _downloadComplete;
    const btnText = "sendYourFilesLink";
    return _downloadComplete = document.createElement("div"), _downloadComplete.setAttribute("id", "download-complete"), _downloadComplete.setAttribute("class", "flex flex-col items-center justify-center h-full w-full bg-white p-2 dark:bg-grey-90"), _appendChild(_downloadComplete, ["\n      ", (_textCenter = document.createElement("h1"), _textCenter.setAttribute("class", "text-center text-3xl font-bold my-2"), _appendChild(_textCenter, ["\n        ", state.translate("downloadFinish"), "\n      "]), _textCenter), "\n      ", (_my_ = document.createElementNS(_svgNamespace, "svg"), _my_.setAttribute("class", "my-8 h-48 text-primary"), _appendChild(_my_, ["\n        ", (_use = document.createElementNS(_svgNamespace, "use"), _use.setAttributeNS(_xlinkNamespace, "xlink:href", "" + String(assets.get("completed.svg")) + "#Page-1"), _use), "\n      "]), _my_), "\n      ", (_textGrey_ = document.createElement("p"), _textGrey_.setAttribute("class", "text-grey-80 leading-normal dark:text-grey-40"), _appendChild(_textGrey_, ["\n        ", state.translate("trySendDescription"), "\n      "]), _textGrey_), "\n      ", (_my_2 = document.createElement("p"), _my_2.setAttribute("class", "my-5"), _appendChild(_my_2, ["\n        ", (_btn = document.createElement("a"), _btn.setAttribute("href", "/"), _btn.setAttribute("role", "button"), _btn.onclick = forceNavigate, _btn.setAttribute("class", "btn rounded-lg flex items-center mt-4"), _appendChild(_btn, [state.translate(btnText)]), _btn), "\n      "]), _my_2), "\n    "]), _downloadComplete;
  };
  function forceNavigate(event) {
    event.preventDefault();
    const anchor2 = event.currentTarget;
    if (anchor2 && anchor2.href) {
      window.location.assign(anchor2.href);
    }
  }
  return downloadCompleted;
}
var utilsExports = requireUtils();
async function checkCrypto() {
  try {
    const key = await crypto.subtle.generateKey({
      name: "AES-GCM",
      length: 128
    }, true, ["encrypt", "decrypt"]);
    await crypto.subtle.exportKey("raw", key);
    await crypto.subtle.encrypt({
      name: "AES-GCM",
      iv: crypto.getRandomValues(new Uint8Array(12)),
      tagLength: 128
    }, key, new ArrayBuffer(8));
    await crypto.subtle.importKey("raw", crypto.getRandomValues(new Uint8Array(16)), "PBKDF2", false, ["deriveKey"]);
    await crypto.subtle.importKey("raw", crypto.getRandomValues(new Uint8Array(16)), "HKDF", false, ["deriveKey"]);
    await crypto.subtle.generateKey({
      name: "ECDH",
      namedCurve: "P-256"
    }, true, ["deriveBits"]);
    return true;
  } catch (err) {
    return false;
  }
}
function checkStreams() {
  try {
    new ReadableStream({
      pull() {
      }
    });
    return true;
  } catch (e) {
    return false;
  }
}
async function getCapabilities() {
  const browser2 = utilsExports.browserName();
  const isMobile = /mobi|android/i.test(navigator.userAgent);
  const serviceWorker = "serviceWorker" in navigator && browser2 !== "edge";
  let crypto2 = await checkCrypto();
  const streams = checkStreams();
  const share = isMobile && typeof navigator.share === "function" && utilsExports.locale().startsWith("en");
  const standalone = window.matchMedia("(display-mode: standalone)").matches || navigator.standalone;
  const mobileFirefox = browser2 === "firefox" && isMobile;
  return {
    crypto: crypto2,
    serviceWorker,
    streamUpload: streams,
    streamDownload: streams && serviceWorker && browser2 !== "safari" && !mobileFirefox,
    multifile: streams,
    share,
    standalone
  };
}
var download$1;
var hasRequiredDownload;
function requireDownload() {
  if (hasRequiredDownload) return download$1;
  hasRequiredDownload = 1;
  var _appendChild = appendChild$1;
  const archiveTile2 = requireArchiveTile();
  const modal2 = requireModal();
  const noStreams2 = requireNoStreams();
  const notFound2 = requireNotFound();
  const downloadPassword2 = requireDownloadPassword();
  const downloadCompleted2 = requireDownloadCompleted();
  const BIG_SIZE = 1024 * 1024 * 256;
  function createFileInfo(state) {
    return {
      id: state.params.id,
      secretKey: state.params.key,
      nonce: downloadMetadata.nonce,
      requiresPassword: downloadMetadata.pwd
    };
  }
  function downloading(state, emit) {
    var _text_3xl, _flex;
    return _flex = document.createElement("div"), _flex.setAttribute("class", "flex flex-col w-full h-full items-center md:justify-center md:-mt-8"), _appendChild(_flex, ["\n      ", (_text_3xl = document.createElement("h1"), _text_3xl.setAttribute("class", "text-3xl font-bold mb-4"), _appendChild(_text_3xl, ["\n        ", state.translate("downloadingTitle"), "\n      "]), _text_3xl), "\n      ", archiveTile2.downloading(state, emit), "\n    "]), _flex;
  }
  function preview(state, emit) {
    var _text_3xl2, _wFull, _flex2;
    if (!state.capabilities.streamDownload && state.fileInfo.size > BIG_SIZE) {
      return noStreams2(state, emit);
    }
    return _flex2 = document.createElement("div"), _flex2.setAttribute("class", "flex flex-col w-full max-w-md h-full mx-auto items-center justify-center"), _appendChild(_flex2, ["\n      ", (_text_3xl2 = document.createElement("h1"), _text_3xl2.setAttribute("class", "text-3xl font-bold mb-4"), _appendChild(_text_3xl2, ["\n        ", state.translate("downloadTitle"), "\n      "]), _text_3xl2), "\n      ", (_wFull = document.createElement("p"), _wFull.setAttribute("class", "w-full text-grey-80 text-center leading-normal dark:text-grey-40"), _appendChild(_wFull, ["\n        ", state.translate("downloadDescription"), "\n      "]), _wFull), "\n      ", archiveTile2.preview(state, emit), "\n    "]), _flex2;
  }
  download$1 = function(state, emit) {
    var _relative, _main;
    let content = "";
    if (!state.fileInfo) {
      state.fileInfo = createFileInfo(state);
      if (downloadMetadata.status === 404) {
        return notFound2(state);
      }
      if (!state.fileInfo.nonce) {
        return location.reload();
      }
    }
    if (!state.transfer && !state.fileInfo.requiresPassword) {
      emit("getMetadata");
    }
    if (state.transfer) {
      switch (state.transfer.state) {
        case "downloading":
        case "decrypting":
          content = downloading(state, emit);
          break;
        case "complete":
          content = downloadCompleted2(state);
          break;
        default:
          content = preview(state, emit);
      }
    } else if (state.fileInfo.requiresPassword && !state.fileInfo.password) {
      content = downloadPassword2(state, emit);
    }
    return _main = document.createElement("div"), _main.setAttribute("class", "main"), _appendChild(_main, ["\n      ", state.modal && modal2(state, emit), "\n      ", (_relative = document.createElement("section"), _relative.setAttribute("class", "relative h-full w-full p-6 md:p-8 md:rounded-xl md:shadow-big"), _appendChild(_relative, ["\n        ", content, "\n      "]), _relative), "\n    "]), _main;
  };
  return download$1;
}
var body;
var hasRequiredBody;
function requireBody() {
  if (hasRequiredBody) return body;
  hasRequiredBody = 1;
  var _appendChild = appendChild$1;
  body = function body2(main) {
    return function(state, emit) {
      var _flex;
      const b = (_flex = document.createElement("main"), _flex.setAttribute("class", "flex flex-col items-center font-sans md:h-screen md:bg-grey-10 dark:bg-black w-full"), _appendChild(_flex, ["\n        ", main(state, emit), "\n      "]), _flex);
      if (state.layout) {
        return state.layout(state, b);
      }
      return b;
    };
  };
  return body;
}
var intro;
var hasRequiredIntro;
function requireIntro() {
  if (hasRequiredIntro) return intro;
  hasRequiredIntro = 1;
  var _appendChild = appendChild$1;
  const raw$12 = raw2;
  requireAssets();
  intro = function intro2(state) {
    var _wFull, _text_3xl, _maxWSm, _mt_, _flex;
    const notice = state.WEB_UI.MAIN_NOTICE_HTML ? (_wFull = document.createElement("p"), _wFull.setAttribute("class", "w-full mt-2 p-2 border-default dark:border-grey-70 rounded-default text-orange-60 bg-yellow-40 text-center leading-normal"), _appendChild(_wFull, ["\n          ", raw$12(state.WEB_UI.MAIN_NOTICE_HTML), "\n        "]), _wFull) : "";
    return _flex = document.createElement("send-intro"), _flex.setAttribute("class", "flex flex-col items-center justify-center bg-white px-6 md:py-0 py-6 mb-0 h-full w-full dark:bg-grey-90"), _appendChild(_flex, ["\n      ", notice, "\n      ", (_mt_ = document.createElement("div"), _mt_.setAttribute("class", "mt-12 flex flex-col h-full"), _appendChild(_mt_, ["\n        ", (_text_3xl = document.createElement("h1"), _text_3xl.setAttribute("class", "text-3xl font-bold md:pb-2"), _appendChild(_text_3xl, ["\n          ", state.translate("introTitle"), "\n        "]), _text_3xl), "\n        ", (_maxWSm = document.createElement("p"), _maxWSm.setAttribute("class", "max-w-sm leading-loose mt-6 md:mt-2 md:pr-14"), _appendChild(_maxWSm, ["\n          ", state.translate("introDescription"), "\n        "]), _maxWSm), "\n      "]), _mt_), "\n    "]), _flex;
  };
  return intro;
}
var home;
var hasRequiredHome;
function requireHome() {
  if (hasRequiredHome) return home;
  hasRequiredHome = 1;
  var _appendChild = appendChild$1;
  const raw$12 = raw2;
  const {
    list
  } = requireUtils();
  const archiveTile2 = requireArchiveTile();
  const modal2 = requireModal();
  const intro2 = requireIntro();
  requireAssets();
  home = function(state, emit) {
    var _px_, _mt_, _hFull, _main;
    const archives = state.storage.files.filter((archive) => !archive.expired).map((archive) => archiveTile2(state, emit, archive));
    let left = "";
    if (state.uploading) {
      left = archiveTile2.uploading(state, emit);
    } else if (state.archive.numFiles > 0) {
      left = archiveTile2.wip(state, emit);
    } else {
      left = archiveTile2.empty(state, emit);
    }
    if (archives.length > 0 && state.WEB_UI.UPLOADS_LIST_NOTICE_HTML) {
      var _wFull;
      archives.push((_wFull = document.createElement("p"), _wFull.setAttribute("class", "w-full p-2 border-default dark:border-grey-70 rounded-default text-orange-60 bg-yellow-40 text-center leading-normal"), _appendChild(_wFull, ["\n        ", raw$12(state.WEB_UI.UPLOADS_LIST_NOTICE_HTML), "\n      "]), _wFull));
    }
    archives.reverse();
    const right = archives.length === 0 ? intro2(state) : list(archives, "p-2 h-full overflow-y-auto w-full", "mb-4 w-full");
    return _main = document.createElement("div"), _main.setAttribute("class", "main"), _appendChild(_main, ["\n      ", state.modal && modal2(state, emit), "\n      ", (_hFull = document.createElement("section"), _hFull.setAttribute("class", "h-full w-full p-6 md:p-8 overflow-hidden md:flex md:flex-row md:rounded-xl md:shadow-big"), _appendChild(_hFull, ["\n        ", (_px_ = document.createElement("div"), _px_.setAttribute("class", "px-2 w-full md:px-0 md:mr-8 md:w-1/2"), _appendChild(_px_, [left]), _px_), "\n        ", (_mt_ = document.createElement("div"), _mt_.setAttribute("class", "mt-6 w-full md:w-1/2 md:-m-2"), _appendChild(_mt_, [right]), _mt_), "\n      "]), _hFull), "\n    "]), _main;
  };
  return home;
}
var unsupported;
var hasRequiredUnsupported;
function requireUnsupported() {
  if (hasRequiredUnsupported) return unsupported;
  hasRequiredUnsupported = 1;
  var _appendChild = appendChild$1;
  const modal2 = requireModal();
  unsupported = function(state, emit) {
    var _text_3xl, _mt_, _btn, _flex, _main;
    let strings = {};
    let why = "";
    let url = "";
    if (state.params.reason !== "outdated") {
      var _textPrimary;
      strings = unsupportedStrings(state);
      why = (_textPrimary = document.createElement("a"), _textPrimary.setAttribute("href", "https://github.com/timvisee/send/blob/master/docs/faq.md#why-is-my-browser-not-supported"), _textPrimary.setAttribute("class", "text-primary"), _appendChild(_textPrimary, ["\n        ", state.translate("notSupportedLink"), "\n      "]), _textPrimary);
      url = "https://www.mozilla.org/firefox/new/?utm_campaign=send-acquisition&utm_medium=referral&utm_source=send.firefox.com";
    } else {
      strings = outdatedStrings(state);
      url = "https://support.mozilla.org/kb/update-firefox-latest-version";
    }
    return _main = document.createElement("div"), _main.setAttribute("class", "main"), _appendChild(_main, ["\n      ", state.modal && modal2(state, emit), "\n      ", (_flex = document.createElement("section"), _flex.setAttribute("class", "flex flex-col items-center justify-center text-center bg-white m-6 px-6 py-8 border-default border-grey-30 md:border-none md:px-12 md:py-16 shadow-default w-full md:h-full dark:bg-grey-90"), _appendChild(_flex, ["\n        ", (_text_3xl = document.createElement("h1"), _text_3xl.setAttribute("class", "text-3xl font-bold"), _appendChild(_text_3xl, [strings.header]), _text_3xl), "\n        ", (_mt_ = document.createElement("p"), _mt_.setAttribute("class", "mt-4 mb-8 max-w-md leading-normal"), _appendChild(_mt_, [strings.description]), _mt_), "\n        ", why, "\n        ", (_btn = document.createElement("a"), _btn.setAttribute("href", "" + String(url)), _btn.setAttribute("class", "btn rounded-lg mt-8 px-8"), _appendChild(_btn, ["\n          ", strings.button, "\n        "]), _btn), "\n      "]), _flex), "\n    "]), _main;
  };
  function outdatedStrings(state) {
    return {
      header: state.translate("notSupportedHeader"),
      description: state.translate("notSupportedOutdatedDetail"),
      button: state.translate("updateFirefox")
    };
  }
  function unsupportedStrings(state) {
    return {
      header: state.translate("notSupportedHeader"),
      description: state.translate("notSupportedDescription"),
      button: state.translate("downloadFirefox")
    };
  }
  return unsupported;
}
var error2;
var hasRequiredError;
function requireError() {
  if (hasRequiredError) return error2;
  hasRequiredError = 1;
  var _appendChild = appendChild$1, _svgNamespace = "http://www.w3.org/2000/svg", _xlinkNamespace = "http://www.w3.org/1999/xlink";
  const assets = requireAssets();
  const modal2 = requireModal();
  error2 = function(state, emit) {
    var _textCenter, _use, _textPrimary, _p, _btn, _my_, _flex, _main;
    const btnText = "sendYourFilesLink";
    return _main = document.createElement("div"), _main.setAttribute("class", "main"), _appendChild(_main, ["\n      ", state.modal && modal2(state, emit), "\n      ", (_flex = document.createElement("section"), _flex.setAttribute("class", "flex flex-col items-center justify-center h-full w-full p-6 md:p-8 overflow-hidden md:rounded-xl md:shadow-big"), _appendChild(_flex, ["\n        ", (_textCenter = document.createElement("h1"), _textCenter.setAttribute("class", "text-center text-3xl font-bold my-2"), _appendChild(_textCenter, ["\n          ", state.translate("errorPageHeader"), "\n        "]), _textCenter), "\n        ", (_textPrimary = document.createElementNS(_svgNamespace, "svg"), _textPrimary.setAttribute("class", "text-primary my-12 h-48"), _appendChild(_textPrimary, ["\n          ", (_use = document.createElementNS(_svgNamespace, "use"), _use.setAttributeNS(_xlinkNamespace, "xlink:href", "" + String(assets.get("error.svg")) + "#svg114"), _use), "\n        "]), _textPrimary), "\n        ", (_p = document.createElement("p"), _p.setAttribute("class", "max-w-md text-center text-grey-80 leading-normal dark:text-grey-40 " + String(state.user.loggedIn ? "hidden" : "")), _appendChild(_p, ["\n          ", state.translate("trySendDescription"), "\n        "]), _p), "\n        ", (_my_ = document.createElement("p"), _my_.setAttribute("class", "my-5"), _appendChild(_my_, ["\n          ", (_btn = document.createElement("a"), _btn.setAttribute("href", "/"), _btn.setAttribute("role", "button"), _btn.setAttribute("class", "btn rounded-lg flex items-center"), _appendChild(_btn, [state.translate(btnText)]), _btn), "\n        "]), _my_), "\n      "]), _flex), "\n    "]), _main;
  };
  return error2;
}
var routes$1;
var hasRequiredRoutes;
function requireRoutes() {
  if (hasRequiredRoutes) return routes$1;
  hasRequiredRoutes = 1;
  const choo$12 = choo;
  const download2 = requireDownload();
  const body2 = requireBody();
  routes$1 = function(app = choo$12({
    hash: true
  })) {
    app.route("/", body2(requireHome()));
    app.route("/download/:id", body2(download2));
    app.route("/download/:id/:key", body2(download2));
    app.route("/unsupported/:reason", body2(requireUnsupported()));
    app.route("/error", body2(requireError()));
    app.route("*", body2(requireNotFound()));
    return app;
  };
  return routes$1;
}
var routesExports = requireRoutes();
const routes = /* @__PURE__ */ getDefaultExportFromCjs(routesExports);
var utilsWorker;
var hasRequiredUtilsWorker;
function requireUtilsWorker() {
  if (hasRequiredUtilsWorker) return utilsWorker;
  hasRequiredUtilsWorker = 1;
  const b64 = base64Js;
  function arrayToB64(array) {
    return b64.fromByteArray(array).replace(/\+/g, "-").replace(/\//g, "_").replace(/=/g, "");
  }
  function b64ToArray(str) {
    return b64.toByteArray(str + "===".slice((str.length + 3) % 4));
  }
  function delay(delay2 = 100) {
    return new Promise((resolve2) => setTimeout(resolve2, delay2));
  }
  async function streamToArrayBuffer(stream, size3) {
    const reader = stream.getReader();
    let state = await reader.read();
    if (size3) {
      const result2 = new Uint8Array(size3);
      let offset2 = 0;
      while (!state.done) {
        result2.set(state.value, offset2);
        offset2 += state.value.length;
        state = await reader.read();
      }
      return result2.buffer;
    }
    const parts = [];
    let len = 0;
    while (!state.done) {
      parts.push(state.value);
      len += state.value.length;
      state = await reader.read();
    }
    let offset = 0;
    const result = new Uint8Array(len);
    for (const part of parts) {
      result.set(part, offset);
      offset += part.length;
    }
    return result.buffer;
  }
  utilsWorker = {
    arrayToB64,
    b64ToArray,
    delay,
    streamToArrayBuffer
  };
  return utilsWorker;
}
var utilsWorkerExports = requireUtilsWorker();
function transformStream(readable, transformer = {}, oncancel) {
  const reader = readable.getReader();
  const wrappedTransformer = transformer || {};
  return new ReadableStream({
    async start(controller2) {
      if (wrappedTransformer.start) {
        await wrappedTransformer.start(controller2);
      }
    },
    async pull(controller2) {
      while (true) {
        const {
          value,
          done
        } = await reader.read();
        if (done) {
          if (wrappedTransformer.flush) {
            await wrappedTransformer.flush(controller2);
          }
          reader.releaseLock();
          controller2.close();
          return;
        }
        if (!wrappedTransformer.transform) {
          controller2.enqueue(value);
          return;
        }
        let enqueued = false;
        const wrappedController = {
          enqueue(chunk) {
            enqueued = true;
            controller2.enqueue(chunk);
          }
        };
        await wrappedTransformer.transform(value, wrappedController);
        if (enqueued) {
          return;
        }
      }
    },
    cancel(reason) {
      reader.cancel(reason);
      if (wrappedTransformer.cancel) {
        wrappedTransformer.cancel(reason);
      }
    }
  });
}
class BlobStreamController {
  constructor(blob, size3) {
    this.blob = blob;
    this.index = 0;
    this.chunkSize = size3 || 1024 * 64;
  }
  pull(controller2) {
    return new Promise((resolve2, reject2) => {
      const bytesLeft = this.blob.size - this.index;
      if (bytesLeft <= 0) {
        controller2.close();
        return resolve2();
      }
      const size3 = Math.min(this.chunkSize, bytesLeft);
      const slice5 = this.blob.slice(this.index, this.index + size3);
      const reader = new FileReader();
      reader.onload = () => {
        controller2.enqueue(new Uint8Array(reader.result));
        resolve2();
      };
      reader.onerror = reject2;
      reader.readAsArrayBuffer(slice5);
      this.index += size3;
    });
  }
}
function blobStream(blob, size3) {
  return new ReadableStream(new BlobStreamController(blob, size3));
}
class ConcatStreamController {
  constructor(streams) {
    this.streams = streams;
    this.index = 0;
    this.reader = null;
    this.nextReader();
  }
  nextReader() {
    const next11 = this.streams[this.index++];
    this.reader = next11 && next11.getReader();
  }
  async pull(controller2) {
    if (!this.reader) {
      return controller2.close();
    }
    const data2 = await this.reader.read();
    if (data2.done) {
      this.nextReader();
      return this.pull(controller2);
    }
    controller2.enqueue(data2.value);
  }
}
function concatStream(streams) {
  return new ReadableStream(new ConcatStreamController(streams));
}
if (typeof window !== "undefined") {
  window.Buffer = buffer$2.Buffer;
}
const NONCE_LENGTH = 12;
const TAG_LENGTH = 16;
const KEY_LENGTH = 16;
const MODE_ENCRYPT = "encrypt";
const MODE_DECRYPT = "decrypt";
const ECE_RECORD_SIZE = 1024 * 64;
const encoder$2 = new TextEncoder();
function generateSalt(len) {
  const randSalt = new Uint8Array(len);
  crypto.getRandomValues(randSalt);
  return randSalt.buffer;
}
class ECETransformer {
  constructor(mode, ikm, rs, salt) {
    this.mode = mode;
    this.prevChunk;
    this.seq = 0;
    this.firstchunk = true;
    this.rs = rs;
    this.ikm = ikm.buffer;
    this.salt = salt;
  }
  async generateKey() {
    const inputKey = await crypto.subtle.importKey("raw", this.ikm, "HKDF", false, ["deriveKey"]);
    return crypto.subtle.deriveKey(
      {
        name: "HKDF",
        salt: this.salt,
        info: encoder$2.encode("Content-Encoding: aes128gcm\0"),
        hash: "SHA-256"
      },
      inputKey,
      {
        name: "AES-GCM",
        length: 128
      },
      true,
      // Edge polyfill requires key to be extractable to encrypt :/
      ["encrypt", "decrypt"]
    );
  }
  async generateNonceBase() {
    const inputKey = await crypto.subtle.importKey("raw", this.ikm, "HKDF", false, ["deriveKey"]);
    const base2 = await crypto.subtle.exportKey("raw", await crypto.subtle.deriveKey({
      name: "HKDF",
      salt: this.salt,
      info: encoder$2.encode("Content-Encoding: nonce\0"),
      hash: "SHA-256"
    }, inputKey, {
      name: "AES-GCM",
      length: 128
    }, true, ["encrypt", "decrypt"]));
    return buffer$2.Buffer.from(base2.slice(0, NONCE_LENGTH));
  }
  generateNonce(seq) {
    if (seq > 4294967295) {
      throw new Error("record sequence number exceeds limit");
    }
    const nonce = buffer$2.Buffer.from(this.nonceBase);
    const m = nonce.readUIntBE(nonce.length - 4, 4);
    const xor = (m ^ seq) >>> 0;
    nonce.writeUIntBE(xor, nonce.length - 4, 4);
    return nonce;
  }
  pad(data2, isLast) {
    const len = data2.length;
    if (len + TAG_LENGTH >= this.rs) {
      throw new Error("data too large for record size");
    }
    if (isLast) {
      const padding = buffer$2.Buffer.alloc(1);
      padding.writeUInt8(2, 0);
      return buffer$2.Buffer.concat([data2, padding]);
    } else {
      const padding = buffer$2.Buffer.alloc(this.rs - len - TAG_LENGTH);
      padding.fill(0);
      padding.writeUInt8(1, 0);
      return buffer$2.Buffer.concat([data2, padding]);
    }
  }
  unpad(data2, isLast) {
    for (let i = data2.length - 1; i >= 0; i--) {
      if (data2[i]) {
        if (isLast) {
          if (data2[i] !== 2) {
            throw new Error("delimiter of final record is not 2");
          }
        } else {
          if (data2[i] !== 1) {
            throw new Error("delimiter of not final record is not 1");
          }
        }
        return data2.slice(0, i);
      }
    }
    throw new Error("no delimiter found");
  }
  createHeader() {
    const nums = buffer$2.Buffer.alloc(5);
    nums.writeUIntBE(this.rs, 0, 4);
    nums.writeUIntBE(0, 4, 1);
    return buffer$2.Buffer.concat([buffer$2.Buffer.from(this.salt), nums]);
  }
  readHeader(buffer2) {
    if (buffer2.length < 21) {
      throw new Error("chunk too small for reading header");
    }
    const header = {};
    header.salt = buffer2.buffer.slice(0, KEY_LENGTH);
    header.rs = buffer2.readUIntBE(KEY_LENGTH, 4);
    const idlen = buffer2.readUInt8(KEY_LENGTH + 4);
    header.length = idlen + KEY_LENGTH + 5;
    return header;
  }
  async encryptRecord(buffer2, seq, isLast) {
    const nonce = this.generateNonce(seq);
    const encrypted = await crypto.subtle.encrypt({
      name: "AES-GCM",
      iv: nonce
    }, this.key, this.pad(buffer2, isLast));
    return buffer$2.Buffer.from(encrypted);
  }
  async decryptRecord(buffer2, seq, isLast) {
    const nonce = this.generateNonce(seq);
    const data2 = await crypto.subtle.decrypt({
      name: "AES-GCM",
      iv: nonce,
      tagLength: 128
    }, this.key, buffer2);
    return this.unpad(buffer$2.Buffer.from(data2), isLast);
  }
  async start(controller2) {
    if (this.mode === MODE_ENCRYPT) {
      this.key = await this.generateKey();
      this.nonceBase = await this.generateNonceBase();
      controller2.enqueue(this.createHeader());
    } else if (this.mode !== MODE_DECRYPT) {
      throw new Error("mode must be either encrypt or decrypt");
    }
  }
  async transformPrevChunk(isLast, controller2) {
    if (this.mode === MODE_ENCRYPT) {
      controller2.enqueue(await this.encryptRecord(this.prevChunk, this.seq, isLast));
      this.seq++;
    } else {
      if (this.seq === 0) {
        const header = this.readHeader(this.prevChunk);
        this.salt = header.salt;
        this.rs = header.rs;
        this.key = await this.generateKey();
        this.nonceBase = await this.generateNonceBase();
      } else {
        controller2.enqueue(await this.decryptRecord(this.prevChunk, this.seq - 1, isLast));
      }
      this.seq++;
    }
  }
  async transform(chunk, controller2) {
    if (!this.firstchunk) {
      await this.transformPrevChunk(false, controller2);
    }
    this.firstchunk = false;
    this.prevChunk = buffer$2.Buffer.from(chunk.buffer);
  }
  async flush(controller2) {
    if (this.prevChunk) {
      await this.transformPrevChunk(true, controller2);
    }
  }
}
class StreamSlicer {
  constructor(rs, mode) {
    this.mode = mode;
    this.rs = rs;
    this.chunkSize = mode === MODE_ENCRYPT ? rs - 17 : 21;
    this.partialChunk = new Uint8Array(this.chunkSize);
    this.offset = 0;
  }
  send(buf, controller2) {
    controller2.enqueue(buf);
    if (this.chunkSize === 21 && this.mode === MODE_DECRYPT) {
      this.chunkSize = this.rs;
    }
    this.partialChunk = new Uint8Array(this.chunkSize);
    this.offset = 0;
  }
  //reslice input into record sized chunks
  transform(chunk, controller2) {
    let i = 0;
    if (this.offset > 0) {
      const len = Math.min(chunk.byteLength, this.chunkSize - this.offset);
      this.partialChunk.set(chunk.slice(0, len), this.offset);
      this.offset += len;
      i += len;
      if (this.offset === this.chunkSize) {
        this.send(this.partialChunk, controller2);
      }
    }
    while (i < chunk.byteLength) {
      const remainingBytes = chunk.byteLength - i;
      if (remainingBytes >= this.chunkSize) {
        const record = chunk.slice(i, i + this.chunkSize);
        i += this.chunkSize;
        this.send(record, controller2);
      } else {
        const end = chunk.slice(i, i + remainingBytes);
        i += end.byteLength;
        this.partialChunk.set(end);
        this.offset = end.byteLength;
      }
    }
  }
  flush(controller2) {
    if (this.offset > 0) {
      controller2.enqueue(this.partialChunk.slice(0, this.offset));
    }
  }
}
function encryptStream(input, key, rs = ECE_RECORD_SIZE, salt = generateSalt(KEY_LENGTH)) {
  const mode = "encrypt";
  const inputStream = transformStream(input, new StreamSlicer(rs, mode));
  return transformStream(inputStream, new ECETransformer(mode, key, rs, salt));
}
function decryptStream(input, key, rs = ECE_RECORD_SIZE) {
  const mode = "decrypt";
  const inputStream = transformStream(input, new StreamSlicer(rs, mode));
  return transformStream(inputStream, new ECETransformer(mode, key, rs));
}
const encoder$1 = new TextEncoder();
const decoder = new TextDecoder();
class Keychain {
  constructor(secretKeyB64, nonce) {
    this._nonce = nonce || "yRCdyQ1EMSA3mo4rqSkuNQ==";
    if (secretKeyB64) {
      this.rawSecret = utilsWorkerExports.b64ToArray(secretKeyB64);
    } else {
      this.rawSecret = crypto.getRandomValues(new Uint8Array(16));
    }
    this.secretKeyPromise = crypto.subtle.importKey("raw", this.rawSecret, "HKDF", false, ["deriveKey"]);
    this.metaKeyPromise = this.secretKeyPromise.then(function(secretKey) {
      return crypto.subtle.deriveKey({
        name: "HKDF",
        salt: new Uint8Array(),
        info: encoder$1.encode("metadata"),
        hash: "SHA-256"
      }, secretKey, {
        name: "AES-GCM",
        length: 128
      }, false, ["encrypt", "decrypt"]);
    });
    this.authKeyPromise = this.secretKeyPromise.then(function(secretKey) {
      return crypto.subtle.deriveKey({
        name: "HKDF",
        salt: new Uint8Array(),
        info: encoder$1.encode("authentication"),
        hash: "SHA-256"
      }, secretKey, {
        name: "HMAC",
        hash: {
          name: "SHA-256"
        }
      }, true, ["sign"]);
    });
  }
  get nonce() {
    return this._nonce;
  }
  set nonce(n) {
    if (n && n !== this._nonce) {
      this._nonce = n;
    }
  }
  setPassword(password, shareUrl) {
    this.authKeyPromise = crypto.subtle.importKey("raw", encoder$1.encode(password), {
      name: "PBKDF2"
    }, false, ["deriveKey"]).then((passwordKey) => crypto.subtle.deriveKey({
      name: "PBKDF2",
      salt: encoder$1.encode(shareUrl),
      iterations: 100,
      hash: "SHA-256"
    }, passwordKey, {
      name: "HMAC",
      hash: "SHA-256"
    }, true, ["sign"]));
  }
  setAuthKey(authKeyB64) {
    this.authKeyPromise = crypto.subtle.importKey("raw", utilsWorkerExports.b64ToArray(authKeyB64), {
      name: "HMAC",
      hash: "SHA-256"
    }, true, ["sign"]);
  }
  async authKeyB64() {
    const authKey = await this.authKeyPromise;
    const rawAuth = await crypto.subtle.exportKey("raw", authKey);
    return utilsWorkerExports.arrayToB64(new Uint8Array(rawAuth));
  }
  async authHeader() {
    const authKey = await this.authKeyPromise;
    const sig = await crypto.subtle.sign({
      name: "HMAC"
    }, authKey, utilsWorkerExports.b64ToArray(this.nonce));
    return `send-v1 ${utilsWorkerExports.arrayToB64(new Uint8Array(sig))}`;
  }
  async encryptMetadata(metadata3) {
    const metaKey = await this.metaKeyPromise;
    const ciphertext = await crypto.subtle.encrypt({
      name: "AES-GCM",
      iv: new Uint8Array(12),
      tagLength: 128
    }, metaKey, encoder$1.encode(JSON.stringify({
      name: metadata3.name,
      size: metadata3.size,
      type: metadata3.type || "application/octet-stream",
      manifest: metadata3.manifest || {}
    })));
    return ciphertext;
  }
  encryptStream(plainStream) {
    return encryptStream(plainStream, this.rawSecret);
  }
  decryptStream(cryptotext) {
    return decryptStream(cryptotext, this.rawSecret);
  }
  async decryptMetadata(ciphertext) {
    const metaKey = await this.metaKeyPromise;
    const plaintext = await crypto.subtle.decrypt({
      name: "AES-GCM",
      iv: new Uint8Array(12),
      tagLength: 128
    }, metaKey, ciphertext);
    return JSON.parse(decoder.decode(plaintext));
  }
}
let fileProtocolWssUrl = null;
try {
  fileProtocolWssUrl = localStorage.getItem("wssURL");
} catch (e) {
}
if (!fileProtocolWssUrl) {
  fileProtocolWssUrl = "wss://send.firefox.com/api/ws";
}
class ConnectionError extends Error {
  constructor(cancelled, duration, size3) {
    super(cancelled ? "0" : "connection closed");
    this.cancelled = cancelled;
    this.duration = duration;
    this.size = size3;
  }
}
let apiUrlPrefix = "";
function getApiUrl(path2) {
  return apiUrlPrefix + path2;
}
function post(obj) {
  const h = {
    "Content-Type": "application/json"
  };
  return {
    method: "POST",
    headers: new Headers(h),
    body: JSON.stringify(obj)
  };
}
function parseNonce(header) {
  header = header || "";
  return header.split(" ")[1];
}
async function fetchWithAuth(url, params2, keychain) {
  const result = {};
  params2 = params2 || {};
  const h = await keychain.authHeader();
  params2.headers = new Headers({
    Authorization: h,
    "Content-Type": "application/json"
  });
  const response = await fetch(url, params2);
  result.response = response;
  result.ok = response.ok;
  const nonce = parseNonce(response.headers.get("WWW-Authenticate"));
  result.shouldRetry = response.status === 401 && nonce !== keychain.nonce;
  keychain.nonce = nonce;
  return result;
}
async function fetchWithAuthAndRetry(url, params2, keychain) {
  const result = await fetchWithAuth(url, params2, keychain);
  if (result.shouldRetry) {
    return fetchWithAuth(url, params2, keychain);
  }
  return result;
}
async function del(id2, owner_token) {
  const response = await fetch(getApiUrl(`/api/delete/${id2}`), post({
    owner_token
  }));
  return response.ok;
}
async function setParams(id2, owner_token, params2) {
  const response = await fetch(getApiUrl(`/api/params/${id2}`), post({
    owner_token,
    dlimit: params2.dlimit
  }));
  return response.ok;
}
async function fileInfo(id2, owner_token) {
  const response = await fetch(getApiUrl(`/api/info/${id2}`), post({
    owner_token
  }));
  if (response.ok) {
    const obj = await response.json();
    return obj;
  }
  throw new Error(response.status);
}
async function metadata2(id2, keychain) {
  const result = await fetchWithAuthAndRetry(getApiUrl(`/api/metadata/${id2}`), {
    method: "GET"
  }, keychain);
  if (result.ok) {
    const data2 = await result.response.json();
    const meta2 = await keychain.decryptMetadata(utilsWorkerExports.b64ToArray(data2.metadata));
    return {
      size: meta2.size,
      ttl: data2.ttl,
      iv: meta2.iv,
      name: meta2.name,
      type: meta2.type,
      manifest: meta2.manifest
    };
  }
  throw new Error(result.response.status);
}
async function setPassword(id2, owner_token, keychain) {
  const auth = await keychain.authKeyB64();
  const response = await fetch(getApiUrl(`/api/password/${id2}`), post({
    owner_token,
    auth
  }));
  return response.ok;
}
function asyncInitWebSocket(server) {
  return new Promise((resolve2, reject2) => {
    try {
      const ws = new WebSocket(server);
      ws.addEventListener("open", () => resolve2(ws), {
        once: true
      });
    } catch (e) {
      reject2(new ConnectionError(false));
    }
  });
}
function listenForResponse(ws, canceller) {
  return new Promise((resolve2, reject2) => {
    function handleClose(event) {
      ws.removeEventListener("message", handleMessage);
      reject2(new ConnectionError(canceller.cancelled));
    }
    function handleMessage(msg) {
      ws.removeEventListener("close", handleClose);
      try {
        const response = JSON.parse(msg.data);
        if (response.error) {
          throw new Error(response.error);
        } else {
          resolve2(response);
        }
      } catch (e) {
        reject2(e);
      }
    }
    ws.addEventListener("message", handleMessage, {
      once: true
    });
    ws.addEventListener("close", handleClose, {
      once: true
    });
  });
}
async function upload(stream, metadata3, verifierB64, timeLimit, dlimit, onprogress, canceller) {
  let size3 = 0;
  const start2 = Date.now();
  const host = window.location.hostname;
  const port2 = window.location.port;
  const protocol2 = window.location.protocol === "https:" ? "wss:" : "ws:";
  const endpoint = window.location.protocol === "file:" ? fileProtocolWssUrl : `${protocol2}//${host}${port2 ? ":" : ""}${port2}/api/ws`;
  const ws = await asyncInitWebSocket(endpoint);
  try {
    const metadataHeader = utilsWorkerExports.arrayToB64(new Uint8Array(metadata3));
    const fileMeta = {
      fileMetadata: metadataHeader,
      authorization: `send-v1 ${verifierB64}`,
      timeLimit,
      dlimit
    };
    const uploadInfoResponse = listenForResponse(ws, canceller);
    ws.send(JSON.stringify(fileMeta));
    const uploadInfo = await uploadInfoResponse;
    const completedResponse = listenForResponse(ws, canceller);
    const reader = stream.getReader();
    let state = await reader.read();
    while (!state.done) {
      if (canceller.cancelled) {
        ws.close();
      }
      if (ws.readyState !== WebSocket.OPEN) {
        break;
      }
      const buf = state.value;
      ws.send(buf);
      onprogress(size3);
      size3 += buf.length;
      state = await reader.read();
      while (ws.bufferedAmount > ECE_RECORD_SIZE * 2 && ws.readyState === WebSocket.OPEN && !canceller.cancelled) {
        await utilsWorkerExports.delay();
      }
    }
    if (ws.readyState === WebSocket.OPEN) {
      ws.send(new Uint8Array([0]));
    }
    await completedResponse;
    uploadInfo.duration = Date.now() - start2;
    return uploadInfo;
  } catch (e) {
    e.size = size3;
    e.duration = Date.now() - start2;
    throw e;
  } finally {
    if (![WebSocket.CLOSED, WebSocket.CLOSING].includes(ws.readyState)) {
      ws.close();
    }
  }
}
function uploadWs(encrypted, metadata3, verifierB64, timeLimit, dlimit, onprogress) {
  const canceller = {
    cancelled: false
  };
  return {
    cancel: function() {
      canceller.cancelled = true;
    },
    result: upload(encrypted, metadata3, verifierB64, timeLimit, dlimit, onprogress, canceller)
  };
}
async function download(id2, keychain, onprogress, canceller) {
  const auth = await keychain.authHeader();
  const xhr = new XMLHttpRequest();
  canceller.oncancel = function() {
    xhr.abort();
  };
  return new Promise(function(resolve2, reject2) {
    xhr.addEventListener("loadend", function() {
      canceller.oncancel = function() {
      };
      const authHeader = xhr.getResponseHeader("WWW-Authenticate");
      if (authHeader) {
        keychain.nonce = parseNonce(authHeader);
      }
      if (xhr.status !== 200) {
        return reject2(new Error(xhr.status));
      }
      const blob = new Blob([xhr.response]);
      resolve2(blob);
    });
    xhr.addEventListener("progress", function(event) {
      if (event.target.status === 200) {
        onprogress(event.loaded);
      }
    });
    xhr.open("get", getApiUrl(`/api/download/blob/${id2}`));
    xhr.setRequestHeader("Authorization", auth);
    xhr.responseType = "blob";
    xhr.send();
    onprogress(0);
  });
}
async function tryDownload(id2, keychain, onprogress, canceller, tries = 2) {
  try {
    const result = await download(id2, keychain, onprogress, canceller);
    return result;
  } catch (e) {
    if (e.message === "401" && --tries > 0) {
      return tryDownload(id2, keychain, onprogress, canceller, tries);
    }
    throw e;
  }
}
function downloadFile(id2, keychain, onprogress) {
  const canceller = {
    oncancel: function() {
    }
    // download() sets this
  };
  function cancel() {
    canceller.oncancel();
  }
  return {
    cancel,
    result: tryDownload(id2, keychain, onprogress, canceller)
  };
}
var buffer = {};
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
(function(exports) {
  var base64 = base64Js;
  var ieee7542 = ieee754$1;
  var customInspectSymbol = typeof Symbol === "function" && typeof Symbol["for"] === "function" ? Symbol["for"]("nodejs.util.inspect.custom") : null;
  exports.Buffer = Buffer;
  exports.SlowBuffer = SlowBuffer;
  exports.INSPECT_MAX_BYTES = 50;
  var K_MAX_LENGTH = 2147483647;
  exports.kMaxLength = K_MAX_LENGTH;
  Buffer.TYPED_ARRAY_SUPPORT = typedArraySupport();
  if (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== "undefined" && typeof console.error === "function") {
    console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support.");
  }
  function typedArraySupport() {
    try {
      var arr = new Uint8Array(1);
      var proto = {
        foo: function() {
          return 42;
        }
      };
      Object.setPrototypeOf(proto, Uint8Array.prototype);
      Object.setPrototypeOf(arr, proto);
      return arr.foo() === 42;
    } catch (e) {
      return false;
    }
  }
  Object.defineProperty(Buffer.prototype, "parent", {
    enumerable: true,
    get: function() {
      if (!Buffer.isBuffer(this)) return void 0;
      return this.buffer;
    }
  });
  Object.defineProperty(Buffer.prototype, "offset", {
    enumerable: true,
    get: function() {
      if (!Buffer.isBuffer(this)) return void 0;
      return this.byteOffset;
    }
  });
  function createBuffer2(length) {
    if (length > K_MAX_LENGTH) {
      throw new RangeError('The value "' + length + '" is invalid for option "size"');
    }
    var buf = new Uint8Array(length);
    Object.setPrototypeOf(buf, Buffer.prototype);
    return buf;
  }
  function Buffer(arg, encodingOrOffset, length) {
    if (typeof arg === "number") {
      if (typeof encodingOrOffset === "string") {
        throw new TypeError('The "string" argument must be of type string. Received type number');
      }
      return allocUnsafe(arg);
    }
    return from7(arg, encodingOrOffset, length);
  }
  Buffer.poolSize = 8192;
  function from7(value, encodingOrOffset, length) {
    if (typeof value === "string") {
      return fromString2(value, encodingOrOffset);
    }
    if (ArrayBuffer.isView(value)) {
      return fromArrayView(value);
    }
    if (value == null) {
      throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value);
    }
    if (isInstance(value, ArrayBuffer) || value && isInstance(value.buffer, ArrayBuffer)) {
      return fromArrayBuffer(value, encodingOrOffset, length);
    }
    if (typeof SharedArrayBuffer !== "undefined" && (isInstance(value, SharedArrayBuffer) || value && isInstance(value.buffer, SharedArrayBuffer))) {
      return fromArrayBuffer(value, encodingOrOffset, length);
    }
    if (typeof value === "number") {
      throw new TypeError('The "value" argument must not be of type number. Received type number');
    }
    var valueOf = value.valueOf && value.valueOf();
    if (valueOf != null && valueOf !== value) {
      return Buffer.from(valueOf, encodingOrOffset, length);
    }
    var b = fromObject(value);
    if (b) return b;
    if (typeof Symbol !== "undefined" && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === "function") {
      return Buffer.from(value[Symbol.toPrimitive]("string"), encodingOrOffset, length);
    }
    throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value);
  }
  Buffer.from = function(value, encodingOrOffset, length) {
    return from7(value, encodingOrOffset, length);
  };
  Object.setPrototypeOf(Buffer.prototype, Uint8Array.prototype);
  Object.setPrototypeOf(Buffer, Uint8Array);
  function assertSize(size3) {
    if (typeof size3 !== "number") {
      throw new TypeError('"size" argument must be of type number');
    } else if (size3 < 0) {
      throw new RangeError('The value "' + size3 + '" is invalid for option "size"');
    }
  }
  function alloc(size3, fill4, encoding) {
    assertSize(size3);
    if (size3 <= 0) {
      return createBuffer2(size3);
    }
    if (fill4 !== void 0) {
      return typeof encoding === "string" ? createBuffer2(size3).fill(fill4, encoding) : createBuffer2(size3).fill(fill4);
    }
    return createBuffer2(size3);
  }
  Buffer.alloc = function(size3, fill4, encoding) {
    return alloc(size3, fill4, encoding);
  };
  function allocUnsafe(size3) {
    assertSize(size3);
    return createBuffer2(size3 < 0 ? 0 : checked(size3) | 0);
  }
  Buffer.allocUnsafe = function(size3) {
    return allocUnsafe(size3);
  };
  Buffer.allocUnsafeSlow = function(size3) {
    return allocUnsafe(size3);
  };
  function fromString2(string, encoding) {
    if (typeof encoding !== "string" || encoding === "") {
      encoding = "utf8";
    }
    if (!Buffer.isEncoding(encoding)) {
      throw new TypeError("Unknown encoding: " + encoding);
    }
    var length = byteLength2(string, encoding) | 0;
    var buf = createBuffer2(length);
    var actual = buf.write(string, encoding);
    if (actual !== length) {
      buf = buf.slice(0, actual);
    }
    return buf;
  }
  function fromArrayLike(array) {
    var length = array.length < 0 ? 0 : checked(array.length) | 0;
    var buf = createBuffer2(length);
    for (var i = 0; i < length; i += 1) {
      buf[i] = array[i] & 255;
    }
    return buf;
  }
  function fromArrayView(arrayView) {
    if (isInstance(arrayView, Uint8Array)) {
      var copy = new Uint8Array(arrayView);
      return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength);
    }
    return fromArrayLike(arrayView);
  }
  function fromArrayBuffer(array, byteOffset, length) {
    if (byteOffset < 0 || array.byteLength < byteOffset) {
      throw new RangeError('"offset" is outside of buffer bounds');
    }
    if (array.byteLength < byteOffset + (length || 0)) {
      throw new RangeError('"length" is outside of buffer bounds');
    }
    var buf;
    if (byteOffset === void 0 && length === void 0) {
      buf = new Uint8Array(array);
    } else if (length === void 0) {
      buf = new Uint8Array(array, byteOffset);
    } else {
      buf = new Uint8Array(array, byteOffset, length);
    }
    Object.setPrototypeOf(buf, Buffer.prototype);
    return buf;
  }
  function fromObject(obj) {
    if (Buffer.isBuffer(obj)) {
      var len = checked(obj.length) | 0;
      var buf = createBuffer2(len);
      if (buf.length === 0) {
        return buf;
      }
      obj.copy(buf, 0, 0, len);
      return buf;
    }
    if (obj.length !== void 0) {
      if (typeof obj.length !== "number" || numberIsNaN(obj.length)) {
        return createBuffer2(0);
      }
      return fromArrayLike(obj);
    }
    if (obj.type === "Buffer" && Array.isArray(obj.data)) {
      return fromArrayLike(obj.data);
    }
  }
  function checked(length) {
    if (length >= K_MAX_LENGTH) {
      throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + K_MAX_LENGTH.toString(16) + " bytes");
    }
    return length | 0;
  }
  function SlowBuffer(length) {
    if (+length != length) {
      length = 0;
    }
    return Buffer.alloc(+length);
  }
  Buffer.isBuffer = function isBuffer(b) {
    return b != null && b._isBuffer === true && b !== Buffer.prototype;
  };
  Buffer.compare = function compare(a, b) {
    if (isInstance(a, Uint8Array)) a = Buffer.from(a, a.offset, a.byteLength);
    if (isInstance(b, Uint8Array)) b = Buffer.from(b, b.offset, b.byteLength);
    if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
      throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
    }
    if (a === b) return 0;
    var x = a.length;
    var y = b.length;
    for (var i = 0, len = Math.min(x, y); i < len; ++i) {
      if (a[i] !== b[i]) {
        x = a[i];
        y = b[i];
        break;
      }
    }
    if (x < y) return -1;
    if (y < x) return 1;
    return 0;
  };
  Buffer.isEncoding = function isEncoding(encoding) {
    switch (String(encoding).toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "latin1":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return true;
      default:
        return false;
    }
  };
  Buffer.concat = function concat4(list, length) {
    if (!Array.isArray(list)) {
      throw new TypeError('"list" argument must be an Array of Buffers');
    }
    if (list.length === 0) {
      return Buffer.alloc(0);
    }
    var i;
    if (length === void 0) {
      length = 0;
      for (i = 0; i < list.length; ++i) {
        length += list[i].length;
      }
    }
    var buffer2 = Buffer.allocUnsafe(length);
    var pos = 0;
    for (i = 0; i < list.length; ++i) {
      var buf = list[i];
      if (isInstance(buf, Uint8Array)) {
        if (pos + buf.length > buffer2.length) {
          Buffer.from(buf).copy(buffer2, pos);
        } else {
          Uint8Array.prototype.set.call(buffer2, buf, pos);
        }
      } else if (!Buffer.isBuffer(buf)) {
        throw new TypeError('"list" argument must be an Array of Buffers');
      } else {
        buf.copy(buffer2, pos);
      }
      pos += buf.length;
    }
    return buffer2;
  };
  function byteLength2(string, encoding) {
    if (Buffer.isBuffer(string)) {
      return string.length;
    }
    if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
      return string.byteLength;
    }
    if (typeof string !== "string") {
      throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof string);
    }
    var len = string.length;
    var mustMatch = arguments.length > 2 && arguments[2] === true;
    if (!mustMatch && len === 0) return 0;
    var loweredCase = false;
    for (; ; ) {
      switch (encoding) {
        case "ascii":
        case "latin1":
        case "binary":
          return len;
        case "utf8":
        case "utf-8":
          return utf8ToBytes(string).length;
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return len * 2;
        case "hex":
          return len >>> 1;
        case "base64":
          return base64ToBytes(string).length;
        default:
          if (loweredCase) {
            return mustMatch ? -1 : utf8ToBytes(string).length;
          }
          encoding = ("" + encoding).toLowerCase();
          loweredCase = true;
      }
    }
  }
  Buffer.byteLength = byteLength2;
  function slowToString(encoding, start2, end) {
    var loweredCase = false;
    if (start2 === void 0 || start2 < 0) {
      start2 = 0;
    }
    if (start2 > this.length) {
      return "";
    }
    if (end === void 0 || end > this.length) {
      end = this.length;
    }
    if (end <= 0) {
      return "";
    }
    end >>>= 0;
    start2 >>>= 0;
    if (end <= start2) {
      return "";
    }
    if (!encoding) encoding = "utf8";
    while (true) {
      switch (encoding) {
        case "hex":
          return hexSlice(this, start2, end);
        case "utf8":
        case "utf-8":
          return utf8Slice(this, start2, end);
        case "ascii":
          return asciiSlice(this, start2, end);
        case "latin1":
        case "binary":
          return latin1Slice(this, start2, end);
        case "base64":
          return base64Slice(this, start2, end);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return utf16leSlice(this, start2, end);
        default:
          if (loweredCase) throw new TypeError("Unknown encoding: " + encoding);
          encoding = (encoding + "").toLowerCase();
          loweredCase = true;
      }
    }
  }
  Buffer.prototype._isBuffer = true;
  function swap(b, n, m) {
    var i = b[n];
    b[n] = b[m];
    b[m] = i;
  }
  Buffer.prototype.swap16 = function swap16() {
    var len = this.length;
    if (len % 2 !== 0) {
      throw new RangeError("Buffer size must be a multiple of 16-bits");
    }
    for (var i = 0; i < len; i += 2) {
      swap(this, i, i + 1);
    }
    return this;
  };
  Buffer.prototype.swap32 = function swap32() {
    var len = this.length;
    if (len % 4 !== 0) {
      throw new RangeError("Buffer size must be a multiple of 32-bits");
    }
    for (var i = 0; i < len; i += 4) {
      swap(this, i, i + 3);
      swap(this, i + 1, i + 2);
    }
    return this;
  };
  Buffer.prototype.swap64 = function swap64() {
    var len = this.length;
    if (len % 8 !== 0) {
      throw new RangeError("Buffer size must be a multiple of 64-bits");
    }
    for (var i = 0; i < len; i += 8) {
      swap(this, i, i + 7);
      swap(this, i + 1, i + 6);
      swap(this, i + 2, i + 5);
      swap(this, i + 3, i + 4);
    }
    return this;
  };
  Buffer.prototype.toString = function toString7() {
    var length = this.length;
    if (length === 0) return "";
    if (arguments.length === 0) return utf8Slice(this, 0, length);
    return slowToString.apply(this, arguments);
  };
  Buffer.prototype.toLocaleString = Buffer.prototype.toString;
  Buffer.prototype.equals = function equals(b) {
    if (!Buffer.isBuffer(b)) throw new TypeError("Argument must be a Buffer");
    if (this === b) return true;
    return Buffer.compare(this, b) === 0;
  };
  Buffer.prototype.inspect = function inspect() {
    var str = "";
    var max2 = exports.INSPECT_MAX_BYTES;
    str = this.toString("hex", 0, max2).replace(/(.{2})/g, "$1 ").trim();
    if (this.length > max2) str += " ... ";
    return "<Buffer " + str + ">";
  };
  if (customInspectSymbol) {
    Buffer.prototype[customInspectSymbol] = Buffer.prototype.inspect;
  }
  Buffer.prototype.compare = function compare(target, start2, end, thisStart, thisEnd) {
    if (isInstance(target, Uint8Array)) {
      target = Buffer.from(target, target.offset, target.byteLength);
    }
    if (!Buffer.isBuffer(target)) {
      throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof target);
    }
    if (start2 === void 0) {
      start2 = 0;
    }
    if (end === void 0) {
      end = target ? target.length : 0;
    }
    if (thisStart === void 0) {
      thisStart = 0;
    }
    if (thisEnd === void 0) {
      thisEnd = this.length;
    }
    if (start2 < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
      throw new RangeError("out of range index");
    }
    if (thisStart >= thisEnd && start2 >= end) {
      return 0;
    }
    if (thisStart >= thisEnd) {
      return -1;
    }
    if (start2 >= end) {
      return 1;
    }
    start2 >>>= 0;
    end >>>= 0;
    thisStart >>>= 0;
    thisEnd >>>= 0;
    if (this === target) return 0;
    var x = thisEnd - thisStart;
    var y = end - start2;
    var len = Math.min(x, y);
    var thisCopy = this.slice(thisStart, thisEnd);
    var targetCopy = target.slice(start2, end);
    for (var i = 0; i < len; ++i) {
      if (thisCopy[i] !== targetCopy[i]) {
        x = thisCopy[i];
        y = targetCopy[i];
        break;
      }
    }
    if (x < y) return -1;
    if (y < x) return 1;
    return 0;
  };
  function bidirectionalIndexOf(buffer2, val, byteOffset, encoding, dir) {
    if (buffer2.length === 0) return -1;
    if (typeof byteOffset === "string") {
      encoding = byteOffset;
      byteOffset = 0;
    } else if (byteOffset > 2147483647) {
      byteOffset = 2147483647;
    } else if (byteOffset < -2147483648) {
      byteOffset = -2147483648;
    }
    byteOffset = +byteOffset;
    if (numberIsNaN(byteOffset)) {
      byteOffset = dir ? 0 : buffer2.length - 1;
    }
    if (byteOffset < 0) byteOffset = buffer2.length + byteOffset;
    if (byteOffset >= buffer2.length) {
      if (dir) return -1;
      else byteOffset = buffer2.length - 1;
    } else if (byteOffset < 0) {
      if (dir) byteOffset = 0;
      else return -1;
    }
    if (typeof val === "string") {
      val = Buffer.from(val, encoding);
    }
    if (Buffer.isBuffer(val)) {
      if (val.length === 0) {
        return -1;
      }
      return arrayIndexOf(buffer2, val, byteOffset, encoding, dir);
    } else if (typeof val === "number") {
      val = val & 255;
      if (typeof Uint8Array.prototype.indexOf === "function") {
        if (dir) {
          return Uint8Array.prototype.indexOf.call(buffer2, val, byteOffset);
        } else {
          return Uint8Array.prototype.lastIndexOf.call(buffer2, val, byteOffset);
        }
      }
      return arrayIndexOf(buffer2, [val], byteOffset, encoding, dir);
    }
    throw new TypeError("val must be string, number or Buffer");
  }
  function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
    var indexSize = 1;
    var arrLength = arr.length;
    var valLength = val.length;
    if (encoding !== void 0) {
      encoding = String(encoding).toLowerCase();
      if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
        if (arr.length < 2 || val.length < 2) {
          return -1;
        }
        indexSize = 2;
        arrLength /= 2;
        valLength /= 2;
        byteOffset /= 2;
      }
    }
    function read(buf, i2) {
      if (indexSize === 1) {
        return buf[i2];
      } else {
        return buf.readUInt16BE(i2 * indexSize);
      }
    }
    var i;
    if (dir) {
      var foundIndex = -1;
      for (i = byteOffset; i < arrLength; i++) {
        if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
          if (foundIndex === -1) foundIndex = i;
          if (i - foundIndex + 1 === valLength) return foundIndex * indexSize;
        } else {
          if (foundIndex !== -1) i -= i - foundIndex;
          foundIndex = -1;
        }
      }
    } else {
      if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;
      for (i = byteOffset; i >= 0; i--) {
        var found = true;
        for (var j = 0; j < valLength; j++) {
          if (read(arr, i + j) !== read(val, j)) {
            found = false;
            break;
          }
        }
        if (found) return i;
      }
    }
    return -1;
  }
  Buffer.prototype.includes = function includes5(val, byteOffset, encoding) {
    return this.indexOf(val, byteOffset, encoding) !== -1;
  };
  Buffer.prototype.indexOf = function indexOf4(val, byteOffset, encoding) {
    return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
  };
  Buffer.prototype.lastIndexOf = function lastIndexOf4(val, byteOffset, encoding) {
    return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
  };
  function hexWrite(buf, string, offset, length) {
    offset = Number(offset) || 0;
    var remaining = buf.length - offset;
    if (!length) {
      length = remaining;
    } else {
      length = Number(length);
      if (length > remaining) {
        length = remaining;
      }
    }
    var strLen = string.length;
    if (length > strLen / 2) {
      length = strLen / 2;
    }
    for (var i = 0; i < length; ++i) {
      var parsed = parseInt(string.substr(i * 2, 2), 16);
      if (numberIsNaN(parsed)) return i;
      buf[offset + i] = parsed;
    }
    return i;
  }
  function utf8Write(buf, string, offset, length) {
    return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
  }
  function asciiWrite(buf, string, offset, length) {
    return blitBuffer(asciiToBytes(string), buf, offset, length);
  }
  function base64Write(buf, string, offset, length) {
    return blitBuffer(base64ToBytes(string), buf, offset, length);
  }
  function ucs2Write(buf, string, offset, length) {
    return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
  }
  Buffer.prototype.write = function write(string, offset, length, encoding) {
    if (offset === void 0) {
      encoding = "utf8";
      length = this.length;
      offset = 0;
    } else if (length === void 0 && typeof offset === "string") {
      encoding = offset;
      length = this.length;
      offset = 0;
    } else if (isFinite(offset)) {
      offset = offset >>> 0;
      if (isFinite(length)) {
        length = length >>> 0;
        if (encoding === void 0) encoding = "utf8";
      } else {
        encoding = length;
        length = void 0;
      }
    } else {
      throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
    }
    var remaining = this.length - offset;
    if (length === void 0 || length > remaining) length = remaining;
    if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
      throw new RangeError("Attempt to write outside buffer bounds");
    }
    if (!encoding) encoding = "utf8";
    var loweredCase = false;
    for (; ; ) {
      switch (encoding) {
        case "hex":
          return hexWrite(this, string, offset, length);
        case "utf8":
        case "utf-8":
          return utf8Write(this, string, offset, length);
        case "ascii":
        case "latin1":
        case "binary":
          return asciiWrite(this, string, offset, length);
        case "base64":
          return base64Write(this, string, offset, length);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return ucs2Write(this, string, offset, length);
        default:
          if (loweredCase) throw new TypeError("Unknown encoding: " + encoding);
          encoding = ("" + encoding).toLowerCase();
          loweredCase = true;
      }
    }
  };
  Buffer.prototype.toJSON = function toJSON4() {
    return {
      type: "Buffer",
      data: Array.prototype.slice.call(this._arr || this, 0)
    };
  };
  function base64Slice(buf, start2, end) {
    if (start2 === 0 && end === buf.length) {
      return base64.fromByteArray(buf);
    } else {
      return base64.fromByteArray(buf.slice(start2, end));
    }
  }
  function utf8Slice(buf, start2, end) {
    end = Math.min(buf.length, end);
    var res = [];
    var i = start2;
    while (i < end) {
      var firstByte = buf[i];
      var codePoint = null;
      var bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
      if (i + bytesPerSequence <= end) {
        var secondByte, thirdByte, fourthByte, tempCodePoint;
        switch (bytesPerSequence) {
          case 1:
            if (firstByte < 128) {
              codePoint = firstByte;
            }
            break;
          case 2:
            secondByte = buf[i + 1];
            if ((secondByte & 192) === 128) {
              tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
              if (tempCodePoint > 127) {
                codePoint = tempCodePoint;
              }
            }
            break;
          case 3:
            secondByte = buf[i + 1];
            thirdByte = buf[i + 2];
            if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
              tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
              if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
                codePoint = tempCodePoint;
              }
            }
            break;
          case 4:
            secondByte = buf[i + 1];
            thirdByte = buf[i + 2];
            fourthByte = buf[i + 3];
            if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
              tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
              if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
                codePoint = tempCodePoint;
              }
            }
        }
      }
      if (codePoint === null) {
        codePoint = 65533;
        bytesPerSequence = 1;
      } else if (codePoint > 65535) {
        codePoint -= 65536;
        res.push(codePoint >>> 10 & 1023 | 55296);
        codePoint = 56320 | codePoint & 1023;
      }
      res.push(codePoint);
      i += bytesPerSequence;
    }
    return decodeCodePointsArray(res);
  }
  var MAX_ARGUMENTS_LENGTH = 4096;
  function decodeCodePointsArray(codePoints3) {
    var len = codePoints3.length;
    if (len <= MAX_ARGUMENTS_LENGTH) {
      return String.fromCharCode.apply(String, codePoints3);
    }
    var res = "";
    var i = 0;
    while (i < len) {
      res += String.fromCharCode.apply(String, codePoints3.slice(i, i += MAX_ARGUMENTS_LENGTH));
    }
    return res;
  }
  function asciiSlice(buf, start2, end) {
    var ret = "";
    end = Math.min(buf.length, end);
    for (var i = start2; i < end; ++i) {
      ret += String.fromCharCode(buf[i] & 127);
    }
    return ret;
  }
  function latin1Slice(buf, start2, end) {
    var ret = "";
    end = Math.min(buf.length, end);
    for (var i = start2; i < end; ++i) {
      ret += String.fromCharCode(buf[i]);
    }
    return ret;
  }
  function hexSlice(buf, start2, end) {
    var len = buf.length;
    if (!start2 || start2 < 0) start2 = 0;
    if (!end || end < 0 || end > len) end = len;
    var out = "";
    for (var i = start2; i < end; ++i) {
      out += hexSliceLookupTable[buf[i]];
    }
    return out;
  }
  function utf16leSlice(buf, start2, end) {
    var bytes = buf.slice(start2, end);
    var res = "";
    for (var i = 0; i < bytes.length - 1; i += 2) {
      res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
    }
    return res;
  }
  Buffer.prototype.slice = function slice5(start2, end) {
    var len = this.length;
    start2 = ~~start2;
    end = end === void 0 ? len : ~~end;
    if (start2 < 0) {
      start2 += len;
      if (start2 < 0) start2 = 0;
    } else if (start2 > len) {
      start2 = len;
    }
    if (end < 0) {
      end += len;
      if (end < 0) end = 0;
    } else if (end > len) {
      end = len;
    }
    if (end < start2) end = start2;
    var newBuf = this.subarray(start2, end);
    Object.setPrototypeOf(newBuf, Buffer.prototype);
    return newBuf;
  };
  function checkOffset(offset, ext, length) {
    if (offset % 1 !== 0 || offset < 0) throw new RangeError("offset is not uint");
    if (offset + ext > length) throw new RangeError("Trying to access beyond buffer length");
  }
  Buffer.prototype.readUintLE = Buffer.prototype.readUIntLE = function readUIntLE(offset, byteLength3, noAssert) {
    offset = offset >>> 0;
    byteLength3 = byteLength3 >>> 0;
    if (!noAssert) checkOffset(offset, byteLength3, this.length);
    var val = this[offset];
    var mul = 1;
    var i = 0;
    while (++i < byteLength3 && (mul *= 256)) {
      val += this[offset + i] * mul;
    }
    return val;
  };
  Buffer.prototype.readUintBE = Buffer.prototype.readUIntBE = function readUIntBE(offset, byteLength3, noAssert) {
    offset = offset >>> 0;
    byteLength3 = byteLength3 >>> 0;
    if (!noAssert) {
      checkOffset(offset, byteLength3, this.length);
    }
    var val = this[offset + --byteLength3];
    var mul = 1;
    while (byteLength3 > 0 && (mul *= 256)) {
      val += this[offset + --byteLength3] * mul;
    }
    return val;
  };
  Buffer.prototype.readUint8 = Buffer.prototype.readUInt8 = function readUInt8(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 1, this.length);
    return this[offset];
  };
  Buffer.prototype.readUint16LE = Buffer.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 2, this.length);
    return this[offset] | this[offset + 1] << 8;
  };
  Buffer.prototype.readUint16BE = Buffer.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 2, this.length);
    return this[offset] << 8 | this[offset + 1];
  };
  Buffer.prototype.readUint32LE = Buffer.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216;
  };
  Buffer.prototype.readUint32BE = Buffer.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
  };
  Buffer.prototype.readIntLE = function readIntLE(offset, byteLength3, noAssert) {
    offset = offset >>> 0;
    byteLength3 = byteLength3 >>> 0;
    if (!noAssert) checkOffset(offset, byteLength3, this.length);
    var val = this[offset];
    var mul = 1;
    var i = 0;
    while (++i < byteLength3 && (mul *= 256)) {
      val += this[offset + i] * mul;
    }
    mul *= 128;
    if (val >= mul) val -= Math.pow(2, 8 * byteLength3);
    return val;
  };
  Buffer.prototype.readIntBE = function readIntBE(offset, byteLength3, noAssert) {
    offset = offset >>> 0;
    byteLength3 = byteLength3 >>> 0;
    if (!noAssert) checkOffset(offset, byteLength3, this.length);
    var i = byteLength3;
    var mul = 1;
    var val = this[offset + --i];
    while (i > 0 && (mul *= 256)) {
      val += this[offset + --i] * mul;
    }
    mul *= 128;
    if (val >= mul) val -= Math.pow(2, 8 * byteLength3);
    return val;
  };
  Buffer.prototype.readInt8 = function readInt8(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 1, this.length);
    if (!(this[offset] & 128)) return this[offset];
    return (255 - this[offset] + 1) * -1;
  };
  Buffer.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 2, this.length);
    var val = this[offset] | this[offset + 1] << 8;
    return val & 32768 ? val | 4294901760 : val;
  };
  Buffer.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 2, this.length);
    var val = this[offset + 1] | this[offset] << 8;
    return val & 32768 ? val | 4294901760 : val;
  };
  Buffer.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
  };
  Buffer.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
  };
  Buffer.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return ieee7542.read(this, offset, true, 23, 4);
  };
  Buffer.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return ieee7542.read(this, offset, false, 23, 4);
  };
  Buffer.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 8, this.length);
    return ieee7542.read(this, offset, true, 52, 8);
  };
  Buffer.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 8, this.length);
    return ieee7542.read(this, offset, false, 52, 8);
  };
  function checkInt(buf, value, offset, ext, max2, min2) {
    if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance');
    if (value > max2 || value < min2) throw new RangeError('"value" argument is out of bounds');
    if (offset + ext > buf.length) throw new RangeError("Index out of range");
  }
  Buffer.prototype.writeUintLE = Buffer.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength3, noAssert) {
    value = +value;
    offset = offset >>> 0;
    byteLength3 = byteLength3 >>> 0;
    if (!noAssert) {
      var maxBytes = Math.pow(2, 8 * byteLength3) - 1;
      checkInt(this, value, offset, byteLength3, maxBytes, 0);
    }
    var mul = 1;
    var i = 0;
    this[offset] = value & 255;
    while (++i < byteLength3 && (mul *= 256)) {
      this[offset + i] = value / mul & 255;
    }
    return offset + byteLength3;
  };
  Buffer.prototype.writeUintBE = Buffer.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength3, noAssert) {
    value = +value;
    offset = offset >>> 0;
    byteLength3 = byteLength3 >>> 0;
    if (!noAssert) {
      var maxBytes = Math.pow(2, 8 * byteLength3) - 1;
      checkInt(this, value, offset, byteLength3, maxBytes, 0);
    }
    var i = byteLength3 - 1;
    var mul = 1;
    this[offset + i] = value & 255;
    while (--i >= 0 && (mul *= 256)) {
      this[offset + i] = value / mul & 255;
    }
    return offset + byteLength3;
  };
  Buffer.prototype.writeUint8 = Buffer.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 1, 255, 0);
    this[offset] = value & 255;
    return offset + 1;
  };
  Buffer.prototype.writeUint16LE = Buffer.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 2, 65535, 0);
    this[offset] = value & 255;
    this[offset + 1] = value >>> 8;
    return offset + 2;
  };
  Buffer.prototype.writeUint16BE = Buffer.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 2, 65535, 0);
    this[offset] = value >>> 8;
    this[offset + 1] = value & 255;
    return offset + 2;
  };
  Buffer.prototype.writeUint32LE = Buffer.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 4, 4294967295, 0);
    this[offset + 3] = value >>> 24;
    this[offset + 2] = value >>> 16;
    this[offset + 1] = value >>> 8;
    this[offset] = value & 255;
    return offset + 4;
  };
  Buffer.prototype.writeUint32BE = Buffer.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 4, 4294967295, 0);
    this[offset] = value >>> 24;
    this[offset + 1] = value >>> 16;
    this[offset + 2] = value >>> 8;
    this[offset + 3] = value & 255;
    return offset + 4;
  };
  Buffer.prototype.writeIntLE = function writeIntLE(value, offset, byteLength3, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) {
      var limit = Math.pow(2, 8 * byteLength3 - 1);
      checkInt(this, value, offset, byteLength3, limit - 1, -limit);
    }
    var i = 0;
    var mul = 1;
    var sub2 = 0;
    this[offset] = value & 255;
    while (++i < byteLength3 && (mul *= 256)) {
      if (value < 0 && sub2 === 0 && this[offset + i - 1] !== 0) {
        sub2 = 1;
      }
      this[offset + i] = (value / mul >> 0) - sub2 & 255;
    }
    return offset + byteLength3;
  };
  Buffer.prototype.writeIntBE = function writeIntBE(value, offset, byteLength3, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) {
      var limit = Math.pow(2, 8 * byteLength3 - 1);
      checkInt(this, value, offset, byteLength3, limit - 1, -limit);
    }
    var i = byteLength3 - 1;
    var mul = 1;
    var sub2 = 0;
    this[offset + i] = value & 255;
    while (--i >= 0 && (mul *= 256)) {
      if (value < 0 && sub2 === 0 && this[offset + i + 1] !== 0) {
        sub2 = 1;
      }
      this[offset + i] = (value / mul >> 0) - sub2 & 255;
    }
    return offset + byteLength3;
  };
  Buffer.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 1, 127, -128);
    if (value < 0) value = 255 + value + 1;
    this[offset] = value & 255;
    return offset + 1;
  };
  Buffer.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 2, 32767, -32768);
    this[offset] = value & 255;
    this[offset + 1] = value >>> 8;
    return offset + 2;
  };
  Buffer.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 2, 32767, -32768);
    this[offset] = value >>> 8;
    this[offset + 1] = value & 255;
    return offset + 2;
  };
  Buffer.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 4, 2147483647, -2147483648);
    this[offset] = value & 255;
    this[offset + 1] = value >>> 8;
    this[offset + 2] = value >>> 16;
    this[offset + 3] = value >>> 24;
    return offset + 4;
  };
  Buffer.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 4, 2147483647, -2147483648);
    if (value < 0) value = 4294967295 + value + 1;
    this[offset] = value >>> 24;
    this[offset + 1] = value >>> 16;
    this[offset + 2] = value >>> 8;
    this[offset + 3] = value & 255;
    return offset + 4;
  };
  function checkIEEE754(buf, value, offset, ext, max2, min2) {
    if (offset + ext > buf.length) throw new RangeError("Index out of range");
    if (offset < 0) throw new RangeError("Index out of range");
  }
  function writeFloat(buf, value, offset, littleEndian, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) {
      checkIEEE754(buf, value, offset, 4);
    }
    ieee7542.write(buf, value, offset, littleEndian, 23, 4);
    return offset + 4;
  }
  Buffer.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
    return writeFloat(this, value, offset, true, noAssert);
  };
  Buffer.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
    return writeFloat(this, value, offset, false, noAssert);
  };
  function writeDouble(buf, value, offset, littleEndian, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) {
      checkIEEE754(buf, value, offset, 8);
    }
    ieee7542.write(buf, value, offset, littleEndian, 52, 8);
    return offset + 8;
  }
  Buffer.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
    return writeDouble(this, value, offset, true, noAssert);
  };
  Buffer.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
    return writeDouble(this, value, offset, false, noAssert);
  };
  Buffer.prototype.copy = function copy(target, targetStart, start2, end) {
    if (!Buffer.isBuffer(target)) throw new TypeError("argument should be a Buffer");
    if (!start2) start2 = 0;
    if (!end && end !== 0) end = this.length;
    if (targetStart >= target.length) targetStart = target.length;
    if (!targetStart) targetStart = 0;
    if (end > 0 && end < start2) end = start2;
    if (end === start2) return 0;
    if (target.length === 0 || this.length === 0) return 0;
    if (targetStart < 0) {
      throw new RangeError("targetStart out of bounds");
    }
    if (start2 < 0 || start2 >= this.length) throw new RangeError("Index out of range");
    if (end < 0) throw new RangeError("sourceEnd out of bounds");
    if (end > this.length) end = this.length;
    if (target.length - targetStart < end - start2) {
      end = target.length - targetStart + start2;
    }
    var len = end - start2;
    if (this === target && typeof Uint8Array.prototype.copyWithin === "function") {
      this.copyWithin(targetStart, start2, end);
    } else {
      Uint8Array.prototype.set.call(target, this.subarray(start2, end), targetStart);
    }
    return len;
  };
  Buffer.prototype.fill = function fill4(val, start2, end, encoding) {
    if (typeof val === "string") {
      if (typeof start2 === "string") {
        encoding = start2;
        start2 = 0;
        end = this.length;
      } else if (typeof end === "string") {
        encoding = end;
        end = this.length;
      }
      if (encoding !== void 0 && typeof encoding !== "string") {
        throw new TypeError("encoding must be a string");
      }
      if (typeof encoding === "string" && !Buffer.isEncoding(encoding)) {
        throw new TypeError("Unknown encoding: " + encoding);
      }
      if (val.length === 1) {
        var code2 = val.charCodeAt(0);
        if (encoding === "utf8" && code2 < 128 || encoding === "latin1") {
          val = code2;
        }
      }
    } else if (typeof val === "number") {
      val = val & 255;
    } else if (typeof val === "boolean") {
      val = Number(val);
    }
    if (start2 < 0 || this.length < start2 || this.length < end) {
      throw new RangeError("Out of range index");
    }
    if (end <= start2) {
      return this;
    }
    start2 = start2 >>> 0;
    end = end === void 0 ? this.length : end >>> 0;
    if (!val) val = 0;
    var i;
    if (typeof val === "number") {
      for (i = start2; i < end; ++i) {
        this[i] = val;
      }
    } else {
      var bytes = Buffer.isBuffer(val) ? val : Buffer.from(val, encoding);
      var len = bytes.length;
      if (len === 0) {
        throw new TypeError('The value "' + val + '" is invalid for argument "value"');
      }
      for (i = 0; i < end - start2; ++i) {
        this[i + start2] = bytes[i % len];
      }
    }
    return this;
  };
  var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
  function base64clean(str) {
    str = str.split("=")[0];
    str = str.trim().replace(INVALID_BASE64_RE, "");
    if (str.length < 2) return "";
    while (str.length % 4 !== 0) {
      str = str + "=";
    }
    return str;
  }
  function utf8ToBytes(string, units) {
    units = units || Infinity;
    var codePoint;
    var length = string.length;
    var leadSurrogate = null;
    var bytes = [];
    for (var i = 0; i < length; ++i) {
      codePoint = string.charCodeAt(i);
      if (codePoint > 55295 && codePoint < 57344) {
        if (!leadSurrogate) {
          if (codePoint > 56319) {
            if ((units -= 3) > -1) bytes.push(239, 191, 189);
            continue;
          } else if (i + 1 === length) {
            if ((units -= 3) > -1) bytes.push(239, 191, 189);
            continue;
          }
          leadSurrogate = codePoint;
          continue;
        }
        if (codePoint < 56320) {
          if ((units -= 3) > -1) bytes.push(239, 191, 189);
          leadSurrogate = codePoint;
          continue;
        }
        codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
      } else if (leadSurrogate) {
        if ((units -= 3) > -1) bytes.push(239, 191, 189);
      }
      leadSurrogate = null;
      if (codePoint < 128) {
        if ((units -= 1) < 0) break;
        bytes.push(codePoint);
      } else if (codePoint < 2048) {
        if ((units -= 2) < 0) break;
        bytes.push(codePoint >> 6 | 192, codePoint & 63 | 128);
      } else if (codePoint < 65536) {
        if ((units -= 3) < 0) break;
        bytes.push(codePoint >> 12 | 224, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
      } else if (codePoint < 1114112) {
        if ((units -= 4) < 0) break;
        bytes.push(codePoint >> 18 | 240, codePoint >> 12 & 63 | 128, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
      } else {
        throw new Error("Invalid code point");
      }
    }
    return bytes;
  }
  function asciiToBytes(str) {
    var byteArray = [];
    for (var i = 0; i < str.length; ++i) {
      byteArray.push(str.charCodeAt(i) & 255);
    }
    return byteArray;
  }
  function utf16leToBytes(str, units) {
    var c, hi2, lo;
    var byteArray = [];
    for (var i = 0; i < str.length; ++i) {
      if ((units -= 2) < 0) break;
      c = str.charCodeAt(i);
      hi2 = c >> 8;
      lo = c % 256;
      byteArray.push(lo);
      byteArray.push(hi2);
    }
    return byteArray;
  }
  function base64ToBytes(str) {
    return base64.toByteArray(base64clean(str));
  }
  function blitBuffer(src, dst, offset, length) {
    for (var i = 0; i < length; ++i) {
      if (i + offset >= dst.length || i >= src.length) break;
      dst[i + offset] = src[i];
    }
    return i;
  }
  function isInstance(obj, type) {
    return obj instanceof type || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type.name;
  }
  function numberIsNaN(obj) {
    return obj !== obj;
  }
  var hexSliceLookupTable = function() {
    var alphabet = "0123456789abcdef";
    var table = new Array(256);
    for (var i = 0; i < 16; ++i) {
      var i16 = i * 16;
      for (var j = 0; j < 16; ++j) {
        table[i16 + j] = alphabet[i] + alphabet[j];
      }
    }
    return table;
  }();
})(buffer);
const createBuffer = buffer.Buffer.from && buffer.Buffer.alloc && buffer.Buffer.allocUnsafe && buffer.Buffer.allocUnsafeSlow ? buffer.Buffer.from : (
  // support for Node < 5.10
  (val) => new buffer.Buffer(val)
);
function defineCrc(model, calc) {
  const fn = (buf, previous) => calc(buf, previous) >>> 0;
  fn.signed = calc;
  fn.unsigned = fn;
  fn.model = model;
  return fn;
}
let TABLE = [0, 1996959894, 3993919788, 2567524794, 124634137, 1886057615, 3915621685, 2657392035, 249268274, 2044508324, 3772115230, 2547177864, 162941995, 2125561021, 3887607047, 2428444049, 498536548, 1789927666, 4089016648, 2227061214, 450548861, 1843258603, 4107580753, 2211677639, 325883990, 1684777152, 4251122042, 2321926636, 335633487, 1661365465, 4195302755, 2366115317, 997073096, 1281953886, 3579855332, 2724688242, 1006888145, 1258607687, 3524101629, 2768942443, 901097722, 1119000684, 3686517206, 2898065728, 853044451, 1172266101, 3705015759, 2882616665, 651767980, 1373503546, 3369554304, 3218104598, 565507253, 1454621731, 3485111705, 3099436303, 671266974, 1594198024, 3322730930, 2970347812, 795835527, 1483230225, 3244367275, 3060149565, 1994146192, 31158534, 2563907772, 4023717930, 1907459465, 112637215, 2680153253, 3904427059, 2013776290, 251722036, 2517215374, 3775830040, 2137656763, 141376813, 2439277719, 3865271297, 1802195444, 476864866, 2238001368, 4066508878, 1812370925, 453092731, 2181625025, 4111451223, 1706088902, 314042704, 2344532202, 4240017532, 1658658271, 366619977, 2362670323, 4224994405, 1303535960, 984961486, 2747007092, 3569037538, 1256170817, 1037604311, 2765210733, 3554079995, 1131014506, 879679996, 2909243462, 3663771856, 1141124467, 855842277, 2852801631, 3708648649, 1342533948, 654459306, 3188396048, 3373015174, 1466479909, 544179635, 3110523913, 3462522015, 1591671054, 702138776, 2966460450, 3352799412, 1504918807, 783551873, 3082640443, 3233442989, 3988292384, 2596254646, 62317068, 1957810842, 3939845945, 2647816111, 81470997, 1943803523, 3814918930, 2489596804, 225274430, 2053790376, 3826175755, 2466906013, 167816743, 2097651377, 4027552580, 2265490386, 503444072, 1762050814, 4150417245, 2154129355, 426522225, 1852507879, 4275313526, 2312317920, 282753626, 1742555852, 4189708143, 2394877945, 397917763, 1622183637, 3604390888, 2714866558, 953729732, 1340076626, 3518719985, 2797360999, 1068828381, 1219638859, 3624741850, 2936675148, 906185462, 1090812512, 3747672003, 2825379669, 829329135, 1181335161, 3412177804, 3160834842, 628085408, 1382605366, 3423369109, 3138078467, 570562233, 1426400815, 3317316542, 2998733608, 733239954, 1555261956, 3268935591, 3050360625, 752459403, 1541320221, 2607071920, 3965973030, 1969922972, 40735498, 2617837225, 3943577151, 1913087877, 83908371, 2512341634, 3803740692, 2075208622, 213261112, 2463272603, 3855990285, 2094854071, 198958881, 2262029012, 4057260610, 1759359992, 534414190, 2176718541, 4139329115, 1873836001, 414664567, 2282248934, 4279200368, 1711684554, 285281116, 2405801727, 4167216745, 1634467795, 376229701, 2685067896, 3608007406, 1308918612, 956543938, 2808555105, 3495958263, 1231636301, 1047427035, 2932959818, 3654703836, 1088359270, 936918e3, 2847714899, 3736837829, 1202900863, 817233897, 3183342108, 3401237130, 1404277552, 615818150, 3134207493, 3453421203, 1423857449, 601450431, 3009837614, 3294710456, 1567103746, 711928724, 3020668471, 3272380065, 1510334235, 755167117];
if (typeof Int32Array !== "undefined") TABLE = new Int32Array(TABLE);
const crc32 = defineCrc("crc-32", function(buf, previous) {
  if (!buffer.Buffer.isBuffer(buf)) buf = createBuffer(buf);
  let crc = previous === 0 ? 0 : ~~previous ^ -1;
  for (let index = 0; index < buf.length; index++) {
    const byte = buf[index];
    crc = TABLE[(crc ^ byte) & 255] ^ crc >>> 8;
  }
  return crc ^ -1;
});
const encoder = new TextEncoder();
function dosDateTime(dateTime = /* @__PURE__ */ new Date()) {
  const year = dateTime.getFullYear() - 1980 << 9;
  const month = dateTime.getMonth() + 1 << 5;
  const day = dateTime.getDate();
  const date = year | month | day;
  const hour = dateTime.getHours() << 11;
  const minute = dateTime.getMinutes() << 5;
  const second = Math.floor(dateTime.getSeconds() / 2);
  const time = hour | minute | second;
  return {
    date,
    time
  };
}
let File$1 = class File2 {
  constructor(info) {
    this.name = encoder.encode(info.name);
    this.size = info.size;
    this.bytesRead = 0;
    this.crc = null;
    this.dateTime = dosDateTime();
  }
  get header() {
    const h = new ArrayBuffer(30 + this.name.byteLength);
    const v = new DataView(h);
    v.setUint32(0, 67324752, true);
    v.setUint16(4, 20, true);
    v.setUint16(6, 2056, true);
    v.setUint16(8, 0, true);
    v.setUint16(10, this.dateTime.time, true);
    v.setUint16(12, this.dateTime.date, true);
    v.setUint32(14, 0, true);
    v.setUint32(18, 0, true);
    v.setUint32(22, 0, true);
    v.setUint16(26, this.name.byteLength, true);
    v.setUint16(28, 0, true);
    for (let i = 0; i < this.name.byteLength; i++) {
      v.setUint8(30 + i, this.name[i]);
    }
    return new Uint8Array(h);
  }
  get dataDescriptor() {
    const dd = new ArrayBuffer(16);
    const v = new DataView(dd);
    v.setUint32(0, 134695760, true);
    v.setUint32(4, this.crc, true);
    v.setUint32(8, this.size, true);
    v.setUint32(12, this.size, true);
    return new Uint8Array(dd);
  }
  directoryRecord(offset) {
    const dr = new ArrayBuffer(46 + this.name.byteLength);
    const v = new DataView(dr);
    v.setUint32(0, 33639248, true);
    v.setUint16(4, 20, true);
    v.setUint16(6, 20, true);
    v.setUint16(8, 2056, true);
    v.setUint16(10, 0, true);
    v.setUint16(12, this.dateTime.time, true);
    v.setUint16(14, this.dateTime.date, true);
    v.setUint32(16, this.crc, true);
    v.setUint32(20, this.size, true);
    v.setUint32(24, this.size, true);
    v.setUint16(28, this.name.byteLength, true);
    v.setUint16(30, 0, true);
    v.setUint16(32, 0, true);
    v.setUint16(34, 0, true);
    v.setUint16(36, 0, true);
    v.setUint32(38, 0, true);
    v.setUint32(42, offset, true);
    for (let i = 0; i < this.name.byteLength; i++) {
      v.setUint8(46 + i, this.name[i]);
    }
    return new Uint8Array(dr);
  }
  get byteLength() {
    return this.size + this.name.byteLength + 30 + 16;
  }
  append(data2, controller2) {
    this.bytesRead += data2.byteLength;
    const endIndex = data2.byteLength - Math.max(this.bytesRead - this.size, 0);
    const buf = data2.slice(0, endIndex);
    this.crc = crc32(buf, this.crc);
    controller2.enqueue(buf);
    if (endIndex < data2.byteLength) {
      return data2.slice(endIndex, data2.byteLength);
    }
  }
};
function centralDirectory(files, controller2) {
  let directoryOffset = 0;
  let directorySize = 0;
  for (let i = 0; i < files.length; i++) {
    const file = files[i];
    const record = file.directoryRecord(directoryOffset);
    directoryOffset += file.byteLength;
    controller2.enqueue(record);
    directorySize += record.byteLength;
  }
  controller2.enqueue(eod(files.length, directorySize, directoryOffset));
}
function eod(fileCount, directorySize, directoryOffset) {
  const e = new ArrayBuffer(22);
  const v = new DataView(e);
  v.setUint32(0, 101010256, true);
  v.setUint16(4, 0, true);
  v.setUint16(6, 0, true);
  v.setUint16(8, fileCount, true);
  v.setUint16(10, fileCount, true);
  v.setUint32(12, directorySize, true);
  v.setUint32(16, directoryOffset, true);
  v.setUint16(20, 0, true);
  return new Uint8Array(e);
}
class ZipStreamController {
  constructor(files, source) {
    this.files = files;
    this.fileIndex = 0;
    this.file = null;
    this.reader = source.getReader();
    this.nextFile();
    this.extra = null;
  }
  nextFile() {
    this.file = this.files[this.fileIndex++];
  }
  async pull(controller2) {
    if (!this.file) {
      centralDirectory(this.files, controller2);
      return controller2.close();
    }
    if (this.file.bytesRead === 0) {
      controller2.enqueue(this.file.header);
      if (this.extra) {
        this.extra = this.file.append(this.extra, controller2);
      }
    }
    if (this.file.bytesRead >= this.file.size) {
      controller2.enqueue(this.file.dataDescriptor);
      this.nextFile();
      return this.pull(controller2);
    }
    const data2 = await this.reader.read();
    if (data2.done) {
      this.nextFile();
      return this.pull(controller2);
    }
    this.extra = this.file.append(data2.value, controller2);
  }
}
class Zip {
  constructor(manifest, source) {
    this.files = manifest.files.map((info) => new File$1(info));
    this.source = source;
  }
  get stream() {
    return new ReadableStream(new ZipStreamController(this.files, this.source));
  }
  get size() {
    const entries5 = this.files.reduce((total, file) => total + file.byteLength * 2 - file.size, 0);
    const eod2 = 22;
    return entries5 + eod2;
  }
}
class FileReceiver extends Nanobus$1 {
  constructor(fileInfo2) {
    super("FileReceiver");
    this.keychain = new Keychain(fileInfo2.secretKey, fileInfo2.nonce);
    if (fileInfo2.requiresPassword) {
      this.keychain.setPassword(fileInfo2.password, fileInfo2.url);
    }
    this.fileInfo = fileInfo2;
    this.reset();
  }
  get progressRatio() {
    return this.progress[0] / this.progress[1];
  }
  get progressIndefinite() {
    return this.state !== "downloading";
  }
  get sizes() {
    return {
      partialSize: utilsExports.bytes(this.progress[0]),
      totalSize: utilsExports.bytes(this.progress[1])
    };
  }
  cancel() {
    if (this.downloadRequest) {
      this.downloadRequest.cancel();
    }
  }
  reset() {
    this.msg = "fileSizeProgress";
    this.state = "initialized";
    this.progress = [0, 1];
  }
  async getMetadata() {
    const meta2 = await metadata2(this.fileInfo.id, this.keychain);
    this.fileInfo.name = meta2.name;
    this.fileInfo.type = meta2.type;
    this.fileInfo.iv = meta2.iv;
    this.fileInfo.size = +meta2.size;
    this.fileInfo.manifest = meta2.manifest;
    this.state = "ready";
  }
  // Removed: reportLink feature not implemented in Go backend
  // async reportLink(reason) {
  //   await reportLink(this.fileInfo.id, this.keychain, reason);
  // }
  sendMessageToSw(msg) {
    return new Promise((resolve2, reject2) => {
      const channel2 = new MessageChannel();
      channel2.port1.onmessage = function(event) {
        if (event.data === void 0) {
          reject2("bad response from serviceWorker");
        } else if (event.data.error !== void 0) {
          reject2(event.data.error);
        } else {
          resolve2(event.data);
        }
      };
      navigator.serviceWorker.controller.postMessage(msg, [channel2.port2]);
    });
  }
  async downloadBlob(noSave = false) {
    this.state = "downloading";
    this.downloadRequest = await downloadFile(this.fileInfo.id, this.keychain, (p) => {
      this.progress = [p, this.fileInfo.size];
      this.emit("progress");
    });
    try {
      const ciphertext = await this.downloadRequest.result;
      this.downloadRequest = null;
      this.msg = "decryptingFile";
      this.state = "decrypting";
      this.emit("decrypting");
      let size3 = this.fileInfo.size;
      let plainStream = this.keychain.decryptStream(blobStream(ciphertext));
      if (this.fileInfo.type === "send-archive") {
        const zip = new Zip(this.fileInfo.manifest, plainStream);
        plainStream = zip.stream;
        size3 = zip.size;
      }
      const plaintext = await utilsExports.streamToArrayBuffer(plainStream, size3);
      if (!noSave) {
        await saveFile({
          plaintext,
          name: decodeURIComponent(this.fileInfo.name),
          type: this.fileInfo.type
        });
      }
      this.msg = "downloadFinish";
      this.emit("complete");
      this.state = "complete";
    } catch (e) {
      this.downloadRequest = null;
      throw e;
    }
  }
  async downloadStream(noSave = false) {
    if (!navigator.serviceWorker.controller) {
      console.log("Service worker NA, switching to legacy download");
      return this.downloadBlob(noSave);
    }
    const start2 = Date.now();
    const onprogress = (p) => {
      this.progress = [p, this.fileInfo.size];
      this.emit("progress");
    };
    this.downloadRequest = {
      cancel: () => {
        this.sendMessageToSw({
          request: "cancel",
          id: this.fileInfo.id
        });
      }
    };
    try {
      this.state = "downloading";
      const info = {
        request: "init",
        id: this.fileInfo.id,
        filename: this.fileInfo.name,
        type: this.fileInfo.type,
        manifest: this.fileInfo.manifest,
        key: this.fileInfo.secretKey,
        requiresPassword: this.fileInfo.requiresPassword,
        password: this.fileInfo.password,
        url: this.fileInfo.url,
        size: this.fileInfo.size,
        nonce: this.keychain.nonce,
        noSave
      };
      await this.sendMessageToSw(info);
      onprogress(0);
      if (noSave) {
        const res = await fetch(getApiUrl(`/api/download/${this.fileInfo.id}`));
        if (res.status !== 200) {
          throw new Error(res.status);
        }
      } else {
        const downloadPath = `/api/download/${this.fileInfo.id}`;
        let downloadUrl = getApiUrl(downloadPath);
        if (downloadUrl === downloadPath) {
          downloadUrl = `${location.protocol}//${location.host}${downloadPath}`;
        }
        const a = document.createElement("a");
        a.href = downloadUrl;
        document.body.appendChild(a);
        a.click();
      }
      let prog = 0;
      let hangs = 0;
      while (prog < this.fileInfo.size) {
        const msg = await this.sendMessageToSw({
          request: "progress",
          id: this.fileInfo.id
        });
        if (msg.progress === prog) {
          hangs++;
        } else {
          hangs = 0;
        }
        if (hangs > 30) {
          const e = new Error("hung download");
          e.duration = Date.now() - start2;
          e.size = this.fileInfo.size;
          e.progress = prog;
          throw e;
        }
        prog = msg.progress;
        onprogress(prog);
        await utilsExports.delay(1e3);
      }
      this.downloadRequest = null;
      this.msg = "downloadFinish";
      this.emit("complete");
      this.state = "complete";
    } catch (e) {
      this.downloadRequest = null;
      if (e === "cancelled" || e.message === "400") {
        throw new Error(0);
      }
      throw e;
    }
  }
  download(options) {
    if (options.stream) {
      return this.downloadStream(options.noSave);
    }
    return this.downloadBlob(options.noSave);
  }
}
async function saveFile(file) {
  return new Promise(function(resolve2, reject2) {
    const dataView = new DataView(file.plaintext);
    const blob = new Blob([dataView], {
      type: file.type
    });
    if (navigator.msSaveBlob) {
      navigator.msSaveBlob(blob, file.name);
      return resolve2();
    } else {
      const downloadUrl = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = downloadUrl;
      a.download = file.name;
      document.body.appendChild(a);
      a.click();
      URL.revokeObjectURL(downloadUrl);
      setTimeout(resolve2, 100);
    }
  });
}
class OwnedFile {
  constructor(obj) {
    if (!obj.manifest) {
      throw new Error("invalid file object");
    }
    this.id = obj.id;
    this.url = obj.url;
    this.name = obj.name;
    this.size = obj.size;
    this.manifest = obj.manifest;
    this.time = obj.time;
    this.speed = obj.speed;
    this.createdAt = obj.createdAt;
    this.expiresAt = obj.expiresAt;
    this.ownerToken = obj.ownerToken;
    this.dlimit = obj.dlimit || 1;
    this.dtotal = obj.dtotal || 0;
    this.keychain = new Keychain(obj.secretKey, obj.nonce);
    this._hasPassword = !!obj.hasPassword;
    this.timeLimit = obj.timeLimit;
  }
  get hasPassword() {
    return !!this._hasPassword;
  }
  get expired() {
    return this.dlimit === this.dtotal || Date.now() > this.expiresAt;
  }
  async setPassword(password) {
    try {
      this.password = password;
      this._hasPassword = true;
      this.keychain.setPassword(password, this.url);
      const result = await setPassword(this.id, this.ownerToken, this.keychain);
      return result;
    } catch (e) {
      this.password = null;
      this._hasPassword = false;
      throw e;
    }
  }
  del() {
    return del(this.id, this.ownerToken);
  }
  changeLimit(dlimit) {
    if (this.dlimit !== dlimit) {
      this.dlimit = dlimit;
      return setParams(this.id, this.ownerToken, {
        dlimit
      });
    }
    return Promise.resolve(true);
  }
  async updateDownloadCount() {
    const oldTotal = this.dtotal;
    const oldLimit = this.dlimit;
    try {
      const result = await fileInfo(this.id, this.ownerToken);
      this.dtotal = result.dtotal;
      this.dlimit = result.dlimit;
    } catch (e) {
      if (e.message === "404") {
        this.dtotal = this.dlimit;
      }
    }
    return oldTotal !== this.dtotal || oldLimit !== this.dlimit;
  }
  toJSON() {
    return {
      id: this.id,
      url: this.url,
      name: this.name,
      size: this.size,
      manifest: this.manifest,
      time: this.time,
      speed: this.speed,
      createdAt: this.createdAt,
      expiresAt: this.expiresAt,
      secretKey: utilsExports.arrayToB64(this.keychain.rawSecret),
      ownerToken: this.ownerToken,
      dlimit: this.dlimit,
      dtotal: this.dtotal,
      hasPassword: this.hasPassword,
      timeLimit: this.timeLimit
    };
  }
}
class FileSender extends Nanobus$1 {
  constructor() {
    super("FileSender");
    this.keychain = new Keychain();
    this.reset();
  }
  get progressRatio() {
    return this.progress[0] / this.progress[1];
  }
  get progressIndefinite() {
    return ["fileSizeProgress", "notifyUploadEncryptDone"].indexOf(this.msg) === -1;
  }
  get sizes() {
    return {
      partialSize: utilsExports.bytes(this.progress[0]),
      totalSize: utilsExports.bytes(this.progress[1])
    };
  }
  reset() {
    this.uploadRequest = null;
    this.msg = "importingFile";
    this.progress = [0, 1];
    this.cancelled = false;
  }
  cancel() {
    this.cancelled = true;
    if (this.uploadRequest) {
      this.uploadRequest.cancel();
    }
  }
  async upload(archive) {
    if (this.cancelled) {
      throw new Error(0);
    }
    this.msg = "encryptingFile";
    this.emit("encrypting");
    const totalSize = utilsExports.encryptedSize(archive.size);
    const encStream = await this.keychain.encryptStream(archive.stream);
    const metadata3 = await this.keychain.encryptMetadata(archive);
    const authKeyB64 = await this.keychain.authKeyB64();
    this.uploadRequest = uploadWs(encStream, metadata3, authKeyB64, archive.timeLimit, archive.dlimit, (p) => {
      this.progress = [p, totalSize];
      this.emit("progress");
    });
    if (this.cancelled) {
      throw new Error(0);
    }
    this.msg = "fileSizeProgress";
    this.emit("progress");
    try {
      const result = await this.uploadRequest.result;
      this.msg = "notifyUploadEncryptDone";
      this.uploadRequest = null;
      this.progress = [1, 1];
      const secretKey = utilsExports.arrayToB64(this.keychain.rawSecret);
      const ownedFile = new OwnedFile({
        id: result.id,
        url: `${result.url}#${secretKey}`,
        name: archive.name,
        size: archive.size,
        manifest: archive.manifest,
        time: result.duration,
        speed: archive.size / (result.duration / 1e3),
        createdAt: Date.now(),
        expiresAt: Date.now() + archive.timeLimit * 1e3,
        secretKey,
        nonce: this.keychain.nonce,
        ownerToken: result.ownerToken,
        dlimit: archive.dlimit,
        timeLimit: archive.timeLimit
      });
      return ownedFile;
    } catch (e) {
      this.msg = "errorPageHeader";
      this.uploadRequest = null;
      throw e;
    }
  }
}
var qrcode = { exports: {} };
var hasRequiredQrcode;
function requireQrcode() {
  if (hasRequiredQrcode) return qrcode.exports;
  hasRequiredQrcode = 1;
  (function(module, exports) {
    var qrcode2 = function() {
      var qrcode3 = function(typeNumber, errorCorrectionLevel) {
        var PAD0 = 236;
        var PAD1 = 17;
        var _typeNumber = typeNumber;
        var _errorCorrectionLevel = QRErrorCorrectionLevel[errorCorrectionLevel];
        var _modules = null;
        var _moduleCount = 0;
        var _dataCache = null;
        var _dataList = [];
        var _this = {};
        var makeImpl = function(test2, maskPattern) {
          _moduleCount = _typeNumber * 4 + 17;
          _modules = function(moduleCount) {
            var modules = new Array(moduleCount);
            for (var row = 0; row < moduleCount; row += 1) {
              modules[row] = new Array(moduleCount);
              for (var col = 0; col < moduleCount; col += 1) {
                modules[row][col] = null;
              }
            }
            return modules;
          }(_moduleCount);
          setupPositionProbePattern(0, 0);
          setupPositionProbePattern(_moduleCount - 7, 0);
          setupPositionProbePattern(0, _moduleCount - 7);
          setupPositionAdjustPattern();
          setupTimingPattern();
          setupTypeInfo(test2, maskPattern);
          if (_typeNumber >= 7) {
            setupTypeNumber(test2);
          }
          if (_dataCache == null) {
            _dataCache = createData(_typeNumber, _errorCorrectionLevel, _dataList);
          }
          mapData(_dataCache, maskPattern);
        };
        var setupPositionProbePattern = function(row, col) {
          for (var r = -1; r <= 7; r += 1) {
            if (row + r <= -1 || _moduleCount <= row + r) continue;
            for (var c = -1; c <= 7; c += 1) {
              if (col + c <= -1 || _moduleCount <= col + c) continue;
              if (0 <= r && r <= 6 && (c == 0 || c == 6) || 0 <= c && c <= 6 && (r == 0 || r == 6) || 2 <= r && r <= 4 && 2 <= c && c <= 4) {
                _modules[row + r][col + c] = true;
              } else {
                _modules[row + r][col + c] = false;
              }
            }
          }
        };
        var getBestMaskPattern = function() {
          var minLostPoint = 0;
          var pattern = 0;
          for (var i = 0; i < 8; i += 1) {
            makeImpl(true, i);
            var lostPoint = QRUtil.getLostPoint(_this);
            if (i == 0 || minLostPoint > lostPoint) {
              minLostPoint = lostPoint;
              pattern = i;
            }
          }
          return pattern;
        };
        var setupTimingPattern = function() {
          for (var r = 8; r < _moduleCount - 8; r += 1) {
            if (_modules[r][6] != null) {
              continue;
            }
            _modules[r][6] = r % 2 == 0;
          }
          for (var c = 8; c < _moduleCount - 8; c += 1) {
            if (_modules[6][c] != null) {
              continue;
            }
            _modules[6][c] = c % 2 == 0;
          }
        };
        var setupPositionAdjustPattern = function() {
          var pos = QRUtil.getPatternPosition(_typeNumber);
          for (var i = 0; i < pos.length; i += 1) {
            for (var j = 0; j < pos.length; j += 1) {
              var row = pos[i];
              var col = pos[j];
              if (_modules[row][col] != null) {
                continue;
              }
              for (var r = -2; r <= 2; r += 1) {
                for (var c = -2; c <= 2; c += 1) {
                  if (r == -2 || r == 2 || c == -2 || c == 2 || r == 0 && c == 0) {
                    _modules[row + r][col + c] = true;
                  } else {
                    _modules[row + r][col + c] = false;
                  }
                }
              }
            }
          }
        };
        var setupTypeNumber = function(test2) {
          var bits = QRUtil.getBCHTypeNumber(_typeNumber);
          for (var i = 0; i < 18; i += 1) {
            var mod = !test2 && (bits >> i & 1) == 1;
            _modules[Math.floor(i / 3)][i % 3 + _moduleCount - 8 - 3] = mod;
          }
          for (var i = 0; i < 18; i += 1) {
            var mod = !test2 && (bits >> i & 1) == 1;
            _modules[i % 3 + _moduleCount - 8 - 3][Math.floor(i / 3)] = mod;
          }
        };
        var setupTypeInfo = function(test2, maskPattern) {
          var data2 = _errorCorrectionLevel << 3 | maskPattern;
          var bits = QRUtil.getBCHTypeInfo(data2);
          for (var i = 0; i < 15; i += 1) {
            var mod = !test2 && (bits >> i & 1) == 1;
            if (i < 6) {
              _modules[i][8] = mod;
            } else if (i < 8) {
              _modules[i + 1][8] = mod;
            } else {
              _modules[_moduleCount - 15 + i][8] = mod;
            }
          }
          for (var i = 0; i < 15; i += 1) {
            var mod = !test2 && (bits >> i & 1) == 1;
            if (i < 8) {
              _modules[8][_moduleCount - i - 1] = mod;
            } else if (i < 9) {
              _modules[8][15 - i - 1 + 1] = mod;
            } else {
              _modules[8][15 - i - 1] = mod;
            }
          }
          _modules[_moduleCount - 8][8] = !test2;
        };
        var mapData = function(data2, maskPattern) {
          var inc = -1;
          var row = _moduleCount - 1;
          var bitIndex = 7;
          var byteIndex = 0;
          var maskFunc = QRUtil.getMaskFunction(maskPattern);
          for (var col = _moduleCount - 1; col > 0; col -= 2) {
            if (col == 6) col -= 1;
            while (true) {
              for (var c = 0; c < 2; c += 1) {
                if (_modules[row][col - c] == null) {
                  var dark = false;
                  if (byteIndex < data2.length) {
                    dark = (data2[byteIndex] >>> bitIndex & 1) == 1;
                  }
                  var mask = maskFunc(row, col - c);
                  if (mask) {
                    dark = !dark;
                  }
                  _modules[row][col - c] = dark;
                  bitIndex -= 1;
                  if (bitIndex == -1) {
                    byteIndex += 1;
                    bitIndex = 7;
                  }
                }
              }
              row += inc;
              if (row < 0 || _moduleCount <= row) {
                row -= inc;
                inc = -inc;
                break;
              }
            }
          }
        };
        var createBytes = function(buffer2, rsBlocks) {
          var offset = 0;
          var maxDcCount = 0;
          var maxEcCount = 0;
          var dcdata = new Array(rsBlocks.length);
          var ecdata = new Array(rsBlocks.length);
          for (var r = 0; r < rsBlocks.length; r += 1) {
            var dcCount = rsBlocks[r].dataCount;
            var ecCount = rsBlocks[r].totalCount - dcCount;
            maxDcCount = Math.max(maxDcCount, dcCount);
            maxEcCount = Math.max(maxEcCount, ecCount);
            dcdata[r] = new Array(dcCount);
            for (var i = 0; i < dcdata[r].length; i += 1) {
              dcdata[r][i] = 255 & buffer2.getBuffer()[i + offset];
            }
            offset += dcCount;
            var rsPoly = QRUtil.getErrorCorrectPolynomial(ecCount);
            var rawPoly = qrPolynomial(dcdata[r], rsPoly.getLength() - 1);
            var modPoly = rawPoly.mod(rsPoly);
            ecdata[r] = new Array(rsPoly.getLength() - 1);
            for (var i = 0; i < ecdata[r].length; i += 1) {
              var modIndex = i + modPoly.getLength() - ecdata[r].length;
              ecdata[r][i] = modIndex >= 0 ? modPoly.getAt(modIndex) : 0;
            }
          }
          var totalCodeCount = 0;
          for (var i = 0; i < rsBlocks.length; i += 1) {
            totalCodeCount += rsBlocks[i].totalCount;
          }
          var data2 = new Array(totalCodeCount);
          var index = 0;
          for (var i = 0; i < maxDcCount; i += 1) {
            for (var r = 0; r < rsBlocks.length; r += 1) {
              if (i < dcdata[r].length) {
                data2[index] = dcdata[r][i];
                index += 1;
              }
            }
          }
          for (var i = 0; i < maxEcCount; i += 1) {
            for (var r = 0; r < rsBlocks.length; r += 1) {
              if (i < ecdata[r].length) {
                data2[index] = ecdata[r][i];
                index += 1;
              }
            }
          }
          return data2;
        };
        var createData = function(typeNumber2, errorCorrectionLevel2, dataList) {
          var rsBlocks = QRRSBlock.getRSBlocks(typeNumber2, errorCorrectionLevel2);
          var buffer2 = qrBitBuffer();
          for (var i = 0; i < dataList.length; i += 1) {
            var data2 = dataList[i];
            buffer2.put(data2.getMode(), 4);
            buffer2.put(data2.getLength(), QRUtil.getLengthInBits(data2.getMode(), typeNumber2));
            data2.write(buffer2);
          }
          var totalDataCount = 0;
          for (var i = 0; i < rsBlocks.length; i += 1) {
            totalDataCount += rsBlocks[i].dataCount;
          }
          if (buffer2.getLengthInBits() > totalDataCount * 8) {
            throw "code length overflow. (" + buffer2.getLengthInBits() + ">" + totalDataCount * 8 + ")";
          }
          if (buffer2.getLengthInBits() + 4 <= totalDataCount * 8) {
            buffer2.put(0, 4);
          }
          while (buffer2.getLengthInBits() % 8 != 0) {
            buffer2.putBit(false);
          }
          while (true) {
            if (buffer2.getLengthInBits() >= totalDataCount * 8) {
              break;
            }
            buffer2.put(PAD0, 8);
            if (buffer2.getLengthInBits() >= totalDataCount * 8) {
              break;
            }
            buffer2.put(PAD1, 8);
          }
          return createBytes(buffer2, rsBlocks);
        };
        _this.addData = function(data2, mode) {
          mode = mode || "Byte";
          var newData = null;
          switch (mode) {
            case "Numeric":
              newData = qrNumber(data2);
              break;
            case "Alphanumeric":
              newData = qrAlphaNum(data2);
              break;
            case "Byte":
              newData = qr8BitByte(data2);
              break;
            case "Kanji":
              newData = qrKanji(data2);
              break;
            default:
              throw "mode:" + mode;
          }
          _dataList.push(newData);
          _dataCache = null;
        };
        _this.isDark = function(row, col) {
          if (row < 0 || _moduleCount <= row || col < 0 || _moduleCount <= col) {
            throw row + "," + col;
          }
          return _modules[row][col];
        };
        _this.getModuleCount = function() {
          return _moduleCount;
        };
        _this.make = function() {
          if (_typeNumber < 1) {
            var typeNumber2 = 1;
            for (; typeNumber2 < 40; typeNumber2++) {
              var rsBlocks = QRRSBlock.getRSBlocks(typeNumber2, _errorCorrectionLevel);
              var buffer2 = qrBitBuffer();
              for (var i = 0; i < _dataList.length; i++) {
                var data2 = _dataList[i];
                buffer2.put(data2.getMode(), 4);
                buffer2.put(data2.getLength(), QRUtil.getLengthInBits(data2.getMode(), typeNumber2));
                data2.write(buffer2);
              }
              var totalDataCount = 0;
              for (var i = 0; i < rsBlocks.length; i++) {
                totalDataCount += rsBlocks[i].dataCount;
              }
              if (buffer2.getLengthInBits() <= totalDataCount * 8) {
                break;
              }
            }
            _typeNumber = typeNumber2;
          }
          makeImpl(false, getBestMaskPattern());
        };
        _this.createTableTag = function(cellSize, margin) {
          cellSize = cellSize || 2;
          margin = typeof margin == "undefined" ? cellSize * 4 : margin;
          var qrHtml = "";
          qrHtml += '<table style="';
          qrHtml += " border-width: 0px; border-style: none;";
          qrHtml += " border-collapse: collapse;";
          qrHtml += " padding: 0px; margin: " + margin + "px;";
          qrHtml += '">';
          qrHtml += "<tbody>";
          for (var r = 0; r < _this.getModuleCount(); r += 1) {
            qrHtml += "<tr>";
            for (var c = 0; c < _this.getModuleCount(); c += 1) {
              qrHtml += '<td style="';
              qrHtml += " border-width: 0px; border-style: none;";
              qrHtml += " border-collapse: collapse;";
              qrHtml += " padding: 0px; margin: 0px;";
              qrHtml += " width: " + cellSize + "px;";
              qrHtml += " height: " + cellSize + "px;";
              qrHtml += " background-color: ";
              qrHtml += _this.isDark(r, c) ? "#000000" : "#ffffff";
              qrHtml += ";";
              qrHtml += '"/>';
            }
            qrHtml += "</tr>";
          }
          qrHtml += "</tbody>";
          qrHtml += "</table>";
          return qrHtml;
        };
        _this.createSvgTag = function(cellSize, margin, alt, title) {
          var opts = {};
          if (typeof arguments[0] == "object") {
            opts = arguments[0];
            cellSize = opts.cellSize;
            margin = opts.margin;
            alt = opts.alt;
            title = opts.title;
          }
          cellSize = cellSize || 2;
          margin = typeof margin == "undefined" ? cellSize * 4 : margin;
          alt = typeof alt === "string" ? {
            text: alt
          } : alt || {};
          alt.text = alt.text || null;
          alt.id = alt.text ? alt.id || "qrcode-description" : null;
          title = typeof title === "string" ? {
            text: title
          } : title || {};
          title.text = title.text || null;
          title.id = title.text ? title.id || "qrcode-title" : null;
          var size3 = _this.getModuleCount() * cellSize + margin * 2;
          var c, mc, r, mr, qrSvg = "", rect;
          rect = "l" + cellSize + ",0 0," + cellSize + " -" + cellSize + ",0 0,-" + cellSize + "z ";
          qrSvg += '<svg version="1.1" xmlns="http://www.w3.org/2000/svg"';
          qrSvg += !opts.scalable ? ' width="' + size3 + 'px" height="' + size3 + 'px"' : "";
          qrSvg += ' viewBox="0 0 ' + size3 + " " + size3 + '" ';
          qrSvg += ' preserveAspectRatio="xMinYMin meet"';
          qrSvg += title.text || alt.text ? ' role="img" aria-labelledby="' + escapeXml([title.id, alt.id].join(" ").trim()) + '"' : "";
          qrSvg += ">";
          qrSvg += title.text ? '<title id="' + escapeXml(title.id) + '">' + escapeXml(title.text) + "</title>" : "";
          qrSvg += alt.text ? '<description id="' + escapeXml(alt.id) + '">' + escapeXml(alt.text) + "</description>" : "";
          qrSvg += '<rect width="100%" height="100%" fill="white" cx="0" cy="0"/>';
          qrSvg += '<path d="';
          for (r = 0; r < _this.getModuleCount(); r += 1) {
            mr = r * cellSize + margin;
            for (c = 0; c < _this.getModuleCount(); c += 1) {
              if (_this.isDark(r, c)) {
                mc = c * cellSize + margin;
                qrSvg += "M" + mc + "," + mr + rect;
              }
            }
          }
          qrSvg += '" stroke="transparent" fill="black"/>';
          qrSvg += "</svg>";
          return qrSvg;
        };
        _this.createDataURL = function(cellSize, margin) {
          cellSize = cellSize || 2;
          margin = typeof margin == "undefined" ? cellSize * 4 : margin;
          var size3 = _this.getModuleCount() * cellSize + margin * 2;
          var min2 = margin;
          var max2 = size3 - margin;
          return createDataURL(size3, size3, function(x, y) {
            if (min2 <= x && x < max2 && min2 <= y && y < max2) {
              var c = Math.floor((x - min2) / cellSize);
              var r = Math.floor((y - min2) / cellSize);
              return _this.isDark(r, c) ? 0 : 1;
            } else {
              return 1;
            }
          });
        };
        _this.createImgTag = function(cellSize, margin, alt) {
          cellSize = cellSize || 2;
          margin = typeof margin == "undefined" ? cellSize * 4 : margin;
          var size3 = _this.getModuleCount() * cellSize + margin * 2;
          var img = "";
          img += "<img";
          img += ' src="';
          img += _this.createDataURL(cellSize, margin);
          img += '"';
          img += ' width="';
          img += size3;
          img += '"';
          img += ' height="';
          img += size3;
          img += '"';
          if (alt) {
            img += ' alt="';
            img += escapeXml(alt);
            img += '"';
          }
          img += "/>";
          return img;
        };
        var escapeXml = function(s) {
          var escaped = "";
          for (var i = 0; i < s.length; i += 1) {
            var c = s.charAt(i);
            switch (c) {
              case "<":
                escaped += "&lt;";
                break;
              case ">":
                escaped += "&gt;";
                break;
              case "&":
                escaped += "&amp;";
                break;
              case '"':
                escaped += "&quot;";
                break;
              default:
                escaped += c;
                break;
            }
          }
          return escaped;
        };
        var _createHalfASCII = function(margin) {
          var cellSize = 1;
          margin = typeof margin == "undefined" ? cellSize * 2 : margin;
          var size3 = _this.getModuleCount() * cellSize + margin * 2;
          var min2 = margin;
          var max2 = size3 - margin;
          var y, x, r1, r2, p;
          var blocks = {
            "": "",
            " ": "",
            " ": "",
            "  ": " "
          };
          var blocksLastLineNoMargin = {
            "": "",
            " ": "",
            " ": " ",
            "  ": " "
          };
          var ascii = "";
          for (y = 0; y < size3; y += 2) {
            r1 = Math.floor((y - min2) / cellSize);
            r2 = Math.floor((y + 1 - min2) / cellSize);
            for (x = 0; x < size3; x += 1) {
              p = "";
              if (min2 <= x && x < max2 && min2 <= y && y < max2 && _this.isDark(r1, Math.floor((x - min2) / cellSize))) {
                p = " ";
              }
              if (min2 <= x && x < max2 && min2 <= y + 1 && y + 1 < max2 && _this.isDark(r2, Math.floor((x - min2) / cellSize))) {
                p += " ";
              } else {
                p += "";
              }
              ascii += margin < 1 && y + 1 >= max2 ? blocksLastLineNoMargin[p] : blocks[p];
            }
            ascii += "\n";
          }
          if (size3 % 2 && margin > 0) {
            return ascii.substring(0, ascii.length - size3 - 1) + Array(size3 + 1).join("");
          }
          return ascii.substring(0, ascii.length - 1);
        };
        _this.createASCII = function(cellSize, margin) {
          cellSize = cellSize || 1;
          if (cellSize < 2) {
            return _createHalfASCII(margin);
          }
          cellSize -= 1;
          margin = typeof margin == "undefined" ? cellSize * 2 : margin;
          var size3 = _this.getModuleCount() * cellSize + margin * 2;
          var min2 = margin;
          var max2 = size3 - margin;
          var y, x, r, p;
          var white = Array(cellSize + 1).join("");
          var black = Array(cellSize + 1).join("  ");
          var ascii = "";
          var line = "";
          for (y = 0; y < size3; y += 1) {
            r = Math.floor((y - min2) / cellSize);
            line = "";
            for (x = 0; x < size3; x += 1) {
              p = 1;
              if (min2 <= x && x < max2 && min2 <= y && y < max2 && _this.isDark(r, Math.floor((x - min2) / cellSize))) {
                p = 0;
              }
              line += p ? white : black;
            }
            for (r = 0; r < cellSize; r += 1) {
              ascii += line + "\n";
            }
          }
          return ascii.substring(0, ascii.length - 1);
        };
        _this.renderTo2dContext = function(context, cellSize) {
          cellSize = cellSize || 2;
          var length = _this.getModuleCount();
          for (var row = 0; row < length; row++) {
            for (var col = 0; col < length; col++) {
              context.fillStyle = _this.isDark(row, col) ? "black" : "white";
              context.fillRect(row * cellSize, col * cellSize, cellSize, cellSize);
            }
          }
        };
        return _this;
      };
      qrcode3.stringToBytesFuncs = {
        default: function(s) {
          var bytes = [];
          for (var i = 0; i < s.length; i += 1) {
            var c = s.charCodeAt(i);
            bytes.push(c & 255);
          }
          return bytes;
        }
      };
      qrcode3.stringToBytes = qrcode3.stringToBytesFuncs["default"];
      qrcode3.createStringToBytes = function(unicodeData, numChars) {
        var unicodeMap = function() {
          var bin = base64DecodeInputStream(unicodeData);
          var read = function() {
            var b = bin.read();
            if (b == -1) throw "eof";
            return b;
          };
          var count = 0;
          var unicodeMap2 = {};
          while (true) {
            var b0 = bin.read();
            if (b0 == -1) break;
            var b1 = read();
            var b2 = read();
            var b3 = read();
            var k = String.fromCharCode(b0 << 8 | b1);
            var v = b2 << 8 | b3;
            unicodeMap2[k] = v;
            count += 1;
          }
          if (count != numChars) {
            throw count + " != " + numChars;
          }
          return unicodeMap2;
        }();
        var unknownChar = "?".charCodeAt(0);
        return function(s) {
          var bytes = [];
          for (var i = 0; i < s.length; i += 1) {
            var c = s.charCodeAt(i);
            if (c < 128) {
              bytes.push(c);
            } else {
              var b = unicodeMap[s.charAt(i)];
              if (typeof b == "number") {
                if ((b & 255) == b) {
                  bytes.push(b);
                } else {
                  bytes.push(b >>> 8);
                  bytes.push(b & 255);
                }
              } else {
                bytes.push(unknownChar);
              }
            }
          }
          return bytes;
        };
      };
      var QRMode = {
        MODE_NUMBER: 1 << 0,
        MODE_ALPHA_NUM: 1 << 1,
        MODE_8BIT_BYTE: 1 << 2,
        MODE_KANJI: 1 << 3
      };
      var QRErrorCorrectionLevel = {
        L: 1,
        M: 0,
        Q: 3,
        H: 2
      };
      var QRMaskPattern = {
        PATTERN000: 0,
        PATTERN001: 1,
        PATTERN010: 2,
        PATTERN011: 3,
        PATTERN100: 4,
        PATTERN101: 5,
        PATTERN110: 6,
        PATTERN111: 7
      };
      var QRUtil = function() {
        var PATTERN_POSITION_TABLE = [[], [6, 18], [6, 22], [6, 26], [6, 30], [6, 34], [6, 22, 38], [6, 24, 42], [6, 26, 46], [6, 28, 50], [6, 30, 54], [6, 32, 58], [6, 34, 62], [6, 26, 46, 66], [6, 26, 48, 70], [6, 26, 50, 74], [6, 30, 54, 78], [6, 30, 56, 82], [6, 30, 58, 86], [6, 34, 62, 90], [6, 28, 50, 72, 94], [6, 26, 50, 74, 98], [6, 30, 54, 78, 102], [6, 28, 54, 80, 106], [6, 32, 58, 84, 110], [6, 30, 58, 86, 114], [6, 34, 62, 90, 118], [6, 26, 50, 74, 98, 122], [6, 30, 54, 78, 102, 126], [6, 26, 52, 78, 104, 130], [6, 30, 56, 82, 108, 134], [6, 34, 60, 86, 112, 138], [6, 30, 58, 86, 114, 142], [6, 34, 62, 90, 118, 146], [6, 30, 54, 78, 102, 126, 150], [6, 24, 50, 76, 102, 128, 154], [6, 28, 54, 80, 106, 132, 158], [6, 32, 58, 84, 110, 136, 162], [6, 26, 54, 82, 110, 138, 166], [6, 30, 58, 86, 114, 142, 170]];
        var G15 = 1 << 10 | 1 << 8 | 1 << 5 | 1 << 4 | 1 << 2 | 1 << 1 | 1 << 0;
        var G18 = 1 << 12 | 1 << 11 | 1 << 10 | 1 << 9 | 1 << 8 | 1 << 5 | 1 << 2 | 1 << 0;
        var G15_MASK = 1 << 14 | 1 << 12 | 1 << 10 | 1 << 4 | 1 << 1;
        var _this = {};
        var getBCHDigit = function(data2) {
          var digit = 0;
          while (data2 != 0) {
            digit += 1;
            data2 >>>= 1;
          }
          return digit;
        };
        _this.getBCHTypeInfo = function(data2) {
          var d = data2 << 10;
          while (getBCHDigit(d) - getBCHDigit(G15) >= 0) {
            d ^= G15 << getBCHDigit(d) - getBCHDigit(G15);
          }
          return (data2 << 10 | d) ^ G15_MASK;
        };
        _this.getBCHTypeNumber = function(data2) {
          var d = data2 << 12;
          while (getBCHDigit(d) - getBCHDigit(G18) >= 0) {
            d ^= G18 << getBCHDigit(d) - getBCHDigit(G18);
          }
          return data2 << 12 | d;
        };
        _this.getPatternPosition = function(typeNumber) {
          return PATTERN_POSITION_TABLE[typeNumber - 1];
        };
        _this.getMaskFunction = function(maskPattern) {
          switch (maskPattern) {
            case QRMaskPattern.PATTERN000:
              return function(i, j) {
                return (i + j) % 2 == 0;
              };
            case QRMaskPattern.PATTERN001:
              return function(i, j) {
                return i % 2 == 0;
              };
            case QRMaskPattern.PATTERN010:
              return function(i, j) {
                return j % 3 == 0;
              };
            case QRMaskPattern.PATTERN011:
              return function(i, j) {
                return (i + j) % 3 == 0;
              };
            case QRMaskPattern.PATTERN100:
              return function(i, j) {
                return (Math.floor(i / 2) + Math.floor(j / 3)) % 2 == 0;
              };
            case QRMaskPattern.PATTERN101:
              return function(i, j) {
                return i * j % 2 + i * j % 3 == 0;
              };
            case QRMaskPattern.PATTERN110:
              return function(i, j) {
                return (i * j % 2 + i * j % 3) % 2 == 0;
              };
            case QRMaskPattern.PATTERN111:
              return function(i, j) {
                return (i * j % 3 + (i + j) % 2) % 2 == 0;
              };
            default:
              throw "bad maskPattern:" + maskPattern;
          }
        };
        _this.getErrorCorrectPolynomial = function(errorCorrectLength) {
          var a = qrPolynomial([1], 0);
          for (var i = 0; i < errorCorrectLength; i += 1) {
            a = a.multiply(qrPolynomial([1, QRMath.gexp(i)], 0));
          }
          return a;
        };
        _this.getLengthInBits = function(mode, type) {
          if (1 <= type && type < 10) {
            switch (mode) {
              case QRMode.MODE_NUMBER:
                return 10;
              case QRMode.MODE_ALPHA_NUM:
                return 9;
              case QRMode.MODE_8BIT_BYTE:
                return 8;
              case QRMode.MODE_KANJI:
                return 8;
              default:
                throw "mode:" + mode;
            }
          } else if (type < 27) {
            switch (mode) {
              case QRMode.MODE_NUMBER:
                return 12;
              case QRMode.MODE_ALPHA_NUM:
                return 11;
              case QRMode.MODE_8BIT_BYTE:
                return 16;
              case QRMode.MODE_KANJI:
                return 10;
              default:
                throw "mode:" + mode;
            }
          } else if (type < 41) {
            switch (mode) {
              case QRMode.MODE_NUMBER:
                return 14;
              case QRMode.MODE_ALPHA_NUM:
                return 13;
              case QRMode.MODE_8BIT_BYTE:
                return 16;
              case QRMode.MODE_KANJI:
                return 12;
              default:
                throw "mode:" + mode;
            }
          } else {
            throw "type:" + type;
          }
        };
        _this.getLostPoint = function(qrcode4) {
          var moduleCount = qrcode4.getModuleCount();
          var lostPoint = 0;
          for (var row = 0; row < moduleCount; row += 1) {
            for (var col = 0; col < moduleCount; col += 1) {
              var sameCount = 0;
              var dark = qrcode4.isDark(row, col);
              for (var r = -1; r <= 1; r += 1) {
                if (row + r < 0 || moduleCount <= row + r) {
                  continue;
                }
                for (var c = -1; c <= 1; c += 1) {
                  if (col + c < 0 || moduleCount <= col + c) {
                    continue;
                  }
                  if (r == 0 && c == 0) {
                    continue;
                  }
                  if (dark == qrcode4.isDark(row + r, col + c)) {
                    sameCount += 1;
                  }
                }
              }
              if (sameCount > 5) {
                lostPoint += 3 + sameCount - 5;
              }
            }
          }
          for (var row = 0; row < moduleCount - 1; row += 1) {
            for (var col = 0; col < moduleCount - 1; col += 1) {
              var count = 0;
              if (qrcode4.isDark(row, col)) count += 1;
              if (qrcode4.isDark(row + 1, col)) count += 1;
              if (qrcode4.isDark(row, col + 1)) count += 1;
              if (qrcode4.isDark(row + 1, col + 1)) count += 1;
              if (count == 0 || count == 4) {
                lostPoint += 3;
              }
            }
          }
          for (var row = 0; row < moduleCount; row += 1) {
            for (var col = 0; col < moduleCount - 6; col += 1) {
              if (qrcode4.isDark(row, col) && !qrcode4.isDark(row, col + 1) && qrcode4.isDark(row, col + 2) && qrcode4.isDark(row, col + 3) && qrcode4.isDark(row, col + 4) && !qrcode4.isDark(row, col + 5) && qrcode4.isDark(row, col + 6)) {
                lostPoint += 40;
              }
            }
          }
          for (var col = 0; col < moduleCount; col += 1) {
            for (var row = 0; row < moduleCount - 6; row += 1) {
              if (qrcode4.isDark(row, col) && !qrcode4.isDark(row + 1, col) && qrcode4.isDark(row + 2, col) && qrcode4.isDark(row + 3, col) && qrcode4.isDark(row + 4, col) && !qrcode4.isDark(row + 5, col) && qrcode4.isDark(row + 6, col)) {
                lostPoint += 40;
              }
            }
          }
          var darkCount = 0;
          for (var col = 0; col < moduleCount; col += 1) {
            for (var row = 0; row < moduleCount; row += 1) {
              if (qrcode4.isDark(row, col)) {
                darkCount += 1;
              }
            }
          }
          var ratio = Math.abs(100 * darkCount / moduleCount / moduleCount - 50) / 5;
          lostPoint += ratio * 10;
          return lostPoint;
        };
        return _this;
      }();
      var QRMath = function() {
        var EXP_TABLE = new Array(256);
        var LOG_TABLE = new Array(256);
        for (var i = 0; i < 8; i += 1) {
          EXP_TABLE[i] = 1 << i;
        }
        for (var i = 8; i < 256; i += 1) {
          EXP_TABLE[i] = EXP_TABLE[i - 4] ^ EXP_TABLE[i - 5] ^ EXP_TABLE[i - 6] ^ EXP_TABLE[i - 8];
        }
        for (var i = 0; i < 255; i += 1) {
          LOG_TABLE[EXP_TABLE[i]] = i;
        }
        var _this = {};
        _this.glog = function(n) {
          if (n < 1) {
            throw "glog(" + n + ")";
          }
          return LOG_TABLE[n];
        };
        _this.gexp = function(n) {
          while (n < 0) {
            n += 255;
          }
          while (n >= 256) {
            n -= 255;
          }
          return EXP_TABLE[n];
        };
        return _this;
      }();
      function qrPolynomial(num, shift2) {
        if (typeof num.length == "undefined") {
          throw num.length + "/" + shift2;
        }
        var _num = function() {
          var offset = 0;
          while (offset < num.length && num[offset] == 0) {
            offset += 1;
          }
          var _num2 = new Array(num.length - offset + shift2);
          for (var i = 0; i < num.length - offset; i += 1) {
            _num2[i] = num[i + offset];
          }
          return _num2;
        }();
        var _this = {};
        _this.getAt = function(index) {
          return _num[index];
        };
        _this.getLength = function() {
          return _num.length;
        };
        _this.multiply = function(e) {
          var num2 = new Array(_this.getLength() + e.getLength() - 1);
          for (var i = 0; i < _this.getLength(); i += 1) {
            for (var j = 0; j < e.getLength(); j += 1) {
              num2[i + j] ^= QRMath.gexp(QRMath.glog(_this.getAt(i)) + QRMath.glog(e.getAt(j)));
            }
          }
          return qrPolynomial(num2, 0);
        };
        _this.mod = function(e) {
          if (_this.getLength() - e.getLength() < 0) {
            return _this;
          }
          var ratio = QRMath.glog(_this.getAt(0)) - QRMath.glog(e.getAt(0));
          var num2 = new Array(_this.getLength());
          for (var i = 0; i < _this.getLength(); i += 1) {
            num2[i] = _this.getAt(i);
          }
          for (var i = 0; i < e.getLength(); i += 1) {
            num2[i] ^= QRMath.gexp(QRMath.glog(e.getAt(i)) + ratio);
          }
          return qrPolynomial(num2, 0).mod(e);
        };
        return _this;
      }
      var QRRSBlock = function() {
        var RS_BLOCK_TABLE = [
          // L
          // M
          // Q
          // H
          // 1
          [1, 26, 19],
          [1, 26, 16],
          [1, 26, 13],
          [1, 26, 9],
          // 2
          [1, 44, 34],
          [1, 44, 28],
          [1, 44, 22],
          [1, 44, 16],
          // 3
          [1, 70, 55],
          [1, 70, 44],
          [2, 35, 17],
          [2, 35, 13],
          // 4
          [1, 100, 80],
          [2, 50, 32],
          [2, 50, 24],
          [4, 25, 9],
          // 5
          [1, 134, 108],
          [2, 67, 43],
          [2, 33, 15, 2, 34, 16],
          [2, 33, 11, 2, 34, 12],
          // 6
          [2, 86, 68],
          [4, 43, 27],
          [4, 43, 19],
          [4, 43, 15],
          // 7
          [2, 98, 78],
          [4, 49, 31],
          [2, 32, 14, 4, 33, 15],
          [4, 39, 13, 1, 40, 14],
          // 8
          [2, 121, 97],
          [2, 60, 38, 2, 61, 39],
          [4, 40, 18, 2, 41, 19],
          [4, 40, 14, 2, 41, 15],
          // 9
          [2, 146, 116],
          [3, 58, 36, 2, 59, 37],
          [4, 36, 16, 4, 37, 17],
          [4, 36, 12, 4, 37, 13],
          // 10
          [2, 86, 68, 2, 87, 69],
          [4, 69, 43, 1, 70, 44],
          [6, 43, 19, 2, 44, 20],
          [6, 43, 15, 2, 44, 16],
          // 11
          [4, 101, 81],
          [1, 80, 50, 4, 81, 51],
          [4, 50, 22, 4, 51, 23],
          [3, 36, 12, 8, 37, 13],
          // 12
          [2, 116, 92, 2, 117, 93],
          [6, 58, 36, 2, 59, 37],
          [4, 46, 20, 6, 47, 21],
          [7, 42, 14, 4, 43, 15],
          // 13
          [4, 133, 107],
          [8, 59, 37, 1, 60, 38],
          [8, 44, 20, 4, 45, 21],
          [12, 33, 11, 4, 34, 12],
          // 14
          [3, 145, 115, 1, 146, 116],
          [4, 64, 40, 5, 65, 41],
          [11, 36, 16, 5, 37, 17],
          [11, 36, 12, 5, 37, 13],
          // 15
          [5, 109, 87, 1, 110, 88],
          [5, 65, 41, 5, 66, 42],
          [5, 54, 24, 7, 55, 25],
          [11, 36, 12, 7, 37, 13],
          // 16
          [5, 122, 98, 1, 123, 99],
          [7, 73, 45, 3, 74, 46],
          [15, 43, 19, 2, 44, 20],
          [3, 45, 15, 13, 46, 16],
          // 17
          [1, 135, 107, 5, 136, 108],
          [10, 74, 46, 1, 75, 47],
          [1, 50, 22, 15, 51, 23],
          [2, 42, 14, 17, 43, 15],
          // 18
          [5, 150, 120, 1, 151, 121],
          [9, 69, 43, 4, 70, 44],
          [17, 50, 22, 1, 51, 23],
          [2, 42, 14, 19, 43, 15],
          // 19
          [3, 141, 113, 4, 142, 114],
          [3, 70, 44, 11, 71, 45],
          [17, 47, 21, 4, 48, 22],
          [9, 39, 13, 16, 40, 14],
          // 20
          [3, 135, 107, 5, 136, 108],
          [3, 67, 41, 13, 68, 42],
          [15, 54, 24, 5, 55, 25],
          [15, 43, 15, 10, 44, 16],
          // 21
          [4, 144, 116, 4, 145, 117],
          [17, 68, 42],
          [17, 50, 22, 6, 51, 23],
          [19, 46, 16, 6, 47, 17],
          // 22
          [2, 139, 111, 7, 140, 112],
          [17, 74, 46],
          [7, 54, 24, 16, 55, 25],
          [34, 37, 13],
          // 23
          [4, 151, 121, 5, 152, 122],
          [4, 75, 47, 14, 76, 48],
          [11, 54, 24, 14, 55, 25],
          [16, 45, 15, 14, 46, 16],
          // 24
          [6, 147, 117, 4, 148, 118],
          [6, 73, 45, 14, 74, 46],
          [11, 54, 24, 16, 55, 25],
          [30, 46, 16, 2, 47, 17],
          // 25
          [8, 132, 106, 4, 133, 107],
          [8, 75, 47, 13, 76, 48],
          [7, 54, 24, 22, 55, 25],
          [22, 45, 15, 13, 46, 16],
          // 26
          [10, 142, 114, 2, 143, 115],
          [19, 74, 46, 4, 75, 47],
          [28, 50, 22, 6, 51, 23],
          [33, 46, 16, 4, 47, 17],
          // 27
          [8, 152, 122, 4, 153, 123],
          [22, 73, 45, 3, 74, 46],
          [8, 53, 23, 26, 54, 24],
          [12, 45, 15, 28, 46, 16],
          // 28
          [3, 147, 117, 10, 148, 118],
          [3, 73, 45, 23, 74, 46],
          [4, 54, 24, 31, 55, 25],
          [11, 45, 15, 31, 46, 16],
          // 29
          [7, 146, 116, 7, 147, 117],
          [21, 73, 45, 7, 74, 46],
          [1, 53, 23, 37, 54, 24],
          [19, 45, 15, 26, 46, 16],
          // 30
          [5, 145, 115, 10, 146, 116],
          [19, 75, 47, 10, 76, 48],
          [15, 54, 24, 25, 55, 25],
          [23, 45, 15, 25, 46, 16],
          // 31
          [13, 145, 115, 3, 146, 116],
          [2, 74, 46, 29, 75, 47],
          [42, 54, 24, 1, 55, 25],
          [23, 45, 15, 28, 46, 16],
          // 32
          [17, 145, 115],
          [10, 74, 46, 23, 75, 47],
          [10, 54, 24, 35, 55, 25],
          [19, 45, 15, 35, 46, 16],
          // 33
          [17, 145, 115, 1, 146, 116],
          [14, 74, 46, 21, 75, 47],
          [29, 54, 24, 19, 55, 25],
          [11, 45, 15, 46, 46, 16],
          // 34
          [13, 145, 115, 6, 146, 116],
          [14, 74, 46, 23, 75, 47],
          [44, 54, 24, 7, 55, 25],
          [59, 46, 16, 1, 47, 17],
          // 35
          [12, 151, 121, 7, 152, 122],
          [12, 75, 47, 26, 76, 48],
          [39, 54, 24, 14, 55, 25],
          [22, 45, 15, 41, 46, 16],
          // 36
          [6, 151, 121, 14, 152, 122],
          [6, 75, 47, 34, 76, 48],
          [46, 54, 24, 10, 55, 25],
          [2, 45, 15, 64, 46, 16],
          // 37
          [17, 152, 122, 4, 153, 123],
          [29, 74, 46, 14, 75, 47],
          [49, 54, 24, 10, 55, 25],
          [24, 45, 15, 46, 46, 16],
          // 38
          [4, 152, 122, 18, 153, 123],
          [13, 74, 46, 32, 75, 47],
          [48, 54, 24, 14, 55, 25],
          [42, 45, 15, 32, 46, 16],
          // 39
          [20, 147, 117, 4, 148, 118],
          [40, 75, 47, 7, 76, 48],
          [43, 54, 24, 22, 55, 25],
          [10, 45, 15, 67, 46, 16],
          // 40
          [19, 148, 118, 6, 149, 119],
          [18, 75, 47, 31, 76, 48],
          [34, 54, 24, 34, 55, 25],
          [20, 45, 15, 61, 46, 16]
        ];
        var qrRSBlock = function(totalCount, dataCount) {
          var _this2 = {};
          _this2.totalCount = totalCount;
          _this2.dataCount = dataCount;
          return _this2;
        };
        var _this = {};
        var getRsBlockTable = function(typeNumber, errorCorrectionLevel) {
          switch (errorCorrectionLevel) {
            case QRErrorCorrectionLevel.L:
              return RS_BLOCK_TABLE[(typeNumber - 1) * 4 + 0];
            case QRErrorCorrectionLevel.M:
              return RS_BLOCK_TABLE[(typeNumber - 1) * 4 + 1];
            case QRErrorCorrectionLevel.Q:
              return RS_BLOCK_TABLE[(typeNumber - 1) * 4 + 2];
            case QRErrorCorrectionLevel.H:
              return RS_BLOCK_TABLE[(typeNumber - 1) * 4 + 3];
            default:
              return void 0;
          }
        };
        _this.getRSBlocks = function(typeNumber, errorCorrectionLevel) {
          var rsBlock = getRsBlockTable(typeNumber, errorCorrectionLevel);
          if (typeof rsBlock == "undefined") {
            throw "bad rs block @ typeNumber:" + typeNumber + "/errorCorrectionLevel:" + errorCorrectionLevel;
          }
          var length = rsBlock.length / 3;
          var list = [];
          for (var i = 0; i < length; i += 1) {
            var count = rsBlock[i * 3 + 0];
            var totalCount = rsBlock[i * 3 + 1];
            var dataCount = rsBlock[i * 3 + 2];
            for (var j = 0; j < count; j += 1) {
              list.push(qrRSBlock(totalCount, dataCount));
            }
          }
          return list;
        };
        return _this;
      }();
      var qrBitBuffer = function() {
        var _buffer = [];
        var _length = 0;
        var _this = {};
        _this.getBuffer = function() {
          return _buffer;
        };
        _this.getAt = function(index) {
          var bufIndex = Math.floor(index / 8);
          return (_buffer[bufIndex] >>> 7 - index % 8 & 1) == 1;
        };
        _this.put = function(num, length) {
          for (var i = 0; i < length; i += 1) {
            _this.putBit((num >>> length - i - 1 & 1) == 1);
          }
        };
        _this.getLengthInBits = function() {
          return _length;
        };
        _this.putBit = function(bit) {
          var bufIndex = Math.floor(_length / 8);
          if (_buffer.length <= bufIndex) {
            _buffer.push(0);
          }
          if (bit) {
            _buffer[bufIndex] |= 128 >>> _length % 8;
          }
          _length += 1;
        };
        return _this;
      };
      var qrNumber = function(data2) {
        var _mode = QRMode.MODE_NUMBER;
        var _data = data2;
        var _this = {};
        _this.getMode = function() {
          return _mode;
        };
        _this.getLength = function(buffer2) {
          return _data.length;
        };
        _this.write = function(buffer2) {
          var data3 = _data;
          var i = 0;
          while (i + 2 < data3.length) {
            buffer2.put(strToNum(data3.substring(i, i + 3)), 10);
            i += 3;
          }
          if (i < data3.length) {
            if (data3.length - i == 1) {
              buffer2.put(strToNum(data3.substring(i, i + 1)), 4);
            } else if (data3.length - i == 2) {
              buffer2.put(strToNum(data3.substring(i, i + 2)), 7);
            }
          }
        };
        var strToNum = function(s) {
          var num = 0;
          for (var i = 0; i < s.length; i += 1) {
            num = num * 10 + chatToNum(s.charAt(i));
          }
          return num;
        };
        var chatToNum = function(c) {
          if ("0" <= c && c <= "9") {
            return c.charCodeAt(0) - "0".charCodeAt(0);
          }
          throw "illegal char :" + c;
        };
        return _this;
      };
      var qrAlphaNum = function(data2) {
        var _mode = QRMode.MODE_ALPHA_NUM;
        var _data = data2;
        var _this = {};
        _this.getMode = function() {
          return _mode;
        };
        _this.getLength = function(buffer2) {
          return _data.length;
        };
        _this.write = function(buffer2) {
          var s = _data;
          var i = 0;
          while (i + 1 < s.length) {
            buffer2.put(getCode(s.charAt(i)) * 45 + getCode(s.charAt(i + 1)), 11);
            i += 2;
          }
          if (i < s.length) {
            buffer2.put(getCode(s.charAt(i)), 6);
          }
        };
        var getCode = function(c) {
          if ("0" <= c && c <= "9") {
            return c.charCodeAt(0) - "0".charCodeAt(0);
          } else if ("A" <= c && c <= "Z") {
            return c.charCodeAt(0) - "A".charCodeAt(0) + 10;
          } else {
            switch (c) {
              case " ":
                return 36;
              case "$":
                return 37;
              case "%":
                return 38;
              case "*":
                return 39;
              case "+":
                return 40;
              case "-":
                return 41;
              case ".":
                return 42;
              case "/":
                return 43;
              case ":":
                return 44;
              default:
                throw "illegal char :" + c;
            }
          }
        };
        return _this;
      };
      var qr8BitByte = function(data2) {
        var _mode = QRMode.MODE_8BIT_BYTE;
        var _bytes = qrcode3.stringToBytes(data2);
        var _this = {};
        _this.getMode = function() {
          return _mode;
        };
        _this.getLength = function(buffer2) {
          return _bytes.length;
        };
        _this.write = function(buffer2) {
          for (var i = 0; i < _bytes.length; i += 1) {
            buffer2.put(_bytes[i], 8);
          }
        };
        return _this;
      };
      var qrKanji = function(data2) {
        var _mode = QRMode.MODE_KANJI;
        var stringToBytes = qrcode3.stringToBytesFuncs["SJIS"];
        if (!stringToBytes) {
          throw "sjis not supported.";
        }
        !function(c, code2) {
          var test2 = stringToBytes(c);
          if (test2.length != 2 || (test2[0] << 8 | test2[1]) != code2) {
            throw "sjis not supported.";
          }
        }("", 38726);
        var _bytes = stringToBytes(data2);
        var _this = {};
        _this.getMode = function() {
          return _mode;
        };
        _this.getLength = function(buffer2) {
          return ~~(_bytes.length / 2);
        };
        _this.write = function(buffer2) {
          var data3 = _bytes;
          var i = 0;
          while (i + 1 < data3.length) {
            var c = (255 & data3[i]) << 8 | 255 & data3[i + 1];
            if (33088 <= c && c <= 40956) {
              c -= 33088;
            } else if (57408 <= c && c <= 60351) {
              c -= 49472;
            } else {
              throw "illegal char at " + (i + 1) + "/" + c;
            }
            c = (c >>> 8 & 255) * 192 + (c & 255);
            buffer2.put(c, 13);
            i += 2;
          }
          if (i < data3.length) {
            throw "illegal char at " + (i + 1);
          }
        };
        return _this;
      };
      var byteArrayOutputStream = function() {
        var _bytes = [];
        var _this = {};
        _this.writeByte = function(b) {
          _bytes.push(b & 255);
        };
        _this.writeShort = function(i) {
          _this.writeByte(i);
          _this.writeByte(i >>> 8);
        };
        _this.writeBytes = function(b, off, len) {
          off = off || 0;
          len = len || b.length;
          for (var i = 0; i < len; i += 1) {
            _this.writeByte(b[i + off]);
          }
        };
        _this.writeString = function(s) {
          for (var i = 0; i < s.length; i += 1) {
            _this.writeByte(s.charCodeAt(i));
          }
        };
        _this.toByteArray = function() {
          return _bytes;
        };
        _this.toString = function() {
          var s = "";
          s += "[";
          for (var i = 0; i < _bytes.length; i += 1) {
            if (i > 0) {
              s += ",";
            }
            s += _bytes[i];
          }
          s += "]";
          return s;
        };
        return _this;
      };
      var base64EncodeOutputStream = function() {
        var _buffer = 0;
        var _buflen = 0;
        var _length = 0;
        var _base64 = "";
        var _this = {};
        var writeEncoded = function(b) {
          _base64 += String.fromCharCode(encode2(b & 63));
        };
        var encode2 = function(n) {
          if (n < 0) ;
          else if (n < 26) {
            return 65 + n;
          } else if (n < 52) {
            return 97 + (n - 26);
          } else if (n < 62) {
            return 48 + (n - 52);
          } else if (n == 62) {
            return 43;
          } else if (n == 63) {
            return 47;
          }
          throw "n:" + n;
        };
        _this.writeByte = function(n) {
          _buffer = _buffer << 8 | n & 255;
          _buflen += 8;
          _length += 1;
          while (_buflen >= 6) {
            writeEncoded(_buffer >>> _buflen - 6);
            _buflen -= 6;
          }
        };
        _this.flush = function() {
          if (_buflen > 0) {
            writeEncoded(_buffer << 6 - _buflen);
            _buffer = 0;
            _buflen = 0;
          }
          if (_length % 3 != 0) {
            var padlen = 3 - _length % 3;
            for (var i = 0; i < padlen; i += 1) {
              _base64 += "=";
            }
          }
        };
        _this.toString = function() {
          return _base64;
        };
        return _this;
      };
      var base64DecodeInputStream = function(str) {
        var _str = str;
        var _pos = 0;
        var _buffer = 0;
        var _buflen = 0;
        var _this = {};
        _this.read = function() {
          while (_buflen < 8) {
            if (_pos >= _str.length) {
              if (_buflen == 0) {
                return -1;
              }
              throw "unexpected end of file./" + _buflen;
            }
            var c = _str.charAt(_pos);
            _pos += 1;
            if (c == "=") {
              _buflen = 0;
              return -1;
            } else if (c.match(/^\s$/)) {
              continue;
            }
            _buffer = _buffer << 6 | decode2(c.charCodeAt(0));
            _buflen += 6;
          }
          var n = _buffer >>> _buflen - 8 & 255;
          _buflen -= 8;
          return n;
        };
        var decode2 = function(c) {
          if (65 <= c && c <= 90) {
            return c - 65;
          } else if (97 <= c && c <= 122) {
            return c - 97 + 26;
          } else if (48 <= c && c <= 57) {
            return c - 48 + 52;
          } else if (c == 43) {
            return 62;
          } else if (c == 47) {
            return 63;
          } else {
            throw "c:" + c;
          }
        };
        return _this;
      };
      var gifImage = function(width, height) {
        var _width = width;
        var _height = height;
        var _data = new Array(width * height);
        var _this = {};
        _this.setPixel = function(x, y, pixel) {
          _data[y * _width + x] = pixel;
        };
        _this.write = function(out) {
          out.writeString("GIF87a");
          out.writeShort(_width);
          out.writeShort(_height);
          out.writeByte(128);
          out.writeByte(0);
          out.writeByte(0);
          out.writeByte(0);
          out.writeByte(0);
          out.writeByte(0);
          out.writeByte(255);
          out.writeByte(255);
          out.writeByte(255);
          out.writeString(",");
          out.writeShort(0);
          out.writeShort(0);
          out.writeShort(_width);
          out.writeShort(_height);
          out.writeByte(0);
          var lzwMinCodeSize = 2;
          var raster = getLZWRaster(lzwMinCodeSize);
          out.writeByte(lzwMinCodeSize);
          var offset = 0;
          while (raster.length - offset > 255) {
            out.writeByte(255);
            out.writeBytes(raster, offset, 255);
            offset += 255;
          }
          out.writeByte(raster.length - offset);
          out.writeBytes(raster, offset, raster.length - offset);
          out.writeByte(0);
          out.writeString(";");
        };
        var bitOutputStream = function(out) {
          var _out = out;
          var _bitLength = 0;
          var _bitBuffer = 0;
          var _this2 = {};
          _this2.write = function(data2, length) {
            if (data2 >>> length != 0) {
              throw "length over";
            }
            while (_bitLength + length >= 8) {
              _out.writeByte(255 & (data2 << _bitLength | _bitBuffer));
              length -= 8 - _bitLength;
              data2 >>>= 8 - _bitLength;
              _bitBuffer = 0;
              _bitLength = 0;
            }
            _bitBuffer = data2 << _bitLength | _bitBuffer;
            _bitLength = _bitLength + length;
          };
          _this2.flush = function() {
            if (_bitLength > 0) {
              _out.writeByte(_bitBuffer);
            }
          };
          return _this2;
        };
        var getLZWRaster = function(lzwMinCodeSize) {
          var clearCode = 1 << lzwMinCodeSize;
          var endCode = (1 << lzwMinCodeSize) + 1;
          var bitLength = lzwMinCodeSize + 1;
          var table = lzwTable();
          for (var i = 0; i < clearCode; i += 1) {
            table.add(String.fromCharCode(i));
          }
          table.add(String.fromCharCode(clearCode));
          table.add(String.fromCharCode(endCode));
          var byteOut = byteArrayOutputStream();
          var bitOut = bitOutputStream(byteOut);
          bitOut.write(clearCode, bitLength);
          var dataIndex = 0;
          var s = String.fromCharCode(_data[dataIndex]);
          dataIndex += 1;
          while (dataIndex < _data.length) {
            var c = String.fromCharCode(_data[dataIndex]);
            dataIndex += 1;
            if (table.contains(s + c)) {
              s = s + c;
            } else {
              bitOut.write(table.indexOf(s), bitLength);
              if (table.size() < 4095) {
                if (table.size() == 1 << bitLength) {
                  bitLength += 1;
                }
                table.add(s + c);
              }
              s = c;
            }
          }
          bitOut.write(table.indexOf(s), bitLength);
          bitOut.write(endCode, bitLength);
          bitOut.flush();
          return byteOut.toByteArray();
        };
        var lzwTable = function() {
          var _map = {};
          var _size = 0;
          var _this2 = {};
          _this2.add = function(key) {
            if (_this2.contains(key)) {
              throw "dup key:" + key;
            }
            _map[key] = _size;
            _size += 1;
          };
          _this2.size = function() {
            return _size;
          };
          _this2.indexOf = function(key) {
            return _map[key];
          };
          _this2.contains = function(key) {
            return typeof _map[key] != "undefined";
          };
          return _this2;
        };
        return _this;
      };
      var createDataURL = function(width, height, getPixel) {
        var gif = gifImage(width, height);
        for (var y = 0; y < height; y += 1) {
          for (var x = 0; x < width; x += 1) {
            gif.setPixel(x, y, getPixel(x, y));
          }
        }
        var b = byteArrayOutputStream();
        gif.write(b);
        var base64 = base64EncodeOutputStream();
        var bytes = b.toByteArray();
        for (var i = 0; i < bytes.length; i += 1) {
          base64.writeByte(bytes[i]);
        }
        base64.flush();
        return "data:image/gif;base64," + base64;
      };
      return qrcode3;
    }();
    !function() {
      qrcode2.stringToBytesFuncs["UTF-8"] = function(s) {
        function toUTF8Array(str) {
          var utf8 = [];
          for (var i = 0; i < str.length; i++) {
            var charcode = str.charCodeAt(i);
            if (charcode < 128) utf8.push(charcode);
            else if (charcode < 2048) {
              utf8.push(192 | charcode >> 6, 128 | charcode & 63);
            } else if (charcode < 55296 || charcode >= 57344) {
              utf8.push(224 | charcode >> 12, 128 | charcode >> 6 & 63, 128 | charcode & 63);
            } else {
              i++;
              charcode = 65536 + ((charcode & 1023) << 10 | str.charCodeAt(i) & 1023);
              utf8.push(240 | charcode >> 18, 128 | charcode >> 12 & 63, 128 | charcode >> 6 & 63, 128 | charcode & 63);
            }
          }
          return utf8;
        }
        return toUTF8Array(s);
      };
    }();
    (function(factory) {
      {
        module.exports = factory();
      }
    })(function() {
      return qrcode2;
    });
  })(qrcode);
  return qrcode.exports;
}
var qr;
var hasRequiredQr;
function requireQr() {
  if (hasRequiredQr) return qr;
  hasRequiredQr = 1;
  const raw$12 = raw2;
  const qrcode2 = requireQrcode();
  qr = function(url) {
    const gen = qrcode2(0, "L");
    gen.addData(url);
    gen.make();
    const qr2 = gen.createSvgTag({
      scalable: true
    });
    return raw$12(qr2);
  };
  return qr;
}
var copyDialog$1;
var hasRequiredCopyDialog;
function requireCopyDialog() {
  if (hasRequiredCopyDialog) return copyDialog$1;
  hasRequiredCopyDialog = 1;
  var _appendChild = appendChild$1;
  const {
    copyToClipboard
  } = requireUtils();
  const qr2 = requireQr();
  copyDialog$1 = function(name, url) {
    const dialog = function(state, emit, close) {
      var _text_3xl, _br, _fontNormal, _shareUrl, _qrBtn, _flex, _btn, _linkPrimary, _flex2;
      return _flex2 = document.createElement("send-copy-dialog"), _flex2.setAttribute("class", "flex flex-col items-center text-center p-4 max-w-sm m-auto"), _appendChild(_flex2, ["\n        ", (_text_3xl = document.createElement("h1"), _text_3xl.setAttribute("class", "text-3xl font-bold my-4"), _appendChild(_text_3xl, ["\n          ", state.translate("notifyUploadEncryptDone"), "\n        "]), _text_3xl), "\n        ", (_fontNormal = document.createElement("p"), _fontNormal.setAttribute("class", "font-normal leading-normal text-grey-80 word-break-all dark:text-grey-40"), _appendChild(_fontNormal, ["\n          ", state.translate("copyLinkDescription"), " ", (_br = document.createElement("br"), _br), "\n          ", name, "\n        "]), _fontNormal), "\n        ", (_flex = document.createElement("div"), _flex.setAttribute("class", "flex flex-row items-center justify-center w-full"), _appendChild(_flex, ["\n          ", (_shareUrl = document.createElement("input"), _shareUrl.setAttribute("type", "text"), _shareUrl.setAttribute("id", "share-url"), _shareUrl.setAttribute("value", "" + String(url)), _shareUrl.setAttribute("readonly", "readonly"), _shareUrl.setAttribute("class", "block w-full my-4 border-default rounded-lg leading-loose h-12 px-2 py-1 dark:bg-grey-80"), _shareUrl), "\n          ", (_qrBtn = document.createElement("button"), _qrBtn.setAttribute("id", "qr-btn"), _qrBtn.onclick = toggleQR, _qrBtn.setAttribute("title", "QR code"), _qrBtn.setAttribute("class", "w-16 m-1 p-1"), _appendChild(_qrBtn, ["\n            ", qr2(url), "\n          "]), _qrBtn), "\n        "]), _flex), "\n        ", (_btn = document.createElement("button"), _btn.onclick = copy, _btn.setAttribute("title", "" + String(state.translate("copyLinkButton"))), _btn.setAttribute("class", "btn rounded-lg w-full flex-shrink-0 focus:outline"), _appendChild(_btn, ["\n          ", state.translate("copyLinkButton"), "\n        "]), _btn), "\n        ", (_linkPrimary = document.createElement("button"), _linkPrimary.onclick = close, _linkPrimary.setAttribute("title", "" + String(state.translate("okButton"))), _linkPrimary.setAttribute("class", "link-primary my-4 font-medium cursor-pointer focus:outline"), _appendChild(_linkPrimary, ["\n          ", state.translate("okButton"), "\n        "]), _linkPrimary), "\n      "]), _flex2;
      function toggleQR(event) {
        event.stopPropagation();
        const shareUrl = document.getElementById("share-url");
        const qrBtn = document.getElementById("qr-btn");
        if (shareUrl.classList.contains("hidden")) {
          shareUrl.classList.replace("hidden", "block");
          qrBtn.classList.replace("w-48", "w-16");
        } else {
          shareUrl.classList.replace("block", "hidden");
          qrBtn.classList.replace("w-16", "w-48");
        }
      }
      function copy(event) {
        event.stopPropagation();
        copyToClipboard(url);
        event.target.textContent = state.translate("copiedUrl");
        setTimeout(close, 1e3);
      }
    };
    dialog.type = "copy";
    return dialog;
  };
  return copyDialog$1;
}
var copyDialogExports = requireCopyDialog();
const copyDialog = /* @__PURE__ */ getDefaultExportFromCjs(copyDialogExports);
var faviconProgressbar$1 = {};
var hasRequiredFaviconProgressbar;
function requireFaviconProgressbar() {
  if (hasRequiredFaviconProgressbar) return faviconProgressbar$1;
  hasRequiredFaviconProgressbar = 1;
  const {
    platform
  } = requireUtils();
  const assets = requireAssets();
  const size3 = 32;
  const loaderWidth = 5;
  const loaderColor = WEB_UI.COLORS.PRIMARY;
  function drawCircle(canvas, context, color, lineWidth, outerWidth, percent) {
    canvas.width = canvas.height = outerWidth;
    context.translate(outerWidth * 0.5, outerWidth * 0.5);
    context.rotate(-Math.PI * 0.5);
    const radius = (outerWidth - lineWidth) * 0.5;
    context.beginPath();
    context.arc(0, 0, radius, 0, Math.PI * 2 * percent, false);
    context.strokeStyle = color;
    context.lineCap = "square";
    context.lineWidth = lineWidth;
    context.stroke();
  }
  function drawNewFavicon(progressRatio) {
    const canvas = document.createElement("canvas");
    const context = canvas.getContext("2d");
    drawCircle(canvas, context, "#efefef", loaderWidth, size3, 1);
    drawCircle(canvas, context, loaderColor, loaderWidth, size3, progressRatio);
    return canvas.toDataURL();
  }
  faviconProgressbar$1.updateFavicon = function(progressRatio) {
    if (platform() === "web") {
      let link2 = document.querySelector("link[rel='icon'][sizes='32x32']");
      if (!link2) {
        link2 = document.createElement("link");
        link2.rel = "icon";
        link2.type = "image/png";
        link2.sizes = "32x32";
        document.head.appendChild(link2);
      }
      const progress = progressRatio * 100;
      if (progress === 0 || progress === 100) {
        link2.type = "image/png";
        link2.href = WEB_UI.CUSTOM_ASSETS.favicon_32px !== "" ? WEB_UI.CUSTOM_ASSETS.favicon_32px : assets.get("favicon-32x32.png");
        return;
      }
      link2.href = drawNewFavicon(progressRatio);
    }
  };
  return faviconProgressbar$1;
}
var faviconProgressbarExports = requireFaviconProgressbar();
const faviconProgressbar = /* @__PURE__ */ getDefaultExportFromCjs(faviconProgressbarExports);
var okDialog$1;
var hasRequiredOkDialog;
function requireOkDialog() {
  if (hasRequiredOkDialog) return okDialog$1;
  hasRequiredOkDialog = 1;
  var _appendChild = appendChild$1;
  okDialog$1 = function(message) {
    return function(state, emit, close) {
      var _textCenter, _btn, _flex;
      return _flex = document.createElement("send-ok-dialog"), _flex.setAttribute("class", "flex flex-col max-w-sm p-4 m-auto"), _appendChild(_flex, ["\n        ", (_textCenter = document.createElement("h2"), _textCenter.setAttribute("class", "text-center text-xl font-bold m-8 leading-normal"), _appendChild(_textCenter, ["\n          ", message, "\n        "]), _textCenter), "\n        ", (_btn = document.createElement("button"), _btn.onclick = close, _btn.setAttribute("title", "" + String(state.translate("okButton"))), _btn.setAttribute("class", "btn rounded-lg w-full flex-shrink-0"), _appendChild(_btn, ["\n          ", state.translate("okButton"), "\n        "]), _btn), "\n      "]), _flex;
    };
  };
  return okDialog$1;
}
var okDialogExports = requireOkDialog();
const okDialog = /* @__PURE__ */ getDefaultExportFromCjs(okDialogExports);
var shareDialog$1;
var hasRequiredShareDialog;
function requireShareDialog() {
  if (hasRequiredShareDialog) return shareDialog$1;
  hasRequiredShareDialog = 1;
  var _appendChild = appendChild$1;
  shareDialog$1 = function(name, url) {
    const dialog = function(state, emit, close) {
      var _text_3xl, _br, _fontNormal, _shareUrl, _btn, _linkPrimary, _flex;
      return _flex = document.createElement("send-share-dialog"), _flex.setAttribute("class", "flex flex-col items-center text-center p-4 max-w-sm m-auto"), _appendChild(_flex, ["\n        ", (_text_3xl = document.createElement("h1"), _text_3xl.setAttribute("class", "text-3xl font-bold my-4"), _appendChild(_text_3xl, ["\n          ", state.translate("notifyUploadEncryptDone"), "\n        "]), _text_3xl), "\n        ", (_fontNormal = document.createElement("p"), _fontNormal.setAttribute("class", "font-normal leading-normal text-grey-80 word-break-all dark:text-grey-40"), _appendChild(_fontNormal, ["\n          ", state.translate("shareLinkDescription"), (_br = document.createElement("br"), _br), "\n          ", name, "\n        "]), _fontNormal), "\n        ", (_shareUrl = document.createElement("input"), _shareUrl.setAttribute("type", "text"), _shareUrl.setAttribute("id", "share-url"), _shareUrl.setAttribute("value", "" + String(url)), _shareUrl.setAttribute("readonly", "readonly"), _shareUrl.setAttribute("class", "w-full my-4 border-default rounded-lg leading-loose h-12 px-2 py-1 dark:bg-grey-80"), _shareUrl), "\n        ", (_btn = document.createElement("button"), _btn.onclick = share, _btn.setAttribute("title", "" + String(state.translate("shareLinkButton"))), _btn.setAttribute("class", "btn rounded-lg w-full flex-shrink-0 focus:outline"), _appendChild(_btn, ["\n          ", state.translate("shareLinkButton"), "\n        "]), _btn), "\n        ", (_linkPrimary = document.createElement("button"), _linkPrimary.onclick = close, _linkPrimary.setAttribute("title", "" + String(state.translate("okButton"))), _linkPrimary.setAttribute("class", "link-primary my-4 font-medium cursor-pointer focus:outline"), _appendChild(_linkPrimary, ["\n          ", state.translate("okButton"), "\n        "]), _linkPrimary), "\n      "]), _flex;
      async function share(event) {
        event.stopPropagation();
        try {
          await navigator.share({
            title: state.translate("-send-brand"),
            text: state.translate("shareMessage", {
              name
            }),
            url
          });
        } catch (e) {
          if (e.code === e.ABORT_ERR) {
            return;
          }
          console.error(e);
        }
        close();
      }
    };
    dialog.type = "share";
    return dialog;
  };
  return shareDialog$1;
}
var shareDialogExports = requireShareDialog();
const shareDialog = /* @__PURE__ */ getDefaultExportFromCjs(shareDialogExports);
function controller(state, emitter) {
  let lastRender = 0;
  let updateTitle = false;
  function render() {
    emitter.emit("render");
  }
  async function checkFiles() {
    const changes = await state.storage.merge();
    const rerender = changes.downloadCount;
    if (rerender) {
      render();
    }
  }
  function updateProgress() {
    if (updateTitle) {
      emitter.emit("DOMTitleChange", utilsExports.percent(state.transfer.progressRatio));
    }
    faviconProgressbar.updateFavicon(state.transfer.progressRatio);
    render();
  }
  emitter.on("DOMContentLoaded", () => {
    document.addEventListener("blur", () => updateTitle = true);
    document.addEventListener("focus", () => {
      updateTitle = false;
      emitter.emit("DOMTitleChange", "Send");
      faviconProgressbar.updateFavicon(0);
    });
    checkFiles();
  });
  emitter.on("render", () => {
    lastRender = Date.now();
  });
  emitter.on("removeUpload", (file) => {
    state.archive.remove(file);
    if (state.archive.numFiles === 0) {
      state.archive.clear();
    }
    render();
  });
  emitter.on("delete", async (ownedFile) => {
    try {
      state.storage.remove(ownedFile.id);
      await ownedFile.del();
    } catch (e) {
      console.error(e);
    }
    render();
  });
  emitter.on("cancel", () => {
    state.transfer.cancel();
    faviconProgressbar.updateFavicon(0);
  });
  emitter.on("addFiles", async ({
    files
  }) => {
    if (files.length < 1) {
      return;
    }
    const maxSize = state.LIMITS.MAX_FILE_SIZE;
    try {
      state.archive.addFiles(files, maxSize, state.LIMITS.MAX_FILES_PER_ARCHIVE);
    } catch (e) {
      state.modal = okDialog(state.translate(e.message, {
        size: utilsExports.bytes(maxSize),
        count: state.LIMITS.MAX_FILES_PER_ARCHIVE
      }));
    }
    render();
  });
  emitter.on("upload", async () => {
    if (state.storage.files.length >= state.LIMITS.MAX_ARCHIVES_PER_USER) {
      state.modal = okDialog(state.translate("tooManyArchives", {
        count: state.LIMITS.MAX_ARCHIVES_PER_USER
      }));
      return render();
    }
    const archive = state.archive;
    const sender = new FileSender();
    sender.on("progress", updateProgress);
    sender.on("encrypting", render);
    sender.on("complete", render);
    state.transfer = sender;
    state.uploading = true;
    render();
    const links = utilsExports.openLinksInNewTab();
    await utilsExports.delay(200);
    try {
      const ownedFile = await sender.upload(archive);
      state.storage.totalUploads += 1;
      faviconProgressbar.updateFavicon(0);
      state.storage.addFile(ownedFile);
      if (archive.password) {
        emitter.emit("password", {
          password: archive.password,
          file: ownedFile
        });
      }
      state.modal = state.capabilities.share ? shareDialog(ownedFile.name, ownedFile.url) : copyDialog(ownedFile.name, ownedFile.url);
    } catch (err) {
      if (err.message === "0") {
        render();
      } else {
        console.error(err);
        emitter.emit("pushState", "/error");
      }
    } finally {
      utilsExports.openLinksInNewTab(links, false);
      archive.clear();
      state.uploading = false;
      state.transfer = null;
      await state.storage.merge();
      render();
    }
  });
  emitter.on("password", async ({
    password,
    file
  }) => {
    try {
      state.settingPassword = true;
      render();
      await file.setPassword(password);
      state.storage.writeFile(file);
      await utilsExports.delay(1e3);
    } catch (err) {
      console.error(err);
      state.passwordSetError = err;
    } finally {
      state.settingPassword = false;
    }
    render();
  });
  emitter.on("getMetadata", async () => {
    const file = state.fileInfo;
    const receiver = new FileReceiver(file);
    try {
      await receiver.getMetadata();
      state.transfer = receiver;
    } catch (e) {
      if (e.message === "401" || e.message === "404") {
        file.password = null;
        if (!file.requiresPassword) {
          return emitter.emit("pushState", "/404");
        }
      } else {
        console.error(e);
        return emitter.emit("pushState", "/error");
      }
    }
    render();
  });
  emitter.on("download", async () => {
    state.transfer.on("progress", updateProgress);
    state.transfer.on("decrypting", render);
    state.transfer.on("complete", render);
    const links = utilsExports.openLinksInNewTab();
    try {
      const dl = state.transfer.download({
        stream: state.capabilities.streamDownload
      });
      render();
      await dl;
      state.storage.totalDownloads += 1;
      faviconProgressbar.updateFavicon(0);
    } catch (err) {
      if (err.message === "0") {
        state.transfer.reset();
        render();
      } else {
        state.transfer = null;
        const location2 = err.message === "404" ? "/404" : "/error";
        if (location2 === "/error") {
          console.error(err);
        }
        emitter.emit("pushState", location2);
      }
    } finally {
      utilsExports.openLinksInNewTab(links, false);
    }
  });
  emitter.on("copy", ({
    url
  }) => {
    utilsExports.copyToClipboard(url);
  });
  emitter.on("closeModal", () => {
    state.modal = null;
    render();
  });
  setInterval(() => {
    if (!state.modal && state.route === "/") {
      checkFiles();
    }
  }, 2 * 60 * 1e3);
  setInterval(() => {
    if (!state.modal && state.route === "/" && state.storage.files.length > 0 && Date.now() - lastRender > 3e4) {
      render();
    }
  }, 6e4);
}
function dragManager(state, emitter) {
  emitter.on("DOMContentLoaded", () => {
    document.body.addEventListener("dragover", (event) => {
      if (state.route === "/") {
        event.preventDefault();
      }
    });
    document.body.addEventListener("drop", (event) => {
      if (state.route === "/" && !state.uploading && event.dataTransfer && event.dataTransfer.files) {
        event.preventDefault();
        emitter.emit("addFiles", {
          files: Array.from(event.dataTransfer.files)
        });
      }
    });
  });
}
function getString(item) {
  return new Promise((resolve2) => {
    item.getAsString(resolve2);
  });
}
function pasteManager(state, emitter) {
  window.addEventListener("paste", async (event) => {
    if (state.route !== "/" || state.uploading) return;
    if (["password", "text", "email"].includes(event.target.type)) return;
    const items = Array.from(event.clipboardData.items);
    const transferFiles = items.filter((item) => item.kind === "file");
    const strings = items.filter((item) => item.kind === "string");
    if (transferFiles.length) {
      const promises = transferFiles.map(async (f, i) => {
        const blob = f.getAsFile();
        if (!blob) {
          return null;
        }
        const name = await getString(strings[i]);
        const file = new File([blob], name, {
          type: blob.type
        });
        return file;
      });
      const files = (await Promise.all(promises)).filter((f) => !!f);
      if (files.length) {
        emitter.emit("addFiles", {
          files
        });
      }
    } else if (strings.length) {
      strings[0].getAsString((s) => {
        const file = new File([s], "pasted.txt", {
          type: "text/plain"
        });
        emitter.emit("addFiles", {
          files: [file]
        });
      });
    }
  });
}
class Mem {
  constructor() {
    this.items = /* @__PURE__ */ new Map();
  }
  get length() {
    return this.items.size;
  }
  getItem(key) {
    return this.items.get(key);
  }
  setItem(key, value) {
    return this.items.set(key, value);
  }
  removeItem(key) {
    return this.items.delete(key);
  }
  key(i) {
    return this.items.keys()[i];
  }
}
class Storage {
  constructor() {
    try {
      this.engine = localStorage || new Mem();
    } catch (e) {
      this.engine = new Mem();
    }
    this._files = this.loadFiles();
  }
  loadFiles() {
    const fs = /* @__PURE__ */ new Map();
    for (let i = 0; i < this.engine.length; i++) {
      const k = this.engine.key(i);
      if (utilsExports.isFile(k)) {
        try {
          const f = new OwnedFile(JSON.parse(this.engine.getItem(k)));
          if (!f.id) {
            f.id = f.fileId;
          }
          fs.set(f.id, f);
        } catch (err) {
          this.engine.removeItem(k);
        }
      }
    }
    return fs;
  }
  get id() {
    let id2 = this.engine.getItem("device_id");
    if (!id2) {
      id2 = utilsExports.arrayToB64(crypto.getRandomValues(new Uint8Array(16)));
      this.engine.setItem("device_id", id2);
    }
    return id2;
  }
  get totalDownloads() {
    return Number(this.engine.getItem("totalDownloads"));
  }
  set totalDownloads(n) {
    this.engine.setItem("totalDownloads", n);
  }
  get totalUploads() {
    return Number(this.engine.getItem("totalUploads"));
  }
  set totalUploads(n) {
    this.engine.setItem("totalUploads", n);
  }
  get referrer() {
    return this.engine.getItem("referrer");
  }
  set referrer(str) {
    this.engine.setItem("referrer", str);
  }
  get enrolled() {
    return JSON.parse(this.engine.getItem("ab_experiments") || "{}");
  }
  enroll(id2, variant) {
    const enrolled = {};
    enrolled[id2] = variant;
    this.engine.setItem("ab_experiments", JSON.stringify(enrolled));
  }
  get files() {
    return Array.from(this._files.values()).sort((a, b) => a.createdAt - b.createdAt);
  }
  getFileById(id2) {
    return this._files.get(id2);
  }
  get(id2) {
    return this.engine.getItem(id2);
  }
  set(id2, value) {
    return this.engine.setItem(id2, value);
  }
  remove(property) {
    if (utilsExports.isFile(property)) {
      this._files.delete(property);
    }
    this.engine.removeItem(property);
  }
  addFile(file) {
    this._files.set(file.id, file);
    this.writeFile(file);
  }
  writeFile(file) {
    this.engine.setItem(file.id, JSON.stringify(file));
  }
  writeFiles() {
    this._files.forEach((f) => this.writeFile(f));
  }
  clearLocalFiles() {
    this._files.forEach((f) => this.engine.removeItem(f.id));
    this._files = /* @__PURE__ */ new Map();
  }
  async merge(files = []) {
    let incoming = false;
    let outgoing = false;
    let downloadCount = false;
    for (const f of files) {
      if (!this.getFileById(f.id)) {
        this.addFile(new OwnedFile(f));
        incoming = true;
      }
    }
    const workingFiles = this.files.slice();
    for (const f of workingFiles) {
      const cc = await f.updateDownloadCount();
      if (cc) {
        await this.writeFile(f);
      }
      downloadCount = downloadCount || cc;
      outgoing = outgoing || f.expired;
      if (f.expired) {
        this.remove(f.id);
      } else if (!files.find((x) => x.id === f.id)) {
        outgoing = true;
      }
    }
    return {
      incoming,
      outgoing,
      downloadCount
    };
  }
}
const storage = new Storage();
const experiments = {};
function checkExperiments(state, emitter) {
  const all2 = Object.keys(experiments);
  const id2 = all2.find((id3) => experiments[id3].eligible(state));
  if (id2) {
    const variant = experiments[id2].variant(state);
    state.storage.enroll(id2, variant);
    experiments[id2].run(variant, state, emitter);
  }
}
function initialize(state, emitter) {
  emitter.on("DOMContentLoaded", () => {
    const xp = experiments[state.query.x];
    if (xp) {
      xp.run(+state.query.v, state, emitter);
    }
  });
  const enrolled = state.storage.enrolled;
  const id2 = Object.keys(enrolled)[0];
  if (Object.keys(experiments).includes(id2)) {
    experiments[id2].run(enrolled[id2], state, emitter);
  } else {
    checkExperiments(state, emitter);
  }
}
const scriptRel = "modulepreload";
const assetsURL = function(dep) {
  return "/" + dep;
};
const seen = {};
const __vitePreload = function preload(baseModule, deps, importerUrl) {
  let promise2 = Promise.resolve();
  if (deps && deps.length > 0) {
    document.getElementsByTagName("link");
    const cspNonceMeta = document.querySelector(
      "meta[property=csp-nonce]"
    );
    const cspNonce = (cspNonceMeta == null ? void 0 : cspNonceMeta.nonce) || (cspNonceMeta == null ? void 0 : cspNonceMeta.getAttribute("nonce"));
    promise2 = Promise.allSettled(
      deps.map((dep) => {
        dep = assetsURL(dep);
        if (dep in seen) return;
        seen[dep] = true;
        const isCss = dep.endsWith(".css");
        const cssSelector = isCss ? '[rel="stylesheet"]' : "";
        if (document.querySelector(`link[href="${dep}"]${cssSelector}`)) {
          return;
        }
        const link2 = document.createElement("link");
        link2.rel = isCss ? "stylesheet" : scriptRel;
        if (!isCss) {
          link2.as = "script";
        }
        link2.crossOrigin = "";
        link2.href = dep;
        if (cspNonce) {
          link2.setAttribute("nonce", cspNonce);
        }
        document.head.appendChild(link2);
        if (isCss) {
          return new Promise((res, rej) => {
            link2.addEventListener("load", res);
            link2.addEventListener(
              "error",
              () => rej(new Error(`Unable to preload CSS for ${dep}`))
            );
          });
        }
      })
    );
  }
  function handlePreloadError(err) {
    const e = new Event("vite:preloadError", {
      cancelable: true
    });
    e.payload = err;
    window.dispatchEvent(e);
    if (!e.defaultPrevented) {
      throw err;
    }
  }
  return promise2.then((res) => {
    for (const item of res || []) {
      if (item.status !== "rejected") continue;
      handlePreloadError(item.reason);
    }
    return baseModule().catch(handlePreloadError);
  });
};
const __variableDynamicImportRuntimeHelper = (glob, path2, segs) => {
  const v = glob[path2];
  if (v) {
    return typeof v === "function" ? v() : Promise.resolve(v);
  }
  return new Promise((_, reject2) => {
    (typeof queueMicrotask === "function" ? queueMicrotask : setTimeout)(
      reject2.bind(
        null,
        new Error(
          "Unknown variable dynamic import: " + path2 + (path2.split("/").length !== segs ? ". Note that variables only represent file names one level deep." : "")
        )
      )
    );
  });
};
class FluentType {
  /**
   * Create a `FluentType` instance.
   *
   * @param value The JavaScript value to wrap.
   */
  constructor(value) {
    this.value = value;
  }
  /**
   * Unwrap the raw value stored by this `FluentType`.
   */
  valueOf() {
    return this.value;
  }
}
class FluentNone extends FluentType {
  /**
   * Create an instance of `FluentNone` with an optional fallback value.
   * @param value The fallback value of this `FluentNone`.
   */
  constructor(value = "???") {
    super(value);
  }
  /**
   * Format this `FluentNone` to the fallback string.
   */
  toString(scope) {
    return `{${this.value}}`;
  }
}
class FluentNumber extends FluentType {
  /**
   * Create an instance of `FluentNumber` with options to the
   * `Intl.NumberFormat` constructor.
   *
   * @param value The number value of this `FluentNumber`.
   * @param opts Options which will be passed to `Intl.NumberFormat`.
   */
  constructor(value, opts = {}) {
    super(value);
    this.opts = opts;
  }
  /**
   * Format this `FluentNumber` to a string.
   */
  toString(scope) {
    try {
      const nf = scope.memoizeIntlObject(Intl.NumberFormat, this.opts);
      return nf.format(this.value);
    } catch (err) {
      scope.reportError(err);
      return this.value.toString(10);
    }
  }
}
class FluentDateTime extends FluentType {
  /**
   * Create an instance of `FluentDateTime` with options to the
   * `Intl.DateTimeFormat` constructor.
   *
   * @param value The number value of this `FluentDateTime`, in milliseconds.
   * @param opts Options which will be passed to `Intl.DateTimeFormat`.
   */
  constructor(value, opts = {}) {
    super(value);
    this.opts = opts;
  }
  /**
   * Format this `FluentDateTime` to a string.
   */
  toString(scope) {
    try {
      const dtf = scope.memoizeIntlObject(Intl.DateTimeFormat, this.opts);
      return dtf.format(this.value);
    } catch (err) {
      scope.reportError(err);
      return new Date(this.value).toISOString();
    }
  }
}
const MAX_PLACEABLES = 100;
const FSI = "";
const PDI = "";
function match(scope, selector, key) {
  if (key === selector) {
    return true;
  }
  if (key instanceof FluentNumber && selector instanceof FluentNumber && key.value === selector.value) {
    return true;
  }
  if (selector instanceof FluentNumber && typeof key === "string") {
    let category = scope.memoizeIntlObject(Intl.PluralRules, selector.opts).select(selector.value);
    if (key === category) {
      return true;
    }
  }
  return false;
}
function getDefault(scope, variants, star) {
  if (variants[star]) {
    return resolvePattern(scope, variants[star].value);
  }
  scope.reportError(new RangeError("No default"));
  return new FluentNone();
}
function getArguments(scope, args) {
  const positional = [];
  const named = /* @__PURE__ */ Object.create(null);
  for (const arg of args) {
    if (arg.type === "narg") {
      named[arg.name] = resolveExpression(scope, arg.value);
    } else {
      positional.push(resolveExpression(scope, arg));
    }
  }
  return {
    positional,
    named
  };
}
function resolveExpression(scope, expr) {
  switch (expr.type) {
    case "str":
      return expr.value;
    case "num":
      return new FluentNumber(expr.value, {
        minimumFractionDigits: expr.precision
      });
    case "var":
      return resolveVariableReference(scope, expr);
    case "mesg":
      return resolveMessageReference(scope, expr);
    case "term":
      return resolveTermReference(scope, expr);
    case "func":
      return resolveFunctionReference(scope, expr);
    case "select":
      return resolveSelectExpression(scope, expr);
    default:
      return new FluentNone();
  }
}
function resolveVariableReference(scope, {
  name
}) {
  let arg;
  if (scope.params) {
    if (Object.prototype.hasOwnProperty.call(scope.params, name)) {
      arg = scope.params[name];
    } else {
      return new FluentNone(`$${name}`);
    }
  } else if (scope.args && Object.prototype.hasOwnProperty.call(scope.args, name)) {
    arg = scope.args[name];
  } else {
    scope.reportError(new ReferenceError(`Unknown variable: $${name}`));
    return new FluentNone(`$${name}`);
  }
  if (arg instanceof FluentType) {
    return arg;
  }
  switch (typeof arg) {
    case "string":
      return arg;
    case "number":
      return new FluentNumber(arg);
    case "object":
      if (arg instanceof Date) {
        return new FluentDateTime(arg.getTime());
      }
    default:
      scope.reportError(new TypeError(`Variable type not supported: $${name}, ${typeof arg}`));
      return new FluentNone(`$${name}`);
  }
}
function resolveMessageReference(scope, {
  name,
  attr
}) {
  const message = scope.bundle._messages.get(name);
  if (!message) {
    scope.reportError(new ReferenceError(`Unknown message: ${name}`));
    return new FluentNone(name);
  }
  if (attr) {
    const attribute = message.attributes[attr];
    if (attribute) {
      return resolvePattern(scope, attribute);
    }
    scope.reportError(new ReferenceError(`Unknown attribute: ${attr}`));
    return new FluentNone(`${name}.${attr}`);
  }
  if (message.value) {
    return resolvePattern(scope, message.value);
  }
  scope.reportError(new ReferenceError(`No value: ${name}`));
  return new FluentNone(name);
}
function resolveTermReference(scope, {
  name,
  attr,
  args
}) {
  const id2 = `-${name}`;
  const term = scope.bundle._terms.get(id2);
  if (!term) {
    scope.reportError(new ReferenceError(`Unknown term: ${id2}`));
    return new FluentNone(id2);
  }
  if (attr) {
    const attribute = term.attributes[attr];
    if (attribute) {
      scope.params = getArguments(scope, args).named;
      const resolved2 = resolvePattern(scope, attribute);
      scope.params = null;
      return resolved2;
    }
    scope.reportError(new ReferenceError(`Unknown attribute: ${attr}`));
    return new FluentNone(`${id2}.${attr}`);
  }
  scope.params = getArguments(scope, args).named;
  const resolved = resolvePattern(scope, term.value);
  scope.params = null;
  return resolved;
}
function resolveFunctionReference(scope, {
  name,
  args
}) {
  let func = scope.bundle._functions[name];
  if (!func) {
    scope.reportError(new ReferenceError(`Unknown function: ${name}()`));
    return new FluentNone(`${name}()`);
  }
  if (typeof func !== "function") {
    scope.reportError(new TypeError(`Function ${name}() is not callable`));
    return new FluentNone(`${name}()`);
  }
  try {
    let resolved = getArguments(scope, args);
    return func(resolved.positional, resolved.named);
  } catch (err) {
    scope.reportError(err);
    return new FluentNone(`${name}()`);
  }
}
function resolveSelectExpression(scope, {
  selector,
  variants,
  star
}) {
  let sel = resolveExpression(scope, selector);
  if (sel instanceof FluentNone) {
    return getDefault(scope, variants, star);
  }
  for (const variant of variants) {
    const key = resolveExpression(scope, variant.key);
    if (match(scope, sel, key)) {
      return resolvePattern(scope, variant.value);
    }
  }
  return getDefault(scope, variants, star);
}
function resolveComplexPattern(scope, ptn) {
  if (scope.dirty.has(ptn)) {
    scope.reportError(new RangeError("Cyclic reference"));
    return new FluentNone();
  }
  scope.dirty.add(ptn);
  const result = [];
  const useIsolating = scope.bundle._useIsolating && ptn.length > 1;
  for (const elem of ptn) {
    if (typeof elem === "string") {
      result.push(scope.bundle._transform(elem));
      continue;
    }
    scope.placeables++;
    if (scope.placeables > MAX_PLACEABLES) {
      scope.dirty.delete(ptn);
      throw new RangeError(`Too many placeables expanded: ${scope.placeables}, max allowed is ${MAX_PLACEABLES}`);
    }
    if (useIsolating) {
      result.push(FSI);
    }
    result.push(resolveExpression(scope, elem).toString(scope));
    if (useIsolating) {
      result.push(PDI);
    }
  }
  scope.dirty.delete(ptn);
  return result.join("");
}
function resolvePattern(scope, value) {
  if (typeof value === "string") {
    return scope.bundle._transform(value);
  }
  return resolveComplexPattern(scope, value);
}
class Scope {
  constructor(bundle, errors, args) {
    this.dirty = /* @__PURE__ */ new WeakSet();
    this.params = null;
    this.placeables = 0;
    this.bundle = bundle;
    this.errors = errors;
    this.args = args;
  }
  reportError(error3) {
    if (!this.errors || !(error3 instanceof Error)) {
      throw error3;
    }
    this.errors.push(error3);
  }
  memoizeIntlObject(ctor, opts) {
    let cache2 = this.bundle._intls.get(ctor);
    if (!cache2) {
      cache2 = {};
      this.bundle._intls.set(ctor, cache2);
    }
    let id2 = JSON.stringify(opts);
    if (!cache2[id2]) {
      cache2[id2] = new ctor(this.bundle.locales, opts);
    }
    return cache2[id2];
  }
}
function values4(opts, allowed) {
  const unwrapped = /* @__PURE__ */ Object.create(null);
  for (const [name, opt] of Object.entries(opts)) {
    if (allowed.includes(name)) {
      unwrapped[name] = opt.valueOf();
    }
  }
  return unwrapped;
}
const NUMBER_ALLOWED = ["unitDisplay", "currencyDisplay", "useGrouping", "minimumIntegerDigits", "minimumFractionDigits", "maximumFractionDigits", "minimumSignificantDigits", "maximumSignificantDigits"];
function NUMBER(args, opts) {
  let arg = args[0];
  if (arg instanceof FluentNone) {
    return new FluentNone(`NUMBER(${arg.valueOf()})`);
  }
  if (arg instanceof FluentNumber) {
    return new FluentNumber(arg.valueOf(), {
      ...arg.opts,
      ...values4(opts, NUMBER_ALLOWED)
    });
  }
  if (arg instanceof FluentDateTime) {
    return new FluentNumber(arg.valueOf(), {
      ...values4(opts, NUMBER_ALLOWED)
    });
  }
  throw new TypeError("Invalid argument to NUMBER");
}
const DATETIME_ALLOWED = ["dateStyle", "timeStyle", "fractionalSecondDigits", "dayPeriod", "hour12", "weekday", "era", "year", "month", "day", "hour", "minute", "second", "timeZoneName"];
function DATETIME(args, opts) {
  let arg = args[0];
  if (arg instanceof FluentNone) {
    return new FluentNone(`DATETIME(${arg.valueOf()})`);
  }
  if (arg instanceof FluentDateTime) {
    return new FluentDateTime(arg.valueOf(), {
      ...arg.opts,
      ...values4(opts, DATETIME_ALLOWED)
    });
  }
  if (arg instanceof FluentNumber) {
    return new FluentDateTime(arg.valueOf(), {
      ...values4(opts, DATETIME_ALLOWED)
    });
  }
  throw new TypeError("Invalid argument to DATETIME");
}
const cache = /* @__PURE__ */ new Map();
function getMemoizerForLocale(locales) {
  const stringLocale = Array.isArray(locales) ? locales.join(" ") : locales;
  let memoizer = cache.get(stringLocale);
  if (memoizer === void 0) {
    memoizer = /* @__PURE__ */ new Map();
    cache.set(stringLocale, memoizer);
  }
  return memoizer;
}
class FluentBundle {
  /**
   * Create an instance of `FluentBundle`.
   *
   * The `locales` argument is used to instantiate `Intl` formatters used by
   * translations. The `options` object can be used to configure the bundle.
   *
   * Examples:
   *
   *     let bundle = new FluentBundle(["en-US", "en"]);
   *
   *     let bundle = new FluentBundle(locales, {useIsolating: false});
   *
   *     let bundle = new FluentBundle(locales, {
   *       useIsolating: true,
   *       functions: {
   *         NODE_ENV: () => process.env.NODE_ENV
   *       }
   *     });
   *
   * Available options:
   *
   *   - `functions` - an object of additional functions available to
   *     translations as builtins.
   *
   *   - `useIsolating` - boolean specifying whether to use Unicode isolation
   *     marks (FSI, PDI) for bidi interpolations. Default: `true`.
   *
   *   - `transform` - a function used to transform string parts of patterns.
   */
  constructor(locales, {
    functions,
    useIsolating = true,
    transform: transform2 = (v) => v
  } = {}) {
    this._terms = /* @__PURE__ */ new Map();
    this._messages = /* @__PURE__ */ new Map();
    this.locales = Array.isArray(locales) ? locales : [locales];
    this._functions = {
      NUMBER,
      DATETIME,
      ...functions
    };
    this._useIsolating = useIsolating;
    this._transform = transform2;
    this._intls = getMemoizerForLocale(locales);
  }
  /**
   * Check if a message is present in the bundle.
   *
   * @param id - The identifier of the message to check.
   */
  hasMessage(id2) {
    return this._messages.has(id2);
  }
  /**
   * Return a raw unformatted message object from the bundle.
   *
   * Raw messages are `{value, attributes}` shapes containing translation units
   * called `Patterns`. `Patterns` are implementation-specific; they should be
   * treated as black boxes and formatted with `FluentBundle.formatPattern`.
   *
   * @param id - The identifier of the message to check.
   */
  getMessage(id2) {
    return this._messages.get(id2);
  }
  /**
   * Add a translation resource to the bundle.
   *
   * The translation resource must be an instance of `FluentResource`.
   *
   *     let res = new FluentResource("foo = Foo");
   *     bundle.addResource(res);
   *     bundle.getMessage("foo");
   *     //  {value: .., attributes: {..}}
   *
   * Available options:
   *
   *   - `allowOverrides` - boolean specifying whether it's allowed to override
   *     an existing message or term with a new value. Default: `false`.
   *
   * @param   res - FluentResource object.
   * @param   options
   */
  addResource(res, {
    allowOverrides = false
  } = {}) {
    const errors = [];
    for (let i = 0; i < res.body.length; i++) {
      let entry = res.body[i];
      if (entry.id.startsWith("-")) {
        if (allowOverrides === false && this._terms.has(entry.id)) {
          errors.push(new Error(`Attempt to override an existing term: "${entry.id}"`));
          continue;
        }
        this._terms.set(entry.id, entry);
      } else {
        if (allowOverrides === false && this._messages.has(entry.id)) {
          errors.push(new Error(`Attempt to override an existing message: "${entry.id}"`));
          continue;
        }
        this._messages.set(entry.id, entry);
      }
    }
    return errors;
  }
  /**
   * Format a `Pattern` to a string.
   *
   * Format a raw `Pattern` into a string. `args` will be used to resolve
   * references to variables passed as arguments to the translation.
   *
   * In case of errors `formatPattern` will try to salvage as much of the
   * translation as possible and will still return a string. For performance
   * reasons, the encountered errors are not returned but instead are appended
   * to the `errors` array passed as the third argument.
   *
   *     let errors = [];
   *     bundle.addResource(
   *         new FluentResource("hello = Hello, {$name}!"));
   *
   *     let hello = bundle.getMessage("hello");
   *     if (hello.value) {
   *         bundle.formatPattern(hello.value, {name: "Jane"}, errors);
   *         // Returns "Hello, Jane!" and `errors` is empty.
   *
   *         bundle.formatPattern(hello.value, undefined, errors);
   *         // Returns "Hello, {$name}!" and `errors` is now:
   *         // [<ReferenceError: Unknown variable: name>]
   *     }
   *
   * If `errors` is omitted, the first encountered error will be thrown.
   */
  formatPattern(pattern, args = null, errors = null) {
    if (typeof pattern === "string") {
      return this._transform(pattern);
    }
    let scope = new Scope(this, errors, args);
    try {
      let value = resolveComplexPattern(scope, pattern);
      return value.toString(scope);
    } catch (err) {
      if (scope.errors && err instanceof Error) {
        scope.errors.push(err);
        return new FluentNone().toString(scope);
      }
      throw err;
    }
  }
}
const RE_MESSAGE_START = /^(-?[a-zA-Z][\w-]*) *= */gm;
const RE_ATTRIBUTE_START = /\.([a-zA-Z][\w-]*) *= */y;
const RE_VARIANT_START = /\*?\[/y;
const RE_NUMBER_LITERAL = /(-?[0-9]+(?:\.([0-9]+))?)/y;
const RE_IDENTIFIER = /([a-zA-Z][\w-]*)/y;
const RE_REFERENCE = /([$-])?([a-zA-Z][\w-]*)(?:\.([a-zA-Z][\w-]*))?/y;
const RE_FUNCTION_NAME = /^[A-Z][A-Z0-9_-]*$/;
const RE_TEXT_RUN = /([^{}\n\r]+)/y;
const RE_STRING_RUN = /([^\\"\n\r]*)/y;
const RE_STRING_ESCAPE = /\\([\\"])/y;
const RE_UNICODE_ESCAPE = /\\u([a-fA-F0-9]{4})|\\U([a-fA-F0-9]{6})/y;
const RE_LEADING_NEWLINES = /^\n+/;
const RE_TRAILING_SPACES = / +$/;
const RE_BLANK_LINES = / *\r?\n/g;
const RE_INDENT = /( *)$/;
const TOKEN_BRACE_OPEN = /{\s*/y;
const TOKEN_BRACE_CLOSE = /\s*}/y;
const TOKEN_BRACKET_OPEN = /\[\s*/y;
const TOKEN_BRACKET_CLOSE = /\s*] */y;
const TOKEN_PAREN_OPEN = /\s*\(\s*/y;
const TOKEN_ARROW = /\s*->\s*/y;
const TOKEN_COLON = /\s*:\s*/y;
const TOKEN_COMMA = /\s*,?\s*/y;
const TOKEN_BLANK = /\s+/y;
class FluentResource {
  constructor(source) {
    this.body = [];
    RE_MESSAGE_START.lastIndex = 0;
    let cursor = 0;
    while (true) {
      let next11 = RE_MESSAGE_START.exec(source);
      if (next11 === null) {
        break;
      }
      cursor = RE_MESSAGE_START.lastIndex;
      try {
        this.body.push(parseMessage(next11[1]));
      } catch (err) {
        if (err instanceof SyntaxError) {
          continue;
        }
        throw err;
      }
    }
    function test2(re) {
      re.lastIndex = cursor;
      return re.test(source);
    }
    function consumeChar(char, errorClass) {
      if (source[cursor] === char) {
        cursor++;
        return true;
      }
      if (errorClass) {
        throw new errorClass(`Expected ${char}`);
      }
      return false;
    }
    function consumeToken(re, errorClass) {
      if (test2(re)) {
        cursor = re.lastIndex;
        return true;
      }
      if (errorClass) {
        throw new errorClass(`Expected ${re.toString()}`);
      }
      return false;
    }
    function match2(re) {
      re.lastIndex = cursor;
      let result = re.exec(source);
      if (result === null) {
        throw new SyntaxError(`Expected ${re.toString()}`);
      }
      cursor = re.lastIndex;
      return result;
    }
    function match1(re) {
      return match2(re)[1];
    }
    function parseMessage(id2) {
      let value = parsePattern();
      let attributes = parseAttributes();
      if (value === null && Object.keys(attributes).length === 0) {
        throw new SyntaxError("Expected message value or attributes");
      }
      return {
        id: id2,
        value,
        attributes
      };
    }
    function parseAttributes() {
      let attrs = /* @__PURE__ */ Object.create(null);
      while (test2(RE_ATTRIBUTE_START)) {
        let name = match1(RE_ATTRIBUTE_START);
        let value = parsePattern();
        if (value === null) {
          throw new SyntaxError("Expected attribute value");
        }
        attrs[name] = value;
      }
      return attrs;
    }
    function parsePattern() {
      let first;
      if (test2(RE_TEXT_RUN)) {
        first = match1(RE_TEXT_RUN);
      }
      if (source[cursor] === "{" || source[cursor] === "}") {
        return parsePatternElements(first ? [first] : [], Infinity);
      }
      let indent = parseIndent();
      if (indent) {
        if (first) {
          return parsePatternElements([first, indent], indent.length);
        }
        indent.value = trim3(indent.value, RE_LEADING_NEWLINES);
        return parsePatternElements([indent], indent.length);
      }
      if (first) {
        return trim3(first, RE_TRAILING_SPACES);
      }
      return null;
    }
    function parsePatternElements(elements = [], commonIndent) {
      while (true) {
        if (test2(RE_TEXT_RUN)) {
          elements.push(match1(RE_TEXT_RUN));
          continue;
        }
        if (source[cursor] === "{") {
          elements.push(parsePlaceable());
          continue;
        }
        if (source[cursor] === "}") {
          throw new SyntaxError("Unbalanced closing brace");
        }
        let indent = parseIndent();
        if (indent) {
          elements.push(indent);
          commonIndent = Math.min(commonIndent, indent.length);
          continue;
        }
        break;
      }
      let lastIndex = elements.length - 1;
      let lastElement = elements[lastIndex];
      if (typeof lastElement === "string") {
        elements[lastIndex] = trim3(lastElement, RE_TRAILING_SPACES);
      }
      let baked = [];
      for (let element of elements) {
        if (element instanceof Indent) {
          element = element.value.slice(0, element.value.length - commonIndent);
        }
        if (element) {
          baked.push(element);
        }
      }
      return baked;
    }
    function parsePlaceable() {
      consumeToken(TOKEN_BRACE_OPEN, SyntaxError);
      let selector = parseInlineExpression();
      if (consumeToken(TOKEN_BRACE_CLOSE)) {
        return selector;
      }
      if (consumeToken(TOKEN_ARROW)) {
        let variants = parseVariants();
        consumeToken(TOKEN_BRACE_CLOSE, SyntaxError);
        return {
          type: "select",
          selector,
          ...variants
        };
      }
      throw new SyntaxError("Unclosed placeable");
    }
    function parseInlineExpression() {
      if (source[cursor] === "{") {
        return parsePlaceable();
      }
      if (test2(RE_REFERENCE)) {
        let [, sigil, name, attr = null] = match2(RE_REFERENCE);
        if (sigil === "$") {
          return {
            type: "var",
            name
          };
        }
        if (consumeToken(TOKEN_PAREN_OPEN)) {
          let args = parseArguments();
          if (sigil === "-") {
            return {
              type: "term",
              name,
              attr,
              args
            };
          }
          if (RE_FUNCTION_NAME.test(name)) {
            return {
              type: "func",
              name,
              args
            };
          }
          throw new SyntaxError("Function names must be all upper-case");
        }
        if (sigil === "-") {
          return {
            type: "term",
            name,
            attr,
            args: []
          };
        }
        return {
          type: "mesg",
          name,
          attr
        };
      }
      return parseLiteral();
    }
    function parseArguments() {
      let args = [];
      while (true) {
        switch (source[cursor]) {
          case ")":
            cursor++;
            return args;
          case void 0:
            throw new SyntaxError("Unclosed argument list");
        }
        args.push(parseArgument());
        consumeToken(TOKEN_COMMA);
      }
    }
    function parseArgument() {
      let expr = parseInlineExpression();
      if (expr.type !== "mesg") {
        return expr;
      }
      if (consumeToken(TOKEN_COLON)) {
        return {
          type: "narg",
          name: expr.name,
          value: parseLiteral()
        };
      }
      return expr;
    }
    function parseVariants() {
      let variants = [];
      let count = 0;
      let star;
      while (test2(RE_VARIANT_START)) {
        if (consumeChar("*")) {
          star = count;
        }
        let key = parseVariantKey();
        let value = parsePattern();
        if (value === null) {
          throw new SyntaxError("Expected variant value");
        }
        variants[count++] = {
          key,
          value
        };
      }
      if (count === 0) {
        return null;
      }
      if (star === void 0) {
        throw new SyntaxError("Expected default variant");
      }
      return {
        variants,
        star
      };
    }
    function parseVariantKey() {
      consumeToken(TOKEN_BRACKET_OPEN, SyntaxError);
      let key;
      if (test2(RE_NUMBER_LITERAL)) {
        key = parseNumberLiteral();
      } else {
        key = {
          type: "str",
          value: match1(RE_IDENTIFIER)
        };
      }
      consumeToken(TOKEN_BRACKET_CLOSE, SyntaxError);
      return key;
    }
    function parseLiteral() {
      if (test2(RE_NUMBER_LITERAL)) {
        return parseNumberLiteral();
      }
      if (source[cursor] === '"') {
        return parseStringLiteral();
      }
      throw new SyntaxError("Invalid expression");
    }
    function parseNumberLiteral() {
      let [, value, fraction = ""] = match2(RE_NUMBER_LITERAL);
      let precision = fraction.length;
      return {
        type: "num",
        value: parseFloat(value),
        precision
      };
    }
    function parseStringLiteral() {
      consumeChar('"', SyntaxError);
      let value = "";
      while (true) {
        value += match1(RE_STRING_RUN);
        if (source[cursor] === "\\") {
          value += parseEscapeSequence();
          continue;
        }
        if (consumeChar('"')) {
          return {
            type: "str",
            value
          };
        }
        throw new SyntaxError("Unclosed string literal");
      }
    }
    function parseEscapeSequence() {
      if (test2(RE_STRING_ESCAPE)) {
        return match1(RE_STRING_ESCAPE);
      }
      if (test2(RE_UNICODE_ESCAPE)) {
        let [, codepoint4, codepoint6] = match2(RE_UNICODE_ESCAPE);
        let codepoint = parseInt(codepoint4 || codepoint6, 16);
        return codepoint <= 55295 || 57344 <= codepoint ? String.fromCodePoint(codepoint) : "";
      }
      throw new SyntaxError("Unknown escape sequence");
    }
    function parseIndent() {
      let start2 = cursor;
      consumeToken(TOKEN_BLANK);
      switch (source[cursor]) {
        case ".":
        case "[":
        case "*":
        case "}":
        case void 0:
          return false;
        case "{":
          return makeIndent(source.slice(start2, cursor));
      }
      if (source[cursor - 1] === " ") {
        return makeIndent(source.slice(start2, cursor));
      }
      return false;
    }
    function trim3(text, re) {
      return text.replace(re, "");
    }
    function makeIndent(blank) {
      let value = blank.replace(RE_BLANK_LINES, "\n");
      let length = RE_INDENT.exec(blank)[1].length;
      return new Indent(value, length);
    }
  }
}
class Indent {
  constructor(value, length) {
    this.value = value;
    this.length = length;
  }
}
function makeBundle(locale, ftl) {
  const bundle = new FluentBundle(locale, {
    useIsolating: false
  });
  bundle.addResource(new FluentResource(ftl));
  return bundle;
}
async function getTranslator(locale) {
  const bundles = [];
  const {
    default: en
  } = await __vitePreload(async () => {
    const {
      default: en2
    } = await import("./send.js");
    return {
      default: en2
    };
  }, true ? [] : void 0);
  if (locale !== "en-US") {
    const {
      default: ftl
    } = await __variableDynamicImportRuntimeHelper(/* @__PURE__ */ Object.assign({ "../public/locales/an/send.ftl": () => __vitePreload(() => import("./send2.js"), true ? [] : void 0), "../public/locales/ar/send.ftl": () => __vitePreload(() => import("./send3.js"), true ? [] : void 0), "../public/locales/ast/send.ftl": () => __vitePreload(() => import("./send4.js"), true ? [] : void 0), "../public/locales/az/send.ftl": () => __vitePreload(() => import("./send5.js"), true ? [] : void 0), "../public/locales/azz/send.ftl": () => __vitePreload(() => import("./send6.js"), true ? [] : void 0), "../public/locales/be/send.ftl": () => __vitePreload(() => import("./send7.js"), true ? [] : void 0), "../public/locales/bn/send.ftl": () => __vitePreload(() => import("./send8.js"), true ? [] : void 0), "../public/locales/br/send.ftl": () => __vitePreload(() => import("./send9.js"), true ? [] : void 0), "../public/locales/bs/send.ftl": () => __vitePreload(() => import("./send10.js"), true ? [] : void 0), "../public/locales/ca/send.ftl": () => __vitePreload(() => import("./send11.js"), true ? [] : void 0), "../public/locales/cak/send.ftl": () => __vitePreload(() => import("./send12.js"), true ? [] : void 0), "../public/locales/ckb/send.ftl": () => __vitePreload(() => import("./send13.js"), true ? [] : void 0), "../public/locales/cs/send.ftl": () => __vitePreload(() => import("./send14.js"), true ? [] : void 0), "../public/locales/cy/send.ftl": () => __vitePreload(() => import("./send15.js"), true ? [] : void 0), "../public/locales/da/send.ftl": () => __vitePreload(() => import("./send16.js"), true ? [] : void 0), "../public/locales/de/send.ftl": () => __vitePreload(() => import("./send17.js"), true ? [] : void 0), "../public/locales/dsb/send.ftl": () => __vitePreload(() => import("./send18.js"), true ? [] : void 0), "../public/locales/el/send.ftl": () => __vitePreload(() => import("./send19.js"), true ? [] : void 0), "../public/locales/en-CA/send.ftl": () => __vitePreload(() => import("./send20.js"), true ? [] : void 0), "../public/locales/en-GB/send.ftl": () => __vitePreload(() => import("./send21.js"), true ? [] : void 0), "../public/locales/en-US/send.ftl": () => __vitePreload(() => import("./send.js"), true ? [] : void 0), "../public/locales/es-AR/send.ftl": () => __vitePreload(() => import("./send22.js"), true ? [] : void 0), "../public/locales/es-CL/send.ftl": () => __vitePreload(() => import("./send23.js"), true ? [] : void 0), "../public/locales/es-ES/send.ftl": () => __vitePreload(() => import("./send24.js"), true ? [] : void 0), "../public/locales/es-MX/send.ftl": () => __vitePreload(() => import("./send25.js"), true ? [] : void 0), "../public/locales/et/send.ftl": () => __vitePreload(() => import("./send26.js"), true ? [] : void 0), "../public/locales/eu/send.ftl": () => __vitePreload(() => import("./send27.js"), true ? [] : void 0), "../public/locales/fa/send.ftl": () => __vitePreload(() => import("./send28.js"), true ? [] : void 0), "../public/locales/fi/send.ftl": () => __vitePreload(() => import("./send29.js"), true ? [] : void 0), "../public/locales/fr/send.ftl": () => __vitePreload(() => import("./send30.js"), true ? [] : void 0), "../public/locales/fy-NL/send.ftl": () => __vitePreload(() => import("./send31.js"), true ? [] : void 0), "../public/locales/gn/send.ftl": () => __vitePreload(() => import("./send32.js"), true ? [] : void 0), "../public/locales/gor/send.ftl": () => __vitePreload(() => import("./send33.js"), true ? [] : void 0), "../public/locales/he/send.ftl": () => __vitePreload(() => import("./send34.js"), true ? [] : void 0), "../public/locales/hr/send.ftl": () => __vitePreload(() => import("./send35.js"), true ? [] : void 0), "../public/locales/hsb/send.ftl": () => __vitePreload(() => import("./send36.js"), true ? [] : void 0), "../public/locales/hu/send.ftl": () => __vitePreload(() => import("./send37.js"), true ? [] : void 0), "../public/locales/hus/send.ftl": () => __vitePreload(() => import("./send38.js"), true ? [] : void 0), "../public/locales/hy-AM/send.ftl": () => __vitePreload(() => import("./send39.js"), true ? [] : void 0), "../public/locales/ia/send.ftl": () => __vitePreload(() => import("./send40.js"), true ? [] : void 0), "../public/locales/id/send.ftl": () => __vitePreload(() => import("./send41.js"), true ? [] : void 0), "../public/locales/ig/send.ftl": () => __vitePreload(() => import("./send42.js"), true ? [] : void 0), "../public/locales/it/send.ftl": () => __vitePreload(() => import("./send43.js"), true ? [] : void 0), "../public/locales/ixl/send.ftl": () => __vitePreload(() => import("./send44.js"), true ? [] : void 0), "../public/locales/ja/send.ftl": () => __vitePreload(() => import("./send45.js"), true ? [] : void 0), "../public/locales/ka/send.ftl": () => __vitePreload(() => import("./send46.js"), true ? [] : void 0), "../public/locales/kab/send.ftl": () => __vitePreload(() => import("./send47.js"), true ? [] : void 0), "../public/locales/ko/send.ftl": () => __vitePreload(() => import("./send48.js"), true ? [] : void 0), "../public/locales/lt/send.ftl": () => __vitePreload(() => import("./send49.js"), true ? [] : void 0), "../public/locales/lus/send.ftl": () => __vitePreload(() => import("./send50.js"), true ? [] : void 0), "../public/locales/meh/send.ftl": () => __vitePreload(() => import("./send51.js"), true ? [] : void 0), "../public/locales/mix/send.ftl": () => __vitePreload(() => import("./send52.js"), true ? [] : void 0), "../public/locales/ml/send.ftl": () => __vitePreload(() => import("./send53.js"), true ? [] : void 0), "../public/locales/ms/send.ftl": () => __vitePreload(() => import("./send54.js"), true ? [] : void 0), "../public/locales/nb-NO/send.ftl": () => __vitePreload(() => import("./send55.js"), true ? [] : void 0), "../public/locales/nl/send.ftl": () => __vitePreload(() => import("./send56.js"), true ? [] : void 0), "../public/locales/nn-NO/send.ftl": () => __vitePreload(() => import("./send57.js"), true ? [] : void 0), "../public/locales/oc/send.ftl": () => __vitePreload(() => import("./send58.js"), true ? [] : void 0), "../public/locales/pa-IN/send.ftl": () => __vitePreload(() => import("./send59.js"), true ? [] : void 0), "../public/locales/pai/send.ftl": () => __vitePreload(() => import("./send60.js"), true ? [] : void 0), "../public/locales/pl/send.ftl": () => __vitePreload(() => import("./send61.js"), true ? [] : void 0), "../public/locales/ppl/send.ftl": () => __vitePreload(() => import("./send62.js"), true ? [] : void 0), "../public/locales/pt-BR/send.ftl": () => __vitePreload(() => import("./send63.js"), true ? [] : void 0), "../public/locales/pt-PT/send.ftl": () => __vitePreload(() => import("./send64.js"), true ? [] : void 0), "../public/locales/quc/send.ftl": () => __vitePreload(() => import("./send65.js"), true ? [] : void 0), "../public/locales/ro/send.ftl": () => __vitePreload(() => import("./send66.js"), true ? [] : void 0), "../public/locales/ru/send.ftl": () => __vitePreload(() => import("./send67.js"), true ? [] : void 0), "../public/locales/sk/send.ftl": () => __vitePreload(() => import("./send68.js"), true ? [] : void 0), "../public/locales/sl/send.ftl": () => __vitePreload(() => import("./send69.js"), true ? [] : void 0), "../public/locales/sn/send.ftl": () => __vitePreload(() => import("./send70.js"), true ? [] : void 0), "../public/locales/sq/send.ftl": () => __vitePreload(() => import("./send71.js"), true ? [] : void 0), "../public/locales/sr/send.ftl": () => __vitePreload(() => import("./send72.js"), true ? [] : void 0), "../public/locales/su/send.ftl": () => __vitePreload(() => import("./send73.js"), true ? [] : void 0), "../public/locales/sv-SE/send.ftl": () => __vitePreload(() => import("./send74.js"), true ? [] : void 0), "../public/locales/te/send.ftl": () => __vitePreload(() => import("./send75.js"), true ? [] : void 0), "../public/locales/th/send.ftl": () => __vitePreload(() => import("./send76.js"), true ? [] : void 0), "../public/locales/tl/send.ftl": () => __vitePreload(() => import("./send77.js"), true ? [] : void 0), "../public/locales/tr/send.ftl": () => __vitePreload(() => import("./send78.js"), true ? [] : void 0), "../public/locales/trs/send.ftl": () => __vitePreload(() => import("./send79.js"), true ? [] : void 0), "../public/locales/uk/send.ftl": () => __vitePreload(() => import("./send80.js"), true ? [] : void 0), "../public/locales/vi/send.ftl": () => __vitePreload(() => import("./send81.js"), true ? [] : void 0), "../public/locales/yo/send.ftl": () => __vitePreload(() => import("./send82.js"), true ? [] : void 0), "../public/locales/yua/send.ftl": () => __vitePreload(() => import("./send83.js"), true ? [] : void 0), "../public/locales/zgh/send.ftl": () => __vitePreload(() => import("./send84.js"), true ? [] : void 0), "../public/locales/zh-CN/send.ftl": () => __vitePreload(() => import("./send85.js"), true ? [] : void 0), "../public/locales/zh-TW/send.ftl": () => __vitePreload(() => import("./send86.js"), true ? [] : void 0) }), `../public/locales/${locale}/send.ftl`, 5);
    bundles.push(makeBundle(locale, ftl));
  }
  bundles.push(makeBundle("en-US", en));
  return function(id2, data2) {
    for (let bundle of bundles) {
      if (bundle.hasMessage(id2)) {
        return bundle.formatPattern(bundle.getMessage(id2).value, data2);
      }
    }
  };
}
function isDupe(newFile, array) {
  for (const file of array) {
    if (newFile.name === file.name && newFile.size === file.size && newFile.lastModified === file.lastModified) {
      return true;
    }
  }
  return false;
}
class Archive {
  constructor(files = [], defaultTimeLimit = 86400, defaultDownloadLimit = 1) {
    this.files = Array.from(files);
    this.defaultTimeLimit = defaultTimeLimit;
    this.defaultDownloadLimit = defaultDownloadLimit;
    this.timeLimit = defaultTimeLimit;
    this.dlimit = defaultDownloadLimit;
    this.password = null;
  }
  get name() {
    return this.files.length > 1 ? "Send-Archive.zip" : this.files[0].name;
  }
  get type() {
    return this.files.length > 1 ? "send-archive" : this.files[0].type;
  }
  get size() {
    return this.files.reduce((total, file) => total + file.size, 0);
  }
  get numFiles() {
    return this.files.length;
  }
  get manifest() {
    return {
      files: this.files.map((file) => ({
        name: file.name,
        size: file.size,
        type: file.type
      }))
    };
  }
  get stream() {
    return concatStream(this.files.map((file) => blobStream(file)));
  }
  addFiles(files, maxSize, maxFiles) {
    if (this.files.length + files.length > maxFiles) {
      throw new Error("tooManyFiles");
    }
    const newFiles = files.filter((file) => file.size > 0 && !isDupe(file, this.files));
    const newSize = newFiles.reduce((total, file) => total + file.size, 0);
    if (this.size + newSize > maxSize) {
      throw new Error("fileTooBig");
    }
    this.files = this.files.concat(newFiles);
    return true;
  }
  remove(file) {
    const index = this.files.indexOf(file);
    if (index > -1) {
      this.files.splice(index, 1);
    }
  }
  clear() {
    this.files = [];
    this.dlimit = this.defaultDownloadLimit;
    this.timeLimit = this.defaultTimeLimit;
    this.password = null;
  }
}
if (typeof window !== "undefined") {
  window.Buffer = buffer$2.Buffer;
}
(async function start() {
  const capabilities = await getCapabilities();
  if (!capabilities.crypto && window.location.pathname !== "/unsupported/crypto") {
    return window.location.assign("/unsupported/crypto");
  }
  if (capabilities.serviceWorker) {
    try {
      await navigator.serviceWorker.register("/serviceWorker.js");
      await navigator.serviceWorker.ready;
    } catch (e) {
      console.log("Service Worker registration failed:", e);
      capabilities.streamDownload = false;
    }
  }
  const translate = await getTranslator(utilsExports.locale());
  utilsExports.setTranslate(translate);
  window.initialState = {
    LIMITS,
    DEFAULTS,
    WEB_UI,
    PREFS,
    archive: new Archive([], DEFAULTS.EXPIRE_SECONDS, DEFAULTS.DOWNLOADS),
    capabilities,
    translate,
    storage,
    transfer: null,
    fileInfo: null,
    locale: utilsExports.locale()
  };
  const app = routes(choo$1({
    hash: true,
    href: false
  }));
  window.app = app;
  app.use((state, emitter) => {
    emitter.once("DOMContentLoaded", () => {
      document.body.addEventListener("click", (event) => {
        const anchor2 = event.target.closest("a[data-action='logout']");
        if (!anchor2) {
          return;
        }
        event.preventDefault();
        try {
          if (typeof localStorage !== "undefined") {
            localStorage.clear();
          }
          if (typeof sessionStorage !== "undefined") {
            sessionStorage.clear();
          }
        } catch (err) {
          console.warn("Failed to clear storage on logout", err);
        }
        window.location.assign(anchor2.href);
      });
    });
  });
  app.use(initialize);
  app.use(controller);
  app.use(dragManager);
  app.use(pasteManager);
  app.mount("main");
})();
//# sourceMappingURL=app.js.map
