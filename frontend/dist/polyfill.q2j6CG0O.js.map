{"version":3,"file":"polyfill.q2j6CG0O.js","sources":["../node_modules/@mattiasbuelens/web-streams-polyfill/dist/polyfill.mjs"],"sourcesContent":["function _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n\nvar SymbolPolyfill = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol' ? Symbol : function (description) {\n  return \"Symbol(\" + description + \")\";\n};\n\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/isInteger#Polyfill\nvar NumberIsInteger = Number.isInteger || function (value) {\n  return typeof value === 'number' && isFinite(value) && Math.floor(value) === value;\n};\n\nfunction noop() {// do nothing\n}\n\nfunction getGlobals() {\n  /* global self, window, global */\n  if (typeof self !== 'undefined') {\n    return self;\n  } else if (typeof window !== 'undefined') {\n    return window;\n  } else if (typeof global !== 'undefined') {\n    return global;\n  }\n\n  return undefined;\n}\n\nvar globals = getGlobals();\n\n\n\nvar betterAssert = ({\n  default: noop\n});\n\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/isNaN#Polyfill\nvar NumberIsNaN = Number.isNaN || function (x) {\n  // eslint-disable-next-line no-self-compare\n  return x !== x;\n};\n\nfunction createCommonjsModule(fn, module) {\n\treturn module = { exports: {} }, fn(module, module.exports), module.exports;\n}\n\nfunction getCjsExportFromNamespace (n) {\n\treturn n && n.default || n;\n}\n\ngetCjsExportFromNamespace(betterAssert);\n\nvar helpers = createCommonjsModule(function (module, exports) {\n\n  var isFakeDetached = SymbolPolyfill('is \"detached\" for our purposes');\n\n  exports.typeIsObject = function (x) {\n    return typeof x === 'object' && x !== null || typeof x === 'function';\n  };\n\n  exports.createDataProperty = function (o, p, v) {\n    Object.defineProperty(o, p, {\n      value: v,\n      writable: true,\n      enumerable: true,\n      configurable: true\n    });\n  };\n\n  exports.createArrayFromList = function (elements) {\n    // We use arrays to represent lists, so this is basically a no-op.\n    // Do a slice though just in case we happen to depend on the unique-ness.\n    return elements.slice();\n  };\n\n  exports.ArrayBufferCopy = function (dest, destOffset, src, srcOffset, n) {\n    new Uint8Array(dest).set(new Uint8Array(src, srcOffset, n), destOffset);\n  };\n\n  exports.IsFiniteNonNegativeNumber = function (v) {\n    if (exports.IsNonNegativeNumber(v) === false) {\n      return false;\n    }\n\n    if (v === Infinity) {\n      return false;\n    }\n\n    return true;\n  };\n\n  exports.IsNonNegativeNumber = function (v) {\n    if (typeof v !== 'number') {\n      return false;\n    }\n\n    if (NumberIsNaN(v)) {\n      return false;\n    }\n\n    if (v < 0) {\n      return false;\n    }\n\n    return true;\n  };\n\n  function Call(F, V, args) {\n    if (typeof F !== 'function') {\n      throw new TypeError('Argument is not a function');\n    }\n\n    return Function.prototype.apply.call(F, V, args);\n  }\n\n  exports.Call = Call;\n\n  exports.CreateAlgorithmFromUnderlyingMethod = function (underlyingObject, methodName, algoArgCount, extraArgs) {\n    var method = underlyingObject[methodName];\n\n    if (method !== undefined) {\n      if (typeof method !== 'function') {\n        throw new TypeError(method + \" is not a method\");\n      }\n\n      switch (algoArgCount) {\n        case 0:\n          {\n            return function () {\n              return PromiseCall(method, underlyingObject, extraArgs);\n            };\n          }\n\n        case 1:\n          {\n            return function (arg) {\n              var fullArgs = [arg].concat(extraArgs);\n              return PromiseCall(method, underlyingObject, fullArgs);\n            };\n          }\n      }\n    }\n\n    return function () {\n      return Promise.resolve();\n    };\n  };\n\n  exports.InvokeOrNoop = function (O, P, args) {\n    var method = O[P];\n\n    if (method === undefined) {\n      return undefined;\n    }\n\n    return Call(method, O, args);\n  };\n\n  function PromiseCall(F, V, args) {\n    try {\n      return Promise.resolve(Call(F, V, args));\n    } catch (value) {\n      return Promise.reject(value);\n    }\n  }\n\n  exports.PromiseCall = PromiseCall; // Not implemented correctly\n\n  exports.TransferArrayBuffer = function (O) {\n    var transferredIshVersion = O.slice(); // This is specifically to fool tests that test \"is transferred\" by taking a non-zero-length\n    // ArrayBuffer and checking if its byteLength starts returning 0.\n\n    Object.defineProperty(O, 'byteLength', {\n      get: function get() {\n        return 0;\n      }\n    });\n    O[isFakeDetached] = true;\n    return transferredIshVersion;\n  }; // Not implemented correctly\n\n\n  exports.IsDetachedBuffer = function (O) {\n    return isFakeDetached in O;\n  };\n\n  exports.ValidateAndNormalizeHighWaterMark = function (highWaterMark) {\n    highWaterMark = Number(highWaterMark);\n\n    if (NumberIsNaN(highWaterMark) || highWaterMark < 0) {\n      throw new RangeError('highWaterMark property of a queuing strategy must be non-negative and non-NaN');\n    }\n\n    return highWaterMark;\n  };\n\n  exports.MakeSizeAlgorithmFromSizeFunction = function (size) {\n    if (size === undefined) {\n      return function () {\n        return 1;\n      };\n    }\n\n    if (typeof size !== 'function') {\n      throw new TypeError('size property of a queuing strategy must be a function');\n    }\n\n    return function (chunk) {\n      return size(chunk);\n    };\n  };\n\n  exports.PerformPromiseThen = function (promise, onFulfilled, onRejected) {\n    // There doesn't appear to be any way to correctly emulate the behaviour from JavaScript, so this is just an\n    // approximation.\n    return Promise.prototype.then.call(promise, onFulfilled, onRejected);\n  };\n\n  exports.WaitForAll = function (promises, successSteps, failureSteps) {\n    var rejected = false;\n\n    var rejectionHandler = function rejectionHandler(arg) {\n      if (rejected === false) {\n        rejected = true;\n        failureSteps(arg);\n      }\n    };\n\n    var index = 0;\n    var fulfilledCount = 0;\n    var total = promises.length;\n    var result = new Array(total);\n\n    var _loop = function _loop(_i2) {\n      var promise = promises[_i2];\n      var promiseIndex = index;\n\n      var fulfillmentHandler = function fulfillmentHandler(arg) {\n        result[promiseIndex] = arg;\n        ++fulfilledCount;\n\n        if (fulfilledCount === total) {\n          successSteps(result);\n        }\n      };\n\n      exports.PerformPromiseThen(promise, fulfillmentHandler, rejectionHandler);\n      ++index;\n    };\n\n    for (var _i2 = 0; _i2 < promises.length; _i2++) {\n      _loop(_i2);\n    }\n  };\n\n  exports.WaitForAllPromise = function (promises, successSteps, failureSteps) {\n    if (failureSteps === void 0) {\n      failureSteps = undefined;\n    }\n\n    var resolvePromise;\n    var rejectPromise;\n    var promise = new Promise(function (resolve, reject) {\n      resolvePromise = resolve;\n      rejectPromise = reject;\n    });\n\n    if (failureSteps === undefined) {\n      failureSteps = function failureSteps(arg) {\n        throw arg;\n      };\n    }\n\n    var successStepsWrapper = function successStepsWrapper(results) {\n      try {\n        var stepsResult = successSteps(results);\n        resolvePromise(stepsResult);\n      } catch (e) {\n        rejectPromise(e);\n      }\n    };\n\n    var failureStepsWrapper = function failureStepsWrapper(reason) {\n      try {\n        var stepsResult = failureSteps(reason);\n        resolvePromise(stepsResult);\n      } catch (e) {\n        rejectPromise(e);\n      }\n    };\n\n    exports.WaitForAll(promises, successStepsWrapper, failureStepsWrapper);\n    return promise;\n  };\n});\nvar helpers_1 = helpers.typeIsObject;\nvar helpers_2 = helpers.createDataProperty;\nvar helpers_3 = helpers.createArrayFromList;\nvar helpers_4 = helpers.ArrayBufferCopy;\nvar helpers_5 = helpers.IsFiniteNonNegativeNumber;\nvar helpers_6 = helpers.IsNonNegativeNumber;\nvar helpers_7 = helpers.Call;\nvar helpers_8 = helpers.CreateAlgorithmFromUnderlyingMethod;\nvar helpers_9 = helpers.InvokeOrNoop;\nvar helpers_10 = helpers.PromiseCall;\nvar helpers_11 = helpers.TransferArrayBuffer;\nvar helpers_12 = helpers.IsDetachedBuffer;\nvar helpers_13 = helpers.ValidateAndNormalizeHighWaterMark;\nvar helpers_14 = helpers.MakeSizeAlgorithmFromSizeFunction;\nvar helpers_15 = helpers.PerformPromiseThen;\nvar helpers_16 = helpers.WaitForAll;\nvar helpers_17 = helpers.WaitForAllPromise;\n\nfunction TransferArrayBuffer(O) {\n  return O;\n} // Not implemented correctly\n\nfunction IsDetachedBuffer(O) {\n  // eslint-disable-line no-unused-vars\n  return false;\n}\n\nvar helpers$1 = ({\n  TransferArrayBuffer: TransferArrayBuffer,\n  IsDetachedBuffer: IsDetachedBuffer,\n  typeIsObject: helpers_1,\n  createDataProperty: helpers_2,\n  createArrayFromList: helpers_3,\n  ArrayBufferCopy: helpers_4,\n  IsFiniteNonNegativeNumber: helpers_5,\n  IsNonNegativeNumber: helpers_6,\n  Call: helpers_7,\n  CreateAlgorithmFromUnderlyingMethod: helpers_8,\n  InvokeOrNoop: helpers_9,\n  PromiseCall: helpers_10,\n  ValidateAndNormalizeHighWaterMark: helpers_13,\n  MakeSizeAlgorithmFromSizeFunction: helpers_14,\n  PerformPromiseThen: helpers_15,\n  WaitForAll: helpers_16,\n  WaitForAllPromise: helpers_17\n});\n\nfunction assert() {// do nothing\n}\nassert.AssertionError = noop;\n\nvar assert$1 = ({\n  default: assert\n});\n\nvar assert$2 = getCjsExportFromNamespace(assert$1);\n\nvar rethrowAssertionErrorRejection = function rethrowAssertionErrorRejection(e) {\n  // Used throughout the reference implementation, as `.catch(rethrowAssertionErrorRejection)`, to ensure any errors\n  // get shown. There are places in the spec where we do promise transformations and purposefully ignore or don't\n  // expect any errors, but assertion errors are always problematic.\n  if (e && e instanceof assert$2.AssertionError) {\n    setTimeout(function () {\n      throw e;\n    }, 0);\n  }\n};\n\nvar utils = {\n  rethrowAssertionErrorRejection: rethrowAssertionErrorRejection\n};\n\nvar require$$0 = getCjsExportFromNamespace(helpers$1);\n\nvar IsFiniteNonNegativeNumber = require$$0.IsFiniteNonNegativeNumber;\n\nvar DequeueValue = function DequeueValue(container) {\n  var pair = container._queue.shift();\n\n  container._queueTotalSize -= pair.size;\n\n  if (container._queueTotalSize < 0) {\n    container._queueTotalSize = 0;\n  }\n\n  return pair.value;\n};\n\nvar EnqueueValueWithSize = function EnqueueValueWithSize(container, value, size) {\n  size = Number(size);\n\n  if (!IsFiniteNonNegativeNumber(size)) {\n    throw new RangeError('Size must be a finite, non-NaN, non-negative number.');\n  }\n\n  container._queue.push({\n    value: value,\n    size: size\n  });\n\n  container._queueTotalSize += size;\n};\n\nvar PeekQueueValue = function PeekQueueValue(container) {\n  var pair = container._queue[0];\n  return pair.value;\n};\n\nvar ResetQueue = function ResetQueue(container) {\n  container._queue = [];\n  container._queueTotalSize = 0;\n};\n\nvar queueWithSizes = {\n  DequeueValue: DequeueValue,\n  EnqueueValueWithSize: EnqueueValueWithSize,\n  PeekQueueValue: PeekQueueValue,\n  ResetQueue: ResetQueue\n};\n\n\n\nvar debug = ({\n  default: noop\n});\n\nvar require$$0$1 = getCjsExportFromNamespace(debug);\n\n// and do not appear in the standard text.\n\n\nvar verbose = require$$0$1('streams:writable-stream:verbose');\nvar CreateAlgorithmFromUnderlyingMethod = require$$0.CreateAlgorithmFromUnderlyingMethod,\n    InvokeOrNoop = require$$0.InvokeOrNoop,\n    ValidateAndNormalizeHighWaterMark = require$$0.ValidateAndNormalizeHighWaterMark,\n    IsNonNegativeNumber = require$$0.IsNonNegativeNumber,\n    MakeSizeAlgorithmFromSizeFunction = require$$0.MakeSizeAlgorithmFromSizeFunction,\n    typeIsObject = require$$0.typeIsObject;\nvar rethrowAssertionErrorRejection$1 = utils.rethrowAssertionErrorRejection;\nvar DequeueValue$1 = queueWithSizes.DequeueValue,\n    EnqueueValueWithSize$1 = queueWithSizes.EnqueueValueWithSize,\n    PeekQueueValue$1 = queueWithSizes.PeekQueueValue,\n    ResetQueue$1 = queueWithSizes.ResetQueue;\nvar AbortSteps = SymbolPolyfill('[[AbortSteps]]');\nvar ErrorSteps = SymbolPolyfill('[[ErrorSteps]]');\n\nvar WritableStream =\n/*#__PURE__*/\nfunction () {\n  function WritableStream(underlyingSink, strategy) {\n    if (underlyingSink === void 0) {\n      underlyingSink = {};\n    }\n\n    if (strategy === void 0) {\n      strategy = {};\n    }\n\n    InitializeWritableStream(this);\n    var size = strategy.size;\n    var highWaterMark = strategy.highWaterMark;\n    var type = underlyingSink.type;\n\n    if (type !== undefined) {\n      throw new RangeError('Invalid type is specified');\n    }\n\n    var sizeAlgorithm = MakeSizeAlgorithmFromSizeFunction(size);\n\n    if (highWaterMark === undefined) {\n      highWaterMark = 1;\n    }\n\n    highWaterMark = ValidateAndNormalizeHighWaterMark(highWaterMark);\n    SetUpWritableStreamDefaultControllerFromUnderlyingSink(this, underlyingSink, highWaterMark, sizeAlgorithm);\n  }\n\n  var _proto = WritableStream.prototype;\n\n  _proto.abort = function abort(reason) {\n    if (IsWritableStream(this) === false) {\n      return Promise.reject(streamBrandCheckException('abort'));\n    }\n\n    if (IsWritableStreamLocked(this) === true) {\n      return Promise.reject(new TypeError('Cannot abort a stream that already has a writer'));\n    }\n\n    return WritableStreamAbort(this, reason);\n  };\n\n  _proto.getWriter = function getWriter() {\n    if (IsWritableStream(this) === false) {\n      throw streamBrandCheckException('getWriter');\n    }\n\n    return AcquireWritableStreamDefaultWriter(this);\n  };\n\n  _createClass(WritableStream, [{\n    key: \"locked\",\n    get: function get() {\n      if (IsWritableStream(this) === false) {\n        throw streamBrandCheckException('locked');\n      }\n\n      return IsWritableStreamLocked(this);\n    }\n  }]);\n\n  return WritableStream;\n}();\n\nvar writableStream = {\n  AcquireWritableStreamDefaultWriter: AcquireWritableStreamDefaultWriter,\n  CreateWritableStream: CreateWritableStream,\n  IsWritableStream: IsWritableStream,\n  IsWritableStreamLocked: IsWritableStreamLocked,\n  WritableStream: WritableStream,\n  WritableStreamAbort: WritableStreamAbort,\n  WritableStreamDefaultControllerErrorIfNeeded: WritableStreamDefaultControllerErrorIfNeeded,\n  WritableStreamDefaultWriterCloseWithErrorPropagation: WritableStreamDefaultWriterCloseWithErrorPropagation,\n  WritableStreamDefaultWriterRelease: WritableStreamDefaultWriterRelease,\n  WritableStreamDefaultWriterWrite: WritableStreamDefaultWriterWrite,\n  WritableStreamCloseQueuedOrInFlight: WritableStreamCloseQueuedOrInFlight\n}; // Abstract operations for the WritableStream.\n\nfunction AcquireWritableStreamDefaultWriter(stream) {\n  return new WritableStreamDefaultWriter(stream);\n} // Throws if and only if startAlgorithm throws.\n\n\nfunction CreateWritableStream(startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark, sizeAlgorithm) {\n  if (highWaterMark === void 0) {\n    highWaterMark = 1;\n  }\n\n  if (sizeAlgorithm === void 0) {\n    sizeAlgorithm = function sizeAlgorithm() {\n      return 1;\n    };\n  }\n\n  var stream = Object.create(WritableStream.prototype);\n  InitializeWritableStream(stream);\n  var controller = Object.create(WritableStreamDefaultController.prototype);\n  SetUpWritableStreamDefaultController(stream, controller, startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark, sizeAlgorithm);\n  return stream;\n}\n\nfunction InitializeWritableStream(stream) {\n  stream._state = 'writable'; // The error that will be reported by new method calls once the state becomes errored. Only set when [[state]] is\n  // 'erroring' or 'errored'. May be set to an undefined value.\n\n  stream._storedError = undefined;\n  stream._writer = undefined; // Initialize to undefined first because the constructor of the controller checks this\n  // variable to validate the caller.\n\n  stream._writableStreamController = undefined; // This queue is placed here instead of the writer class in order to allow for passing a writer to the next data\n  // producer without waiting for the queued writes to finish.\n\n  stream._writeRequests = []; // Write requests are removed from _writeRequests when write() is called on the underlying sink. This prevents\n  // them from being erroneously rejected on error. If a write() call is in-flight, the request is stored here.\n\n  stream._inFlightWriteRequest = undefined; // The promise that was returned from writer.close(). Stored here because it may be fulfilled after the writer\n  // has been detached.\n\n  stream._closeRequest = undefined; // Close request is removed from _closeRequest when close() is called on the underlying sink. This prevents it\n  // from being erroneously rejected on error. If a close() call is in-flight, the request is stored here.\n\n  stream._inFlightCloseRequest = undefined; // The promise that was returned from writer.abort(). This may also be fulfilled after the writer has detached.\n\n  stream._pendingAbortRequest = undefined; // The backpressure signal set by the controller.\n\n  stream._backpressure = false;\n}\n\nfunction IsWritableStream(x) {\n  if (!typeIsObject(x)) {\n    return false;\n  }\n\n  if (!Object.prototype.hasOwnProperty.call(x, '_writableStreamController')) {\n    return false;\n  }\n\n  return true;\n}\n\nfunction IsWritableStreamLocked(stream) {\n  if (stream._writer === undefined) {\n    return false;\n  }\n\n  return true;\n}\n\nfunction WritableStreamAbort(stream, reason) {\n  var state = stream._state;\n\n  if (state === 'closed' || state === 'errored') {\n    return Promise.resolve(undefined);\n  }\n\n  if (stream._pendingAbortRequest !== undefined) {\n    return stream._pendingAbortRequest._promise;\n  }\n\n  var wasAlreadyErroring = false;\n\n  if (state === 'erroring') {\n    wasAlreadyErroring = true; // reason will not be used, so don't keep a reference to it.\n\n    reason = undefined;\n  }\n\n  var promise = new Promise(function (resolve, reject) {\n    stream._pendingAbortRequest = {\n      _resolve: resolve,\n      _reject: reject,\n      _reason: reason,\n      _wasAlreadyErroring: wasAlreadyErroring\n    };\n  });\n  stream._pendingAbortRequest._promise = promise;\n\n  if (wasAlreadyErroring === false) {\n    WritableStreamStartErroring(stream, reason);\n  }\n\n  return promise;\n} // WritableStream API exposed for controllers.\n\n\nfunction WritableStreamAddWriteRequest(stream) {\n  var promise = new Promise(function (resolve, reject) {\n    var writeRequest = {\n      _resolve: resolve,\n      _reject: reject\n    };\n\n    stream._writeRequests.push(writeRequest);\n  });\n  return promise;\n}\n\nfunction WritableStreamDealWithRejection(stream, error) {\n  var state = stream._state;\n\n  if (state === 'writable') {\n    WritableStreamStartErroring(stream, error);\n    return;\n  }\n\n  WritableStreamFinishErroring(stream);\n}\n\nfunction WritableStreamStartErroring(stream, reason) {\n  var controller = stream._writableStreamController;\n  stream._state = 'erroring';\n  stream._storedError = reason;\n  var writer = stream._writer;\n\n  if (writer !== undefined) {\n    WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, reason);\n  }\n\n  if (WritableStreamHasOperationMarkedInFlight(stream) === false && controller._started === true) {\n    WritableStreamFinishErroring(stream);\n  }\n}\n\nfunction WritableStreamFinishErroring(stream) {\n  stream._state = 'errored';\n\n  stream._writableStreamController[ErrorSteps]();\n\n  var storedError = stream._storedError;\n\n  for (var _i2 = 0, _stream$_writeRequest2 = stream._writeRequests; _i2 < _stream$_writeRequest2.length; _i2++) {\n    var writeRequest = _stream$_writeRequest2[_i2];\n\n    writeRequest._reject(storedError);\n  }\n\n  stream._writeRequests = [];\n\n  if (stream._pendingAbortRequest === undefined) {\n    WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);\n    return;\n  }\n\n  var abortRequest = stream._pendingAbortRequest;\n  stream._pendingAbortRequest = undefined;\n\n  if (abortRequest._wasAlreadyErroring === true) {\n    abortRequest._reject(storedError);\n\n    WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);\n    return;\n  }\n\n  var promise = stream._writableStreamController[AbortSteps](abortRequest._reason);\n\n  promise.then(function () {\n    abortRequest._resolve();\n\n    WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);\n  }, function (reason) {\n    abortRequest._reject(reason);\n\n    WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);\n  });\n}\n\nfunction WritableStreamFinishInFlightWrite(stream) {\n  stream._inFlightWriteRequest._resolve(undefined);\n\n  stream._inFlightWriteRequest = undefined;\n}\n\nfunction WritableStreamFinishInFlightWriteWithError(stream, error) {\n  stream._inFlightWriteRequest._reject(error);\n\n  stream._inFlightWriteRequest = undefined;\n  WritableStreamDealWithRejection(stream, error);\n}\n\nfunction WritableStreamFinishInFlightClose(stream) {\n  stream._inFlightCloseRequest._resolve(undefined);\n\n  stream._inFlightCloseRequest = undefined;\n  var state = stream._state;\n\n  if (state === 'erroring') {\n    // The error was too late to do anything, so it is ignored.\n    stream._storedError = undefined;\n\n    if (stream._pendingAbortRequest !== undefined) {\n      stream._pendingAbortRequest._resolve();\n\n      stream._pendingAbortRequest = undefined;\n    }\n  }\n\n  stream._state = 'closed';\n  var writer = stream._writer;\n\n  if (writer !== undefined) {\n    defaultWriterClosedPromiseResolve(writer);\n  }\n}\n\nfunction WritableStreamFinishInFlightCloseWithError(stream, error) {\n  stream._inFlightCloseRequest._reject(error);\n\n  stream._inFlightCloseRequest = undefined; // Never execute sink abort() after sink close().\n\n  if (stream._pendingAbortRequest !== undefined) {\n    stream._pendingAbortRequest._reject(error);\n\n    stream._pendingAbortRequest = undefined;\n  }\n\n  WritableStreamDealWithRejection(stream, error);\n} // TODO(ricea): Fix alphabetical order.\n\n\nfunction WritableStreamCloseQueuedOrInFlight(stream) {\n  if (stream._closeRequest === undefined && stream._inFlightCloseRequest === undefined) {\n    return false;\n  }\n\n  return true;\n}\n\nfunction WritableStreamHasOperationMarkedInFlight(stream) {\n  if (stream._inFlightWriteRequest === undefined && stream._inFlightCloseRequest === undefined) {\n    return false;\n  }\n\n  return true;\n}\n\nfunction WritableStreamMarkCloseRequestInFlight(stream) {\n  stream._inFlightCloseRequest = stream._closeRequest;\n  stream._closeRequest = undefined;\n}\n\nfunction WritableStreamMarkFirstWriteRequestInFlight(stream) {\n  stream._inFlightWriteRequest = stream._writeRequests.shift();\n}\n\nfunction WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream) {\n  if (stream._closeRequest !== undefined) {\n    stream._closeRequest._reject(stream._storedError);\n\n    stream._closeRequest = undefined;\n  }\n\n  var writer = stream._writer;\n\n  if (writer !== undefined) {\n    defaultWriterClosedPromiseReject(writer, stream._storedError);\n\n    writer._closedPromise.catch(function () {});\n  }\n}\n\nfunction WritableStreamUpdateBackpressure(stream, backpressure) {\n  var writer = stream._writer;\n\n  if (writer !== undefined && backpressure !== stream._backpressure) {\n    if (backpressure === true) {\n      defaultWriterReadyPromiseReset(writer);\n    } else {\n      defaultWriterReadyPromiseResolve(writer);\n    }\n  }\n\n  stream._backpressure = backpressure;\n}\n\nvar WritableStreamDefaultWriter =\n/*#__PURE__*/\nfunction () {\n  function WritableStreamDefaultWriter(stream) {\n    if (IsWritableStream(stream) === false) {\n      throw new TypeError('WritableStreamDefaultWriter can only be constructed with a WritableStream instance');\n    }\n\n    if (IsWritableStreamLocked(stream) === true) {\n      throw new TypeError('This stream has already been locked for exclusive writing by another writer');\n    }\n\n    this._ownerWritableStream = stream;\n    stream._writer = this;\n    var state = stream._state;\n\n    if (state === 'writable') {\n      if (WritableStreamCloseQueuedOrInFlight(stream) === false && stream._backpressure === true) {\n        defaultWriterReadyPromiseInitialize(this);\n      } else {\n        defaultWriterReadyPromiseInitializeAsResolved(this);\n      }\n\n      defaultWriterClosedPromiseInitialize(this);\n    } else if (state === 'erroring') {\n      defaultWriterReadyPromiseInitializeAsRejected(this, stream._storedError);\n\n      this._readyPromise.catch(function () {});\n\n      defaultWriterClosedPromiseInitialize(this);\n    } else if (state === 'closed') {\n      defaultWriterReadyPromiseInitializeAsResolved(this);\n      defaultWriterClosedPromiseInitializeAsResolved(this);\n    } else {\n      var storedError = stream._storedError;\n      defaultWriterReadyPromiseInitializeAsRejected(this, storedError);\n\n      this._readyPromise.catch(function () {});\n\n      defaultWriterClosedPromiseInitializeAsRejected(this, storedError);\n\n      this._closedPromise.catch(function () {});\n    }\n  }\n\n  var _proto2 = WritableStreamDefaultWriter.prototype;\n\n  _proto2.abort = function abort(reason) {\n    if (IsWritableStreamDefaultWriter(this) === false) {\n      return Promise.reject(defaultWriterBrandCheckException('abort'));\n    }\n\n    if (this._ownerWritableStream === undefined) {\n      return Promise.reject(defaultWriterLockException('abort'));\n    }\n\n    return WritableStreamDefaultWriterAbort(this, reason);\n  };\n\n  _proto2.close = function close() {\n    if (IsWritableStreamDefaultWriter(this) === false) {\n      return Promise.reject(defaultWriterBrandCheckException('close'));\n    }\n\n    var stream = this._ownerWritableStream;\n\n    if (stream === undefined) {\n      return Promise.reject(defaultWriterLockException('close'));\n    }\n\n    if (WritableStreamCloseQueuedOrInFlight(stream) === true) {\n      return Promise.reject(new TypeError('cannot close an already-closing stream'));\n    }\n\n    return WritableStreamDefaultWriterClose(this);\n  };\n\n  _proto2.releaseLock = function releaseLock() {\n    if (IsWritableStreamDefaultWriter(this) === false) {\n      throw defaultWriterBrandCheckException('releaseLock');\n    }\n\n    var stream = this._ownerWritableStream;\n\n    if (stream === undefined) {\n      return;\n    }\n\n    WritableStreamDefaultWriterRelease(this);\n  };\n\n  _proto2.write = function write(chunk) {\n    if (IsWritableStreamDefaultWriter(this) === false) {\n      return Promise.reject(defaultWriterBrandCheckException('write'));\n    }\n\n    if (this._ownerWritableStream === undefined) {\n      return Promise.reject(defaultWriterLockException('write to'));\n    }\n\n    return WritableStreamDefaultWriterWrite(this, chunk);\n  };\n\n  _createClass(WritableStreamDefaultWriter, [{\n    key: \"closed\",\n    get: function get() {\n      if (IsWritableStreamDefaultWriter(this) === false) {\n        return Promise.reject(defaultWriterBrandCheckException('closed'));\n      }\n\n      return this._closedPromise;\n    }\n  }, {\n    key: \"desiredSize\",\n    get: function get() {\n      if (IsWritableStreamDefaultWriter(this) === false) {\n        throw defaultWriterBrandCheckException('desiredSize');\n      }\n\n      if (this._ownerWritableStream === undefined) {\n        throw defaultWriterLockException('desiredSize');\n      }\n\n      return WritableStreamDefaultWriterGetDesiredSize(this);\n    }\n  }, {\n    key: \"ready\",\n    get: function get() {\n      if (IsWritableStreamDefaultWriter(this) === false) {\n        return Promise.reject(defaultWriterBrandCheckException('ready'));\n      }\n\n      return this._readyPromise;\n    }\n  }]);\n\n  return WritableStreamDefaultWriter;\n}(); // Abstract operations for the WritableStreamDefaultWriter.\n\n\nfunction IsWritableStreamDefaultWriter(x) {\n  if (!typeIsObject(x)) {\n    return false;\n  }\n\n  if (!Object.prototype.hasOwnProperty.call(x, '_ownerWritableStream')) {\n    return false;\n  }\n\n  return true;\n} // A client of WritableStreamDefaultWriter may use these functions directly to bypass state check.\n\n\nfunction WritableStreamDefaultWriterAbort(writer, reason) {\n  var stream = writer._ownerWritableStream;\n  return WritableStreamAbort(stream, reason);\n}\n\nfunction WritableStreamDefaultWriterClose(writer) {\n  var stream = writer._ownerWritableStream;\n  var state = stream._state;\n\n  if (state === 'closed' || state === 'errored') {\n    return Promise.reject(new TypeError(\"The stream (in \" + state + \" state) is not in the writable state and cannot be closed\"));\n  }\n\n  var promise = new Promise(function (resolve, reject) {\n    var closeRequest = {\n      _resolve: resolve,\n      _reject: reject\n    };\n    stream._closeRequest = closeRequest;\n  });\n\n  if (stream._backpressure === true && state === 'writable') {\n    defaultWriterReadyPromiseResolve(writer);\n  }\n\n  WritableStreamDefaultControllerClose(stream._writableStreamController);\n  return promise;\n}\n\nfunction WritableStreamDefaultWriterCloseWithErrorPropagation(writer) {\n  var stream = writer._ownerWritableStream;\n  var state = stream._state;\n\n  if (WritableStreamCloseQueuedOrInFlight(stream) === true || state === 'closed') {\n    return Promise.resolve();\n  }\n\n  if (state === 'errored') {\n    return Promise.reject(stream._storedError);\n  }\n\n  return WritableStreamDefaultWriterClose(writer);\n}\n\nfunction WritableStreamDefaultWriterEnsureClosedPromiseRejected(writer, error) {\n  if (writer._closedPromiseState === 'pending') {\n    defaultWriterClosedPromiseReject(writer, error);\n  } else {\n    defaultWriterClosedPromiseResetToRejected(writer, error);\n  }\n\n  writer._closedPromise.catch(function () {});\n}\n\nfunction WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, error) {\n  if (writer._readyPromiseState === 'pending') {\n    defaultWriterReadyPromiseReject(writer, error);\n  } else {\n    defaultWriterReadyPromiseResetToRejected(writer, error);\n  }\n\n  writer._readyPromise.catch(function () {});\n}\n\nfunction WritableStreamDefaultWriterGetDesiredSize(writer) {\n  var stream = writer._ownerWritableStream;\n  var state = stream._state;\n\n  if (state === 'errored' || state === 'erroring') {\n    return null;\n  }\n\n  if (state === 'closed') {\n    return 0;\n  }\n\n  return WritableStreamDefaultControllerGetDesiredSize(stream._writableStreamController);\n}\n\nfunction WritableStreamDefaultWriterRelease(writer) {\n  var stream = writer._ownerWritableStream;\n  var releasedError = new TypeError('Writer was released and can no longer be used to monitor the stream\\'s closedness');\n  WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, releasedError); // The state transitions to \"errored\" before the sink abort() method runs, but the writer.closed promise is not\n  // rejected until afterwards. This means that simply testing state will not work.\n\n  WritableStreamDefaultWriterEnsureClosedPromiseRejected(writer, releasedError);\n  stream._writer = undefined;\n  writer._ownerWritableStream = undefined;\n}\n\nfunction WritableStreamDefaultWriterWrite(writer, chunk) {\n  var stream = writer._ownerWritableStream;\n  var controller = stream._writableStreamController;\n  var chunkSize = WritableStreamDefaultControllerGetChunkSize(controller, chunk);\n\n  if (stream !== writer._ownerWritableStream) {\n    return Promise.reject(defaultWriterLockException('write to'));\n  }\n\n  var state = stream._state;\n\n  if (state === 'errored') {\n    return Promise.reject(stream._storedError);\n  }\n\n  if (WritableStreamCloseQueuedOrInFlight(stream) === true || state === 'closed') {\n    return Promise.reject(new TypeError('The stream is closing or closed and cannot be written to'));\n  }\n\n  if (state === 'erroring') {\n    return Promise.reject(stream._storedError);\n  }\n\n  var promise = WritableStreamAddWriteRequest(stream);\n  WritableStreamDefaultControllerWrite(controller, chunk, chunkSize);\n  return promise;\n}\n\nvar WritableStreamDefaultController =\n/*#__PURE__*/\nfunction () {\n  function WritableStreamDefaultController() {\n    throw new TypeError('WritableStreamDefaultController cannot be constructed explicitly');\n  }\n\n  var _proto3 = WritableStreamDefaultController.prototype;\n\n  _proto3.error = function error(e) {\n    if (IsWritableStreamDefaultController(this) === false) {\n      throw new TypeError('WritableStreamDefaultController.prototype.error can only be used on a WritableStreamDefaultController');\n    }\n\n    var state = this._controlledWritableStream._state;\n\n    if (state !== 'writable') {\n      // The stream is closed, errored or will be soon. The sink can't do anything useful if it gets an error here, so\n      // just treat it as a no-op.\n      return;\n    }\n\n    WritableStreamDefaultControllerError(this, e);\n  };\n\n  _proto3[AbortSteps] = function (reason) {\n    var result = this._abortAlgorithm(reason);\n\n    WritableStreamDefaultControllerClearAlgorithms(this);\n    return result;\n  };\n\n  _proto3[ErrorSteps] = function () {\n    ResetQueue$1(this);\n  };\n\n  return WritableStreamDefaultController;\n}(); // Abstract operations implementing interface required by the WritableStream.\n\n\nfunction IsWritableStreamDefaultController(x) {\n  if (!typeIsObject(x)) {\n    return false;\n  }\n\n  if (!Object.prototype.hasOwnProperty.call(x, '_controlledWritableStream')) {\n    return false;\n  }\n\n  return true;\n}\n\nfunction SetUpWritableStreamDefaultController(stream, controller, startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark, sizeAlgorithm) {\n  controller._controlledWritableStream = stream;\n  stream._writableStreamController = controller; // Need to set the slots so that the assert doesn't fire. In the spec the slots already exist implicitly.\n\n  controller._queue = undefined;\n  controller._queueTotalSize = undefined;\n  ResetQueue$1(controller);\n  controller._started = false;\n  controller._strategySizeAlgorithm = sizeAlgorithm;\n  controller._strategyHWM = highWaterMark;\n  controller._writeAlgorithm = writeAlgorithm;\n  controller._closeAlgorithm = closeAlgorithm;\n  controller._abortAlgorithm = abortAlgorithm;\n  var backpressure = WritableStreamDefaultControllerGetBackpressure(controller);\n  WritableStreamUpdateBackpressure(stream, backpressure);\n  var startResult = startAlgorithm();\n  var startPromise = Promise.resolve(startResult);\n  startPromise.then(function () {\n    controller._started = true;\n    WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);\n  }, function (r) {\n    controller._started = true;\n    WritableStreamDealWithRejection(stream, r);\n  }).catch(rethrowAssertionErrorRejection$1);\n}\n\nfunction SetUpWritableStreamDefaultControllerFromUnderlyingSink(stream, underlyingSink, highWaterMark, sizeAlgorithm) {\n  var controller = Object.create(WritableStreamDefaultController.prototype);\n\n  function startAlgorithm() {\n    return InvokeOrNoop(underlyingSink, 'start', [controller]);\n  }\n\n  var writeAlgorithm = CreateAlgorithmFromUnderlyingMethod(underlyingSink, 'write', 1, [controller]);\n  var closeAlgorithm = CreateAlgorithmFromUnderlyingMethod(underlyingSink, 'close', 0, []);\n  var abortAlgorithm = CreateAlgorithmFromUnderlyingMethod(underlyingSink, 'abort', 1, []);\n  SetUpWritableStreamDefaultController(stream, controller, startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark, sizeAlgorithm);\n} // ClearAlgorithms may be called twice. Erroring the same stream in multiple ways will often result in redundant calls.\n\n\nfunction WritableStreamDefaultControllerClearAlgorithms(controller) {\n  controller._writeAlgorithm = undefined;\n  controller._closeAlgorithm = undefined;\n  controller._abortAlgorithm = undefined;\n  controller._strategySizeAlgorithm = undefined;\n}\n\nfunction WritableStreamDefaultControllerClose(controller) {\n  EnqueueValueWithSize$1(controller, 'close', 0);\n  WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);\n}\n\nfunction WritableStreamDefaultControllerGetChunkSize(controller, chunk) {\n  try {\n    return controller._strategySizeAlgorithm(chunk);\n  } catch (chunkSizeE) {\n    WritableStreamDefaultControllerErrorIfNeeded(controller, chunkSizeE);\n    return 1;\n  }\n}\n\nfunction WritableStreamDefaultControllerGetDesiredSize(controller) {\n  return controller._strategyHWM - controller._queueTotalSize;\n}\n\nfunction WritableStreamDefaultControllerWrite(controller, chunk, chunkSize) {\n  var writeRecord = {\n    chunk: chunk\n  };\n\n  try {\n    EnqueueValueWithSize$1(controller, writeRecord, chunkSize);\n  } catch (enqueueE) {\n    WritableStreamDefaultControllerErrorIfNeeded(controller, enqueueE);\n    return;\n  }\n\n  var stream = controller._controlledWritableStream;\n\n  if (WritableStreamCloseQueuedOrInFlight(stream) === false && stream._state === 'writable') {\n    var backpressure = WritableStreamDefaultControllerGetBackpressure(controller);\n    WritableStreamUpdateBackpressure(stream, backpressure);\n  }\n\n  WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);\n} // Abstract operations for the WritableStreamDefaultController.\n\n\nfunction WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller) {\n  var stream = controller._controlledWritableStream;\n\n  if (controller._started === false) {\n    return;\n  }\n\n  if (stream._inFlightWriteRequest !== undefined) {\n    return;\n  }\n\n  var state = stream._state;\n\n  if (state === 'closed' || state === 'errored') {\n    return;\n  }\n\n  if (state === 'erroring') {\n    WritableStreamFinishErroring(stream);\n    return;\n  }\n\n  if (controller._queue.length === 0) {\n    return;\n  }\n\n  var writeRecord = PeekQueueValue$1(controller);\n\n  if (writeRecord === 'close') {\n    WritableStreamDefaultControllerProcessClose(controller);\n  } else {\n    WritableStreamDefaultControllerProcessWrite(controller, writeRecord.chunk);\n  }\n}\n\nfunction WritableStreamDefaultControllerErrorIfNeeded(controller, error) {\n  if (controller._controlledWritableStream._state === 'writable') {\n    WritableStreamDefaultControllerError(controller, error);\n  }\n}\n\nfunction WritableStreamDefaultControllerProcessClose(controller) {\n  var stream = controller._controlledWritableStream;\n  WritableStreamMarkCloseRequestInFlight(stream);\n  DequeueValue$1(controller);\n\n  var sinkClosePromise = controller._closeAlgorithm();\n\n  WritableStreamDefaultControllerClearAlgorithms(controller);\n  sinkClosePromise.then(function () {\n    WritableStreamFinishInFlightClose(stream);\n  }, function (reason) {\n    WritableStreamFinishInFlightCloseWithError(stream, reason);\n  }).catch(rethrowAssertionErrorRejection$1);\n}\n\nfunction WritableStreamDefaultControllerProcessWrite(controller, chunk) {\n  var stream = controller._controlledWritableStream;\n  WritableStreamMarkFirstWriteRequestInFlight(stream);\n\n  var sinkWritePromise = controller._writeAlgorithm(chunk);\n\n  sinkWritePromise.then(function () {\n    WritableStreamFinishInFlightWrite(stream);\n    var state = stream._state;\n    DequeueValue$1(controller);\n\n    if (WritableStreamCloseQueuedOrInFlight(stream) === false && state === 'writable') {\n      var backpressure = WritableStreamDefaultControllerGetBackpressure(controller);\n      WritableStreamUpdateBackpressure(stream, backpressure);\n    }\n\n    WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);\n  }, function (reason) {\n    if (stream._state === 'writable') {\n      WritableStreamDefaultControllerClearAlgorithms(controller);\n    }\n\n    WritableStreamFinishInFlightWriteWithError(stream, reason);\n  }).catch(rethrowAssertionErrorRejection$1);\n}\n\nfunction WritableStreamDefaultControllerGetBackpressure(controller) {\n  var desiredSize = WritableStreamDefaultControllerGetDesiredSize(controller);\n  return desiredSize <= 0;\n} // A client of WritableStreamDefaultController may use these functions directly to bypass state check.\n\n\nfunction WritableStreamDefaultControllerError(controller, error) {\n  var stream = controller._controlledWritableStream;\n  WritableStreamDefaultControllerClearAlgorithms(controller);\n  WritableStreamStartErroring(stream, error);\n} // Helper functions for the WritableStream.\n\n\nfunction streamBrandCheckException(name) {\n  return new TypeError(\"WritableStream.prototype.\" + name + \" can only be used on a WritableStream\");\n} // Helper functions for the WritableStreamDefaultWriter.\n\n\nfunction defaultWriterBrandCheckException(name) {\n  return new TypeError(\"WritableStreamDefaultWriter.prototype.\" + name + \" can only be used on a WritableStreamDefaultWriter\");\n}\n\nfunction defaultWriterLockException(name) {\n  return new TypeError('Cannot ' + name + ' a stream using a released writer');\n}\n\nfunction defaultWriterClosedPromiseInitialize(writer) {\n  writer._closedPromise = new Promise(function (resolve, reject) {\n    writer._closedPromise_resolve = resolve;\n    writer._closedPromise_reject = reject;\n    writer._closedPromiseState = 'pending';\n  });\n}\n\nfunction defaultWriterClosedPromiseInitializeAsRejected(writer, reason) {\n  writer._closedPromise = Promise.reject(reason);\n  writer._closedPromise_resolve = undefined;\n  writer._closedPromise_reject = undefined;\n  writer._closedPromiseState = 'rejected';\n}\n\nfunction defaultWriterClosedPromiseInitializeAsResolved(writer) {\n  writer._closedPromise = Promise.resolve(undefined);\n  writer._closedPromise_resolve = undefined;\n  writer._closedPromise_reject = undefined;\n  writer._closedPromiseState = 'resolved';\n}\n\nfunction defaultWriterClosedPromiseReject(writer, reason) {\n  writer._closedPromise_reject(reason);\n\n  writer._closedPromise_resolve = undefined;\n  writer._closedPromise_reject = undefined;\n  writer._closedPromiseState = 'rejected';\n}\n\nfunction defaultWriterClosedPromiseResetToRejected(writer, reason) {\n  writer._closedPromise = Promise.reject(reason);\n  writer._closedPromiseState = 'rejected';\n}\n\nfunction defaultWriterClosedPromiseResolve(writer) {\n  writer._closedPromise_resolve(undefined);\n\n  writer._closedPromise_resolve = undefined;\n  writer._closedPromise_reject = undefined;\n  writer._closedPromiseState = 'resolved';\n}\n\nfunction defaultWriterReadyPromiseInitialize(writer) {\n  writer._readyPromise = new Promise(function (resolve, reject) {\n    writer._readyPromise_resolve = resolve;\n    writer._readyPromise_reject = reject;\n  });\n  writer._readyPromiseState = 'pending';\n}\n\nfunction defaultWriterReadyPromiseInitializeAsRejected(writer, reason) {\n  writer._readyPromise = Promise.reject(reason);\n  writer._readyPromise_resolve = undefined;\n  writer._readyPromise_reject = undefined;\n  writer._readyPromiseState = 'rejected';\n}\n\nfunction defaultWriterReadyPromiseInitializeAsResolved(writer) {\n  writer._readyPromise = Promise.resolve(undefined);\n  writer._readyPromise_resolve = undefined;\n  writer._readyPromise_reject = undefined;\n  writer._readyPromiseState = 'fulfilled';\n}\n\nfunction defaultWriterReadyPromiseReject(writer, reason) {\n  writer._readyPromise_reject(reason);\n\n  writer._readyPromise_resolve = undefined;\n  writer._readyPromise_reject = undefined;\n  writer._readyPromiseState = 'rejected';\n}\n\nfunction defaultWriterReadyPromiseReset(writer) {\n  writer._readyPromise = new Promise(function (resolve, reject) {\n    writer._readyPromise_resolve = resolve;\n    writer._readyPromise_reject = reject;\n  });\n  writer._readyPromiseState = 'pending';\n}\n\nfunction defaultWriterReadyPromiseResetToRejected(writer, reason) {\n  writer._readyPromise = Promise.reject(reason);\n  writer._readyPromiseState = 'rejected';\n}\n\nfunction defaultWriterReadyPromiseResolve(writer) {\n  writer._readyPromise_resolve(undefined);\n\n  writer._readyPromise_resolve = undefined;\n  writer._readyPromise_reject = undefined;\n  writer._readyPromiseState = 'fulfilled';\n}\nvar writableStream_5 = writableStream.WritableStream;\n\n/* global AbortSignal:false */\n\n\nvar ArrayBufferCopy = require$$0.ArrayBufferCopy,\n    CreateAlgorithmFromUnderlyingMethod$1 = require$$0.CreateAlgorithmFromUnderlyingMethod,\n    IsFiniteNonNegativeNumber$1 = require$$0.IsFiniteNonNegativeNumber,\n    InvokeOrNoop$1 = require$$0.InvokeOrNoop,\n    IsDetachedBuffer$1 = require$$0.IsDetachedBuffer,\n    TransferArrayBuffer$1 = require$$0.TransferArrayBuffer,\n    ValidateAndNormalizeHighWaterMark$1 = require$$0.ValidateAndNormalizeHighWaterMark,\n    IsNonNegativeNumber$1 = require$$0.IsNonNegativeNumber,\n    MakeSizeAlgorithmFromSizeFunction$1 = require$$0.MakeSizeAlgorithmFromSizeFunction,\n    createArrayFromList = require$$0.createArrayFromList,\n    typeIsObject$1 = require$$0.typeIsObject,\n    WaitForAllPromise = require$$0.WaitForAllPromise;\nvar rethrowAssertionErrorRejection$2 = utils.rethrowAssertionErrorRejection;\nvar DequeueValue$2 = queueWithSizes.DequeueValue,\n    EnqueueValueWithSize$2 = queueWithSizes.EnqueueValueWithSize,\n    ResetQueue$2 = queueWithSizes.ResetQueue;\nvar AcquireWritableStreamDefaultWriter$1 = writableStream.AcquireWritableStreamDefaultWriter,\n    IsWritableStream$1 = writableStream.IsWritableStream,\n    IsWritableStreamLocked$1 = writableStream.IsWritableStreamLocked,\n    WritableStreamAbort$1 = writableStream.WritableStreamAbort,\n    WritableStreamDefaultWriterCloseWithErrorPropagation$1 = writableStream.WritableStreamDefaultWriterCloseWithErrorPropagation,\n    WritableStreamDefaultWriterRelease$1 = writableStream.WritableStreamDefaultWriterRelease,\n    WritableStreamDefaultWriterWrite$1 = writableStream.WritableStreamDefaultWriterWrite,\n    WritableStreamCloseQueuedOrInFlight$1 = writableStream.WritableStreamCloseQueuedOrInFlight;\nvar CancelSteps = SymbolPolyfill('[[CancelSteps]]');\nvar PullSteps = SymbolPolyfill('[[PullSteps]]');\n\nvar ReadableStream =\n/*#__PURE__*/\nfunction () {\n  function ReadableStream(underlyingSource, strategy) {\n    if (underlyingSource === void 0) {\n      underlyingSource = {};\n    }\n\n    if (strategy === void 0) {\n      strategy = {};\n    }\n\n    InitializeReadableStream(this);\n    var size = strategy.size;\n    var highWaterMark = strategy.highWaterMark;\n    var type = underlyingSource.type;\n    var typeString = String(type);\n\n    if (typeString === 'bytes') {\n      if (size !== undefined) {\n        throw new RangeError('The strategy for a byte stream cannot have a size function');\n      }\n\n      if (highWaterMark === undefined) {\n        highWaterMark = 0;\n      }\n\n      highWaterMark = ValidateAndNormalizeHighWaterMark$1(highWaterMark);\n      SetUpReadableByteStreamControllerFromUnderlyingSource(this, underlyingSource, highWaterMark);\n    } else if (type === undefined) {\n      var sizeAlgorithm = MakeSizeAlgorithmFromSizeFunction$1(size);\n\n      if (highWaterMark === undefined) {\n        highWaterMark = 1;\n      }\n\n      highWaterMark = ValidateAndNormalizeHighWaterMark$1(highWaterMark);\n      SetUpReadableStreamDefaultControllerFromUnderlyingSource(this, underlyingSource, highWaterMark, sizeAlgorithm);\n    } else {\n      throw new RangeError('Invalid type is specified');\n    }\n  }\n\n  var _proto = ReadableStream.prototype;\n\n  _proto.cancel = function cancel(reason) {\n    if (IsReadableStream(this) === false) {\n      return Promise.reject(streamBrandCheckException$1('cancel'));\n    }\n\n    if (IsReadableStreamLocked(this) === true) {\n      return Promise.reject(new TypeError('Cannot cancel a stream that already has a reader'));\n    }\n\n    return ReadableStreamCancel(this, reason);\n  };\n\n  _proto.getReader = function getReader(_temp) {\n    var _ref = _temp === void 0 ? {} : _temp,\n        mode = _ref.mode;\n\n    if (IsReadableStream(this) === false) {\n      throw streamBrandCheckException$1('getReader');\n    }\n\n    if (mode === undefined) {\n      return AcquireReadableStreamDefaultReader(this);\n    }\n\n    mode = String(mode);\n\n    if (mode === 'byob') {\n      return AcquireReadableStreamBYOBReader(this);\n    }\n\n    throw new RangeError('Invalid mode is specified');\n  };\n\n  _proto.pipeThrough = function pipeThrough(_ref2, _temp2) {\n    var writable = _ref2.writable,\n        readable = _ref2.readable;\n\n    var _ref3 = _temp2 === void 0 ? {} : _temp2,\n        preventClose = _ref3.preventClose,\n        preventAbort = _ref3.preventAbort,\n        preventCancel = _ref3.preventCancel,\n        signal = _ref3.signal;\n\n    if (IsReadableStream(this) === false) {\n      throw streamBrandCheckException$1('pipeThrough');\n    }\n\n    if (IsWritableStream$1(writable) === false) {\n      throw new TypeError('writable argument to pipeThrough must be a WritableStream');\n    }\n\n    if (IsReadableStream(readable) === false) {\n      throw new TypeError('readable argument to pipeThrough must be a ReadableStream');\n    }\n\n    preventClose = Boolean(preventClose);\n    preventAbort = Boolean(preventAbort);\n    preventCancel = Boolean(preventCancel);\n\n    if (signal !== undefined && !isAbortSignal(signal)) {\n      throw new TypeError('ReadableStream.prototype.pipeThrough\\'s signal option must be an AbortSignal');\n    }\n\n    if (IsReadableStreamLocked(this) === true) {\n      throw new TypeError('ReadableStream.prototype.pipeThrough cannot be used on a locked ReadableStream');\n    }\n\n    if (IsWritableStreamLocked$1(writable) === true) {\n      throw new TypeError('ReadableStream.prototype.pipeThrough cannot be used on a locked WritableStream');\n    }\n\n    var promise = ReadableStreamPipeTo(this, writable, preventClose, preventAbort, preventCancel, signal);\n    promise.catch(function () {});\n    return readable;\n  };\n\n  _proto.pipeTo = function pipeTo(dest, _temp3) {\n    var _ref4 = _temp3 === void 0 ? {} : _temp3,\n        preventClose = _ref4.preventClose,\n        preventAbort = _ref4.preventAbort,\n        preventCancel = _ref4.preventCancel,\n        signal = _ref4.signal;\n\n    if (IsReadableStream(this) === false) {\n      return Promise.reject(streamBrandCheckException$1('pipeTo'));\n    }\n\n    if (IsWritableStream$1(dest) === false) {\n      return Promise.reject(new TypeError('ReadableStream.prototype.pipeTo\\'s first argument must be a WritableStream'));\n    }\n\n    preventClose = Boolean(preventClose);\n    preventAbort = Boolean(preventAbort);\n    preventCancel = Boolean(preventCancel);\n\n    if (signal !== undefined && !isAbortSignal(signal)) {\n      return Promise.reject(new TypeError('ReadableStream.prototype.pipeTo\\'s signal option must be an AbortSignal'));\n    }\n\n    if (IsReadableStreamLocked(this) === true) {\n      return Promise.reject(new TypeError('ReadableStream.prototype.pipeTo cannot be used on a locked ReadableStream'));\n    }\n\n    if (IsWritableStreamLocked$1(dest) === true) {\n      return Promise.reject(new TypeError('ReadableStream.prototype.pipeTo cannot be used on a locked WritableStream'));\n    }\n\n    return ReadableStreamPipeTo(this, dest, preventClose, preventAbort, preventCancel, signal);\n  };\n\n  _proto.tee = function tee() {\n    if (IsReadableStream(this) === false) {\n      throw streamBrandCheckException$1('tee');\n    }\n\n    var branches = ReadableStreamTee(this, false);\n    return createArrayFromList(branches);\n  };\n\n  _createClass(ReadableStream, [{\n    key: \"locked\",\n    get: function get() {\n      if (IsReadableStream(this) === false) {\n        throw streamBrandCheckException$1('locked');\n      }\n\n      return IsReadableStreamLocked(this);\n    }\n  }]);\n\n  return ReadableStream;\n}();\n\nvar readableStream = {\n  CreateReadableByteStream: CreateReadableByteStream,\n  CreateReadableStream: CreateReadableStream,\n  ReadableStream: ReadableStream,\n  IsReadableStreamDisturbed: IsReadableStreamDisturbed,\n  ReadableStreamDefaultControllerClose: ReadableStreamDefaultControllerClose,\n  ReadableStreamDefaultControllerEnqueue: ReadableStreamDefaultControllerEnqueue,\n  ReadableStreamDefaultControllerError: ReadableStreamDefaultControllerError,\n  ReadableStreamDefaultControllerGetDesiredSize: ReadableStreamDefaultControllerGetDesiredSize,\n  ReadableStreamDefaultControllerHasBackpressure: ReadableStreamDefaultControllerHasBackpressure,\n  ReadableStreamDefaultControllerCanCloseOrEnqueue: ReadableStreamDefaultControllerCanCloseOrEnqueue\n}; // Abstract operations for the ReadableStream.\n\nfunction AcquireReadableStreamBYOBReader(stream) {\n  return new ReadableStreamBYOBReader(stream);\n}\n\nfunction AcquireReadableStreamDefaultReader(stream) {\n  return new ReadableStreamDefaultReader(stream);\n} // Throws if and only if startAlgorithm throws.\n\n\nfunction CreateReadableStream(startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, sizeAlgorithm) {\n  if (highWaterMark === void 0) {\n    highWaterMark = 1;\n  }\n\n  if (sizeAlgorithm === void 0) {\n    sizeAlgorithm = function sizeAlgorithm() {\n      return 1;\n    };\n  }\n\n  var stream = Object.create(ReadableStream.prototype);\n  InitializeReadableStream(stream);\n  var controller = Object.create(ReadableStreamDefaultController.prototype);\n  SetUpReadableStreamDefaultController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, sizeAlgorithm);\n  return stream;\n} // Throws if and only if startAlgorithm throws.\n\n\nfunction CreateReadableByteStream(startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, autoAllocateChunkSize) {\n  if (highWaterMark === void 0) {\n    highWaterMark = 0;\n  }\n\n  if (autoAllocateChunkSize === void 0) {\n    autoAllocateChunkSize = undefined;\n  }\n\n  var stream = Object.create(ReadableStream.prototype);\n  InitializeReadableStream(stream);\n  var controller = Object.create(ReadableByteStreamController.prototype);\n  SetUpReadableByteStreamController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, autoAllocateChunkSize);\n  return stream;\n}\n\nfunction InitializeReadableStream(stream) {\n  stream._state = 'readable';\n  stream._reader = undefined;\n  stream._storedError = undefined;\n  stream._disturbed = false;\n}\n\nfunction IsReadableStream(x) {\n  if (!typeIsObject$1(x)) {\n    return false;\n  }\n\n  if (!Object.prototype.hasOwnProperty.call(x, '_readableStreamController')) {\n    return false;\n  }\n\n  return true;\n}\n\nfunction IsReadableStreamDisturbed(stream) {\n  return stream._disturbed;\n}\n\nfunction IsReadableStreamLocked(stream) {\n  if (stream._reader === undefined) {\n    return false;\n  }\n\n  return true;\n}\n\nfunction ReadableStreamPipeTo(source, dest, preventClose, preventAbort, preventCancel, signal) {\n  var reader = AcquireReadableStreamDefaultReader(source);\n  var writer = AcquireWritableStreamDefaultWriter$1(dest);\n  var shuttingDown = false; // This is used to keep track of the spec's requirement that we wait for ongoing writes during shutdown.\n\n  var currentWrite = Promise.resolve();\n  return new Promise(function (resolve, reject) {\n    var abortAlgorithm;\n\n    if (signal !== undefined) {\n      abortAlgorithm = function abortAlgorithm() {\n        var error = new DOMException('Aborted', 'AbortError');\n        var actions = [];\n\n        if (preventAbort === false) {\n          actions.push(function () {\n            if (dest._state === 'writable') {\n              return WritableStreamAbort$1(dest, error);\n            }\n\n            return Promise.resolve();\n          });\n        }\n\n        if (preventCancel === false) {\n          actions.push(function () {\n            if (source._state === 'readable') {\n              return ReadableStreamCancel(source, error);\n            }\n\n            return Promise.resolve();\n          });\n        }\n\n        shutdownWithAction(function () {\n          return WaitForAllPromise(actions.map(function (action) {\n            return action();\n          }), function (results) {\n            return results;\n          });\n        }, true, error);\n      };\n\n      if (signal.aborted === true) {\n        abortAlgorithm();\n        return;\n      }\n\n      signal.addEventListener('abort', abortAlgorithm);\n    } // Using reader and writer, read all chunks from this and write them to dest\n    // - Backpressure must be enforced\n    // - Shutdown must stop all activity\n\n\n    function pipeLoop() {\n      return new Promise(function (resolveLoop, rejectLoop) {\n        function next(done) {\n          if (done) {\n            resolveLoop();\n          } else {\n            pipeStep().then(next, rejectLoop);\n          }\n        }\n\n        next(false);\n      });\n    }\n\n    function pipeStep() {\n      if (shuttingDown === true) {\n        return Promise.resolve(true);\n      }\n\n      return writer._readyPromise.then(function () {\n        return ReadableStreamDefaultReaderRead(reader).then(function (_ref5) {\n          var value = _ref5.value,\n              done = _ref5.done;\n\n          if (done === true) {\n            return true;\n          }\n\n          currentWrite = WritableStreamDefaultWriterWrite$1(writer, value).catch(function () {});\n          return false;\n        });\n      });\n    } // Errors must be propagated forward\n\n\n    isOrBecomesErrored(source, reader._closedPromise, function (storedError) {\n      if (preventAbort === false) {\n        shutdownWithAction(function () {\n          return WritableStreamAbort$1(dest, storedError);\n        }, true, storedError);\n      } else {\n        shutdown(true, storedError);\n      }\n    }); // Errors must be propagated backward\n\n    isOrBecomesErrored(dest, writer._closedPromise, function (storedError) {\n      if (preventCancel === false) {\n        shutdownWithAction(function () {\n          return ReadableStreamCancel(source, storedError);\n        }, true, storedError);\n      } else {\n        shutdown(true, storedError);\n      }\n    }); // Closing must be propagated forward\n\n    isOrBecomesClosed(source, reader._closedPromise, function () {\n      if (preventClose === false) {\n        shutdownWithAction(function () {\n          return WritableStreamDefaultWriterCloseWithErrorPropagation$1(writer);\n        });\n      } else {\n        shutdown();\n      }\n    }); // Closing must be propagated backward\n\n    if (WritableStreamCloseQueuedOrInFlight$1(dest) === true || dest._state === 'closed') {\n      var destClosed = new TypeError('the destination writable stream closed before all data could be piped to it');\n\n      if (preventCancel === false) {\n        shutdownWithAction(function () {\n          return ReadableStreamCancel(source, destClosed);\n        }, true, destClosed);\n      } else {\n        shutdown(true, destClosed);\n      }\n    }\n\n    pipeLoop().catch(function (err) {\n      currentWrite = Promise.resolve();\n      rethrowAssertionErrorRejection$2(err);\n    });\n\n    function waitForWritesToFinish() {\n      // Another write may have started while we were waiting on this currentWrite, so we have to be sure to wait\n      // for that too.\n      var oldCurrentWrite = currentWrite;\n      return currentWrite.then(function () {\n        return oldCurrentWrite !== currentWrite ? waitForWritesToFinish() : undefined;\n      });\n    }\n\n    function isOrBecomesErrored(stream, promise, action) {\n      if (stream._state === 'errored') {\n        action(stream._storedError);\n      } else {\n        promise.catch(action).catch(rethrowAssertionErrorRejection$2);\n      }\n    }\n\n    function isOrBecomesClosed(stream, promise, action) {\n      if (stream._state === 'closed') {\n        action();\n      } else {\n        promise.then(action).catch(rethrowAssertionErrorRejection$2);\n      }\n    }\n\n    function shutdownWithAction(action, originalIsError, originalError) {\n      if (shuttingDown === true) {\n        return;\n      }\n\n      shuttingDown = true;\n\n      if (dest._state === 'writable' && WritableStreamCloseQueuedOrInFlight$1(dest) === false) {\n        waitForWritesToFinish().then(doTheRest);\n      } else {\n        doTheRest();\n      }\n\n      function doTheRest() {\n        action().then(function () {\n          return finalize(originalIsError, originalError);\n        }, function (newError) {\n          return finalize(true, newError);\n        }).catch(rethrowAssertionErrorRejection$2);\n      }\n    }\n\n    function shutdown(isError, error) {\n      if (shuttingDown === true) {\n        return;\n      }\n\n      shuttingDown = true;\n\n      if (dest._state === 'writable' && WritableStreamCloseQueuedOrInFlight$1(dest) === false) {\n        waitForWritesToFinish().then(function () {\n          return finalize(isError, error);\n        }).catch(rethrowAssertionErrorRejection$2);\n      } else {\n        finalize(isError, error);\n      }\n    }\n\n    function finalize(isError, error) {\n      WritableStreamDefaultWriterRelease$1(writer);\n      ReadableStreamReaderGenericRelease(reader);\n\n      if (signal !== undefined) {\n        signal.removeEventListener('abort', abortAlgorithm);\n      }\n\n      if (isError) {\n        reject(error);\n      } else {\n        resolve(undefined);\n      }\n    }\n  });\n}\n\nfunction ReadableStreamTee(stream, cloneForBranch2) {\n  var reader = AcquireReadableStreamDefaultReader(stream);\n  var closedOrErrored = false;\n  var canceled1 = false;\n  var canceled2 = false;\n  var reason1;\n  var reason2;\n  var branch1;\n  var branch2;\n  var resolveCancelPromise;\n  var cancelPromise = new Promise(function (resolve) {\n    resolveCancelPromise = resolve;\n  });\n\n  function pullAlgorithm() {\n    return ReadableStreamDefaultReaderRead(reader).then(function (result) {\n      var value = result.value;\n      var done = result.done;\n\n      if (done === true && closedOrErrored === false) {\n        if (canceled1 === false) {\n          ReadableStreamDefaultControllerClose(branch1._readableStreamController);\n        }\n\n        if (canceled2 === false) {\n          ReadableStreamDefaultControllerClose(branch2._readableStreamController);\n        }\n\n        closedOrErrored = true;\n      }\n\n      if (closedOrErrored === true) {\n        return;\n      }\n\n      var value1 = value;\n      var value2 = value; // There is no way to access the cloning code right now in the reference implementation.\n      // If we add one then we'll need an implementation for serializable objects.\n      // if (canceled2 === false && cloneForBranch2 === true) {\n      //   value2 = StructuredDeserialize(StructuredSerialize(value2));\n      // }\n\n      if (canceled1 === false) {\n        ReadableStreamDefaultControllerEnqueue(branch1._readableStreamController, value1);\n      }\n\n      if (canceled2 === false) {\n        ReadableStreamDefaultControllerEnqueue(branch2._readableStreamController, value2);\n      }\n    });\n  }\n\n  function cancel1Algorithm(reason) {\n    canceled1 = true;\n    reason1 = reason;\n\n    if (canceled2 === true) {\n      var compositeReason = createArrayFromList([reason1, reason2]);\n      var cancelResult = ReadableStreamCancel(stream, compositeReason);\n      resolveCancelPromise(cancelResult);\n    }\n\n    return cancelPromise;\n  }\n\n  function cancel2Algorithm(reason) {\n    canceled2 = true;\n    reason2 = reason;\n\n    if (canceled1 === true) {\n      var compositeReason = createArrayFromList([reason1, reason2]);\n      var cancelResult = ReadableStreamCancel(stream, compositeReason);\n      resolveCancelPromise(cancelResult);\n    }\n\n    return cancelPromise;\n  }\n\n  function startAlgorithm() {}\n\n  branch1 = CreateReadableStream(startAlgorithm, pullAlgorithm, cancel1Algorithm);\n  branch2 = CreateReadableStream(startAlgorithm, pullAlgorithm, cancel2Algorithm);\n\n  reader._closedPromise.catch(function (r) {\n    if (closedOrErrored === true) {\n      return;\n    }\n\n    ReadableStreamDefaultControllerError(branch1._readableStreamController, r);\n    ReadableStreamDefaultControllerError(branch2._readableStreamController, r);\n    closedOrErrored = true;\n  });\n\n  return [branch1, branch2];\n} // ReadableStream API exposed for controllers.\n\n\nfunction ReadableStreamAddReadIntoRequest(stream, forAuthorCode) {\n  var promise = new Promise(function (resolve, reject) {\n    var readIntoRequest = {\n      _resolve: resolve,\n      _reject: reject,\n      _forAuthorCode: forAuthorCode\n    };\n\n    stream._reader._readIntoRequests.push(readIntoRequest);\n  });\n  return promise;\n}\n\nfunction ReadableStreamAddReadRequest(stream, forAuthorCode) {\n  var promise = new Promise(function (resolve, reject) {\n    var readRequest = {\n      _resolve: resolve,\n      _reject: reject,\n      _forAuthorCode: forAuthorCode\n    };\n\n    stream._reader._readRequests.push(readRequest);\n  });\n  return promise;\n}\n\nfunction ReadableStreamCancel(stream, reason) {\n  stream._disturbed = true;\n\n  if (stream._state === 'closed') {\n    return Promise.resolve(undefined);\n  }\n\n  if (stream._state === 'errored') {\n    return Promise.reject(stream._storedError);\n  }\n\n  ReadableStreamClose(stream);\n\n  var sourceCancelPromise = stream._readableStreamController[CancelSteps](reason);\n\n  return sourceCancelPromise.then(function () {\n    return undefined;\n  });\n}\n\nfunction ReadableStreamClose(stream) {\n  stream._state = 'closed';\n  var reader = stream._reader;\n\n  if (reader === undefined) {\n    return undefined;\n  }\n\n  if (IsReadableStreamDefaultReader(reader) === true) {\n    for (var _i2 = 0, _reader$_readRequests2 = reader._readRequests; _i2 < _reader$_readRequests2.length; _i2++) {\n      var _reader$_readRequests3 = _reader$_readRequests2[_i2],\n          _resolve = _reader$_readRequests3._resolve,\n          _forAuthorCode = _reader$_readRequests3._forAuthorCode;\n\n      _resolve(ReadableStreamCreateReadResult(undefined, true, _forAuthorCode));\n    }\n\n    reader._readRequests = [];\n  }\n\n  defaultReaderClosedPromiseResolve(reader);\n  return undefined;\n}\n\nfunction ReadableStreamCreateReadResult(value, done, forAuthorCode) {\n  var prototype = null;\n\n  if (forAuthorCode === true) {\n    prototype = Object.prototype;\n  }\n\n  var obj = Object.create(prototype);\n  Object.defineProperty(obj, 'value', {\n    value: value,\n    enumerable: true,\n    writable: true,\n    configurable: true\n  });\n  Object.defineProperty(obj, 'done', {\n    value: done,\n    enumerable: true,\n    writable: true,\n    configurable: true\n  });\n  return obj;\n}\n\nfunction ReadableStreamError(stream, e) {\n  stream._state = 'errored';\n  stream._storedError = e;\n  var reader = stream._reader;\n\n  if (reader === undefined) {\n    return undefined;\n  }\n\n  if (IsReadableStreamDefaultReader(reader) === true) {\n    for (var _i4 = 0, _reader$_readRequests5 = reader._readRequests; _i4 < _reader$_readRequests5.length; _i4++) {\n      var readRequest = _reader$_readRequests5[_i4];\n\n      readRequest._reject(e);\n    }\n\n    reader._readRequests = [];\n  } else {\n    for (var _i6 = 0, _reader$_readIntoRequ2 = reader._readIntoRequests; _i6 < _reader$_readIntoRequ2.length; _i6++) {\n      var readIntoRequest = _reader$_readIntoRequ2[_i6];\n\n      readIntoRequest._reject(e);\n    }\n\n    reader._readIntoRequests = [];\n  }\n\n  defaultReaderClosedPromiseReject(reader, e);\n\n  reader._closedPromise.catch(function () {});\n}\n\nfunction ReadableStreamFulfillReadIntoRequest(stream, chunk, done) {\n  var reader = stream._reader;\n\n  var readIntoRequest = reader._readIntoRequests.shift();\n\n  readIntoRequest._resolve(ReadableStreamCreateReadResult(chunk, done, readIntoRequest._forAuthorCode));\n}\n\nfunction ReadableStreamFulfillReadRequest(stream, chunk, done) {\n  var reader = stream._reader;\n\n  var readRequest = reader._readRequests.shift();\n\n  readRequest._resolve(ReadableStreamCreateReadResult(chunk, done, readRequest._forAuthorCode));\n}\n\nfunction ReadableStreamGetNumReadIntoRequests(stream) {\n  return stream._reader._readIntoRequests.length;\n}\n\nfunction ReadableStreamGetNumReadRequests(stream) {\n  return stream._reader._readRequests.length;\n}\n\nfunction ReadableStreamHasBYOBReader(stream) {\n  var reader = stream._reader;\n\n  if (reader === undefined) {\n    return false;\n  }\n\n  if (IsReadableStreamBYOBReader(reader) === false) {\n    return false;\n  }\n\n  return true;\n}\n\nfunction ReadableStreamHasDefaultReader(stream) {\n  var reader = stream._reader;\n\n  if (reader === undefined) {\n    return false;\n  }\n\n  if (IsReadableStreamDefaultReader(reader) === false) {\n    return false;\n  }\n\n  return true;\n} // Readers\n\n\nvar ReadableStreamDefaultReader =\n/*#__PURE__*/\nfunction () {\n  function ReadableStreamDefaultReader(stream) {\n    if (IsReadableStream(stream) === false) {\n      throw new TypeError('ReadableStreamDefaultReader can only be constructed with a ReadableStream instance');\n    }\n\n    if (IsReadableStreamLocked(stream) === true) {\n      throw new TypeError('This stream has already been locked for exclusive reading by another reader');\n    }\n\n    ReadableStreamReaderGenericInitialize(this, stream);\n    this._readRequests = [];\n  }\n\n  var _proto2 = ReadableStreamDefaultReader.prototype;\n\n  _proto2.cancel = function cancel(reason) {\n    if (IsReadableStreamDefaultReader(this) === false) {\n      return Promise.reject(defaultReaderBrandCheckException('cancel'));\n    }\n\n    if (this._ownerReadableStream === undefined) {\n      return Promise.reject(readerLockException('cancel'));\n    }\n\n    return ReadableStreamReaderGenericCancel(this, reason);\n  };\n\n  _proto2.read = function read() {\n    if (IsReadableStreamDefaultReader(this) === false) {\n      return Promise.reject(defaultReaderBrandCheckException('read'));\n    }\n\n    if (this._ownerReadableStream === undefined) {\n      return Promise.reject(readerLockException('read from'));\n    }\n\n    return ReadableStreamDefaultReaderRead(this, true);\n  };\n\n  _proto2.releaseLock = function releaseLock() {\n    if (IsReadableStreamDefaultReader(this) === false) {\n      throw defaultReaderBrandCheckException('releaseLock');\n    }\n\n    if (this._ownerReadableStream === undefined) {\n      return;\n    }\n\n    if (this._readRequests.length > 0) {\n      throw new TypeError('Tried to release a reader lock when that reader has pending read() calls un-settled');\n    }\n\n    ReadableStreamReaderGenericRelease(this);\n  };\n\n  _createClass(ReadableStreamDefaultReader, [{\n    key: \"closed\",\n    get: function get() {\n      if (IsReadableStreamDefaultReader(this) === false) {\n        return Promise.reject(defaultReaderBrandCheckException('closed'));\n      }\n\n      return this._closedPromise;\n    }\n  }]);\n\n  return ReadableStreamDefaultReader;\n}();\n\nvar ReadableStreamBYOBReader =\n/*#__PURE__*/\nfunction () {\n  function ReadableStreamBYOBReader(stream) {\n    if (!IsReadableStream(stream)) {\n      throw new TypeError('ReadableStreamBYOBReader can only be constructed with a ReadableStream instance given a ' + 'byte source');\n    }\n\n    if (IsReadableByteStreamController(stream._readableStreamController) === false) {\n      throw new TypeError('Cannot construct a ReadableStreamBYOBReader for a stream not constructed with a byte ' + 'source');\n    }\n\n    if (IsReadableStreamLocked(stream)) {\n      throw new TypeError('This stream has already been locked for exclusive reading by another reader');\n    }\n\n    ReadableStreamReaderGenericInitialize(this, stream);\n    this._readIntoRequests = [];\n  }\n\n  var _proto3 = ReadableStreamBYOBReader.prototype;\n\n  _proto3.cancel = function cancel(reason) {\n    if (!IsReadableStreamBYOBReader(this)) {\n      return Promise.reject(byobReaderBrandCheckException('cancel'));\n    }\n\n    if (this._ownerReadableStream === undefined) {\n      return Promise.reject(readerLockException('cancel'));\n    }\n\n    return ReadableStreamReaderGenericCancel(this, reason);\n  };\n\n  _proto3.read = function read(view) {\n    if (!IsReadableStreamBYOBReader(this)) {\n      return Promise.reject(byobReaderBrandCheckException('read'));\n    }\n\n    if (this._ownerReadableStream === undefined) {\n      return Promise.reject(readerLockException('read from'));\n    }\n\n    if (!ArrayBuffer.isView(view)) {\n      return Promise.reject(new TypeError('view must be an array buffer view'));\n    }\n\n    if (IsDetachedBuffer$1(view.buffer) === true) {\n      return Promise.reject(new TypeError('Cannot read into a view onto a detached ArrayBuffer'));\n    }\n\n    if (view.byteLength === 0) {\n      return Promise.reject(new TypeError('view must have non-zero byteLength'));\n    }\n\n    return ReadableStreamBYOBReaderRead(this, view, true);\n  };\n\n  _proto3.releaseLock = function releaseLock() {\n    if (!IsReadableStreamBYOBReader(this)) {\n      throw byobReaderBrandCheckException('releaseLock');\n    }\n\n    if (this._ownerReadableStream === undefined) {\n      return;\n    }\n\n    if (this._readIntoRequests.length > 0) {\n      throw new TypeError('Tried to release a reader lock when that reader has pending read() calls un-settled');\n    }\n\n    ReadableStreamReaderGenericRelease(this);\n  };\n\n  _createClass(ReadableStreamBYOBReader, [{\n    key: \"closed\",\n    get: function get() {\n      if (!IsReadableStreamBYOBReader(this)) {\n        return Promise.reject(byobReaderBrandCheckException('closed'));\n      }\n\n      return this._closedPromise;\n    }\n  }]);\n\n  return ReadableStreamBYOBReader;\n}(); // Abstract operations for the readers.\n\n\nfunction IsReadableStreamBYOBReader(x) {\n  if (!typeIsObject$1(x)) {\n    return false;\n  }\n\n  if (!Object.prototype.hasOwnProperty.call(x, '_readIntoRequests')) {\n    return false;\n  }\n\n  return true;\n}\n\nfunction IsReadableStreamDefaultReader(x) {\n  if (!typeIsObject$1(x)) {\n    return false;\n  }\n\n  if (!Object.prototype.hasOwnProperty.call(x, '_readRequests')) {\n    return false;\n  }\n\n  return true;\n}\n\nfunction ReadableStreamReaderGenericInitialize(reader, stream) {\n  reader._ownerReadableStream = stream;\n  stream._reader = reader;\n\n  if (stream._state === 'readable') {\n    defaultReaderClosedPromiseInitialize(reader);\n  } else if (stream._state === 'closed') {\n    defaultReaderClosedPromiseInitializeAsResolved(reader);\n  } else {\n    defaultReaderClosedPromiseInitializeAsRejected(reader, stream._storedError);\n\n    reader._closedPromise.catch(function () {});\n  }\n} // A client of ReadableStreamDefaultReader and ReadableStreamBYOBReader may use these functions directly to bypass state\n// check.\n\n\nfunction ReadableStreamReaderGenericCancel(reader, reason) {\n  var stream = reader._ownerReadableStream;\n  return ReadableStreamCancel(stream, reason);\n}\n\nfunction ReadableStreamReaderGenericRelease(reader) {\n  if (reader._ownerReadableStream._state === 'readable') {\n    defaultReaderClosedPromiseReject(reader, new TypeError('Reader was released and can no longer be used to monitor the stream\\'s closedness'));\n  } else {\n    defaultReaderClosedPromiseResetToRejected(reader, new TypeError('Reader was released and can no longer be used to monitor the stream\\'s closedness'));\n  }\n\n  reader._closedPromise.catch(function () {});\n\n  reader._ownerReadableStream._reader = undefined;\n  reader._ownerReadableStream = undefined;\n}\n\nfunction ReadableStreamBYOBReaderRead(reader, view, forAuthorCode) {\n  if (forAuthorCode === void 0) {\n    forAuthorCode = false;\n  }\n\n  var stream = reader._ownerReadableStream;\n  stream._disturbed = true;\n\n  if (stream._state === 'errored') {\n    return Promise.reject(stream._storedError);\n  } // Controllers must implement this.\n\n\n  return ReadableByteStreamControllerPullInto(stream._readableStreamController, view, forAuthorCode);\n}\n\nfunction ReadableStreamDefaultReaderRead(reader, forAuthorCode) {\n  if (forAuthorCode === void 0) {\n    forAuthorCode = false;\n  }\n\n  var stream = reader._ownerReadableStream;\n  stream._disturbed = true;\n\n  if (stream._state === 'closed') {\n    return Promise.resolve(ReadableStreamCreateReadResult(undefined, true, forAuthorCode));\n  }\n\n  if (stream._state === 'errored') {\n    return Promise.reject(stream._storedError);\n  }\n\n  return stream._readableStreamController[PullSteps](forAuthorCode);\n} // Controllers\n\n\nvar ReadableStreamDefaultController =\n/*#__PURE__*/\nfunction () {\n  function ReadableStreamDefaultController() {\n    throw new TypeError();\n  }\n\n  var _proto4 = ReadableStreamDefaultController.prototype;\n\n  _proto4.close = function close() {\n    if (IsReadableStreamDefaultController(this) === false) {\n      throw defaultControllerBrandCheckException('close');\n    }\n\n    if (ReadableStreamDefaultControllerCanCloseOrEnqueue(this) === false) {\n      throw new TypeError('The stream is not in a state that permits close');\n    }\n\n    ReadableStreamDefaultControllerClose(this);\n  };\n\n  _proto4.enqueue = function enqueue(chunk) {\n    if (IsReadableStreamDefaultController(this) === false) {\n      throw defaultControllerBrandCheckException('enqueue');\n    }\n\n    if (ReadableStreamDefaultControllerCanCloseOrEnqueue(this) === false) {\n      throw new TypeError('The stream is not in a state that permits enqueue');\n    }\n\n    return ReadableStreamDefaultControllerEnqueue(this, chunk);\n  };\n\n  _proto4.error = function error(e) {\n    if (IsReadableStreamDefaultController(this) === false) {\n      throw defaultControllerBrandCheckException('error');\n    }\n\n    ReadableStreamDefaultControllerError(this, e);\n  };\n\n  _proto4[CancelSteps] = function (reason) {\n    ResetQueue$2(this);\n\n    var result = this._cancelAlgorithm(reason);\n\n    ReadableStreamDefaultControllerClearAlgorithms(this);\n    return result;\n  };\n\n  _proto4[PullSteps] = function (forAuthorCode) {\n    var stream = this._controlledReadableStream;\n\n    if (this._queue.length > 0) {\n      var chunk = DequeueValue$2(this);\n\n      if (this._closeRequested === true && this._queue.length === 0) {\n        ReadableStreamDefaultControllerClearAlgorithms(this);\n        ReadableStreamClose(stream);\n      } else {\n        ReadableStreamDefaultControllerCallPullIfNeeded(this);\n      }\n\n      return Promise.resolve(ReadableStreamCreateReadResult(chunk, false, forAuthorCode));\n    }\n\n    var pendingPromise = ReadableStreamAddReadRequest(stream, forAuthorCode);\n    ReadableStreamDefaultControllerCallPullIfNeeded(this);\n    return pendingPromise;\n  };\n\n  _createClass(ReadableStreamDefaultController, [{\n    key: \"desiredSize\",\n    get: function get() {\n      if (IsReadableStreamDefaultController(this) === false) {\n        throw defaultControllerBrandCheckException('desiredSize');\n      }\n\n      return ReadableStreamDefaultControllerGetDesiredSize(this);\n    }\n  }]);\n\n  return ReadableStreamDefaultController;\n}(); // Abstract operations for the ReadableStreamDefaultController.\n\n\nfunction IsReadableStreamDefaultController(x) {\n  if (!typeIsObject$1(x)) {\n    return false;\n  }\n\n  if (!Object.prototype.hasOwnProperty.call(x, '_controlledReadableStream')) {\n    return false;\n  }\n\n  return true;\n}\n\nfunction ReadableStreamDefaultControllerCallPullIfNeeded(controller) {\n  var shouldPull = ReadableStreamDefaultControllerShouldCallPull(controller);\n\n  if (shouldPull === false) {\n    return undefined;\n  }\n\n  if (controller._pulling === true) {\n    controller._pullAgain = true;\n    return undefined;\n  }\n\n  controller._pulling = true;\n\n  var pullPromise = controller._pullAlgorithm();\n\n  pullPromise.then(function () {\n    controller._pulling = false;\n\n    if (controller._pullAgain === true) {\n      controller._pullAgain = false;\n      return ReadableStreamDefaultControllerCallPullIfNeeded(controller);\n    }\n\n    return undefined;\n  }, function (e) {\n    ReadableStreamDefaultControllerError(controller, e);\n  }).catch(rethrowAssertionErrorRejection$2);\n  return undefined;\n}\n\nfunction ReadableStreamDefaultControllerShouldCallPull(controller) {\n  var stream = controller._controlledReadableStream;\n\n  if (ReadableStreamDefaultControllerCanCloseOrEnqueue(controller) === false) {\n    return false;\n  }\n\n  if (controller._started === false) {\n    return false;\n  }\n\n  if (IsReadableStreamLocked(stream) === true && ReadableStreamGetNumReadRequests(stream) > 0) {\n    return true;\n  }\n\n  var desiredSize = ReadableStreamDefaultControllerGetDesiredSize(controller);\n\n  if (desiredSize > 0) {\n    return true;\n  }\n\n  return false;\n}\n\nfunction ReadableStreamDefaultControllerClearAlgorithms(controller) {\n  controller._pullAlgorithm = undefined;\n  controller._cancelAlgorithm = undefined;\n  controller._strategySizeAlgorithm = undefined;\n} // A client of ReadableStreamDefaultController may use these functions directly to bypass state check.\n\n\nfunction ReadableStreamDefaultControllerClose(controller) {\n  var stream = controller._controlledReadableStream;\n  controller._closeRequested = true;\n\n  if (controller._queue.length === 0) {\n    ReadableStreamDefaultControllerClearAlgorithms(controller);\n    ReadableStreamClose(stream);\n  }\n}\n\nfunction ReadableStreamDefaultControllerEnqueue(controller, chunk) {\n  var stream = controller._controlledReadableStream;\n\n  if (IsReadableStreamLocked(stream) === true && ReadableStreamGetNumReadRequests(stream) > 0) {\n    ReadableStreamFulfillReadRequest(stream, chunk, false);\n  } else {\n    var chunkSize;\n\n    try {\n      chunkSize = controller._strategySizeAlgorithm(chunk);\n    } catch (chunkSizeE) {\n      ReadableStreamDefaultControllerError(controller, chunkSizeE);\n      throw chunkSizeE;\n    }\n\n    try {\n      EnqueueValueWithSize$2(controller, chunk, chunkSize);\n    } catch (enqueueE) {\n      ReadableStreamDefaultControllerError(controller, enqueueE);\n      throw enqueueE;\n    }\n  }\n\n  ReadableStreamDefaultControllerCallPullIfNeeded(controller);\n  return undefined;\n}\n\nfunction ReadableStreamDefaultControllerError(controller, e) {\n  var stream = controller._controlledReadableStream;\n\n  if (stream._state !== 'readable') {\n    return;\n  }\n\n  ResetQueue$2(controller);\n  ReadableStreamDefaultControllerClearAlgorithms(controller);\n  ReadableStreamError(stream, e);\n}\n\nfunction ReadableStreamDefaultControllerGetDesiredSize(controller) {\n  var stream = controller._controlledReadableStream;\n  var state = stream._state;\n\n  if (state === 'errored') {\n    return null;\n  }\n\n  if (state === 'closed') {\n    return 0;\n  }\n\n  return controller._strategyHWM - controller._queueTotalSize;\n} // This is used in the implementation of TransformStream.\n\n\nfunction ReadableStreamDefaultControllerHasBackpressure(controller) {\n  if (ReadableStreamDefaultControllerShouldCallPull(controller) === true) {\n    return false;\n  }\n\n  return true;\n}\n\nfunction ReadableStreamDefaultControllerCanCloseOrEnqueue(controller) {\n  var state = controller._controlledReadableStream._state;\n\n  if (controller._closeRequested === false && state === 'readable') {\n    return true;\n  }\n\n  return false;\n}\n\nfunction SetUpReadableStreamDefaultController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, sizeAlgorithm) {\n  controller._controlledReadableStream = stream;\n  controller._queue = undefined;\n  controller._queueTotalSize = undefined;\n  ResetQueue$2(controller);\n  controller._started = false;\n  controller._closeRequested = false;\n  controller._pullAgain = false;\n  controller._pulling = false;\n  controller._strategySizeAlgorithm = sizeAlgorithm;\n  controller._strategyHWM = highWaterMark;\n  controller._pullAlgorithm = pullAlgorithm;\n  controller._cancelAlgorithm = cancelAlgorithm;\n  stream._readableStreamController = controller;\n  var startResult = startAlgorithm();\n  Promise.resolve(startResult).then(function () {\n    controller._started = true;\n    ReadableStreamDefaultControllerCallPullIfNeeded(controller);\n  }, function (r) {\n    ReadableStreamDefaultControllerError(controller, r);\n  }).catch(rethrowAssertionErrorRejection$2);\n}\n\nfunction SetUpReadableStreamDefaultControllerFromUnderlyingSource(stream, underlyingSource, highWaterMark, sizeAlgorithm) {\n  var controller = Object.create(ReadableStreamDefaultController.prototype);\n\n  function startAlgorithm() {\n    return InvokeOrNoop$1(underlyingSource, 'start', [controller]);\n  }\n\n  var pullAlgorithm = CreateAlgorithmFromUnderlyingMethod$1(underlyingSource, 'pull', 0, [controller]);\n  var cancelAlgorithm = CreateAlgorithmFromUnderlyingMethod$1(underlyingSource, 'cancel', 1, []);\n  SetUpReadableStreamDefaultController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, sizeAlgorithm);\n}\n\nvar ReadableStreamBYOBRequest =\n/*#__PURE__*/\nfunction () {\n  function ReadableStreamBYOBRequest() {\n    throw new TypeError('ReadableStreamBYOBRequest cannot be used directly');\n  }\n\n  var _proto5 = ReadableStreamBYOBRequest.prototype;\n\n  _proto5.respond = function respond(bytesWritten) {\n    if (IsReadableStreamBYOBRequest(this) === false) {\n      throw byobRequestBrandCheckException('respond');\n    }\n\n    if (this._associatedReadableByteStreamController === undefined) {\n      throw new TypeError('This BYOB request has been invalidated');\n    }\n\n    if (IsDetachedBuffer$1(this._view.buffer) === true) {\n      throw new TypeError('The BYOB request\\'s buffer has been detached and so cannot be used as a response');\n    }\n\n    ReadableByteStreamControllerRespond(this._associatedReadableByteStreamController, bytesWritten);\n  };\n\n  _proto5.respondWithNewView = function respondWithNewView(view) {\n    if (IsReadableStreamBYOBRequest(this) === false) {\n      throw byobRequestBrandCheckException('respond');\n    }\n\n    if (this._associatedReadableByteStreamController === undefined) {\n      throw new TypeError('This BYOB request has been invalidated');\n    }\n\n    if (!ArrayBuffer.isView(view)) {\n      throw new TypeError('You can only respond with array buffer views');\n    }\n\n    if (IsDetachedBuffer$1(view.buffer) === true) {\n      throw new TypeError('The supplied view\\'s buffer has been detached and so cannot be used as a response');\n    }\n\n    ReadableByteStreamControllerRespondWithNewView(this._associatedReadableByteStreamController, view);\n  };\n\n  _createClass(ReadableStreamBYOBRequest, [{\n    key: \"view\",\n    get: function get() {\n      if (IsReadableStreamBYOBRequest(this) === false) {\n        throw byobRequestBrandCheckException('view');\n      }\n\n      return this._view;\n    }\n  }]);\n\n  return ReadableStreamBYOBRequest;\n}();\n\nvar ReadableByteStreamController =\n/*#__PURE__*/\nfunction () {\n  function ReadableByteStreamController() {\n    throw new TypeError('ReadableByteStreamController constructor cannot be used directly');\n  }\n\n  var _proto6 = ReadableByteStreamController.prototype;\n\n  _proto6.close = function close() {\n    if (IsReadableByteStreamController(this) === false) {\n      throw byteStreamControllerBrandCheckException('close');\n    }\n\n    if (this._closeRequested === true) {\n      throw new TypeError('The stream has already been closed; do not close it again!');\n    }\n\n    var state = this._controlledReadableByteStream._state;\n\n    if (state !== 'readable') {\n      throw new TypeError(\"The stream (in \" + state + \" state) is not in the readable state and cannot be closed\");\n    }\n\n    ReadableByteStreamControllerClose(this);\n  };\n\n  _proto6.enqueue = function enqueue(chunk) {\n    if (IsReadableByteStreamController(this) === false) {\n      throw byteStreamControllerBrandCheckException('enqueue');\n    }\n\n    if (this._closeRequested === true) {\n      throw new TypeError('stream is closed or draining');\n    }\n\n    var state = this._controlledReadableByteStream._state;\n\n    if (state !== 'readable') {\n      throw new TypeError(\"The stream (in \" + state + \" state) is not in the readable state and cannot be enqueued to\");\n    }\n\n    if (!ArrayBuffer.isView(chunk)) {\n      throw new TypeError('You can only enqueue array buffer views when using a ReadableByteStreamController');\n    }\n\n    if (IsDetachedBuffer$1(chunk.buffer) === true) {\n      throw new TypeError('Cannot enqueue a view onto a detached ArrayBuffer');\n    }\n\n    ReadableByteStreamControllerEnqueue(this, chunk);\n  };\n\n  _proto6.error = function error(e) {\n    if (IsReadableByteStreamController(this) === false) {\n      throw byteStreamControllerBrandCheckException('error');\n    }\n\n    ReadableByteStreamControllerError(this, e);\n  };\n\n  _proto6[CancelSteps] = function (reason) {\n    if (this._pendingPullIntos.length > 0) {\n      var firstDescriptor = this._pendingPullIntos[0];\n      firstDescriptor.bytesFilled = 0;\n    }\n\n    ResetQueue$2(this);\n\n    var result = this._cancelAlgorithm(reason);\n\n    ReadableByteStreamControllerClearAlgorithms(this);\n    return result;\n  };\n\n  _proto6[PullSteps] = function (forAuthorCode) {\n    var stream = this._controlledReadableByteStream;\n\n    if (this._queueTotalSize > 0) {\n      var entry = this._queue.shift();\n\n      this._queueTotalSize -= entry.byteLength;\n      ReadableByteStreamControllerHandleQueueDrain(this);\n      var view;\n\n      try {\n        view = new Uint8Array(entry.buffer, entry.byteOffset, entry.byteLength);\n      } catch (viewE) {\n        return Promise.reject(viewE);\n      }\n\n      return Promise.resolve(ReadableStreamCreateReadResult(view, false, forAuthorCode));\n    }\n\n    var autoAllocateChunkSize = this._autoAllocateChunkSize;\n\n    if (autoAllocateChunkSize !== undefined) {\n      var buffer;\n\n      try {\n        buffer = new ArrayBuffer(autoAllocateChunkSize);\n      } catch (bufferE) {\n        return Promise.reject(bufferE);\n      }\n\n      var pullIntoDescriptor = {\n        buffer: buffer,\n        byteOffset: 0,\n        byteLength: autoAllocateChunkSize,\n        bytesFilled: 0,\n        elementSize: 1,\n        ctor: Uint8Array,\n        readerType: 'default'\n      };\n\n      this._pendingPullIntos.push(pullIntoDescriptor);\n    }\n\n    var promise = ReadableStreamAddReadRequest(stream, forAuthorCode);\n    ReadableByteStreamControllerCallPullIfNeeded(this);\n    return promise;\n  };\n\n  _createClass(ReadableByteStreamController, [{\n    key: \"byobRequest\",\n    get: function get() {\n      if (IsReadableByteStreamController(this) === false) {\n        throw byteStreamControllerBrandCheckException('byobRequest');\n      }\n\n      if (this._byobRequest === undefined && this._pendingPullIntos.length > 0) {\n        var firstDescriptor = this._pendingPullIntos[0];\n        var view = new Uint8Array(firstDescriptor.buffer, firstDescriptor.byteOffset + firstDescriptor.bytesFilled, firstDescriptor.byteLength - firstDescriptor.bytesFilled);\n        var byobRequest = Object.create(ReadableStreamBYOBRequest.prototype);\n        SetUpReadableStreamBYOBRequest(byobRequest, this, view);\n        this._byobRequest = byobRequest;\n      }\n\n      return this._byobRequest;\n    }\n  }, {\n    key: \"desiredSize\",\n    get: function get() {\n      if (IsReadableByteStreamController(this) === false) {\n        throw byteStreamControllerBrandCheckException('desiredSize');\n      }\n\n      return ReadableByteStreamControllerGetDesiredSize(this);\n    }\n  }]);\n\n  return ReadableByteStreamController;\n}(); // Abstract operations for the ReadableByteStreamController.\n\n\nfunction IsReadableByteStreamController(x) {\n  if (!typeIsObject$1(x)) {\n    return false;\n  }\n\n  if (!Object.prototype.hasOwnProperty.call(x, '_controlledReadableByteStream')) {\n    return false;\n  }\n\n  return true;\n}\n\nfunction IsReadableStreamBYOBRequest(x) {\n  if (!typeIsObject$1(x)) {\n    return false;\n  }\n\n  if (!Object.prototype.hasOwnProperty.call(x, '_associatedReadableByteStreamController')) {\n    return false;\n  }\n\n  return true;\n}\n\nfunction ReadableByteStreamControllerCallPullIfNeeded(controller) {\n  var shouldPull = ReadableByteStreamControllerShouldCallPull(controller);\n\n  if (shouldPull === false) {\n    return undefined;\n  }\n\n  if (controller._pulling === true) {\n    controller._pullAgain = true;\n    return undefined;\n  }\n\n  controller._pulling = true; // TODO: Test controller argument\n\n  var pullPromise = controller._pullAlgorithm();\n\n  pullPromise.then(function () {\n    controller._pulling = false;\n\n    if (controller._pullAgain === true) {\n      controller._pullAgain = false;\n      ReadableByteStreamControllerCallPullIfNeeded(controller);\n    }\n  }, function (e) {\n    ReadableByteStreamControllerError(controller, e);\n  }).catch(rethrowAssertionErrorRejection$2);\n  return undefined;\n}\n\nfunction ReadableByteStreamControllerClearPendingPullIntos(controller) {\n  ReadableByteStreamControllerInvalidateBYOBRequest(controller);\n  controller._pendingPullIntos = [];\n}\n\nfunction ReadableByteStreamControllerCommitPullIntoDescriptor(stream, pullIntoDescriptor) {\n  var done = false;\n\n  if (stream._state === 'closed') {\n    done = true;\n  }\n\n  var filledView = ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor);\n\n  if (pullIntoDescriptor.readerType === 'default') {\n    ReadableStreamFulfillReadRequest(stream, filledView, done);\n  } else {\n    ReadableStreamFulfillReadIntoRequest(stream, filledView, done);\n  }\n}\n\nfunction ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor) {\n  var bytesFilled = pullIntoDescriptor.bytesFilled;\n  var elementSize = pullIntoDescriptor.elementSize;\n  return new pullIntoDescriptor.ctor(pullIntoDescriptor.buffer, pullIntoDescriptor.byteOffset, bytesFilled / elementSize);\n}\n\nfunction ReadableByteStreamControllerEnqueueChunkToQueue(controller, buffer, byteOffset, byteLength) {\n  controller._queue.push({\n    buffer: buffer,\n    byteOffset: byteOffset,\n    byteLength: byteLength\n  });\n\n  controller._queueTotalSize += byteLength;\n}\n\nfunction ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor) {\n  var elementSize = pullIntoDescriptor.elementSize;\n  var currentAlignedBytes = pullIntoDescriptor.bytesFilled - pullIntoDescriptor.bytesFilled % elementSize;\n  var maxBytesToCopy = Math.min(controller._queueTotalSize, pullIntoDescriptor.byteLength - pullIntoDescriptor.bytesFilled);\n  var maxBytesFilled = pullIntoDescriptor.bytesFilled + maxBytesToCopy;\n  var maxAlignedBytes = maxBytesFilled - maxBytesFilled % elementSize;\n  var totalBytesToCopyRemaining = maxBytesToCopy;\n  var ready = false;\n\n  if (maxAlignedBytes > currentAlignedBytes) {\n    totalBytesToCopyRemaining = maxAlignedBytes - pullIntoDescriptor.bytesFilled;\n    ready = true;\n  }\n\n  var queue = controller._queue;\n\n  while (totalBytesToCopyRemaining > 0) {\n    var headOfQueue = queue[0];\n    var bytesToCopy = Math.min(totalBytesToCopyRemaining, headOfQueue.byteLength);\n    var destStart = pullIntoDescriptor.byteOffset + pullIntoDescriptor.bytesFilled;\n    ArrayBufferCopy(pullIntoDescriptor.buffer, destStart, headOfQueue.buffer, headOfQueue.byteOffset, bytesToCopy);\n\n    if (headOfQueue.byteLength === bytesToCopy) {\n      queue.shift();\n    } else {\n      headOfQueue.byteOffset += bytesToCopy;\n      headOfQueue.byteLength -= bytesToCopy;\n    }\n\n    controller._queueTotalSize -= bytesToCopy;\n    ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, bytesToCopy, pullIntoDescriptor);\n    totalBytesToCopyRemaining -= bytesToCopy;\n  }\n\n  return ready;\n}\n\nfunction ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, size, pullIntoDescriptor) {\n  ReadableByteStreamControllerInvalidateBYOBRequest(controller);\n  pullIntoDescriptor.bytesFilled += size;\n}\n\nfunction ReadableByteStreamControllerHandleQueueDrain(controller) {\n  if (controller._queueTotalSize === 0 && controller._closeRequested === true) {\n    ReadableByteStreamControllerClearAlgorithms(controller);\n    ReadableStreamClose(controller._controlledReadableByteStream);\n  } else {\n    ReadableByteStreamControllerCallPullIfNeeded(controller);\n  }\n}\n\nfunction ReadableByteStreamControllerInvalidateBYOBRequest(controller) {\n  if (controller._byobRequest === undefined) {\n    return;\n  }\n\n  controller._byobRequest._associatedReadableByteStreamController = undefined;\n  controller._byobRequest._view = undefined;\n  controller._byobRequest = undefined;\n}\n\nfunction ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller) {\n  while (controller._pendingPullIntos.length > 0) {\n    if (controller._queueTotalSize === 0) {\n      return;\n    }\n\n    var pullIntoDescriptor = controller._pendingPullIntos[0];\n\n    if (ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor) === true) {\n      ReadableByteStreamControllerShiftPendingPullInto(controller);\n      ReadableByteStreamControllerCommitPullIntoDescriptor(controller._controlledReadableByteStream, pullIntoDescriptor);\n    }\n  }\n}\n\nfunction ReadableByteStreamControllerPullInto(controller, view, forAuthorCode) {\n  var stream = controller._controlledReadableByteStream;\n  var elementSize = 1;\n\n  if (view.constructor !== DataView) {\n    elementSize = view.constructor.BYTES_PER_ELEMENT;\n  }\n\n  var ctor = view.constructor;\n  var buffer = TransferArrayBuffer$1(view.buffer);\n  var pullIntoDescriptor = {\n    buffer: buffer,\n    byteOffset: view.byteOffset,\n    byteLength: view.byteLength,\n    bytesFilled: 0,\n    elementSize: elementSize,\n    ctor: ctor,\n    readerType: 'byob'\n  };\n\n  if (controller._pendingPullIntos.length > 0) {\n    controller._pendingPullIntos.push(pullIntoDescriptor); // No ReadableByteStreamControllerCallPullIfNeeded() call since:\n    // - No change happens on desiredSize\n    // - The source has already been notified of that there's at least 1 pending read(view)\n\n\n    return ReadableStreamAddReadIntoRequest(stream, forAuthorCode);\n  }\n\n  if (stream._state === 'closed') {\n    var emptyView = new view.constructor(pullIntoDescriptor.buffer, pullIntoDescriptor.byteOffset, 0);\n    return Promise.resolve(ReadableStreamCreateReadResult(emptyView, true, forAuthorCode));\n  }\n\n  if (controller._queueTotalSize > 0) {\n    if (ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor) === true) {\n      var filledView = ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor);\n      ReadableByteStreamControllerHandleQueueDrain(controller);\n      return Promise.resolve(ReadableStreamCreateReadResult(filledView, false, forAuthorCode));\n    }\n\n    if (controller._closeRequested === true) {\n      var e = new TypeError('Insufficient bytes to fill elements in the given buffer');\n      ReadableByteStreamControllerError(controller, e);\n      return Promise.reject(e);\n    }\n  }\n\n  controller._pendingPullIntos.push(pullIntoDescriptor);\n\n  var promise = ReadableStreamAddReadIntoRequest(stream, forAuthorCode);\n  ReadableByteStreamControllerCallPullIfNeeded(controller);\n  return promise;\n}\n\nfunction ReadableByteStreamControllerRespondInClosedState(controller, firstDescriptor) {\n  firstDescriptor.buffer = TransferArrayBuffer$1(firstDescriptor.buffer);\n  var stream = controller._controlledReadableByteStream;\n\n  if (ReadableStreamHasBYOBReader(stream) === true) {\n    while (ReadableStreamGetNumReadIntoRequests(stream) > 0) {\n      var pullIntoDescriptor = ReadableByteStreamControllerShiftPendingPullInto(controller);\n      ReadableByteStreamControllerCommitPullIntoDescriptor(stream, pullIntoDescriptor);\n    }\n  }\n}\n\nfunction ReadableByteStreamControllerRespondInReadableState(controller, bytesWritten, pullIntoDescriptor) {\n  if (pullIntoDescriptor.bytesFilled + bytesWritten > pullIntoDescriptor.byteLength) {\n    throw new RangeError('bytesWritten out of range');\n  }\n\n  ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, bytesWritten, pullIntoDescriptor);\n\n  if (pullIntoDescriptor.bytesFilled < pullIntoDescriptor.elementSize) {\n    // TODO: Figure out whether we should detach the buffer or not here.\n    return;\n  }\n\n  ReadableByteStreamControllerShiftPendingPullInto(controller);\n  var remainderSize = pullIntoDescriptor.bytesFilled % pullIntoDescriptor.elementSize;\n\n  if (remainderSize > 0) {\n    var end = pullIntoDescriptor.byteOffset + pullIntoDescriptor.bytesFilled;\n    var remainder = pullIntoDescriptor.buffer.slice(end - remainderSize, end);\n    ReadableByteStreamControllerEnqueueChunkToQueue(controller, remainder, 0, remainder.byteLength);\n  }\n\n  pullIntoDescriptor.buffer = TransferArrayBuffer$1(pullIntoDescriptor.buffer);\n  pullIntoDescriptor.bytesFilled -= remainderSize;\n  ReadableByteStreamControllerCommitPullIntoDescriptor(controller._controlledReadableByteStream, pullIntoDescriptor);\n  ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller);\n}\n\nfunction ReadableByteStreamControllerRespondInternal(controller, bytesWritten) {\n  var firstDescriptor = controller._pendingPullIntos[0];\n  var stream = controller._controlledReadableByteStream;\n\n  if (stream._state === 'closed') {\n    if (bytesWritten !== 0) {\n      throw new TypeError('bytesWritten must be 0 when calling respond() on a closed stream');\n    }\n\n    ReadableByteStreamControllerRespondInClosedState(controller, firstDescriptor);\n  } else {\n    ReadableByteStreamControllerRespondInReadableState(controller, bytesWritten, firstDescriptor);\n  }\n\n  ReadableByteStreamControllerCallPullIfNeeded(controller);\n}\n\nfunction ReadableByteStreamControllerShiftPendingPullInto(controller) {\n  var descriptor = controller._pendingPullIntos.shift();\n\n  ReadableByteStreamControllerInvalidateBYOBRequest(controller);\n  return descriptor;\n}\n\nfunction ReadableByteStreamControllerShouldCallPull(controller) {\n  var stream = controller._controlledReadableByteStream;\n\n  if (stream._state !== 'readable') {\n    return false;\n  }\n\n  if (controller._closeRequested === true) {\n    return false;\n  }\n\n  if (controller._started === false) {\n    return false;\n  }\n\n  if (ReadableStreamHasDefaultReader(stream) === true && ReadableStreamGetNumReadRequests(stream) > 0) {\n    return true;\n  }\n\n  if (ReadableStreamHasBYOBReader(stream) === true && ReadableStreamGetNumReadIntoRequests(stream) > 0) {\n    return true;\n  }\n\n  var desiredSize = ReadableByteStreamControllerGetDesiredSize(controller);\n\n  if (desiredSize > 0) {\n    return true;\n  }\n\n  return false;\n}\n\nfunction ReadableByteStreamControllerClearAlgorithms(controller) {\n  controller._pullAlgorithm = undefined;\n  controller._cancelAlgorithm = undefined;\n} // A client of ReadableByteStreamController may use these functions directly to bypass state check.\n\n\nfunction ReadableByteStreamControllerClose(controller) {\n  var stream = controller._controlledReadableByteStream;\n\n  if (controller._queueTotalSize > 0) {\n    controller._closeRequested = true;\n    return;\n  }\n\n  if (controller._pendingPullIntos.length > 0) {\n    var firstPendingPullInto = controller._pendingPullIntos[0];\n\n    if (firstPendingPullInto.bytesFilled > 0) {\n      var e = new TypeError('Insufficient bytes to fill elements in the given buffer');\n      ReadableByteStreamControllerError(controller, e);\n      throw e;\n    }\n  }\n\n  ReadableByteStreamControllerClearAlgorithms(controller);\n  ReadableStreamClose(stream);\n}\n\nfunction ReadableByteStreamControllerEnqueue(controller, chunk) {\n  var stream = controller._controlledReadableByteStream;\n  var buffer = chunk.buffer;\n  var byteOffset = chunk.byteOffset;\n  var byteLength = chunk.byteLength;\n  var transferredBuffer = TransferArrayBuffer$1(buffer);\n\n  if (ReadableStreamHasDefaultReader(stream) === true) {\n    if (ReadableStreamGetNumReadRequests(stream) === 0) {\n      ReadableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength);\n    } else {\n      var transferredView = new Uint8Array(transferredBuffer, byteOffset, byteLength);\n      ReadableStreamFulfillReadRequest(stream, transferredView, false);\n    }\n  } else if (ReadableStreamHasBYOBReader(stream) === true) {\n    // TODO: Ideally in this branch detaching should happen only if the buffer is not consumed fully.\n    ReadableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength);\n    ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller);\n  } else {\n    ReadableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength);\n  }\n\n  ReadableByteStreamControllerCallPullIfNeeded(controller);\n}\n\nfunction ReadableByteStreamControllerError(controller, e) {\n  var stream = controller._controlledReadableByteStream;\n\n  if (stream._state !== 'readable') {\n    return;\n  }\n\n  ReadableByteStreamControllerClearPendingPullIntos(controller);\n  ResetQueue$2(controller);\n  ReadableByteStreamControllerClearAlgorithms(controller);\n  ReadableStreamError(stream, e);\n}\n\nfunction ReadableByteStreamControllerGetDesiredSize(controller) {\n  var stream = controller._controlledReadableByteStream;\n  var state = stream._state;\n\n  if (state === 'errored') {\n    return null;\n  }\n\n  if (state === 'closed') {\n    return 0;\n  }\n\n  return controller._strategyHWM - controller._queueTotalSize;\n}\n\nfunction ReadableByteStreamControllerRespond(controller, bytesWritten) {\n  bytesWritten = Number(bytesWritten);\n\n  if (IsFiniteNonNegativeNumber$1(bytesWritten) === false) {\n    throw new RangeError('bytesWritten must be a finite');\n  }\n\n  ReadableByteStreamControllerRespondInternal(controller, bytesWritten);\n}\n\nfunction ReadableByteStreamControllerRespondWithNewView(controller, view) {\n  var firstDescriptor = controller._pendingPullIntos[0];\n\n  if (firstDescriptor.byteOffset + firstDescriptor.bytesFilled !== view.byteOffset) {\n    throw new RangeError('The region specified by view does not match byobRequest');\n  }\n\n  if (firstDescriptor.byteLength !== view.byteLength) {\n    throw new RangeError('The buffer of view has different capacity than byobRequest');\n  }\n\n  firstDescriptor.buffer = view.buffer;\n  ReadableByteStreamControllerRespondInternal(controller, view.byteLength);\n}\n\nfunction SetUpReadableByteStreamController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, autoAllocateChunkSize) {\n\n  controller._controlledReadableByteStream = stream;\n  controller._pullAgain = false;\n  controller._pulling = false;\n  ReadableByteStreamControllerClearPendingPullIntos(controller); // Need to set the slots so that the assert doesn't fire. In the spec the slots already exist implicitly.\n\n  controller._queue = controller._queueTotalSize = undefined;\n  ResetQueue$2(controller);\n  controller._closeRequested = false;\n  controller._started = false;\n  controller._strategyHWM = ValidateAndNormalizeHighWaterMark$1(highWaterMark);\n  controller._pullAlgorithm = pullAlgorithm;\n  controller._cancelAlgorithm = cancelAlgorithm;\n  controller._autoAllocateChunkSize = autoAllocateChunkSize;\n  controller._pendingPullIntos = [];\n  stream._readableStreamController = controller;\n  var startResult = startAlgorithm();\n  Promise.resolve(startResult).then(function () {\n    controller._started = true;\n    ReadableByteStreamControllerCallPullIfNeeded(controller);\n  }, function (r) {\n    ReadableByteStreamControllerError(controller, r);\n  }).catch(rethrowAssertionErrorRejection$2);\n}\n\nfunction SetUpReadableByteStreamControllerFromUnderlyingSource(stream, underlyingByteSource, highWaterMark) {\n  var controller = Object.create(ReadableByteStreamController.prototype);\n\n  function startAlgorithm() {\n    return InvokeOrNoop$1(underlyingByteSource, 'start', [controller]);\n  }\n\n  var pullAlgorithm = CreateAlgorithmFromUnderlyingMethod$1(underlyingByteSource, 'pull', 0, [controller]);\n  var cancelAlgorithm = CreateAlgorithmFromUnderlyingMethod$1(underlyingByteSource, 'cancel', 1, []);\n  var autoAllocateChunkSize = underlyingByteSource.autoAllocateChunkSize;\n\n  if (autoAllocateChunkSize !== undefined) {\n    autoAllocateChunkSize = Number(autoAllocateChunkSize);\n\n    if (NumberIsInteger(autoAllocateChunkSize) === false || autoAllocateChunkSize <= 0) {\n      throw new RangeError('autoAllocateChunkSize must be a positive integer');\n    }\n  }\n\n  SetUpReadableByteStreamController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, autoAllocateChunkSize);\n}\n\nfunction SetUpReadableStreamBYOBRequest(request, controller, view) {\n  request._associatedReadableByteStreamController = controller;\n  request._view = view;\n} // Helper functions for the ReadableStream.\n\n\nfunction isAbortSignal(value) {\n  if (typeof value !== 'object' || value === null) {\n    return false;\n  } // Use the brand check to distinguish a real AbortSignal from a fake one.\n\n\n  var aborted = Object.getOwnPropertyDescriptor(AbortSignal.prototype, 'aborted').get;\n\n  try {\n    aborted.call(value);\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\nfunction streamBrandCheckException$1(name) {\n  return new TypeError(\"ReadableStream.prototype.\" + name + \" can only be used on a ReadableStream\");\n} // Helper functions for the readers.\n\n\nfunction readerLockException(name) {\n  return new TypeError('Cannot ' + name + ' a stream using a released reader');\n} // Helper functions for the ReadableStreamDefaultReader.\n\n\nfunction defaultReaderBrandCheckException(name) {\n  return new TypeError(\"ReadableStreamDefaultReader.prototype.\" + name + \" can only be used on a ReadableStreamDefaultReader\");\n}\n\nfunction defaultReaderClosedPromiseInitialize(reader) {\n  reader._closedPromise = new Promise(function (resolve, reject) {\n    reader._closedPromise_resolve = resolve;\n    reader._closedPromise_reject = reject;\n  });\n}\n\nfunction defaultReaderClosedPromiseInitializeAsRejected(reader, reason) {\n  reader._closedPromise = Promise.reject(reason);\n  reader._closedPromise_resolve = undefined;\n  reader._closedPromise_reject = undefined;\n}\n\nfunction defaultReaderClosedPromiseInitializeAsResolved(reader) {\n  reader._closedPromise = Promise.resolve(undefined);\n  reader._closedPromise_resolve = undefined;\n  reader._closedPromise_reject = undefined;\n}\n\nfunction defaultReaderClosedPromiseReject(reader, reason) {\n  reader._closedPromise_reject(reason);\n\n  reader._closedPromise_resolve = undefined;\n  reader._closedPromise_reject = undefined;\n}\n\nfunction defaultReaderClosedPromiseResetToRejected(reader, reason) {\n  reader._closedPromise = Promise.reject(reason);\n}\n\nfunction defaultReaderClosedPromiseResolve(reader) {\n  reader._closedPromise_resolve(undefined);\n\n  reader._closedPromise_resolve = undefined;\n  reader._closedPromise_reject = undefined;\n} // Helper functions for the ReadableStreamDefaultReader.\n\n\nfunction byobReaderBrandCheckException(name) {\n  return new TypeError(\"ReadableStreamBYOBReader.prototype.\" + name + \" can only be used on a ReadableStreamBYOBReader\");\n} // Helper functions for the ReadableStreamDefaultController.\n\n\nfunction defaultControllerBrandCheckException(name) {\n  return new TypeError(\"ReadableStreamDefaultController.prototype.\" + name + \" can only be used on a ReadableStreamDefaultController\");\n} // Helper functions for the ReadableStreamBYOBRequest.\n\n\nfunction byobRequestBrandCheckException(name) {\n  return new TypeError(\"ReadableStreamBYOBRequest.prototype.\" + name + \" can only be used on a ReadableStreamBYOBRequest\");\n} // Helper functions for the ReadableByteStreamController.\n\n\nfunction byteStreamControllerBrandCheckException(name) {\n  return new TypeError(\"ReadableByteStreamController.prototype.\" + name + \" can only be used on a ReadableByteStreamController\");\n}\nvar readableStream_3 = readableStream.ReadableStream;\n\nvar createDataProperty = require$$0.createDataProperty;\n\nvar byteLengthQueuingStrategy =\n/*#__PURE__*/\nfunction () {\n  function ByteLengthQueuingStrategy(_ref) {\n    var highWaterMark = _ref.highWaterMark;\n    createDataProperty(this, 'highWaterMark', highWaterMark);\n  }\n\n  var _proto = ByteLengthQueuingStrategy.prototype;\n\n  _proto.size = function size(chunk) {\n    return chunk.byteLength;\n  };\n\n  return ByteLengthQueuingStrategy;\n}();\n\nvar createDataProperty$1 = require$$0.createDataProperty;\n\nvar countQueuingStrategy =\n/*#__PURE__*/\nfunction () {\n  function CountQueuingStrategy(_ref) {\n    var highWaterMark = _ref.highWaterMark;\n    createDataProperty$1(this, 'highWaterMark', highWaterMark);\n  }\n\n  var _proto = CountQueuingStrategy.prototype;\n\n  _proto.size = function size() {\n    return 1;\n  };\n\n  return CountQueuingStrategy;\n}();\n\n// and do not appear in the standard text.\n\n\nvar verbose$1 = require$$0$1('streams:transform-stream:verbose');\nvar InvokeOrNoop$2 = require$$0.InvokeOrNoop,\n    CreateAlgorithmFromUnderlyingMethod$2 = require$$0.CreateAlgorithmFromUnderlyingMethod,\n    PromiseCall = require$$0.PromiseCall,\n    typeIsObject$2 = require$$0.typeIsObject,\n    ValidateAndNormalizeHighWaterMark$2 = require$$0.ValidateAndNormalizeHighWaterMark,\n    IsNonNegativeNumber$2 = require$$0.IsNonNegativeNumber,\n    MakeSizeAlgorithmFromSizeFunction$2 = require$$0.MakeSizeAlgorithmFromSizeFunction;\nvar CreateReadableStream$1 = readableStream.CreateReadableStream,\n    ReadableStreamDefaultControllerClose$1 = readableStream.ReadableStreamDefaultControllerClose,\n    ReadableStreamDefaultControllerEnqueue$1 = readableStream.ReadableStreamDefaultControllerEnqueue,\n    ReadableStreamDefaultControllerError$1 = readableStream.ReadableStreamDefaultControllerError,\n    ReadableStreamDefaultControllerGetDesiredSize$1 = readableStream.ReadableStreamDefaultControllerGetDesiredSize,\n    ReadableStreamDefaultControllerHasBackpressure$1 = readableStream.ReadableStreamDefaultControllerHasBackpressure,\n    ReadableStreamDefaultControllerCanCloseOrEnqueue$1 = readableStream.ReadableStreamDefaultControllerCanCloseOrEnqueue;\nvar CreateWritableStream$1 = writableStream.CreateWritableStream,\n    WritableStreamDefaultControllerErrorIfNeeded$1 = writableStream.WritableStreamDefaultControllerErrorIfNeeded; // Class TransformStream\n\nvar TransformStream =\n/*#__PURE__*/\nfunction () {\n  function TransformStream(transformer, writableStrategy, readableStrategy) {\n    if (transformer === void 0) {\n      transformer = {};\n    }\n\n    if (writableStrategy === void 0) {\n      writableStrategy = {};\n    }\n\n    if (readableStrategy === void 0) {\n      readableStrategy = {};\n    }\n\n    var writableSizeFunction = writableStrategy.size;\n    var writableHighWaterMark = writableStrategy.highWaterMark;\n    var readableSizeFunction = readableStrategy.size;\n    var readableHighWaterMark = readableStrategy.highWaterMark;\n    var writableType = transformer.writableType;\n\n    if (writableType !== undefined) {\n      throw new RangeError('Invalid writable type specified');\n    }\n\n    var writableSizeAlgorithm = MakeSizeAlgorithmFromSizeFunction$2(writableSizeFunction);\n\n    if (writableHighWaterMark === undefined) {\n      writableHighWaterMark = 1;\n    }\n\n    writableHighWaterMark = ValidateAndNormalizeHighWaterMark$2(writableHighWaterMark);\n    var readableType = transformer.readableType;\n\n    if (readableType !== undefined) {\n      throw new RangeError('Invalid readable type specified');\n    }\n\n    var readableSizeAlgorithm = MakeSizeAlgorithmFromSizeFunction$2(readableSizeFunction);\n\n    if (readableHighWaterMark === undefined) {\n      readableHighWaterMark = 0;\n    }\n\n    readableHighWaterMark = ValidateAndNormalizeHighWaterMark$2(readableHighWaterMark);\n    var startPromise_resolve;\n    var startPromise = new Promise(function (resolve) {\n      startPromise_resolve = resolve;\n    });\n    InitializeTransformStream(this, startPromise, writableHighWaterMark, writableSizeAlgorithm, readableHighWaterMark, readableSizeAlgorithm);\n    SetUpTransformStreamDefaultControllerFromTransformer(this, transformer);\n    var startResult = InvokeOrNoop$2(transformer, 'start', [this._transformStreamController]);\n    startPromise_resolve(startResult);\n  }\n\n  _createClass(TransformStream, [{\n    key: \"readable\",\n    get: function get() {\n      if (IsTransformStream(this) === false) {\n        throw streamBrandCheckException$2('readable');\n      }\n\n      return this._readable;\n    }\n  }, {\n    key: \"writable\",\n    get: function get() {\n      if (IsTransformStream(this) === false) {\n        throw streamBrandCheckException$2('writable');\n      }\n\n      return this._writable;\n    }\n  }]);\n\n  return TransformStream;\n}(); // Transform Stream Abstract Operations\n\n\nfunction CreateTransformStream(startAlgorithm, transformAlgorithm, flushAlgorithm, writableHighWaterMark, writableSizeAlgorithm, readableHighWaterMark, readableSizeAlgorithm) {\n  if (writableHighWaterMark === void 0) {\n    writableHighWaterMark = 1;\n  }\n\n  if (writableSizeAlgorithm === void 0) {\n    writableSizeAlgorithm = function writableSizeAlgorithm() {\n      return 1;\n    };\n  }\n\n  if (readableHighWaterMark === void 0) {\n    readableHighWaterMark = 0;\n  }\n\n  if (readableSizeAlgorithm === void 0) {\n    readableSizeAlgorithm = function readableSizeAlgorithm() {\n      return 1;\n    };\n  }\n\n  var stream = Object.create(TransformStream.prototype);\n  var startPromise_resolve;\n  var startPromise = new Promise(function (resolve) {\n    startPromise_resolve = resolve;\n  });\n  InitializeTransformStream(stream, startPromise, writableHighWaterMark, writableSizeAlgorithm, readableHighWaterMark, readableSizeAlgorithm);\n  var controller = Object.create(TransformStreamDefaultController.prototype);\n  SetUpTransformStreamDefaultController(stream, controller, transformAlgorithm, flushAlgorithm);\n  var startResult = startAlgorithm();\n  startPromise_resolve(startResult);\n  return stream;\n}\n\nfunction InitializeTransformStream(stream, startPromise, writableHighWaterMark, writableSizeAlgorithm, readableHighWaterMark, readableSizeAlgorithm) {\n  function startAlgorithm() {\n    return startPromise;\n  }\n\n  function writeAlgorithm(chunk) {\n    return TransformStreamDefaultSinkWriteAlgorithm(stream, chunk);\n  }\n\n  function abortAlgorithm(reason) {\n    return TransformStreamDefaultSinkAbortAlgorithm(stream, reason);\n  }\n\n  function closeAlgorithm() {\n    return TransformStreamDefaultSinkCloseAlgorithm(stream);\n  }\n\n  stream._writable = CreateWritableStream$1(startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, writableHighWaterMark, writableSizeAlgorithm);\n\n  function pullAlgorithm() {\n    return TransformStreamDefaultSourcePullAlgorithm(stream);\n  }\n\n  function cancelAlgorithm(reason) {\n    TransformStreamErrorWritableAndUnblockWrite(stream, reason);\n    return Promise.resolve();\n  }\n\n  stream._readable = CreateReadableStream$1(startAlgorithm, pullAlgorithm, cancelAlgorithm, readableHighWaterMark, readableSizeAlgorithm); // The [[backpressure]] slot is set to undefined so that it can be initialised by TransformStreamSetBackpressure.\n\n  stream._backpressure = undefined;\n  stream._backpressureChangePromise = undefined;\n  stream._backpressureChangePromise_resolve = undefined;\n  TransformStreamSetBackpressure(stream, true); // Used by IsWritableStream() which is called by SetUpTransformStreamDefaultController().\n\n  stream._transformStreamController = undefined;\n}\n\nfunction IsTransformStream(x) {\n  if (!typeIsObject$2(x)) {\n    return false;\n  }\n\n  if (!Object.prototype.hasOwnProperty.call(x, '_transformStreamController')) {\n    return false;\n  }\n\n  return true;\n} // This is a no-op if both sides are already errored.\n\n\nfunction TransformStreamError(stream, e) {\n  ReadableStreamDefaultControllerError$1(stream._readable._readableStreamController, e);\n  TransformStreamErrorWritableAndUnblockWrite(stream, e);\n}\n\nfunction TransformStreamErrorWritableAndUnblockWrite(stream, e) {\n  TransformStreamDefaultControllerClearAlgorithms(stream._transformStreamController);\n  WritableStreamDefaultControllerErrorIfNeeded$1(stream._writable._writableStreamController, e);\n\n  if (stream._backpressure === true) {\n    // Pretend that pull() was called to permit any pending write() calls to complete. TransformStreamSetBackpressure()\n    // cannot be called from enqueue() or pull() once the ReadableStream is errored, so this will will be the final time\n    // _backpressure is set.\n    TransformStreamSetBackpressure(stream, false);\n  }\n}\n\nfunction TransformStreamSetBackpressure(stream, backpressure) {\n  // Passes also when called during construction.\n  if (stream._backpressureChangePromise !== undefined) {\n    stream._backpressureChangePromise_resolve();\n  }\n\n  stream._backpressureChangePromise = new Promise(function (resolve) {\n    stream._backpressureChangePromise_resolve = resolve;\n  });\n  stream._backpressure = backpressure;\n} // Class TransformStreamDefaultController\n\n\nvar TransformStreamDefaultController =\n/*#__PURE__*/\nfunction () {\n  function TransformStreamDefaultController() {\n    throw new TypeError('TransformStreamDefaultController instances cannot be created directly');\n  }\n\n  var _proto = TransformStreamDefaultController.prototype;\n\n  _proto.enqueue = function enqueue(chunk) {\n    if (IsTransformStreamDefaultController(this) === false) {\n      throw defaultControllerBrandCheckException$1('enqueue');\n    }\n\n    TransformStreamDefaultControllerEnqueue(this, chunk);\n  };\n\n  _proto.error = function error(reason) {\n    if (IsTransformStreamDefaultController(this) === false) {\n      throw defaultControllerBrandCheckException$1('error');\n    }\n\n    TransformStreamDefaultControllerError(this, reason);\n  };\n\n  _proto.terminate = function terminate() {\n    if (IsTransformStreamDefaultController(this) === false) {\n      throw defaultControllerBrandCheckException$1('terminate');\n    }\n\n    TransformStreamDefaultControllerTerminate(this);\n  };\n\n  _createClass(TransformStreamDefaultController, [{\n    key: \"desiredSize\",\n    get: function get() {\n      if (IsTransformStreamDefaultController(this) === false) {\n        throw defaultControllerBrandCheckException$1('desiredSize');\n      }\n\n      var readableController = this._controlledTransformStream._readable._readableStreamController;\n      return ReadableStreamDefaultControllerGetDesiredSize$1(readableController);\n    }\n  }]);\n\n  return TransformStreamDefaultController;\n}(); // Transform Stream Default Controller Abstract Operations\n\n\nfunction IsTransformStreamDefaultController(x) {\n  if (!typeIsObject$2(x)) {\n    return false;\n  }\n\n  if (!Object.prototype.hasOwnProperty.call(x, '_controlledTransformStream')) {\n    return false;\n  }\n\n  return true;\n}\n\nfunction SetUpTransformStreamDefaultController(stream, controller, transformAlgorithm, flushAlgorithm) {\n  controller._controlledTransformStream = stream;\n  stream._transformStreamController = controller;\n  controller._transformAlgorithm = transformAlgorithm;\n  controller._flushAlgorithm = flushAlgorithm;\n}\n\nfunction SetUpTransformStreamDefaultControllerFromTransformer(stream, transformer) {\n  var controller = Object.create(TransformStreamDefaultController.prototype);\n\n  var transformAlgorithm = function transformAlgorithm(chunk) {\n    try {\n      TransformStreamDefaultControllerEnqueue(controller, chunk);\n      return Promise.resolve();\n    } catch (transformResultE) {\n      return Promise.reject(transformResultE);\n    }\n  };\n\n  var transformMethod = transformer.transform;\n\n  if (transformMethod !== undefined) {\n    if (typeof transformMethod !== 'function') {\n      throw new TypeError('transform is not a method');\n    }\n\n    transformAlgorithm = function transformAlgorithm(chunk) {\n      return PromiseCall(transformMethod, transformer, [chunk, controller]);\n    };\n  }\n\n  var flushAlgorithm = CreateAlgorithmFromUnderlyingMethod$2(transformer, 'flush', 0, [controller]);\n  SetUpTransformStreamDefaultController(stream, controller, transformAlgorithm, flushAlgorithm);\n}\n\nfunction TransformStreamDefaultControllerClearAlgorithms(controller) {\n  controller._transformAlgorithm = undefined;\n  controller._flushAlgorithm = undefined;\n}\n\nfunction TransformStreamDefaultControllerEnqueue(controller, chunk) {\n  var stream = controller._controlledTransformStream;\n  var readableController = stream._readable._readableStreamController;\n\n  if (ReadableStreamDefaultControllerCanCloseOrEnqueue$1(readableController) === false) {\n    throw new TypeError('Readable side is not in a state that permits enqueue');\n  } // We throttle transform invocations based on the backpressure of the ReadableStream, but we still\n  // accept TransformStreamDefaultControllerEnqueue() calls.\n\n\n  try {\n    ReadableStreamDefaultControllerEnqueue$1(readableController, chunk);\n  } catch (e) {\n    // This happens when readableStrategy.size() throws.\n    TransformStreamErrorWritableAndUnblockWrite(stream, e);\n    throw stream._readable._storedError;\n  }\n\n  var backpressure = ReadableStreamDefaultControllerHasBackpressure$1(readableController);\n\n  if (backpressure !== stream._backpressure) {\n    TransformStreamSetBackpressure(stream, true);\n  }\n}\n\nfunction TransformStreamDefaultControllerError(controller, e) {\n  TransformStreamError(controller._controlledTransformStream, e);\n}\n\nfunction TransformStreamDefaultControllerPerformTransform(controller, chunk) {\n  var transformPromise = controller._transformAlgorithm(chunk);\n\n  return transformPromise.catch(function (r) {\n    TransformStreamError(controller._controlledTransformStream, r);\n    throw r;\n  });\n}\n\nfunction TransformStreamDefaultControllerTerminate(controller) {\n  var stream = controller._controlledTransformStream;\n  var readableController = stream._readable._readableStreamController;\n\n  if (ReadableStreamDefaultControllerCanCloseOrEnqueue$1(readableController) === true) {\n    ReadableStreamDefaultControllerClose$1(readableController);\n  }\n\n  var error = new TypeError('TransformStream terminated');\n  TransformStreamErrorWritableAndUnblockWrite(stream, error);\n} // TransformStreamDefaultSink Algorithms\n\n\nfunction TransformStreamDefaultSinkWriteAlgorithm(stream, chunk) {\n  var controller = stream._transformStreamController;\n\n  if (stream._backpressure === true) {\n    var backpressureChangePromise = stream._backpressureChangePromise;\n    return backpressureChangePromise.then(function () {\n      var writable = stream._writable;\n      var state = writable._state;\n\n      if (state === 'erroring') {\n        throw writable._storedError;\n      }\n\n      return TransformStreamDefaultControllerPerformTransform(controller, chunk);\n    });\n  }\n\n  return TransformStreamDefaultControllerPerformTransform(controller, chunk);\n}\n\nfunction TransformStreamDefaultSinkAbortAlgorithm(stream, reason) {\n  // abort() is not called synchronously, so it is possible for abort() to be called when the stream is already\n  // errored.\n  TransformStreamError(stream, reason);\n  return Promise.resolve();\n}\n\nfunction TransformStreamDefaultSinkCloseAlgorithm(stream) {\n  // stream._readable cannot change after construction, so caching it across a call to user code is safe.\n  var readable = stream._readable;\n  var controller = stream._transformStreamController;\n\n  var flushPromise = controller._flushAlgorithm();\n\n  TransformStreamDefaultControllerClearAlgorithms(controller); // Return a promise that is fulfilled with undefined on success.\n\n  return flushPromise.then(function () {\n    if (readable._state === 'errored') {\n      throw readable._storedError;\n    }\n\n    var readableController = readable._readableStreamController;\n\n    if (ReadableStreamDefaultControllerCanCloseOrEnqueue$1(readableController) === true) {\n      ReadableStreamDefaultControllerClose$1(readableController);\n    }\n  }).catch(function (r) {\n    TransformStreamError(stream, r);\n    throw readable._storedError;\n  });\n} // TransformStreamDefaultSource Algorithms\n\n\nfunction TransformStreamDefaultSourcePullAlgorithm(stream) {\n  // Invariant. Enforced by the promises returned by start() and pull().\n  TransformStreamSetBackpressure(stream, false); // Prevent the next pull() call until there is backpressure.\n\n  return stream._backpressureChangePromise;\n}\n\nvar transformStream = {\n  CreateTransformStream: CreateTransformStream,\n  TransformStream: TransformStream\n}; // Helper functions for the TransformStreamDefaultController.\n\nfunction defaultControllerBrandCheckException$1(name) {\n  return new TypeError(\"TransformStreamDefaultController.prototype.\" + name + \" can only be used on a TransformStreamDefaultController\");\n} // Helper functions for the TransformStream.\n\n\nfunction streamBrandCheckException$2(name) {\n  return new TypeError(\"TransformStream.prototype.\" + name + \" can only be used on a TransformStream\");\n}\nvar transformStream_2 = transformStream.TransformStream;\n\nvar exports$1 = {\n  ReadableStream: readableStream_3,\n  WritableStream: writableStream_5,\n  ByteLengthQueuingStrategy: byteLengthQueuingStrategy,\n  CountQueuingStrategy: countQueuingStrategy,\n  TransformStream: transformStream_2\n}; // Add classes to global scope\n\nif (typeof globals !== 'undefined') {\n  _extends(globals, exports$1);\n}\n\nexport { readableStream_3 as ReadableStream, writableStream_5 as WritableStream, byteLengthQueuingStrategy as ByteLengthQueuingStrategy, countQueuingStrategy as CountQueuingStrategy, transformStream_2 as TransformStream };\n//# sourceMappingURL=polyfill.mjs.map\n"],"names":["_defineProperties","target","props","i","descriptor","_createClass","Constructor","protoProps","staticProps","_extends","source","key","SymbolPolyfill","description","NumberIsInteger","value","noop","getGlobals","globals","betterAssert","NumberIsNaN","x","createCommonjsModule","fn","module","getCjsExportFromNamespace","n","helpers","exports","isFakeDetached","o","p","v","elements","dest","destOffset","src","srcOffset","Call","F","V","args","underlyingObject","methodName","algoArgCount","extraArgs","method","PromiseCall","arg","fullArgs","O","P","transferredIshVersion","highWaterMark","size","chunk","promise","onFulfilled","onRejected","promises","successSteps","failureSteps","rejected","rejectionHandler","index","fulfilledCount","total","result","_loop","_i2","promiseIndex","fulfillmentHandler","resolvePromise","rejectPromise","resolve","reject","successStepsWrapper","results","stepsResult","e","failureStepsWrapper","reason","helpers_1","helpers_2","helpers_3","helpers_4","helpers_5","helpers_6","helpers_7","helpers_8","helpers_9","helpers_10","helpers_13","helpers_14","helpers_15","helpers_16","helpers_17","TransferArrayBuffer","IsDetachedBuffer","helpers$1","assert","assert$1","assert$2","rethrowAssertionErrorRejection","utils","require$$0","IsFiniteNonNegativeNumber","DequeueValue","container","pair","EnqueueValueWithSize","PeekQueueValue","ResetQueue","queueWithSizes","debug","require$$0$1","CreateAlgorithmFromUnderlyingMethod","InvokeOrNoop","ValidateAndNormalizeHighWaterMark","MakeSizeAlgorithmFromSizeFunction","typeIsObject","rethrowAssertionErrorRejection$1","DequeueValue$1","EnqueueValueWithSize$1","PeekQueueValue$1","ResetQueue$1","AbortSteps","ErrorSteps","WritableStream","underlyingSink","strategy","InitializeWritableStream","type","sizeAlgorithm","SetUpWritableStreamDefaultControllerFromUnderlyingSink","_proto","IsWritableStream","streamBrandCheckException","IsWritableStreamLocked","WritableStreamAbort","AcquireWritableStreamDefaultWriter","writableStream","CreateWritableStream","WritableStreamDefaultControllerErrorIfNeeded","WritableStreamDefaultWriterCloseWithErrorPropagation","WritableStreamDefaultWriterRelease","WritableStreamDefaultWriterWrite","WritableStreamCloseQueuedOrInFlight","stream","WritableStreamDefaultWriter","startAlgorithm","writeAlgorithm","closeAlgorithm","abortAlgorithm","controller","WritableStreamDefaultController","SetUpWritableStreamDefaultController","state","wasAlreadyErroring","WritableStreamStartErroring","WritableStreamAddWriteRequest","writeRequest","WritableStreamDealWithRejection","error","WritableStreamFinishErroring","writer","WritableStreamDefaultWriterEnsureReadyPromiseRejected","WritableStreamHasOperationMarkedInFlight","storedError","_stream$_writeRequest2","WritableStreamRejectCloseAndClosedPromiseIfNeeded","abortRequest","WritableStreamFinishInFlightWrite","WritableStreamFinishInFlightWriteWithError","WritableStreamFinishInFlightClose","defaultWriterClosedPromiseResolve","WritableStreamFinishInFlightCloseWithError","WritableStreamMarkCloseRequestInFlight","WritableStreamMarkFirstWriteRequestInFlight","defaultWriterClosedPromiseReject","WritableStreamUpdateBackpressure","backpressure","defaultWriterReadyPromiseReset","defaultWriterReadyPromiseResolve","defaultWriterReadyPromiseInitialize","defaultWriterReadyPromiseInitializeAsResolved","defaultWriterClosedPromiseInitialize","defaultWriterReadyPromiseInitializeAsRejected","defaultWriterClosedPromiseInitializeAsResolved","defaultWriterClosedPromiseInitializeAsRejected","_proto2","IsWritableStreamDefaultWriter","defaultWriterBrandCheckException","defaultWriterLockException","WritableStreamDefaultWriterAbort","WritableStreamDefaultWriterClose","WritableStreamDefaultWriterGetDesiredSize","closeRequest","WritableStreamDefaultControllerClose","WritableStreamDefaultWriterEnsureClosedPromiseRejected","defaultWriterClosedPromiseResetToRejected","defaultWriterReadyPromiseReject","defaultWriterReadyPromiseResetToRejected","WritableStreamDefaultControllerGetDesiredSize","releasedError","chunkSize","WritableStreamDefaultControllerGetChunkSize","WritableStreamDefaultControllerWrite","_proto3","IsWritableStreamDefaultController","WritableStreamDefaultControllerError","WritableStreamDefaultControllerClearAlgorithms","WritableStreamDefaultControllerGetBackpressure","startResult","startPromise","WritableStreamDefaultControllerAdvanceQueueIfNeeded","r","chunkSizeE","writeRecord","enqueueE","WritableStreamDefaultControllerProcessClose","WritableStreamDefaultControllerProcessWrite","sinkClosePromise","sinkWritePromise","desiredSize","name","writableStream_5","ArrayBufferCopy","CreateAlgorithmFromUnderlyingMethod$1","IsFiniteNonNegativeNumber$1","InvokeOrNoop$1","IsDetachedBuffer$1","TransferArrayBuffer$1","ValidateAndNormalizeHighWaterMark$1","MakeSizeAlgorithmFromSizeFunction$1","createArrayFromList","typeIsObject$1","WaitForAllPromise","rethrowAssertionErrorRejection$2","DequeueValue$2","EnqueueValueWithSize$2","ResetQueue$2","AcquireWritableStreamDefaultWriter$1","IsWritableStream$1","IsWritableStreamLocked$1","WritableStreamAbort$1","WritableStreamDefaultWriterCloseWithErrorPropagation$1","WritableStreamDefaultWriterRelease$1","WritableStreamDefaultWriterWrite$1","WritableStreamCloseQueuedOrInFlight$1","CancelSteps","PullSteps","ReadableStream","underlyingSource","InitializeReadableStream","typeString","SetUpReadableByteStreamControllerFromUnderlyingSource","SetUpReadableStreamDefaultControllerFromUnderlyingSource","IsReadableStream","streamBrandCheckException$1","IsReadableStreamLocked","ReadableStreamCancel","_temp","_ref","mode","AcquireReadableStreamDefaultReader","AcquireReadableStreamBYOBReader","_ref2","_temp2","writable","readable","_ref3","preventClose","preventAbort","preventCancel","signal","isAbortSignal","ReadableStreamPipeTo","_temp3","_ref4","branches","ReadableStreamTee","readableStream","CreateReadableStream","ReadableStreamDefaultControllerClose","ReadableStreamDefaultControllerEnqueue","ReadableStreamDefaultControllerError","ReadableStreamDefaultControllerGetDesiredSize","ReadableStreamDefaultControllerHasBackpressure","ReadableStreamDefaultControllerCanCloseOrEnqueue","ReadableStreamBYOBReader","ReadableStreamDefaultReader","pullAlgorithm","cancelAlgorithm","ReadableStreamDefaultController","SetUpReadableStreamDefaultController","reader","shuttingDown","currentWrite","actions","shutdownWithAction","action","pipeLoop","resolveLoop","rejectLoop","next","done","pipeStep","ReadableStreamDefaultReaderRead","_ref5","isOrBecomesErrored","shutdown","isOrBecomesClosed","destClosed","err","waitForWritesToFinish","oldCurrentWrite","originalIsError","originalError","doTheRest","finalize","newError","isError","ReadableStreamReaderGenericRelease","cloneForBranch2","closedOrErrored","canceled1","canceled2","reason1","reason2","branch1","branch2","resolveCancelPromise","cancelPromise","value1","value2","cancel1Algorithm","compositeReason","cancelResult","cancel2Algorithm","ReadableStreamAddReadIntoRequest","forAuthorCode","readIntoRequest","ReadableStreamAddReadRequest","readRequest","ReadableStreamClose","sourceCancelPromise","IsReadableStreamDefaultReader","_reader$_readRequests2","_reader$_readRequests3","_resolve","_forAuthorCode","ReadableStreamCreateReadResult","defaultReaderClosedPromiseResolve","prototype","obj","ReadableStreamError","_i4","_reader$_readRequests5","_i6","_reader$_readIntoRequ2","defaultReaderClosedPromiseReject","ReadableStreamFulfillReadIntoRequest","ReadableStreamFulfillReadRequest","ReadableStreamGetNumReadIntoRequests","ReadableStreamGetNumReadRequests","ReadableStreamHasBYOBReader","IsReadableStreamBYOBReader","ReadableStreamHasDefaultReader","ReadableStreamReaderGenericInitialize","defaultReaderBrandCheckException","readerLockException","ReadableStreamReaderGenericCancel","IsReadableByteStreamController","byobReaderBrandCheckException","view","ReadableStreamBYOBReaderRead","defaultReaderClosedPromiseInitialize","defaultReaderClosedPromiseInitializeAsResolved","defaultReaderClosedPromiseInitializeAsRejected","defaultReaderClosedPromiseResetToRejected","ReadableByteStreamControllerPullInto","_proto4","IsReadableStreamDefaultController","defaultControllerBrandCheckException","ReadableStreamDefaultControllerClearAlgorithms","ReadableStreamDefaultControllerCallPullIfNeeded","pendingPromise","shouldPull","ReadableStreamDefaultControllerShouldCallPull","pullPromise","ReadableStreamBYOBRequest","_proto5","bytesWritten","IsReadableStreamBYOBRequest","byobRequestBrandCheckException","ReadableByteStreamControllerRespond","ReadableByteStreamControllerRespondWithNewView","ReadableByteStreamController","_proto6","byteStreamControllerBrandCheckException","ReadableByteStreamControllerClose","ReadableByteStreamControllerEnqueue","ReadableByteStreamControllerError","firstDescriptor","ReadableByteStreamControllerClearAlgorithms","entry","ReadableByteStreamControllerHandleQueueDrain","viewE","autoAllocateChunkSize","buffer","bufferE","pullIntoDescriptor","ReadableByteStreamControllerCallPullIfNeeded","byobRequest","SetUpReadableStreamBYOBRequest","ReadableByteStreamControllerGetDesiredSize","ReadableByteStreamControllerShouldCallPull","ReadableByteStreamControllerClearPendingPullIntos","ReadableByteStreamControllerInvalidateBYOBRequest","ReadableByteStreamControllerCommitPullIntoDescriptor","filledView","ReadableByteStreamControllerConvertPullIntoDescriptor","bytesFilled","elementSize","ReadableByteStreamControllerEnqueueChunkToQueue","byteOffset","byteLength","ReadableByteStreamControllerFillPullIntoDescriptorFromQueue","currentAlignedBytes","maxBytesToCopy","maxBytesFilled","maxAlignedBytes","totalBytesToCopyRemaining","ready","queue","headOfQueue","bytesToCopy","destStart","ReadableByteStreamControllerFillHeadPullIntoDescriptor","ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue","ReadableByteStreamControllerShiftPendingPullInto","ctor","emptyView","ReadableByteStreamControllerRespondInClosedState","ReadableByteStreamControllerRespondInReadableState","remainderSize","end","remainder","ReadableByteStreamControllerRespondInternal","firstPendingPullInto","transferredBuffer","transferredView","SetUpReadableByteStreamController","underlyingByteSource","request","aborted","readableStream_3","createDataProperty","byteLengthQueuingStrategy","ByteLengthQueuingStrategy","createDataProperty$1","countQueuingStrategy","CountQueuingStrategy","InvokeOrNoop$2","CreateAlgorithmFromUnderlyingMethod$2","typeIsObject$2","ValidateAndNormalizeHighWaterMark$2","MakeSizeAlgorithmFromSizeFunction$2","CreateReadableStream$1","ReadableStreamDefaultControllerClose$1","ReadableStreamDefaultControllerEnqueue$1","ReadableStreamDefaultControllerError$1","ReadableStreamDefaultControllerGetDesiredSize$1","ReadableStreamDefaultControllerHasBackpressure$1","ReadableStreamDefaultControllerCanCloseOrEnqueue$1","CreateWritableStream$1","WritableStreamDefaultControllerErrorIfNeeded$1","TransformStream","transformer","writableStrategy","readableStrategy","writableSizeFunction","writableHighWaterMark","readableSizeFunction","readableHighWaterMark","writableType","writableSizeAlgorithm","readableType","readableSizeAlgorithm","startPromise_resolve","InitializeTransformStream","SetUpTransformStreamDefaultControllerFromTransformer","IsTransformStream","streamBrandCheckException$2","TransformStreamDefaultSinkWriteAlgorithm","TransformStreamDefaultSinkAbortAlgorithm","TransformStreamDefaultSinkCloseAlgorithm","TransformStreamDefaultSourcePullAlgorithm","TransformStreamErrorWritableAndUnblockWrite","TransformStreamSetBackpressure","TransformStreamError","TransformStreamDefaultControllerClearAlgorithms","TransformStreamDefaultController","IsTransformStreamDefaultController","defaultControllerBrandCheckException$1","TransformStreamDefaultControllerEnqueue","TransformStreamDefaultControllerError","TransformStreamDefaultControllerTerminate","readableController","SetUpTransformStreamDefaultController","transformAlgorithm","flushAlgorithm","transformResultE","transformMethod","TransformStreamDefaultControllerPerformTransform","transformPromise","backpressureChangePromise","flushPromise","transformStream","transformStream_2","exports$1"],"mappings":"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","x_google_ignoreList":[0]}