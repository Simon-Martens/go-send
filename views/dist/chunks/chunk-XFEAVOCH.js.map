{
  "version": 3,
  "sources": ["../../src/syncFiles.mjs"],
  "sourcesContent": ["import { arrayToB64, b64ToArray } from \"./utils.mjs\";\nimport Keychain from \"./keychain.mjs\";\nimport OwnedFile from \"./ownedFile.mjs\";\nimport storage from \"./storage.mjs\";\n\n/**\n * Sync owned files from server to localStorage\n * This is called on app startup and after login to ensure all files\n * uploaded from other devices are available locally\n *\n * @param {UserSecrets} userSecrets - User secrets for decryption\n * @param {Object} options - Sync options\n * @param {boolean} options.clearFirst - If true, clear all local files before syncing (used during login)\n */\nexport async function syncOwnedFiles(userSecrets, options = {}) {\n  const { clearFirst = false } = options;\n\n  if (!userSecrets) {\n    console.warn(\"[syncFiles] No user secrets provided, skipping sync\");\n    return;\n  }\n\n  try {\n    const response = await fetch(\"/api/me/files\", {\n      method: \"GET\",\n      headers: {\n        \"Accept\": \"application/json\",\n      },\n      credentials: \"same-origin\",\n    });\n\n    if (!response.ok) {\n      console.warn(\"[syncFiles] Failed to fetch owned files\", response.status);\n      return;\n    }\n\n    const payload = await response.json();\n    const files = Array.isArray(payload?.files) ? payload.files : [];\n\n    // Clear local files if requested (e.g., during login to get fresh state)\n    if (clearFirst) {\n      storage.clearLocalFiles();\n    }\n\n    // Get existing file IDs to avoid duplicates\n    const existingFileIds = clearFirst ? new Set() : new Set(\n      storage.files.map(f => f.id).filter(id => id)\n    );\n\n    let addedCount = 0;\n    let skippedCount = 0;\n\n    for (const file of files) {\n      try {\n        // Skip if file already exists in localStorage\n        if (existingFileIds.has(file.id)) {\n          skippedCount++;\n          continue;\n        }\n\n        const secretBytes = await userSecrets.unwrapSecret({\n          ciphertext: file.secret_ciphertext,\n          nonce: file.secret_nonce,\n          ephemeralPublicKey: file.secret_ephemeral_pub,\n          version: file.secret_version,\n        });\n\n        try {\n          const secretB64 = arrayToB64(secretBytes);\n          const keychain = new Keychain(secretB64, file.nonce);\n          const metadataBytes = b64ToArray(file.metadata);\n          const metadata = await keychain.decryptMetadata(metadataBytes);\n\n          const ownedFile = new OwnedFile({\n            id: file.id,\n            url: `${window.location.origin}/download/${file.id}#${secretB64}`,\n            name: metadata.name,\n            size: metadata.size,\n            manifest: metadata.manifest || {},\n            time: 0,\n            speed: metadata.size || 0,\n            createdAt: file.created_at * 1000,\n            expiresAt: file.expires_at * 1000,\n            secretKey: secretB64,\n            nonce: file.nonce,\n            ownerToken: file.owner_token,\n            dlimit: file.dl_limit,\n            dtotal: file.dl_count,\n            hasPassword: file.password,\n            timeLimit: file.time_limit,\n          });\n\n          storage.addFile(ownedFile);\n          addedCount++;\n        } finally {\n          secretBytes.fill(0);\n        }\n      } catch (fileError) {\n        console.warn(\"[syncFiles] Failed to restore file\", fileError, file?.id);\n      }\n    }\n\n    if (addedCount > 0 || skippedCount > 0) {\n      console.log(`[syncFiles] Sync complete: ${addedCount} added, ${skippedCount} already present`);\n    }\n  } catch (err) {\n    console.warn(\"[syncFiles] Failed to sync owned files\", err);\n  }\n}\n"],
  "mappings": ";;;;;;;;;;;AAcA,eAAsB,eAAe,aAAa,UAAU,CAAC,GAAG;AAC9D,QAAM,EAAE,aAAa,MAAM,IAAI;AAE/B,MAAI,CAAC,aAAa;AAChB,YAAQ,KAAK,qDAAqD;AAClE;AAAA,EACF;AAEA,MAAI;AACF,UAAM,WAAW,MAAM,MAAM,iBAAiB;AAAA,MAC5C,QAAQ;AAAA,MACR,SAAS;AAAA,QACP,UAAU;AAAA,MACZ;AAAA,MACA,aAAa;AAAA,IACf,CAAC;AAED,QAAI,CAAC,SAAS,IAAI;AAChB,cAAQ,KAAK,2CAA2C,SAAS,MAAM;AACvE;AAAA,IACF;AAEA,UAAM,UAAU,MAAM,SAAS,KAAK;AACpC,UAAM,QAAQ,MAAM,QAAQ,mCAAS,KAAK,IAAI,QAAQ,QAAQ,CAAC;AAG/D,QAAI,YAAY;AACd,sBAAQ,gBAAgB;AAAA,IAC1B;AAGA,UAAM,kBAAkB,aAAa,oBAAI,IAAI,IAAI,IAAI;AAAA,MACnD,gBAAQ,MAAM,IAAI,OAAK,EAAE,EAAE,EAAE,OAAO,QAAM,EAAE;AAAA,IAC9C;AAEA,QAAI,aAAa;AACjB,QAAI,eAAe;AAEnB,eAAW,QAAQ,OAAO;AACxB,UAAI;AAEF,YAAI,gBAAgB,IAAI,KAAK,EAAE,GAAG;AAChC;AACA;AAAA,QACF;AAEA,cAAM,cAAc,MAAM,YAAY,aAAa;AAAA,UACjD,YAAY,KAAK;AAAA,UACjB,OAAO,KAAK;AAAA,UACZ,oBAAoB,KAAK;AAAA,UACzB,SAAS,KAAK;AAAA,QAChB,CAAC;AAED,YAAI;AACF,gBAAM,YAAY,WAAW,WAAW;AACxC,gBAAM,WAAW,IAAI,SAAS,WAAW,KAAK,KAAK;AACnD,gBAAM,gBAAgB,WAAW,KAAK,QAAQ;AAC9C,gBAAM,WAAW,MAAM,SAAS,gBAAgB,aAAa;AAE7D,gBAAM,YAAY,IAAI,UAAU;AAAA,YAC9B,IAAI,KAAK;AAAA,YACT,KAAK,GAAG,OAAO,SAAS,MAAM,aAAa,KAAK,EAAE,IAAI,SAAS;AAAA,YAC/D,MAAM,SAAS;AAAA,YACf,MAAM,SAAS;AAAA,YACf,UAAU,SAAS,YAAY,CAAC;AAAA,YAChC,MAAM;AAAA,YACN,OAAO,SAAS,QAAQ;AAAA,YACxB,WAAW,KAAK,aAAa;AAAA,YAC7B,WAAW,KAAK,aAAa;AAAA,YAC7B,WAAW;AAAA,YACX,OAAO,KAAK;AAAA,YACZ,YAAY,KAAK;AAAA,YACjB,QAAQ,KAAK;AAAA,YACb,QAAQ,KAAK;AAAA,YACb,aAAa,KAAK;AAAA,YAClB,WAAW,KAAK;AAAA,UAClB,CAAC;AAED,0BAAQ,QAAQ,SAAS;AACzB;AAAA,QACF,UAAE;AACA,sBAAY,KAAK,CAAC;AAAA,QACpB;AAAA,MACF,SAAS,WAAW;AAClB,gBAAQ,KAAK,sCAAsC,WAAW,6BAAM,EAAE;AAAA,MACxE;AAAA,IACF;AAEA,QAAI,aAAa,KAAK,eAAe,GAAG;AACtC,cAAQ,IAAI,8BAA8B,UAAU,WAAW,YAAY,kBAAkB;AAAA,IAC/F;AAAA,EACF,SAAS,KAAK;AACZ,YAAQ,KAAK,0CAA0C,GAAG;AAAA,EAC5D;AACF;",
  "names": []
}
